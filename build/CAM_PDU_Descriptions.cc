// This C++ source file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "CAM_PDU_Descriptions.hh"

namespace CAM__PDU__Descriptions {

/* Prototypes of static functions */

static void pre_init_module();

/* Global variable definitions */

static const ASN_Tag_t CAM_header_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t CAM_header_ber_ = { 1u, CAM_header_tag_ };
// No XER for CAM_header
const TTCN_Typedescriptor_t CAM_header_descr_ = { "@CAM-PDU-Descriptions.CAM.header", &CAM_header_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& GenerationDeltaTime_descr_ = INTEGER_descr_;
static const ASN_Tag_t CoopAwareness_generationDeltaTime_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t CoopAwareness_generationDeltaTime_ber_ = { 1u, CoopAwareness_generationDeltaTime_tag_ };
// No XER for CoopAwareness_generationDeltaTime
const TTCN_Typedescriptor_t CoopAwareness_generationDeltaTime_descr_ = { "@CAM-PDU-Descriptions.CoopAwareness.generationDeltaTime", &CoopAwareness_generationDeltaTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicContainer_stationType_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t BasicContainer_stationType_ber_ = { 1u, BasicContainer_stationType_tag_ };
// No XER for BasicContainer_stationType
const TTCN_Typedescriptor_t BasicContainer_stationType_descr_ = { "@CAM-PDU-Descriptions.BasicContainer.stationType", &BasicContainer_stationType_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicContainer_referencePosition_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t BasicContainer_referencePosition_ber_ = { 1u, BasicContainer_referencePosition_tag_ };
// No XER for BasicContainer_referencePosition
const TTCN_Typedescriptor_t BasicContainer_referencePosition_descr_ = { "@CAM-PDU-Descriptions.BasicContainer.referencePosition", &BasicContainer_referencePosition_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for BasicContainer
const TTCN_JSONdescriptor_t BasicContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BasicContainer_descr_ = { "@CAM-PDU-Descriptions.BasicContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &BasicContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t CamParameters_basicContainer_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t CamParameters_basicContainer_ber_ = { 1u, CamParameters_basicContainer_tag_ };
// No XER for CamParameters_basicContainer
const TTCN_Typedescriptor_t CamParameters_basicContainer_descr_ = { "@CAM-PDU-Descriptions.CamParameters.basicContainer", &CamParameters_basicContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for HighFrequencyContainer
const TTCN_JSONdescriptor_t HighFrequencyContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HighFrequencyContainer_descr_ = { "@CAM-PDU-Descriptions.HighFrequencyContainer", &CHOICE_ber_, NULL, NULL, NULL, &HighFrequencyContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_heading_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_heading_ber_ = { 1u, BasicVehicleContainerHighFrequency_heading_tag_ };
// No XER for BasicVehicleContainerHighFrequency_heading
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_heading_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.heading", &BasicVehicleContainerHighFrequency_heading_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_speed_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_speed_ber_ = { 1u, BasicVehicleContainerHighFrequency_speed_tag_ };
// No XER for BasicVehicleContainerHighFrequency_speed
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_speed_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.speed", &BasicVehicleContainerHighFrequency_speed_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_driveDirection_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_driveDirection_ber_ = { 1u, BasicVehicleContainerHighFrequency_driveDirection_tag_ };
// No XER for BasicVehicleContainerHighFrequency_driveDirection
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_driveDirection_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.driveDirection", &BasicVehicleContainerHighFrequency_driveDirection_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_vehicleLength_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_vehicleLength_ber_ = { 1u, BasicVehicleContainerHighFrequency_vehicleLength_tag_ };
// No XER for BasicVehicleContainerHighFrequency_vehicleLength
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_vehicleLength_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.vehicleLength", &BasicVehicleContainerHighFrequency_vehicleLength_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_vehicleWidth_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_vehicleWidth_ber_ = { 1u, BasicVehicleContainerHighFrequency_vehicleWidth_tag_ };
// No XER for BasicVehicleContainerHighFrequency_vehicleWidth
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_vehicleWidth_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.vehicleWidth", &BasicVehicleContainerHighFrequency_vehicleWidth_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_longitudinalAcceleration_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_longitudinalAcceleration_ber_ = { 1u, BasicVehicleContainerHighFrequency_longitudinalAcceleration_tag_ };
// No XER for BasicVehicleContainerHighFrequency_longitudinalAcceleration
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_longitudinalAcceleration_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.longitudinalAcceleration", &BasicVehicleContainerHighFrequency_longitudinalAcceleration_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_curvature_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_curvature_ber_ = { 1u, BasicVehicleContainerHighFrequency_curvature_tag_ };
// No XER for BasicVehicleContainerHighFrequency_curvature
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_curvature_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.curvature", &BasicVehicleContainerHighFrequency_curvature_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_curvatureCalculationMode_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_curvatureCalculationMode_ber_ = { 1u, BasicVehicleContainerHighFrequency_curvatureCalculationMode_tag_ };
// No XER for BasicVehicleContainerHighFrequency_curvatureCalculationMode
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_curvatureCalculationMode_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.curvatureCalculationMode", &BasicVehicleContainerHighFrequency_curvatureCalculationMode_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_yawRate_tag_[] = { { ASN_TAG_CONT, 8u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_yawRate_ber_ = { 1u, BasicVehicleContainerHighFrequency_yawRate_tag_ };
// No XER for BasicVehicleContainerHighFrequency_yawRate
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_yawRate_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.yawRate", &BasicVehicleContainerHighFrequency_yawRate_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for BasicVehicleContainerHighFrequency
const TTCN_JSONdescriptor_t BasicVehicleContainerHighFrequency_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency", &SEQUENCE_ber_, NULL, NULL, NULL, &BasicVehicleContainerHighFrequency_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_accelerationControl_tag_[] = { { ASN_TAG_CONT, 9u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_accelerationControl_ber_ = { 1u, BasicVehicleContainerHighFrequency_accelerationControl_tag_ };
// No XER for BasicVehicleContainerHighFrequency_accelerationControl
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_accelerationControl_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.accelerationControl", &BasicVehicleContainerHighFrequency_accelerationControl_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_lanePosition_tag_[] = { { ASN_TAG_CONT, 10u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_lanePosition_ber_ = { 1u, BasicVehicleContainerHighFrequency_lanePosition_tag_ };
// No XER for BasicVehicleContainerHighFrequency_lanePosition
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_lanePosition_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.lanePosition", &BasicVehicleContainerHighFrequency_lanePosition_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_steeringWheelAngle_tag_[] = { { ASN_TAG_CONT, 11u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_steeringWheelAngle_ber_ = { 1u, BasicVehicleContainerHighFrequency_steeringWheelAngle_tag_ };
// No XER for BasicVehicleContainerHighFrequency_steeringWheelAngle
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_steeringWheelAngle_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.steeringWheelAngle", &BasicVehicleContainerHighFrequency_steeringWheelAngle_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_lateralAcceleration_tag_[] = { { ASN_TAG_CONT, 12u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_lateralAcceleration_ber_ = { 1u, BasicVehicleContainerHighFrequency_lateralAcceleration_tag_ };
// No XER for BasicVehicleContainerHighFrequency_lateralAcceleration
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_lateralAcceleration_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.lateralAcceleration", &BasicVehicleContainerHighFrequency_lateralAcceleration_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_verticalAcceleration_tag_[] = { { ASN_TAG_CONT, 13u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_verticalAcceleration_ber_ = { 1u, BasicVehicleContainerHighFrequency_verticalAcceleration_tag_ };
// No XER for BasicVehicleContainerHighFrequency_verticalAcceleration
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_verticalAcceleration_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.verticalAcceleration", &BasicVehicleContainerHighFrequency_verticalAcceleration_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_performanceClass_tag_[] = { { ASN_TAG_CONT, 14u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_performanceClass_ber_ = { 1u, BasicVehicleContainerHighFrequency_performanceClass_tag_ };
// No XER for BasicVehicleContainerHighFrequency_performanceClass
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_performanceClass_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.performanceClass", &BasicVehicleContainerHighFrequency_performanceClass_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerHighFrequency_cenDsrcTollingZone_tag_[] = { { ASN_TAG_CONT, 15u }};
const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_cenDsrcTollingZone_ber_ = { 1u, BasicVehicleContainerHighFrequency_cenDsrcTollingZone_tag_ };
// No XER for BasicVehicleContainerHighFrequency_cenDsrcTollingZone
const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_cenDsrcTollingZone_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.cenDsrcTollingZone", &BasicVehicleContainerHighFrequency_cenDsrcTollingZone_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t HighFrequencyContainer_basicVehicleContainerHighFrequency_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t HighFrequencyContainer_basicVehicleContainerHighFrequency_ber_ = { 1u, HighFrequencyContainer_basicVehicleContainerHighFrequency_tag_ };
// No XER for HighFrequencyContainer_basicVehicleContainerHighFrequency
const TTCN_Typedescriptor_t HighFrequencyContainer_basicVehicleContainerHighFrequency_descr_ = { "@CAM-PDU-Descriptions.HighFrequencyContainer.basicVehicleContainerHighFrequency", &HighFrequencyContainer_basicVehicleContainerHighFrequency_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RSUContainerHighFrequency
const TTCN_JSONdescriptor_t RSUContainerHighFrequency_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RSUContainerHighFrequency_descr_ = { "@CAM-PDU-Descriptions.RSUContainerHighFrequency", &SEQUENCE_ber_, NULL, NULL, NULL, &RSUContainerHighFrequency_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RSUContainerHighFrequency_protectedCommunicationZonesRSU_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t RSUContainerHighFrequency_protectedCommunicationZonesRSU_ber_ = { 1u, RSUContainerHighFrequency_protectedCommunicationZonesRSU_tag_ };
// No XER for RSUContainerHighFrequency_protectedCommunicationZonesRSU
const TTCN_Typedescriptor_t RSUContainerHighFrequency_protectedCommunicationZonesRSU_descr_ = { "@CAM-PDU-Descriptions.RSUContainerHighFrequency.protectedCommunicationZonesRSU", &RSUContainerHighFrequency_protectedCommunicationZonesRSU_ber_, NULL, NULL, NULL, NULL, &ITS__Container::ProtectedCommunicationZone_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t HighFrequencyContainer_rsuContainerHighFrequency_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t HighFrequencyContainer_rsuContainerHighFrequency_ber_ = { 1u, HighFrequencyContainer_rsuContainerHighFrequency_tag_ };
// No XER for HighFrequencyContainer_rsuContainerHighFrequency
const TTCN_Typedescriptor_t HighFrequencyContainer_rsuContainerHighFrequency_descr_ = { "@CAM-PDU-Descriptions.HighFrequencyContainer.rsuContainerHighFrequency", &HighFrequencyContainer_rsuContainerHighFrequency_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t CamParameters_highFrequencyContainer_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t CamParameters_highFrequencyContainer_ber_ = { 1u, CamParameters_highFrequencyContainer_tag_ };
// No XER for CamParameters_highFrequencyContainer
const TTCN_Typedescriptor_t CamParameters_highFrequencyContainer_descr_ = { "@CAM-PDU-Descriptions.CamParameters.highFrequencyContainer", &CamParameters_highFrequencyContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CamParameters
const TTCN_JSONdescriptor_t CamParameters_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CamParameters_descr_ = { "@CAM-PDU-Descriptions.CamParameters", &SEQUENCE_ber_, NULL, NULL, NULL, &CamParameters_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LowFrequencyContainer
const TTCN_JSONdescriptor_t LowFrequencyContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LowFrequencyContainer_descr_ = { "@CAM-PDU-Descriptions.LowFrequencyContainer", &CHOICE_ber_, NULL, NULL, NULL, &LowFrequencyContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerLowFrequency_vehicleRole_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t BasicVehicleContainerLowFrequency_vehicleRole_ber_ = { 1u, BasicVehicleContainerLowFrequency_vehicleRole_tag_ };
// No XER for BasicVehicleContainerLowFrequency_vehicleRole
const TTCN_Typedescriptor_t BasicVehicleContainerLowFrequency_vehicleRole_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.vehicleRole", &BasicVehicleContainerLowFrequency_vehicleRole_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerLowFrequency_exteriorLights_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t BasicVehicleContainerLowFrequency_exteriorLights_ber_ = { 1u, BasicVehicleContainerLowFrequency_exteriorLights_tag_ };
// No XER for BasicVehicleContainerLowFrequency_exteriorLights
const TTCN_Typedescriptor_t BasicVehicleContainerLowFrequency_exteriorLights_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.exteriorLights", &BasicVehicleContainerLowFrequency_exteriorLights_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t BasicVehicleContainerLowFrequency_pathHistory_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t BasicVehicleContainerLowFrequency_pathHistory_ber_ = { 1u, BasicVehicleContainerLowFrequency_pathHistory_tag_ };
// No XER for BasicVehicleContainerLowFrequency_pathHistory
const TTCN_Typedescriptor_t BasicVehicleContainerLowFrequency_pathHistory_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.pathHistory", &BasicVehicleContainerLowFrequency_pathHistory_ber_, NULL, NULL, NULL, NULL, &ITS__Container::PathPoint_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for BasicVehicleContainerLowFrequency
const TTCN_JSONdescriptor_t BasicVehicleContainerLowFrequency_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BasicVehicleContainerLowFrequency_descr_ = { "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency", &SEQUENCE_ber_, NULL, NULL, NULL, &BasicVehicleContainerLowFrequency_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LowFrequencyContainer_basicVehicleContainerLowFrequency_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t LowFrequencyContainer_basicVehicleContainerLowFrequency_ber_ = { 1u, LowFrequencyContainer_basicVehicleContainerLowFrequency_tag_ };
// No XER for LowFrequencyContainer_basicVehicleContainerLowFrequency
const TTCN_Typedescriptor_t LowFrequencyContainer_basicVehicleContainerLowFrequency_descr_ = { "@CAM-PDU-Descriptions.LowFrequencyContainer.basicVehicleContainerLowFrequency", &LowFrequencyContainer_basicVehicleContainerLowFrequency_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t CamParameters_lowFrequencyContainer_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t CamParameters_lowFrequencyContainer_ber_ = { 1u, CamParameters_lowFrequencyContainer_tag_ };
// No XER for CamParameters_lowFrequencyContainer
const TTCN_Typedescriptor_t CamParameters_lowFrequencyContainer_descr_ = { "@CAM-PDU-Descriptions.CamParameters.lowFrequencyContainer", &CamParameters_lowFrequencyContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SpecialVehicleContainer
const TTCN_JSONdescriptor_t SpecialVehicleContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SpecialVehicleContainer_descr_ = { "@CAM-PDU-Descriptions.SpecialVehicleContainer", &CHOICE_ber_, NULL, NULL, NULL, &SpecialVehicleContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t PublicTransportContainer_embarkationStatus_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t PublicTransportContainer_embarkationStatus_ber_ = { 1u, PublicTransportContainer_embarkationStatus_tag_ };
// No XER for PublicTransportContainer_embarkationStatus
const TTCN_Typedescriptor_t PublicTransportContainer_embarkationStatus_descr_ = { "@CAM-PDU-Descriptions.PublicTransportContainer.embarkationStatus", &PublicTransportContainer_embarkationStatus_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, NULL, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for PublicTransportContainer
const TTCN_JSONdescriptor_t PublicTransportContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PublicTransportContainer_descr_ = { "@CAM-PDU-Descriptions.PublicTransportContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &PublicTransportContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t PublicTransportContainer_ptActivation_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t PublicTransportContainer_ptActivation_ber_ = { 1u, PublicTransportContainer_ptActivation_tag_ };
// No XER for PublicTransportContainer_ptActivation
const TTCN_Typedescriptor_t PublicTransportContainer_ptActivation_descr_ = { "@CAM-PDU-Descriptions.PublicTransportContainer.ptActivation", &PublicTransportContainer_ptActivation_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SpecialVehicleContainer_publicTransportContainer_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t SpecialVehicleContainer_publicTransportContainer_ber_ = { 1u, SpecialVehicleContainer_publicTransportContainer_tag_ };
// No XER for SpecialVehicleContainer_publicTransportContainer
const TTCN_Typedescriptor_t SpecialVehicleContainer_publicTransportContainer_descr_ = { "@CAM-PDU-Descriptions.SpecialVehicleContainer.publicTransportContainer", &SpecialVehicleContainer_publicTransportContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SpecialTransportContainer_specialTransportType_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t SpecialTransportContainer_specialTransportType_ber_ = { 1u, SpecialTransportContainer_specialTransportType_tag_ };
// No XER for SpecialTransportContainer_specialTransportType
const TTCN_Typedescriptor_t SpecialTransportContainer_specialTransportType_descr_ = { "@CAM-PDU-Descriptions.SpecialTransportContainer.specialTransportType", &SpecialTransportContainer_specialTransportType_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SpecialTransportContainer_lightBarSirenInUse_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t SpecialTransportContainer_lightBarSirenInUse_ber_ = { 1u, SpecialTransportContainer_lightBarSirenInUse_tag_ };
// No XER for SpecialTransportContainer_lightBarSirenInUse
const TTCN_Typedescriptor_t SpecialTransportContainer_lightBarSirenInUse_descr_ = { "@CAM-PDU-Descriptions.SpecialTransportContainer.lightBarSirenInUse", &SpecialTransportContainer_lightBarSirenInUse_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SpecialTransportContainer
const TTCN_JSONdescriptor_t SpecialTransportContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SpecialTransportContainer_descr_ = { "@CAM-PDU-Descriptions.SpecialTransportContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &SpecialTransportContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SpecialVehicleContainer_specialTransportContainer_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t SpecialVehicleContainer_specialTransportContainer_ber_ = { 1u, SpecialVehicleContainer_specialTransportContainer_tag_ };
// No XER for SpecialVehicleContainer_specialTransportContainer
const TTCN_Typedescriptor_t SpecialVehicleContainer_specialTransportContainer_descr_ = { "@CAM-PDU-Descriptions.SpecialVehicleContainer.specialTransportContainer", &SpecialVehicleContainer_specialTransportContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DangerousGoodsContainer_dangerousGoodsBasic_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t DangerousGoodsContainer_dangerousGoodsBasic_ber_ = { 1u, DangerousGoodsContainer_dangerousGoodsBasic_tag_ };
// No XER for DangerousGoodsContainer_dangerousGoodsBasic
const TTCN_Typedescriptor_t DangerousGoodsContainer_dangerousGoodsBasic_descr_ = { "@CAM-PDU-Descriptions.DangerousGoodsContainer.dangerousGoodsBasic", &DangerousGoodsContainer_dangerousGoodsBasic_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for DangerousGoodsContainer
const TTCN_JSONdescriptor_t DangerousGoodsContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DangerousGoodsContainer_descr_ = { "@CAM-PDU-Descriptions.DangerousGoodsContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &DangerousGoodsContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SpecialVehicleContainer_dangerousGoodsContainer_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t SpecialVehicleContainer_dangerousGoodsContainer_ber_ = { 1u, SpecialVehicleContainer_dangerousGoodsContainer_tag_ };
// No XER for SpecialVehicleContainer_dangerousGoodsContainer
const TTCN_Typedescriptor_t SpecialVehicleContainer_dangerousGoodsContainer_descr_ = { "@CAM-PDU-Descriptions.SpecialVehicleContainer.dangerousGoodsContainer", &SpecialVehicleContainer_dangerousGoodsContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerBasic_lightBarSirenInUse_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t RoadWorksContainerBasic_lightBarSirenInUse_ber_ = { 1u, RoadWorksContainerBasic_lightBarSirenInUse_tag_ };
// No XER for RoadWorksContainerBasic_lightBarSirenInUse
const TTCN_Typedescriptor_t RoadWorksContainerBasic_lightBarSirenInUse_descr_ = { "@CAM-PDU-Descriptions.RoadWorksContainerBasic.lightBarSirenInUse", &RoadWorksContainerBasic_lightBarSirenInUse_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RoadWorksContainerBasic
const TTCN_JSONdescriptor_t RoadWorksContainerBasic_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RoadWorksContainerBasic_descr_ = { "@CAM-PDU-Descriptions.RoadWorksContainerBasic", &SEQUENCE_ber_, NULL, NULL, NULL, &RoadWorksContainerBasic_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerBasic_roadworksSubCauseCode_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t RoadWorksContainerBasic_roadworksSubCauseCode_ber_ = { 1u, RoadWorksContainerBasic_roadworksSubCauseCode_tag_ };
// No XER for RoadWorksContainerBasic_roadworksSubCauseCode
const TTCN_Typedescriptor_t RoadWorksContainerBasic_roadworksSubCauseCode_descr_ = { "@CAM-PDU-Descriptions.RoadWorksContainerBasic.roadworksSubCauseCode", &RoadWorksContainerBasic_roadworksSubCauseCode_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerBasic_closedLanes_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t RoadWorksContainerBasic_closedLanes_ber_ = { 1u, RoadWorksContainerBasic_closedLanes_tag_ };
// No XER for RoadWorksContainerBasic_closedLanes
const TTCN_Typedescriptor_t RoadWorksContainerBasic_closedLanes_descr_ = { "@CAM-PDU-Descriptions.RoadWorksContainerBasic.closedLanes", &RoadWorksContainerBasic_closedLanes_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SpecialVehicleContainer_roadWorksContainerBasic_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t SpecialVehicleContainer_roadWorksContainerBasic_ber_ = { 1u, SpecialVehicleContainer_roadWorksContainerBasic_tag_ };
// No XER for SpecialVehicleContainer_roadWorksContainerBasic
const TTCN_Typedescriptor_t SpecialVehicleContainer_roadWorksContainerBasic_descr_ = { "@CAM-PDU-Descriptions.SpecialVehicleContainer.roadWorksContainerBasic", &SpecialVehicleContainer_roadWorksContainerBasic_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RescueContainer_lightBarSirenInUse_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t RescueContainer_lightBarSirenInUse_ber_ = { 1u, RescueContainer_lightBarSirenInUse_tag_ };
// No XER for RescueContainer_lightBarSirenInUse
const TTCN_Typedescriptor_t RescueContainer_lightBarSirenInUse_descr_ = { "@CAM-PDU-Descriptions.RescueContainer.lightBarSirenInUse", &RescueContainer_lightBarSirenInUse_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RescueContainer
const TTCN_JSONdescriptor_t RescueContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RescueContainer_descr_ = { "@CAM-PDU-Descriptions.RescueContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &RescueContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SpecialVehicleContainer_rescueContainer_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t SpecialVehicleContainer_rescueContainer_ber_ = { 1u, SpecialVehicleContainer_rescueContainer_tag_ };
// No XER for SpecialVehicleContainer_rescueContainer
const TTCN_Typedescriptor_t SpecialVehicleContainer_rescueContainer_descr_ = { "@CAM-PDU-Descriptions.SpecialVehicleContainer.rescueContainer", &SpecialVehicleContainer_rescueContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t EmergencyContainer_lightBarSirenInUse_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t EmergencyContainer_lightBarSirenInUse_ber_ = { 1u, EmergencyContainer_lightBarSirenInUse_tag_ };
// No XER for EmergencyContainer_lightBarSirenInUse
const TTCN_Typedescriptor_t EmergencyContainer_lightBarSirenInUse_descr_ = { "@CAM-PDU-Descriptions.EmergencyContainer.lightBarSirenInUse", &EmergencyContainer_lightBarSirenInUse_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for EmergencyContainer
const TTCN_JSONdescriptor_t EmergencyContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EmergencyContainer_descr_ = { "@CAM-PDU-Descriptions.EmergencyContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &EmergencyContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t EmergencyContainer_incidentIndication_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t EmergencyContainer_incidentIndication_ber_ = { 1u, EmergencyContainer_incidentIndication_tag_ };
// No XER for EmergencyContainer_incidentIndication
const TTCN_Typedescriptor_t EmergencyContainer_incidentIndication_descr_ = { "@CAM-PDU-Descriptions.EmergencyContainer.incidentIndication", &EmergencyContainer_incidentIndication_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t EmergencyContainer_emergencyPriority_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t EmergencyContainer_emergencyPriority_ber_ = { 1u, EmergencyContainer_emergencyPriority_tag_ };
// No XER for EmergencyContainer_emergencyPriority
const TTCN_Typedescriptor_t EmergencyContainer_emergencyPriority_descr_ = { "@CAM-PDU-Descriptions.EmergencyContainer.emergencyPriority", &EmergencyContainer_emergencyPriority_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SpecialVehicleContainer_emergencyContainer_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t SpecialVehicleContainer_emergencyContainer_ber_ = { 1u, SpecialVehicleContainer_emergencyContainer_tag_ };
// No XER for SpecialVehicleContainer_emergencyContainer
const TTCN_Typedescriptor_t SpecialVehicleContainer_emergencyContainer_descr_ = { "@CAM-PDU-Descriptions.SpecialVehicleContainer.emergencyContainer", &SpecialVehicleContainer_emergencyContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SafetyCarContainer_lightBarSirenInUse_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t SafetyCarContainer_lightBarSirenInUse_ber_ = { 1u, SafetyCarContainer_lightBarSirenInUse_tag_ };
// No XER for SafetyCarContainer_lightBarSirenInUse
const TTCN_Typedescriptor_t SafetyCarContainer_lightBarSirenInUse_descr_ = { "@CAM-PDU-Descriptions.SafetyCarContainer.lightBarSirenInUse", &SafetyCarContainer_lightBarSirenInUse_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SafetyCarContainer
const TTCN_JSONdescriptor_t SafetyCarContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SafetyCarContainer_descr_ = { "@CAM-PDU-Descriptions.SafetyCarContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &SafetyCarContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SafetyCarContainer_incidentIndication_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t SafetyCarContainer_incidentIndication_ber_ = { 1u, SafetyCarContainer_incidentIndication_tag_ };
// No XER for SafetyCarContainer_incidentIndication
const TTCN_Typedescriptor_t SafetyCarContainer_incidentIndication_descr_ = { "@CAM-PDU-Descriptions.SafetyCarContainer.incidentIndication", &SafetyCarContainer_incidentIndication_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SafetyCarContainer_trafficRule_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t SafetyCarContainer_trafficRule_ber_ = { 1u, SafetyCarContainer_trafficRule_tag_ };
// No XER for SafetyCarContainer_trafficRule
const TTCN_Typedescriptor_t SafetyCarContainer_trafficRule_descr_ = { "@CAM-PDU-Descriptions.SafetyCarContainer.trafficRule", &SafetyCarContainer_trafficRule_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SafetyCarContainer_speedLimit_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t SafetyCarContainer_speedLimit_ber_ = { 1u, SafetyCarContainer_speedLimit_tag_ };
// No XER for SafetyCarContainer_speedLimit
const TTCN_Typedescriptor_t SafetyCarContainer_speedLimit_descr_ = { "@CAM-PDU-Descriptions.SafetyCarContainer.speedLimit", &SafetyCarContainer_speedLimit_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SpecialVehicleContainer_safetyCarContainer_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t SpecialVehicleContainer_safetyCarContainer_ber_ = { 1u, SpecialVehicleContainer_safetyCarContainer_tag_ };
// No XER for SpecialVehicleContainer_safetyCarContainer
const TTCN_Typedescriptor_t SpecialVehicleContainer_safetyCarContainer_descr_ = { "@CAM-PDU-Descriptions.SpecialVehicleContainer.safetyCarContainer", &SpecialVehicleContainer_safetyCarContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t CamParameters_specialVehicleContainer_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t CamParameters_specialVehicleContainer_ber_ = { 1u, CamParameters_specialVehicleContainer_tag_ };
// No XER for CamParameters_specialVehicleContainer
const TTCN_Typedescriptor_t CamParameters_specialVehicleContainer_descr_ = { "@CAM-PDU-Descriptions.CamParameters.specialVehicleContainer", &CamParameters_specialVehicleContainer_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t CoopAwareness_camParameters_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t CoopAwareness_camParameters_ber_ = { 1u, CoopAwareness_camParameters_tag_ };
// No XER for CoopAwareness_camParameters
const TTCN_Typedescriptor_t CoopAwareness_camParameters_descr_ = { "@CAM-PDU-Descriptions.CoopAwareness.camParameters", &CoopAwareness_camParameters_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CoopAwareness
const TTCN_JSONdescriptor_t CoopAwareness_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CoopAwareness_descr_ = { "@CAM-PDU-Descriptions.CoopAwareness", &SEQUENCE_ber_, NULL, NULL, NULL, &CoopAwareness_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t CAM_cam_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t CAM_cam_ber_ = { 1u, CAM_cam_tag_ };
// No XER for CAM_cam
const TTCN_Typedescriptor_t CAM_cam_descr_ = { "@CAM-PDU-Descriptions.CAM.cam", &CAM_cam_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CAM
const TTCN_JSONdescriptor_t CAM_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CAM_descr_ = { "@CAM-PDU-Descriptions.CAM", &SEQUENCE_ber_, NULL, NULL, NULL, &CAM_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
TTCN_Module module_object("CAM-PDU-Descriptions", __DATE__, __TIME__, NULL, pre_init_module);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

BasicContainer::BasicContainer()
{
  bound_flag = FALSE;
}

BasicContainer::BasicContainer(const INTEGER& par_stationType,
    const ITS__Container::ReferencePosition& par_referencePosition)
  :   field_stationType(par_stationType),
  field_referencePosition(par_referencePosition)
{
  bound_flag = TRUE;
}

BasicContainer::BasicContainer(const BasicContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.BasicContainer.");
bound_flag = TRUE;
if (other_value.stationType().is_bound()) field_stationType = other_value.stationType();
else field_stationType.clean_up();
if (other_value.referencePosition().is_bound()) field_referencePosition = other_value.referencePosition();
else field_referencePosition.clean_up();
}

void BasicContainer::clean_up()
{
field_stationType.clean_up();
field_referencePosition.clean_up();
bound_flag = FALSE;
}

BasicContainer& BasicContainer::operator=(const BasicContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.BasicContainer.");
  bound_flag = TRUE;
  if (other_value.stationType().is_bound()) field_stationType = other_value.stationType();
  else field_stationType.clean_up();
  if (other_value.referencePosition().is_bound()) field_referencePosition = other_value.referencePosition();
  else field_referencePosition.clean_up();
}
return *this;
}

boolean BasicContainer::operator==(const BasicContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_stationType==other_value.field_stationType
  && field_referencePosition==other_value.field_referencePosition;
}

boolean BasicContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_stationType.is_bound()) return TRUE;
if(field_referencePosition.is_bound()) return TRUE;
return FALSE;
}
boolean BasicContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_stationType.is_value()) return FALSE;
if(!field_referencePosition.is_value()) return FALSE;
return TRUE;
}
int BasicContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.BasicContainer");
  return 2;
}

void BasicContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stationType := ");
field_stationType.log();
TTCN_Logger::log_event_str(", referencePosition := ");
field_referencePosition.log();
TTCN_Logger::log_event_str(" }");
}

void BasicContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.BasicContainer'");
    }
    if (strcmp("stationType", param_field) == 0) {
      stationType().set_param(param);
      return;
    } else if (strcmp("referencePosition", param_field) == 0) {
      referencePosition().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.BasicContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.BasicContainer has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stationType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) referencePosition().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "referencePosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          referencePosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.BasicContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.BasicContainer");
  }
}

Module_Param* BasicContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.BasicContainer'");
    }
    if (strcmp("stationType", param_field) == 0) {
      return stationType().get_param(param_name);
    } else if (strcmp("referencePosition", param_field) == 0) {
      return referencePosition().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.BasicContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_stationType = field_stationType.get_param(param_name);
  mp_field_stationType->set_id(new Module_Param_FieldName(mcopystr("stationType")));
  mp->add_elem(mp_field_stationType);
  Module_Param* mp_field_referencePosition = field_referencePosition.get_param(param_name);
  mp_field_referencePosition->set_id(new Module_Param_FieldName(mcopystr("referencePosition")));
  mp->add_elem(mp_field_referencePosition);
  return mp;
  }

void BasicContainer::set_implicit_omit()
{
if (stationType().is_bound()) stationType().set_implicit_omit();
if (referencePosition().is_bound()) referencePosition().set_implicit_omit();
}

void BasicContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.BasicContainer.");
field_stationType.encode_text(text_buf);
field_referencePosition.encode_text(text_buf);
}

void BasicContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_stationType.decode_text(text_buf);
field_referencePosition.decode_text(text_buf);
}

void BasicContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BasicContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* BasicContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("stationType': ");
  new_tlv->add_TLV(field_stationType.BER_encode_TLV(BasicContainer_stationType_descr_, p_coding));
  ec_1.set_msg("referencePosition': ");
  new_tlv->add_TLV(field_referencePosition.BER_encode_TLV(BasicContainer_referencePosition_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean BasicContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.BasicContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("stationType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_stationType.BER_decode_TLV(BasicContainer_stationType_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("referencePosition': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_referencePosition.BER_decode_TLV(BasicContainer_referencePosition_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int BasicContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.BasicContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stationType");
    enc_len += field_stationType.JSON_encode(BasicContainer_stationType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "referencePosition");
    enc_len += field_referencePosition.JSON_encode(BasicContainer_referencePosition_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BasicContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (11 == name_len && 0 == strncmp(fld_name, "stationType", name_len)) {
         int ret_val = field_stationType.JSON_decode(BasicContainer_stationType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stationType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "referencePosition", name_len)) {
         int ret_val = field_referencePosition.JSON_decode(BasicContainer_referencePosition_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "referencePosition");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_stationType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "stationType");
    return JSON_ERROR_FATAL;
  }
if (!field_referencePosition.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "referencePosition");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct BasicContainer_template::single_value_struct {
INTEGER_template field_stationType;
ITS__Container::ReferencePosition_template field_referencePosition;
};

void BasicContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stationType = ANY_VALUE;
single_value->field_referencePosition = ANY_VALUE;
}
}
}

void BasicContainer_template::copy_value(const BasicContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.stationType().is_bound()) {
  single_value->field_stationType = other_value.stationType();
} else {
  single_value->field_stationType.clean_up();
}
if (other_value.referencePosition().is_bound()) {
  single_value->field_referencePosition = other_value.referencePosition();
} else {
  single_value->field_referencePosition.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BasicContainer_template::copy_template(const BasicContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stationType().get_selection()) {
single_value->field_stationType = other_value.stationType();
} else {
single_value->field_stationType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.referencePosition().get_selection()) {
single_value->field_referencePosition = other_value.referencePosition();
} else {
single_value->field_referencePosition.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BasicContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicContainer.");
break;
}
set_selection(other_value);
}

BasicContainer_template::BasicContainer_template()
{
}

BasicContainer_template::BasicContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BasicContainer_template::BasicContainer_template(const BasicContainer& other_value)
{
copy_value(other_value);
}

BasicContainer_template::BasicContainer_template(const OPTIONAL<BasicContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BasicContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.BasicContainer from an unbound optional field.");
}
}

BasicContainer_template::BasicContainer_template(const BasicContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BasicContainer_template::~BasicContainer_template()
{
clean_up();
}

BasicContainer_template& BasicContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BasicContainer_template& BasicContainer_template::operator=(const BasicContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BasicContainer_template& BasicContainer_template::operator=(const OPTIONAL<BasicContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BasicContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.BasicContainer.");
}
return *this;
}

BasicContainer_template& BasicContainer_template::operator=(const BasicContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BasicContainer_template::match(const BasicContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stationType().is_bound()) return FALSE;
if(!single_value->field_stationType.match(other_value.stationType(), legacy))return FALSE;
if(!other_value.referencePosition().is_bound()) return FALSE;
if(!single_value->field_referencePosition.match(other_value.referencePosition(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicContainer.");
}
return FALSE;
}

boolean BasicContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_stationType.is_bound()) return TRUE;
if (single_value->field_referencePosition.is_bound()) return TRUE;
return FALSE;
}

boolean BasicContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_stationType.is_value()) return FALSE;
if (!single_value->field_referencePosition.is_value()) return FALSE;
return TRUE;
}

void BasicContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BasicContainer BasicContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.BasicContainer.");
BasicContainer ret_val;
if (single_value->field_stationType.is_bound()) {
ret_val.stationType() = single_value->field_stationType.valueof();
}
if (single_value->field_referencePosition.is_bound()) {
ret_val.referencePosition() = single_value->field_referencePosition.valueof();
}
return ret_val;
}

void BasicContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.BasicContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BasicContainer_template[list_length];
}

BasicContainer_template& BasicContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.BasicContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.BasicContainer.");
return value_list.list_value[list_index];
}

INTEGER_template& BasicContainer_template::stationType()
{
set_specific();
return single_value->field_stationType;
}

const INTEGER_template& BasicContainer_template::stationType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stationType of a non-specific template of type @CAM-PDU-Descriptions.BasicContainer.");
return single_value->field_stationType;
}

ITS__Container::ReferencePosition_template& BasicContainer_template::referencePosition()
{
set_specific();
return single_value->field_referencePosition;
}

const ITS__Container::ReferencePosition_template& BasicContainer_template::referencePosition() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field referencePosition of a non-specific template of type @CAM-PDU-Descriptions.BasicContainer.");
return single_value->field_referencePosition;
}

int BasicContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicContainer.");
  }
  return 0;
}

void BasicContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stationType := ");
single_value->field_stationType.log();
TTCN_Logger::log_event_str(", referencePosition := ");
single_value->field_referencePosition.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BasicContainer_template::log_match(const BasicContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_stationType.match(match_value.stationType(), legacy)){
TTCN_Logger::log_logmatch_info(".stationType");
single_value->field_stationType.log_match(match_value.stationType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_referencePosition.match(match_value.referencePosition(), legacy)){
TTCN_Logger::log_logmatch_info(".referencePosition");
single_value->field_referencePosition.log_match(match_value.referencePosition(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stationType := ");
single_value->field_stationType.log_match(match_value.stationType(), legacy);
TTCN_Logger::log_event_str(", referencePosition := ");
single_value->field_referencePosition.log_match(match_value.referencePosition(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BasicContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stationType.encode_text(text_buf);
single_value->field_referencePosition.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicContainer.");
}
}

void BasicContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stationType.decode_text(text_buf);
single_value->field_referencePosition.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BasicContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.BasicContainer.");
}
}

void BasicContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.BasicContainer'");
    }
    if (strcmp("stationType", param_field) == 0) {
      stationType().set_param(param);
      return;
    } else if (strcmp("referencePosition", param_field) == 0) {
      referencePosition().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.BasicContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BasicContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.BasicContainer has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stationType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) referencePosition().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "referencePosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          referencePosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.BasicContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.BasicContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BasicContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.BasicContainer'");
    }
    if (strcmp("stationType", param_field) == 0) {
      return stationType().get_param(param_name);
    } else if (strcmp("referencePosition", param_field) == 0) {
      return referencePosition().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.BasicContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_stationType = single_value->field_stationType.get_param(param_name);
    mp_field_stationType->set_id(new Module_Param_FieldName(mcopystr("stationType")));
    mp->add_elem(mp_field_stationType);
    Module_Param* mp_field_referencePosition = single_value->field_referencePosition.get_param(param_name);
    mp_field_referencePosition->set_id(new Module_Param_FieldName(mcopystr("referencePosition")));
    mp->add_elem(mp_field_referencePosition);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BasicContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stationType.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicContainer");
single_value->field_referencePosition.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.BasicContainer");
}

boolean BasicContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BasicContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HighFrequencyContainer::copy_value(const HighFrequencyContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_basicVehicleContainerHighFrequency:
field_basicVehicleContainerHighFrequency = new BasicVehicleContainerHighFrequency(*other_value.field_basicVehicleContainerHighFrequency);
break;
case ALT_rsuContainerHighFrequency:
field_rsuContainerHighFrequency = new RSUContainerHighFrequency(*other_value.field_rsuContainerHighFrequency);
break;
default:
TTCN_error("Assignment of an unbound union value of type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
union_selection = other_value.union_selection;
}

HighFrequencyContainer::HighFrequencyContainer()
{
union_selection = UNBOUND_VALUE;
}

HighFrequencyContainer::HighFrequencyContainer(const HighFrequencyContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

HighFrequencyContainer::~HighFrequencyContainer()
{
clean_up();
}

HighFrequencyContainer& HighFrequencyContainer::operator=(const HighFrequencyContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean HighFrequencyContainer::operator==(const HighFrequencyContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_basicVehicleContainerHighFrequency:
return *field_basicVehicleContainerHighFrequency == *other_value.field_basicVehicleContainerHighFrequency;
case ALT_rsuContainerHighFrequency:
return *field_rsuContainerHighFrequency == *other_value.field_rsuContainerHighFrequency;
default:
return FALSE;
}
}

BasicVehicleContainerHighFrequency& HighFrequencyContainer::basicVehicleContainerHighFrequency()
{
if (union_selection != ALT_basicVehicleContainerHighFrequency) {
clean_up();
field_basicVehicleContainerHighFrequency = new BasicVehicleContainerHighFrequency;
union_selection = ALT_basicVehicleContainerHighFrequency;
}
return *field_basicVehicleContainerHighFrequency;
}

const BasicVehicleContainerHighFrequency& HighFrequencyContainer::basicVehicleContainerHighFrequency() const
{
if (union_selection != ALT_basicVehicleContainerHighFrequency) TTCN_error("Using non-selected field basicVehicleContainerHighFrequency in a value of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
return *field_basicVehicleContainerHighFrequency;
}

RSUContainerHighFrequency& HighFrequencyContainer::rsuContainerHighFrequency()
{
if (union_selection != ALT_rsuContainerHighFrequency) {
clean_up();
field_rsuContainerHighFrequency = new RSUContainerHighFrequency;
union_selection = ALT_rsuContainerHighFrequency;
}
return *field_rsuContainerHighFrequency;
}

const RSUContainerHighFrequency& HighFrequencyContainer::rsuContainerHighFrequency() const
{
if (union_selection != ALT_rsuContainerHighFrequency) TTCN_error("Using non-selected field rsuContainerHighFrequency in a value of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
return *field_rsuContainerHighFrequency;
}

boolean HighFrequencyContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
return union_selection == checked_selection;
}

boolean HighFrequencyContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean HighFrequencyContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_basicVehicleContainerHighFrequency: return field_basicVehicleContainerHighFrequency->is_value();
case ALT_rsuContainerHighFrequency: return field_rsuContainerHighFrequency->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void HighFrequencyContainer::clean_up()
{
switch (union_selection) {
case ALT_basicVehicleContainerHighFrequency:
  delete field_basicVehicleContainerHighFrequency;
  break;
case ALT_rsuContainerHighFrequency:
  delete field_rsuContainerHighFrequency;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void HighFrequencyContainer::log() const
{
switch (union_selection) {
case ALT_basicVehicleContainerHighFrequency:
TTCN_Logger::log_event_str("{ basicVehicleContainerHighFrequency := ");
field_basicVehicleContainerHighFrequency->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_rsuContainerHighFrequency:
TTCN_Logger::log_event_str("{ rsuContainerHighFrequency := ");
field_rsuContainerHighFrequency->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void HighFrequencyContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@CAM-PDU-Descriptions.HighFrequencyContainer'");
    }
    if (strcmp("basicVehicleContainerHighFrequency", param_field) == 0) {
      basicVehicleContainerHighFrequency().set_param(param);
      return;
    } else if (strcmp("rsuContainerHighFrequency", param_field) == 0) {
      rsuContainerHighFrequency().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@CAM-PDU-Descriptions.HighFrequencyContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "basicVehicleContainerHighFrequency")) {
    basicVehicleContainerHighFrequency().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "rsuContainerHighFrequency")) {
    rsuContainerHighFrequency().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @CAM-PDU-Descriptions.HighFrequencyContainer.", mp_last->get_id()->get_name());
}

Module_Param* HighFrequencyContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@CAM-PDU-Descriptions.HighFrequencyContainer'");
    }
    if (strcmp("basicVehicleContainerHighFrequency", param_field) == 0) {
      return basicVehicleContainerHighFrequency().get_param(param_name);
    } else if (strcmp("rsuContainerHighFrequency", param_field) == 0) {
      return rsuContainerHighFrequency().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `HighFrequencyContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_basicVehicleContainerHighFrequency:
    mp_field = field_basicVehicleContainerHighFrequency->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("basicVehicleContainerHighFrequency")));
    break;
  case ALT_rsuContainerHighFrequency:
    mp_field = field_rsuContainerHighFrequency->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("rsuContainerHighFrequency")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void HighFrequencyContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_basicVehicleContainerHighFrequency:
field_basicVehicleContainerHighFrequency->set_implicit_omit(); break;
case ALT_rsuContainerHighFrequency:
field_rsuContainerHighFrequency->set_implicit_omit(); break;
default: break;
}
}

void HighFrequencyContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_basicVehicleContainerHighFrequency:
field_basicVehicleContainerHighFrequency->encode_text(text_buf);
break;
case ALT_rsuContainerHighFrequency:
field_rsuContainerHighFrequency->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
}

void HighFrequencyContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_basicVehicleContainerHighFrequency:
basicVehicleContainerHighFrequency().decode_text(text_buf);
break;
case ALT_rsuContainerHighFrequency:
rsuContainerHighFrequency().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
}

void HighFrequencyContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HighFrequencyContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t *HighFrequencyContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv;
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  switch (union_selection) {
  case ALT_basicVehicleContainerHighFrequency:
    ec_1.set_msg("basicVehicleContainerHighFrequency': ");
    new_tlv = field_basicVehicleContainerHighFrequency->BER_encode_TLV(HighFrequencyContainer_basicVehicleContainerHighFrequency_descr_, p_coding);
    break;
  case ALT_rsuContainerHighFrequency:
    ec_1.set_msg("rsuContainerHighFrequency': ");
    new_tlv = field_rsuContainerHighFrequency->BER_encode_TLV(HighFrequencyContainer_rsuContainerHighFrequency_descr_, p_coding);
    break;
  case UNBOUND_VALUE:
    new_tlv = BER_encode_chk_bound(FALSE);
    break;
  default:
    TTCN_EncDec_ErrorContext::error_internal("Unknown selection.");
    new_tlv = NULL;
  }
  return ASN_BER_V2TLV(new_tlv, p_td, p_coding);
}

boolean HighFrequencyContainer::BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv)
{
  clean_up();
  field_basicVehicleContainerHighFrequency = new BasicVehicleContainerHighFrequency;
  union_selection = ALT_basicVehicleContainerHighFrequency;
  if (field_basicVehicleContainerHighFrequency->BER_decode_isMyMsg(HighFrequencyContainer_basicVehicleContainerHighFrequency_descr_, p_tlv)) return TRUE;
  delete field_basicVehicleContainerHighFrequency;
  field_rsuContainerHighFrequency = new RSUContainerHighFrequency;
  union_selection = ALT_rsuContainerHighFrequency;
  if (field_rsuContainerHighFrequency->BER_decode_isMyMsg(HighFrequencyContainer_rsuContainerHighFrequency_descr_, p_tlv)) return TRUE;
  delete field_rsuContainerHighFrequency;
  union_selection = UNBOUND_VALUE;
  return FALSE;
}

boolean HighFrequencyContainer::BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv)
{
  if (p_td.ber->n_tags == 0) {
    HighFrequencyContainer tmp_type;
    return tmp_type.BER_decode_set_selection(p_tlv);
  } else return Base_Type::BER_decode_isMyMsg(p_td, p_tlv);
}

boolean HighFrequencyContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.HighFrequencyContainer' type: ");
  ASN_BER_TLV_t tmp_tlv;
  if (!BER_decode_TLV_CHOICE(*p_td.ber, stripped_tlv, L_form, tmp_tlv) || !BER_decode_CHOICE_selection(BER_decode_set_selection(tmp_tlv), tmp_tlv)) return FALSE;
  TTCN_EncDec_ErrorContext ec_1("Alternative '");
  TTCN_EncDec_ErrorContext ec_2;
  switch (union_selection) {
  case ALT_basicVehicleContainerHighFrequency:
    ec_2.set_msg("basicVehicleContainerHighFrequency': ");
    field_basicVehicleContainerHighFrequency->BER_decode_TLV(HighFrequencyContainer_basicVehicleContainerHighFrequency_descr_, tmp_tlv, L_form);
    break;
  case ALT_rsuContainerHighFrequency:
    ec_2.set_msg("rsuContainerHighFrequency': ");
    field_rsuContainerHighFrequency->BER_decode_TLV(HighFrequencyContainer_rsuContainerHighFrequency_descr_, tmp_tlv, L_form);
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

int HighFrequencyContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_basicVehicleContainerHighFrequency:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "basicVehicleContainerHighFrequency");
    enc_len += field_basicVehicleContainerHighFrequency->JSON_encode(HighFrequencyContainer_basicVehicleContainerHighFrequency_descr_, p_tok);
    break;
  case ALT_rsuContainerHighFrequency:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rsuContainerHighFrequency");
    enc_len += field_rsuContainerHighFrequency->JSON_encode(HighFrequencyContainer_rsuContainerHighFrequency_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @CAM-PDU-Descriptions.HighFrequencyContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int HighFrequencyContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "basicVehicleContainerHighFrequency", name_len)) {
      int ret_val = basicVehicleContainerHighFrequency().JSON_decode(HighFrequencyContainer_basicVehicleContainerHighFrequency_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "basicVehicleContainerHighFrequency");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "rsuContainerHighFrequency", name_len)) {
      int ret_val = rsuContainerHighFrequency().JSON_decode(HighFrequencyContainer_rsuContainerHighFrequency_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rsuContainerHighFrequency");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void HighFrequencyContainer_template::copy_value(const HighFrequencyContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
single_value.field_basicVehicleContainerHighFrequency = new BasicVehicleContainerHighFrequency_template(other_value.basicVehicleContainerHighFrequency());
break;
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
single_value.field_rsuContainerHighFrequency = new RSUContainerHighFrequency_template(other_value.rsuContainerHighFrequency());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void HighFrequencyContainer_template::copy_template(const HighFrequencyContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
single_value.field_basicVehicleContainerHighFrequency = new BasicVehicleContainerHighFrequency_template(*other_value.single_value.field_basicVehicleContainerHighFrequency);
break;
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
single_value.field_rsuContainerHighFrequency = new RSUContainerHighFrequency_template(*other_value.single_value.field_rsuContainerHighFrequency);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HighFrequencyContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
set_selection(other_value);
}

HighFrequencyContainer_template::HighFrequencyContainer_template()
{
}

HighFrequencyContainer_template::HighFrequencyContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HighFrequencyContainer_template::HighFrequencyContainer_template(const HighFrequencyContainer& other_value)
{
copy_value(other_value);
}

HighFrequencyContainer_template::HighFrequencyContainer_template(const OPTIONAL<HighFrequencyContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HighFrequencyContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer from an unbound optional field.");
}
}

HighFrequencyContainer_template::HighFrequencyContainer_template(const HighFrequencyContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

HighFrequencyContainer_template::~HighFrequencyContainer_template()
{
clean_up();
}

void HighFrequencyContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
delete single_value.field_basicVehicleContainerHighFrequency;
break;
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
delete single_value.field_rsuContainerHighFrequency;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

HighFrequencyContainer_template& HighFrequencyContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HighFrequencyContainer_template& HighFrequencyContainer_template::operator=(const HighFrequencyContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

HighFrequencyContainer_template& HighFrequencyContainer_template::operator=(const OPTIONAL<HighFrequencyContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HighFrequencyContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
return *this;
}

HighFrequencyContainer_template& HighFrequencyContainer_template::operator=(const HighFrequencyContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HighFrequencyContainer_template::match(const HighFrequencyContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
HighFrequencyContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == HighFrequencyContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
return single_value.field_basicVehicleContainerHighFrequency->match(other_value.basicVehicleContainerHighFrequency(), legacy);
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
return single_value.field_rsuContainerHighFrequency->match(other_value.rsuContainerHighFrequency(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
return FALSE;
}

boolean HighFrequencyContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
return single_value.field_basicVehicleContainerHighFrequency->is_value();
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
return single_value.field_rsuContainerHighFrequency->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
}

HighFrequencyContainer HighFrequencyContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
HighFrequencyContainer ret_val;
switch (single_value.union_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
ret_val.basicVehicleContainerHighFrequency() = single_value.field_basicVehicleContainerHighFrequency->valueof();
break;
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
ret_val.rsuContainerHighFrequency() = single_value.field_rsuContainerHighFrequency->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
return ret_val;
}

HighFrequencyContainer_template& HighFrequencyContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
return value_list.list_value[list_index];
}
void HighFrequencyContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HighFrequencyContainer_template[list_length];
}

BasicVehicleContainerHighFrequency_template& HighFrequencyContainer_template::basicVehicleContainerHighFrequency()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_basicVehicleContainerHighFrequency = new BasicVehicleContainerHighFrequency_template(ANY_VALUE);
else single_value.field_basicVehicleContainerHighFrequency = new BasicVehicleContainerHighFrequency_template;
single_value.union_selection = HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_basicVehicleContainerHighFrequency;
}

const BasicVehicleContainerHighFrequency_template& HighFrequencyContainer_template::basicVehicleContainerHighFrequency() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field basicVehicleContainerHighFrequency in a non-specific template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
if (single_value.union_selection != HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency) TTCN_error("Accessing non-selected field basicVehicleContainerHighFrequency in a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
return *single_value.field_basicVehicleContainerHighFrequency;
}

RSUContainerHighFrequency_template& HighFrequencyContainer_template::rsuContainerHighFrequency()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HighFrequencyContainer::ALT_rsuContainerHighFrequency) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_rsuContainerHighFrequency = new RSUContainerHighFrequency_template(ANY_VALUE);
else single_value.field_rsuContainerHighFrequency = new RSUContainerHighFrequency_template;
single_value.union_selection = HighFrequencyContainer::ALT_rsuContainerHighFrequency;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_rsuContainerHighFrequency;
}

const RSUContainerHighFrequency_template& HighFrequencyContainer_template::rsuContainerHighFrequency() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field rsuContainerHighFrequency in a non-specific template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
if (single_value.union_selection != HighFrequencyContainer::ALT_rsuContainerHighFrequency) TTCN_error("Accessing non-selected field rsuContainerHighFrequency in a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
return *single_value.field_rsuContainerHighFrequency;
}

boolean HighFrequencyContainer_template::ischosen(HighFrequencyContainer::union_selection_type checked_selection) const
{
if (checked_selection == HighFrequencyContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == HighFrequencyContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @CAM-PDU-Descriptions.HighFrequencyContainer");
}
return FALSE;
}

void HighFrequencyContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
TTCN_Logger::log_event_str("{ basicVehicleContainerHighFrequency := ");
single_value.field_basicVehicleContainerHighFrequency->log();
TTCN_Logger::log_event_str(" }");
break;
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
TTCN_Logger::log_event_str("{ rsuContainerHighFrequency := ");
single_value.field_rsuContainerHighFrequency->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HighFrequencyContainer_template::log_match(const HighFrequencyContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".basicVehicleContainerHighFrequency");
single_value.field_basicVehicleContainerHighFrequency->log_match(match_value.basicVehicleContainerHighFrequency(), legacy);
} else {
TTCN_Logger::log_event_str("{ basicVehicleContainerHighFrequency := ");
single_value.field_basicVehicleContainerHighFrequency->log_match(match_value.basicVehicleContainerHighFrequency(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".rsuContainerHighFrequency");
single_value.field_rsuContainerHighFrequency->log_match(match_value.rsuContainerHighFrequency(), legacy);
} else {
TTCN_Logger::log_event_str("{ rsuContainerHighFrequency := ");
single_value.field_rsuContainerHighFrequency->log_match(match_value.rsuContainerHighFrequency(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void HighFrequencyContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
single_value.field_basicVehicleContainerHighFrequency->encode_text(text_buf);
break;
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
single_value.field_rsuContainerHighFrequency->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
}

void HighFrequencyContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = HighFrequencyContainer::UNBOUND_VALUE;
HighFrequencyContainer::union_selection_type new_selection = (HighFrequencyContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
single_value.field_basicVehicleContainerHighFrequency = new BasicVehicleContainerHighFrequency_template;
single_value.field_basicVehicleContainerHighFrequency->decode_text(text_buf);
break;
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
single_value.field_rsuContainerHighFrequency = new RSUContainerHighFrequency_template;
single_value.field_rsuContainerHighFrequency->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HighFrequencyContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
}

boolean HighFrequencyContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HighFrequencyContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HighFrequencyContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@CAM-PDU-Descriptions.HighFrequencyContainer'");
    }
    if (strcmp("basicVehicleContainerHighFrequency", param_field) == 0) {
      basicVehicleContainerHighFrequency().set_param(param);
      return;
    } else if (strcmp("rsuContainerHighFrequency", param_field) == 0) {
      rsuContainerHighFrequency().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@CAM-PDU-Descriptions.HighFrequencyContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HighFrequencyContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@CAM-PDU-Descriptions.HighFrequencyContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "basicVehicleContainerHighFrequency")) {
      basicVehicleContainerHighFrequency().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "rsuContainerHighFrequency")) {
      rsuContainerHighFrequency().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @CAM-PDU-Descriptions.HighFrequencyContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@CAM-PDU-Descriptions.HighFrequencyContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HighFrequencyContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@CAM-PDU-Descriptions.HighFrequencyContainer'");
    }
    if (strcmp("basicVehicleContainerHighFrequency", param_field) == 0) {
      return basicVehicleContainerHighFrequency().get_param(param_name);
    } else if (strcmp("rsuContainerHighFrequency", param_field) == 0) {
      return rsuContainerHighFrequency().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `HighFrequencyContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
      mp_field = single_value.field_basicVehicleContainerHighFrequency->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("basicVehicleContainerHighFrequency")));
      break;
    case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
      mp_field = single_value.field_rsuContainerHighFrequency->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("rsuContainerHighFrequency")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HighFrequencyContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case HighFrequencyContainer::ALT_basicVehicleContainerHighFrequency:
single_value.field_basicVehicleContainerHighFrequency->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.HighFrequencyContainer");
return;
case HighFrequencyContainer::ALT_rsuContainerHighFrequency:
single_value.field_rsuContainerHighFrequency->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.HighFrequencyContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @CAM-PDU-Descriptions.HighFrequencyContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.HighFrequencyContainer");
}

BasicVehicleContainerHighFrequency::BasicVehicleContainerHighFrequency()
{
  bound_flag = FALSE;
}

BasicVehicleContainerHighFrequency::BasicVehicleContainerHighFrequency(const ITS__Container::Heading& par_heading,
    const ITS__Container::Speed& par_speed,
    const ITS__Container::DriveDirection& par_driveDirection,
    const ITS__Container::VehicleLength& par_vehicleLength,
    const INTEGER& par_vehicleWidth,
    const ITS__Container::LongitudinalAcceleration& par_longitudinalAcceleration,
    const ITS__Container::Curvature& par_curvature,
    const ITS__Container::CurvatureCalculationMode& par_curvatureCalculationMode,
    const ITS__Container::YawRate& par_yawRate,
    const OPTIONAL<BITSTRING>& par_accelerationControl,
    const OPTIONAL<INTEGER>& par_lanePosition,
    const OPTIONAL<ITS__Container::SteeringWheelAngle>& par_steeringWheelAngle,
    const OPTIONAL<ITS__Container::LateralAcceleration>& par_lateralAcceleration,
    const OPTIONAL<ITS__Container::VerticalAcceleration>& par_verticalAcceleration,
    const OPTIONAL<INTEGER>& par_performanceClass,
    const OPTIONAL<ITS__Container::CenDsrcTollingZone>& par_cenDsrcTollingZone)
  :   field_heading(par_heading),
  field_speed(par_speed),
  field_driveDirection(par_driveDirection),
  field_vehicleLength(par_vehicleLength),
  field_vehicleWidth(par_vehicleWidth),
  field_longitudinalAcceleration(par_longitudinalAcceleration),
  field_curvature(par_curvature),
  field_curvatureCalculationMode(par_curvatureCalculationMode),
  field_yawRate(par_yawRate),
  field_accelerationControl(par_accelerationControl),
  field_lanePosition(par_lanePosition),
  field_steeringWheelAngle(par_steeringWheelAngle),
  field_lateralAcceleration(par_lateralAcceleration),
  field_verticalAcceleration(par_verticalAcceleration),
  field_performanceClass(par_performanceClass),
  field_cenDsrcTollingZone(par_cenDsrcTollingZone)
{
  bound_flag = TRUE;
}

BasicVehicleContainerHighFrequency::BasicVehicleContainerHighFrequency(const BasicVehicleContainerHighFrequency& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
bound_flag = TRUE;
if (other_value.heading().is_bound()) field_heading = other_value.heading();
else field_heading.clean_up();
if (other_value.speed().is_bound()) field_speed = other_value.speed();
else field_speed.clean_up();
if (other_value.driveDirection().is_bound()) field_driveDirection = other_value.driveDirection();
else field_driveDirection.clean_up();
if (other_value.vehicleLength().is_bound()) field_vehicleLength = other_value.vehicleLength();
else field_vehicleLength.clean_up();
if (other_value.vehicleWidth().is_bound()) field_vehicleWidth = other_value.vehicleWidth();
else field_vehicleWidth.clean_up();
if (other_value.longitudinalAcceleration().is_bound()) field_longitudinalAcceleration = other_value.longitudinalAcceleration();
else field_longitudinalAcceleration.clean_up();
if (other_value.curvature().is_bound()) field_curvature = other_value.curvature();
else field_curvature.clean_up();
if (other_value.curvatureCalculationMode().is_bound()) field_curvatureCalculationMode = other_value.curvatureCalculationMode();
else field_curvatureCalculationMode.clean_up();
if (other_value.yawRate().is_bound()) field_yawRate = other_value.yawRate();
else field_yawRate.clean_up();
if (other_value.accelerationControl().is_bound()) field_accelerationControl = other_value.accelerationControl();
else field_accelerationControl.clean_up();
if (other_value.lanePosition().is_bound()) field_lanePosition = other_value.lanePosition();
else field_lanePosition.clean_up();
if (other_value.steeringWheelAngle().is_bound()) field_steeringWheelAngle = other_value.steeringWheelAngle();
else field_steeringWheelAngle.clean_up();
if (other_value.lateralAcceleration().is_bound()) field_lateralAcceleration = other_value.lateralAcceleration();
else field_lateralAcceleration.clean_up();
if (other_value.verticalAcceleration().is_bound()) field_verticalAcceleration = other_value.verticalAcceleration();
else field_verticalAcceleration.clean_up();
if (other_value.performanceClass().is_bound()) field_performanceClass = other_value.performanceClass();
else field_performanceClass.clean_up();
if (other_value.cenDsrcTollingZone().is_bound()) field_cenDsrcTollingZone = other_value.cenDsrcTollingZone();
else field_cenDsrcTollingZone.clean_up();
}

void BasicVehicleContainerHighFrequency::clean_up()
{
field_heading.clean_up();
field_speed.clean_up();
field_driveDirection.clean_up();
field_vehicleLength.clean_up();
field_vehicleWidth.clean_up();
field_longitudinalAcceleration.clean_up();
field_curvature.clean_up();
field_curvatureCalculationMode.clean_up();
field_yawRate.clean_up();
field_accelerationControl.clean_up();
field_lanePosition.clean_up();
field_steeringWheelAngle.clean_up();
field_lateralAcceleration.clean_up();
field_verticalAcceleration.clean_up();
field_performanceClass.clean_up();
field_cenDsrcTollingZone.clean_up();
bound_flag = FALSE;
}

BasicVehicleContainerHighFrequency& BasicVehicleContainerHighFrequency::operator=(const BasicVehicleContainerHighFrequency& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
  bound_flag = TRUE;
  if (other_value.heading().is_bound()) field_heading = other_value.heading();
  else field_heading.clean_up();
  if (other_value.speed().is_bound()) field_speed = other_value.speed();
  else field_speed.clean_up();
  if (other_value.driveDirection().is_bound()) field_driveDirection = other_value.driveDirection();
  else field_driveDirection.clean_up();
  if (other_value.vehicleLength().is_bound()) field_vehicleLength = other_value.vehicleLength();
  else field_vehicleLength.clean_up();
  if (other_value.vehicleWidth().is_bound()) field_vehicleWidth = other_value.vehicleWidth();
  else field_vehicleWidth.clean_up();
  if (other_value.longitudinalAcceleration().is_bound()) field_longitudinalAcceleration = other_value.longitudinalAcceleration();
  else field_longitudinalAcceleration.clean_up();
  if (other_value.curvature().is_bound()) field_curvature = other_value.curvature();
  else field_curvature.clean_up();
  if (other_value.curvatureCalculationMode().is_bound()) field_curvatureCalculationMode = other_value.curvatureCalculationMode();
  else field_curvatureCalculationMode.clean_up();
  if (other_value.yawRate().is_bound()) field_yawRate = other_value.yawRate();
  else field_yawRate.clean_up();
  if (other_value.accelerationControl().is_bound()) field_accelerationControl = other_value.accelerationControl();
  else field_accelerationControl.clean_up();
  if (other_value.lanePosition().is_bound()) field_lanePosition = other_value.lanePosition();
  else field_lanePosition.clean_up();
  if (other_value.steeringWheelAngle().is_bound()) field_steeringWheelAngle = other_value.steeringWheelAngle();
  else field_steeringWheelAngle.clean_up();
  if (other_value.lateralAcceleration().is_bound()) field_lateralAcceleration = other_value.lateralAcceleration();
  else field_lateralAcceleration.clean_up();
  if (other_value.verticalAcceleration().is_bound()) field_verticalAcceleration = other_value.verticalAcceleration();
  else field_verticalAcceleration.clean_up();
  if (other_value.performanceClass().is_bound()) field_performanceClass = other_value.performanceClass();
  else field_performanceClass.clean_up();
  if (other_value.cenDsrcTollingZone().is_bound()) field_cenDsrcTollingZone = other_value.cenDsrcTollingZone();
  else field_cenDsrcTollingZone.clean_up();
}
return *this;
}

boolean BasicVehicleContainerHighFrequency::operator==(const BasicVehicleContainerHighFrequency& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_heading==other_value.field_heading
  && field_speed==other_value.field_speed
  && field_driveDirection==other_value.field_driveDirection
  && field_vehicleLength==other_value.field_vehicleLength
  && field_vehicleWidth==other_value.field_vehicleWidth
  && field_longitudinalAcceleration==other_value.field_longitudinalAcceleration
  && field_curvature==other_value.field_curvature
  && field_curvatureCalculationMode==other_value.field_curvatureCalculationMode
  && field_yawRate==other_value.field_yawRate
  && field_accelerationControl==other_value.field_accelerationControl
  && field_lanePosition==other_value.field_lanePosition
  && field_steeringWheelAngle==other_value.field_steeringWheelAngle
  && field_lateralAcceleration==other_value.field_lateralAcceleration
  && field_verticalAcceleration==other_value.field_verticalAcceleration
  && field_performanceClass==other_value.field_performanceClass
  && field_cenDsrcTollingZone==other_value.field_cenDsrcTollingZone;
}

boolean BasicVehicleContainerHighFrequency::is_bound() const
{
if (bound_flag) return TRUE;
if(field_heading.is_bound()) return TRUE;
if(field_speed.is_bound()) return TRUE;
if(field_driveDirection.is_bound()) return TRUE;
if(field_vehicleLength.is_bound()) return TRUE;
if(field_vehicleWidth.is_bound()) return TRUE;
if(field_longitudinalAcceleration.is_bound()) return TRUE;
if(field_curvature.is_bound()) return TRUE;
if(field_curvatureCalculationMode.is_bound()) return TRUE;
if(field_yawRate.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_accelerationControl.get_selection() || field_accelerationControl.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_lanePosition.get_selection() || field_lanePosition.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_steeringWheelAngle.get_selection() || field_steeringWheelAngle.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_lateralAcceleration.get_selection() || field_lateralAcceleration.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_verticalAcceleration.get_selection() || field_verticalAcceleration.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_performanceClass.get_selection() || field_performanceClass.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_cenDsrcTollingZone.get_selection() || field_cenDsrcTollingZone.is_bound()) return TRUE;
return FALSE;
}
boolean BasicVehicleContainerHighFrequency::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_heading.is_value()) return FALSE;
if(!field_speed.is_value()) return FALSE;
if(!field_driveDirection.is_value()) return FALSE;
if(!field_vehicleLength.is_value()) return FALSE;
if(!field_vehicleWidth.is_value()) return FALSE;
if(!field_longitudinalAcceleration.is_value()) return FALSE;
if(!field_curvature.is_value()) return FALSE;
if(!field_curvatureCalculationMode.is_value()) return FALSE;
if(!field_yawRate.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_accelerationControl.get_selection() && !field_accelerationControl.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_lanePosition.get_selection() && !field_lanePosition.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_steeringWheelAngle.get_selection() && !field_steeringWheelAngle.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_lateralAcceleration.get_selection() && !field_lateralAcceleration.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_verticalAcceleration.get_selection() && !field_verticalAcceleration.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_performanceClass.get_selection() && !field_performanceClass.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_cenDsrcTollingZone.get_selection() && !field_cenDsrcTollingZone.is_value()) return FALSE;
return TRUE;
}
int BasicVehicleContainerHighFrequency::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
  int ret_val = 9;
  if (field_accelerationControl.ispresent()) ret_val++;
  if (field_lanePosition.ispresent()) ret_val++;
  if (field_steeringWheelAngle.ispresent()) ret_val++;
  if (field_lateralAcceleration.ispresent()) ret_val++;
  if (field_verticalAcceleration.ispresent()) ret_val++;
  if (field_performanceClass.ispresent()) ret_val++;
  if (field_cenDsrcTollingZone.ispresent()) ret_val++;
  return ret_val;
}

void BasicVehicleContainerHighFrequency::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ heading := ");
field_heading.log();
TTCN_Logger::log_event_str(", speed := ");
field_speed.log();
TTCN_Logger::log_event_str(", driveDirection := ");
field_driveDirection.log();
TTCN_Logger::log_event_str(", vehicleLength := ");
field_vehicleLength.log();
TTCN_Logger::log_event_str(", vehicleWidth := ");
field_vehicleWidth.log();
TTCN_Logger::log_event_str(", longitudinalAcceleration := ");
field_longitudinalAcceleration.log();
TTCN_Logger::log_event_str(", curvature := ");
field_curvature.log();
TTCN_Logger::log_event_str(", curvatureCalculationMode := ");
field_curvatureCalculationMode.log();
TTCN_Logger::log_event_str(", yawRate := ");
field_yawRate.log();
TTCN_Logger::log_event_str(", accelerationControl := ");
field_accelerationControl.log();
TTCN_Logger::log_event_str(", lanePosition := ");
field_lanePosition.log();
TTCN_Logger::log_event_str(", steeringWheelAngle := ");
field_steeringWheelAngle.log();
TTCN_Logger::log_event_str(", lateralAcceleration := ");
field_lateralAcceleration.log();
TTCN_Logger::log_event_str(", verticalAcceleration := ");
field_verticalAcceleration.log();
TTCN_Logger::log_event_str(", performanceClass := ");
field_performanceClass.log();
TTCN_Logger::log_event_str(", cenDsrcTollingZone := ");
field_cenDsrcTollingZone.log();
TTCN_Logger::log_event_str(" }");
}

void BasicVehicleContainerHighFrequency::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency'");
    }
    if (strcmp("heading", param_field) == 0) {
      heading().set_param(param);
      return;
    } else if (strcmp("speed", param_field) == 0) {
      speed().set_param(param);
      return;
    } else if (strcmp("driveDirection", param_field) == 0) {
      driveDirection().set_param(param);
      return;
    } else if (strcmp("vehicleLength", param_field) == 0) {
      vehicleLength().set_param(param);
      return;
    } else if (strcmp("vehicleWidth", param_field) == 0) {
      vehicleWidth().set_param(param);
      return;
    } else if (strcmp("longitudinalAcceleration", param_field) == 0) {
      longitudinalAcceleration().set_param(param);
      return;
    } else if (strcmp("curvature", param_field) == 0) {
      curvature().set_param(param);
      return;
    } else if (strcmp("curvatureCalculationMode", param_field) == 0) {
      curvatureCalculationMode().set_param(param);
      return;
    } else if (strcmp("yawRate", param_field) == 0) {
      yawRate().set_param(param);
      return;
    } else if (strcmp("accelerationControl", param_field) == 0) {
      accelerationControl().set_param(param);
      return;
    } else if (strcmp("lanePosition", param_field) == 0) {
      lanePosition().set_param(param);
      return;
    } else if (strcmp("steeringWheelAngle", param_field) == 0) {
      steeringWheelAngle().set_param(param);
      return;
    } else if (strcmp("lateralAcceleration", param_field) == 0) {
      lateralAcceleration().set_param(param);
      return;
    } else if (strcmp("verticalAcceleration", param_field) == 0) {
      verticalAcceleration().set_param(param);
      return;
    } else if (strcmp("performanceClass", param_field) == 0) {
      performanceClass().set_param(param);
      return;
    } else if (strcmp("cenDsrcTollingZone", param_field) == 0) {
      cenDsrcTollingZone().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (16<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency has 16 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) heading().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) speed().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) driveDirection().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) vehicleLength().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) vehicleWidth().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) longitudinalAcceleration().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) curvature().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) curvatureCalculationMode().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) yawRate().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) accelerationControl().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) lanePosition().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) steeringWheelAngle().set_param(*mp->get_elem(11));
    if (mp->get_size()>12 && mp->get_elem(12)->get_type()!=Module_Param::MP_NotUsed) lateralAcceleration().set_param(*mp->get_elem(12));
    if (mp->get_size()>13 && mp->get_elem(13)->get_type()!=Module_Param::MP_NotUsed) verticalAcceleration().set_param(*mp->get_elem(13));
    if (mp->get_size()>14 && mp->get_elem(14)->get_type()!=Module_Param::MP_NotUsed) performanceClass().set_param(*mp->get_elem(14));
    if (mp->get_size()>15 && mp->get_elem(15)->get_type()!=Module_Param::MP_NotUsed) cenDsrcTollingZone().set_param(*mp->get_elem(15));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "heading")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          heading().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "driveDirection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          driveDirection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleWidth")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleWidth().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitudinalAcceleration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitudinalAcceleration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curvature")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curvature().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curvatureCalculationMode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curvatureCalculationMode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "yawRate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          yawRate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "accelerationControl")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          accelerationControl().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lanePosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lanePosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "steeringWheelAngle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          steeringWheelAngle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lateralAcceleration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lateralAcceleration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "verticalAcceleration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          verticalAcceleration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "performanceClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          performanceClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cenDsrcTollingZone")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cenDsrcTollingZone().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
  }
}

Module_Param* BasicVehicleContainerHighFrequency::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency'");
    }
    if (strcmp("heading", param_field) == 0) {
      return heading().get_param(param_name);
    } else if (strcmp("speed", param_field) == 0) {
      return speed().get_param(param_name);
    } else if (strcmp("driveDirection", param_field) == 0) {
      return driveDirection().get_param(param_name);
    } else if (strcmp("vehicleLength", param_field) == 0) {
      return vehicleLength().get_param(param_name);
    } else if (strcmp("vehicleWidth", param_field) == 0) {
      return vehicleWidth().get_param(param_name);
    } else if (strcmp("longitudinalAcceleration", param_field) == 0) {
      return longitudinalAcceleration().get_param(param_name);
    } else if (strcmp("curvature", param_field) == 0) {
      return curvature().get_param(param_name);
    } else if (strcmp("curvatureCalculationMode", param_field) == 0) {
      return curvatureCalculationMode().get_param(param_name);
    } else if (strcmp("yawRate", param_field) == 0) {
      return yawRate().get_param(param_name);
    } else if (strcmp("accelerationControl", param_field) == 0) {
      return accelerationControl().get_param(param_name);
    } else if (strcmp("lanePosition", param_field) == 0) {
      return lanePosition().get_param(param_name);
    } else if (strcmp("steeringWheelAngle", param_field) == 0) {
      return steeringWheelAngle().get_param(param_name);
    } else if (strcmp("lateralAcceleration", param_field) == 0) {
      return lateralAcceleration().get_param(param_name);
    } else if (strcmp("verticalAcceleration", param_field) == 0) {
      return verticalAcceleration().get_param(param_name);
    } else if (strcmp("performanceClass", param_field) == 0) {
      return performanceClass().get_param(param_name);
    } else if (strcmp("cenDsrcTollingZone", param_field) == 0) {
      return cenDsrcTollingZone().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_heading = field_heading.get_param(param_name);
  mp_field_heading->set_id(new Module_Param_FieldName(mcopystr("heading")));
  mp->add_elem(mp_field_heading);
  Module_Param* mp_field_speed = field_speed.get_param(param_name);
  mp_field_speed->set_id(new Module_Param_FieldName(mcopystr("speed")));
  mp->add_elem(mp_field_speed);
  Module_Param* mp_field_driveDirection = field_driveDirection.get_param(param_name);
  mp_field_driveDirection->set_id(new Module_Param_FieldName(mcopystr("driveDirection")));
  mp->add_elem(mp_field_driveDirection);
  Module_Param* mp_field_vehicleLength = field_vehicleLength.get_param(param_name);
  mp_field_vehicleLength->set_id(new Module_Param_FieldName(mcopystr("vehicleLength")));
  mp->add_elem(mp_field_vehicleLength);
  Module_Param* mp_field_vehicleWidth = field_vehicleWidth.get_param(param_name);
  mp_field_vehicleWidth->set_id(new Module_Param_FieldName(mcopystr("vehicleWidth")));
  mp->add_elem(mp_field_vehicleWidth);
  Module_Param* mp_field_longitudinalAcceleration = field_longitudinalAcceleration.get_param(param_name);
  mp_field_longitudinalAcceleration->set_id(new Module_Param_FieldName(mcopystr("longitudinalAcceleration")));
  mp->add_elem(mp_field_longitudinalAcceleration);
  Module_Param* mp_field_curvature = field_curvature.get_param(param_name);
  mp_field_curvature->set_id(new Module_Param_FieldName(mcopystr("curvature")));
  mp->add_elem(mp_field_curvature);
  Module_Param* mp_field_curvatureCalculationMode = field_curvatureCalculationMode.get_param(param_name);
  mp_field_curvatureCalculationMode->set_id(new Module_Param_FieldName(mcopystr("curvatureCalculationMode")));
  mp->add_elem(mp_field_curvatureCalculationMode);
  Module_Param* mp_field_yawRate = field_yawRate.get_param(param_name);
  mp_field_yawRate->set_id(new Module_Param_FieldName(mcopystr("yawRate")));
  mp->add_elem(mp_field_yawRate);
  Module_Param* mp_field_accelerationControl = field_accelerationControl.get_param(param_name);
  mp_field_accelerationControl->set_id(new Module_Param_FieldName(mcopystr("accelerationControl")));
  mp->add_elem(mp_field_accelerationControl);
  Module_Param* mp_field_lanePosition = field_lanePosition.get_param(param_name);
  mp_field_lanePosition->set_id(new Module_Param_FieldName(mcopystr("lanePosition")));
  mp->add_elem(mp_field_lanePosition);
  Module_Param* mp_field_steeringWheelAngle = field_steeringWheelAngle.get_param(param_name);
  mp_field_steeringWheelAngle->set_id(new Module_Param_FieldName(mcopystr("steeringWheelAngle")));
  mp->add_elem(mp_field_steeringWheelAngle);
  Module_Param* mp_field_lateralAcceleration = field_lateralAcceleration.get_param(param_name);
  mp_field_lateralAcceleration->set_id(new Module_Param_FieldName(mcopystr("lateralAcceleration")));
  mp->add_elem(mp_field_lateralAcceleration);
  Module_Param* mp_field_verticalAcceleration = field_verticalAcceleration.get_param(param_name);
  mp_field_verticalAcceleration->set_id(new Module_Param_FieldName(mcopystr("verticalAcceleration")));
  mp->add_elem(mp_field_verticalAcceleration);
  Module_Param* mp_field_performanceClass = field_performanceClass.get_param(param_name);
  mp_field_performanceClass->set_id(new Module_Param_FieldName(mcopystr("performanceClass")));
  mp->add_elem(mp_field_performanceClass);
  Module_Param* mp_field_cenDsrcTollingZone = field_cenDsrcTollingZone.get_param(param_name);
  mp_field_cenDsrcTollingZone->set_id(new Module_Param_FieldName(mcopystr("cenDsrcTollingZone")));
  mp->add_elem(mp_field_cenDsrcTollingZone);
  return mp;
  }

void BasicVehicleContainerHighFrequency::set_implicit_omit()
{
if (heading().is_bound()) heading().set_implicit_omit();
if (speed().is_bound()) speed().set_implicit_omit();
if (driveDirection().is_bound()) driveDirection().set_implicit_omit();
if (vehicleLength().is_bound()) vehicleLength().set_implicit_omit();
if (vehicleWidth().is_bound()) vehicleWidth().set_implicit_omit();
if (longitudinalAcceleration().is_bound()) longitudinalAcceleration().set_implicit_omit();
if (curvature().is_bound()) curvature().set_implicit_omit();
if (curvatureCalculationMode().is_bound()) curvatureCalculationMode().set_implicit_omit();
if (yawRate().is_bound()) yawRate().set_implicit_omit();
if (!accelerationControl().is_bound()) accelerationControl() = OMIT_VALUE;
else accelerationControl().set_implicit_omit();
if (!lanePosition().is_bound()) lanePosition() = OMIT_VALUE;
else lanePosition().set_implicit_omit();
if (!steeringWheelAngle().is_bound()) steeringWheelAngle() = OMIT_VALUE;
else steeringWheelAngle().set_implicit_omit();
if (!lateralAcceleration().is_bound()) lateralAcceleration() = OMIT_VALUE;
else lateralAcceleration().set_implicit_omit();
if (!verticalAcceleration().is_bound()) verticalAcceleration() = OMIT_VALUE;
else verticalAcceleration().set_implicit_omit();
if (!performanceClass().is_bound()) performanceClass() = OMIT_VALUE;
else performanceClass().set_implicit_omit();
if (!cenDsrcTollingZone().is_bound()) cenDsrcTollingZone() = OMIT_VALUE;
else cenDsrcTollingZone().set_implicit_omit();
}

void BasicVehicleContainerHighFrequency::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
field_heading.encode_text(text_buf);
field_speed.encode_text(text_buf);
field_driveDirection.encode_text(text_buf);
field_vehicleLength.encode_text(text_buf);
field_vehicleWidth.encode_text(text_buf);
field_longitudinalAcceleration.encode_text(text_buf);
field_curvature.encode_text(text_buf);
field_curvatureCalculationMode.encode_text(text_buf);
field_yawRate.encode_text(text_buf);
field_accelerationControl.encode_text(text_buf);
field_lanePosition.encode_text(text_buf);
field_steeringWheelAngle.encode_text(text_buf);
field_lateralAcceleration.encode_text(text_buf);
field_verticalAcceleration.encode_text(text_buf);
field_performanceClass.encode_text(text_buf);
field_cenDsrcTollingZone.encode_text(text_buf);
}

void BasicVehicleContainerHighFrequency::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_heading.decode_text(text_buf);
field_speed.decode_text(text_buf);
field_driveDirection.decode_text(text_buf);
field_vehicleLength.decode_text(text_buf);
field_vehicleWidth.decode_text(text_buf);
field_longitudinalAcceleration.decode_text(text_buf);
field_curvature.decode_text(text_buf);
field_curvatureCalculationMode.decode_text(text_buf);
field_yawRate.decode_text(text_buf);
field_accelerationControl.decode_text(text_buf);
field_lanePosition.decode_text(text_buf);
field_steeringWheelAngle.decode_text(text_buf);
field_lateralAcceleration.decode_text(text_buf);
field_verticalAcceleration.decode_text(text_buf);
field_performanceClass.decode_text(text_buf);
field_cenDsrcTollingZone.decode_text(text_buf);
}

void BasicVehicleContainerHighFrequency::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BasicVehicleContainerHighFrequency::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* BasicVehicleContainerHighFrequency::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("heading': ");
  new_tlv->add_TLV(field_heading.BER_encode_TLV(BasicVehicleContainerHighFrequency_heading_descr_, p_coding));
  ec_1.set_msg("speed': ");
  new_tlv->add_TLV(field_speed.BER_encode_TLV(BasicVehicleContainerHighFrequency_speed_descr_, p_coding));
  ec_1.set_msg("driveDirection': ");
  new_tlv->add_TLV(field_driveDirection.BER_encode_TLV(BasicVehicleContainerHighFrequency_driveDirection_descr_, p_coding));
  ec_1.set_msg("vehicleLength': ");
  new_tlv->add_TLV(field_vehicleLength.BER_encode_TLV(BasicVehicleContainerHighFrequency_vehicleLength_descr_, p_coding));
  ec_1.set_msg("vehicleWidth': ");
  new_tlv->add_TLV(field_vehicleWidth.BER_encode_TLV(BasicVehicleContainerHighFrequency_vehicleWidth_descr_, p_coding));
  ec_1.set_msg("longitudinalAcceleration': ");
  new_tlv->add_TLV(field_longitudinalAcceleration.BER_encode_TLV(BasicVehicleContainerHighFrequency_longitudinalAcceleration_descr_, p_coding));
  ec_1.set_msg("curvature': ");
  new_tlv->add_TLV(field_curvature.BER_encode_TLV(BasicVehicleContainerHighFrequency_curvature_descr_, p_coding));
  ec_1.set_msg("curvatureCalculationMode': ");
  new_tlv->add_TLV(field_curvatureCalculationMode.BER_encode_TLV(BasicVehicleContainerHighFrequency_curvatureCalculationMode_descr_, p_coding));
  ec_1.set_msg("yawRate': ");
  new_tlv->add_TLV(field_yawRate.BER_encode_TLV(BasicVehicleContainerHighFrequency_yawRate_descr_, p_coding));
  ec_1.set_msg("accelerationControl': ");
  new_tlv->add_TLV(field_accelerationControl.BER_encode_TLV(BasicVehicleContainerHighFrequency_accelerationControl_descr_, p_coding));
  ec_1.set_msg("lanePosition': ");
  new_tlv->add_TLV(field_lanePosition.BER_encode_TLV(BasicVehicleContainerHighFrequency_lanePosition_descr_, p_coding));
  ec_1.set_msg("steeringWheelAngle': ");
  new_tlv->add_TLV(field_steeringWheelAngle.BER_encode_TLV(BasicVehicleContainerHighFrequency_steeringWheelAngle_descr_, p_coding));
  ec_1.set_msg("lateralAcceleration': ");
  new_tlv->add_TLV(field_lateralAcceleration.BER_encode_TLV(BasicVehicleContainerHighFrequency_lateralAcceleration_descr_, p_coding));
  ec_1.set_msg("verticalAcceleration': ");
  new_tlv->add_TLV(field_verticalAcceleration.BER_encode_TLV(BasicVehicleContainerHighFrequency_verticalAcceleration_descr_, p_coding));
  ec_1.set_msg("performanceClass': ");
  new_tlv->add_TLV(field_performanceClass.BER_encode_TLV(BasicVehicleContainerHighFrequency_performanceClass_descr_, p_coding));
  ec_1.set_msg("cenDsrcTollingZone': ");
  new_tlv->add_TLV(field_cenDsrcTollingZone.BER_encode_TLV(BasicVehicleContainerHighFrequency_cenDsrcTollingZone_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean BasicVehicleContainerHighFrequency::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("heading': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_heading.BER_decode_TLV(BasicVehicleContainerHighFrequency_heading_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("speed': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_speed.BER_decode_TLV(BasicVehicleContainerHighFrequency_speed_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("driveDirection': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_driveDirection.BER_decode_TLV(BasicVehicleContainerHighFrequency_driveDirection_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("vehicleLength': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_vehicleLength.BER_decode_TLV(BasicVehicleContainerHighFrequency_vehicleLength_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("vehicleWidth': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_vehicleWidth.BER_decode_TLV(BasicVehicleContainerHighFrequency_vehicleWidth_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("longitudinalAcceleration': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_longitudinalAcceleration.BER_decode_TLV(BasicVehicleContainerHighFrequency_longitudinalAcceleration_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("curvature': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_curvature.BER_decode_TLV(BasicVehicleContainerHighFrequency_curvature_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("curvatureCalculationMode': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_curvatureCalculationMode.BER_decode_TLV(BasicVehicleContainerHighFrequency_curvatureCalculationMode_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("yawRate': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_yawRate.BER_decode_TLV(BasicVehicleContainerHighFrequency_yawRate_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("accelerationControl': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_accelerationControl=OMIT_VALUE;
    else {
      field_accelerationControl.BER_decode_TLV(BasicVehicleContainerHighFrequency_accelerationControl_descr_, tmp_tlv, L_form);
      if(field_accelerationControl.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("lanePosition': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_lanePosition=OMIT_VALUE;
    else {
      field_lanePosition.BER_decode_TLV(BasicVehicleContainerHighFrequency_lanePosition_descr_, tmp_tlv, L_form);
      if(field_lanePosition.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("steeringWheelAngle': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_steeringWheelAngle=OMIT_VALUE;
    else {
      field_steeringWheelAngle.BER_decode_TLV(BasicVehicleContainerHighFrequency_steeringWheelAngle_descr_, tmp_tlv, L_form);
      if(field_steeringWheelAngle.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("lateralAcceleration': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_lateralAcceleration=OMIT_VALUE;
    else {
      field_lateralAcceleration.BER_decode_TLV(BasicVehicleContainerHighFrequency_lateralAcceleration_descr_, tmp_tlv, L_form);
      if(field_lateralAcceleration.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("verticalAcceleration': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_verticalAcceleration=OMIT_VALUE;
    else {
      field_verticalAcceleration.BER_decode_TLV(BasicVehicleContainerHighFrequency_verticalAcceleration_descr_, tmp_tlv, L_form);
      if(field_verticalAcceleration.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("performanceClass': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_performanceClass=OMIT_VALUE;
    else {
      field_performanceClass.BER_decode_TLV(BasicVehicleContainerHighFrequency_performanceClass_descr_, tmp_tlv, L_form);
      if(field_performanceClass.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("cenDsrcTollingZone': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_cenDsrcTollingZone=OMIT_VALUE;
    else {
      field_cenDsrcTollingZone.BER_decode_TLV(BasicVehicleContainerHighFrequency_cenDsrcTollingZone_descr_, tmp_tlv, L_form);
      if(field_cenDsrcTollingZone.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int BasicVehicleContainerHighFrequency::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "heading");
    enc_len += field_heading.JSON_encode(BasicVehicleContainerHighFrequency_heading_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speed");
    enc_len += field_speed.JSON_encode(BasicVehicleContainerHighFrequency_speed_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "driveDirection");
    enc_len += field_driveDirection.JSON_encode(BasicVehicleContainerHighFrequency_driveDirection_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vehicleLength");
    enc_len += field_vehicleLength.JSON_encode(BasicVehicleContainerHighFrequency_vehicleLength_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vehicleWidth");
    enc_len += field_vehicleWidth.JSON_encode(BasicVehicleContainerHighFrequency_vehicleWidth_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "longitudinalAcceleration");
    enc_len += field_longitudinalAcceleration.JSON_encode(BasicVehicleContainerHighFrequency_longitudinalAcceleration_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "curvature");
    enc_len += field_curvature.JSON_encode(BasicVehicleContainerHighFrequency_curvature_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "curvatureCalculationMode");
    enc_len += field_curvatureCalculationMode.JSON_encode(BasicVehicleContainerHighFrequency_curvatureCalculationMode_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "yawRate");
    enc_len += field_yawRate.JSON_encode(BasicVehicleContainerHighFrequency_yawRate_descr_, p_tok);
  }

  if (field_accelerationControl.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "accelerationControl");
    enc_len += field_accelerationControl.JSON_encode(BasicVehicleContainerHighFrequency_accelerationControl_descr_, p_tok);
  }

  if (field_lanePosition.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lanePosition");
    enc_len += field_lanePosition.JSON_encode(BasicVehicleContainerHighFrequency_lanePosition_descr_, p_tok);
  }

  if (field_steeringWheelAngle.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "steeringWheelAngle");
    enc_len += field_steeringWheelAngle.JSON_encode(BasicVehicleContainerHighFrequency_steeringWheelAngle_descr_, p_tok);
  }

  if (field_lateralAcceleration.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lateralAcceleration");
    enc_len += field_lateralAcceleration.JSON_encode(BasicVehicleContainerHighFrequency_lateralAcceleration_descr_, p_tok);
  }

  if (field_verticalAcceleration.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "verticalAcceleration");
    enc_len += field_verticalAcceleration.JSON_encode(BasicVehicleContainerHighFrequency_verticalAcceleration_descr_, p_tok);
  }

  if (field_performanceClass.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "performanceClass");
    enc_len += field_performanceClass.JSON_encode(BasicVehicleContainerHighFrequency_performanceClass_descr_, p_tok);
  }

  if (field_cenDsrcTollingZone.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "cenDsrcTollingZone");
    enc_len += field_cenDsrcTollingZone.JSON_encode(BasicVehicleContainerHighFrequency_cenDsrcTollingZone_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BasicVehicleContainerHighFrequency::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "heading", name_len)) {
         int ret_val = field_heading.JSON_decode(BasicVehicleContainerHighFrequency_heading_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "heading");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "speed", name_len)) {
         int ret_val = field_speed.JSON_decode(BasicVehicleContainerHighFrequency_speed_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speed");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "driveDirection", name_len)) {
         int ret_val = field_driveDirection.JSON_decode(BasicVehicleContainerHighFrequency_driveDirection_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "driveDirection");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "vehicleLength", name_len)) {
         int ret_val = field_vehicleLength.JSON_decode(BasicVehicleContainerHighFrequency_vehicleLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vehicleLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "vehicleWidth", name_len)) {
         int ret_val = field_vehicleWidth.JSON_decode(BasicVehicleContainerHighFrequency_vehicleWidth_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vehicleWidth");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (24 == name_len && 0 == strncmp(fld_name, "longitudinalAcceleration", name_len)) {
         int ret_val = field_longitudinalAcceleration.JSON_decode(BasicVehicleContainerHighFrequency_longitudinalAcceleration_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "longitudinalAcceleration");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "curvature", name_len)) {
         int ret_val = field_curvature.JSON_decode(BasicVehicleContainerHighFrequency_curvature_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "curvature");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (24 == name_len && 0 == strncmp(fld_name, "curvatureCalculationMode", name_len)) {
         int ret_val = field_curvatureCalculationMode.JSON_decode(BasicVehicleContainerHighFrequency_curvatureCalculationMode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "curvatureCalculationMode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "yawRate", name_len)) {
         int ret_val = field_yawRate.JSON_decode(BasicVehicleContainerHighFrequency_yawRate_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "yawRate");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "accelerationControl", name_len)) {
         int ret_val = field_accelerationControl.JSON_decode(BasicVehicleContainerHighFrequency_accelerationControl_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "accelerationControl");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "lanePosition", name_len)) {
         int ret_val = field_lanePosition.JSON_decode(BasicVehicleContainerHighFrequency_lanePosition_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lanePosition");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "steeringWheelAngle", name_len)) {
         int ret_val = field_steeringWheelAngle.JSON_decode(BasicVehicleContainerHighFrequency_steeringWheelAngle_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "steeringWheelAngle");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "lateralAcceleration", name_len)) {
         int ret_val = field_lateralAcceleration.JSON_decode(BasicVehicleContainerHighFrequency_lateralAcceleration_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lateralAcceleration");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "verticalAcceleration", name_len)) {
         int ret_val = field_verticalAcceleration.JSON_decode(BasicVehicleContainerHighFrequency_verticalAcceleration_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "verticalAcceleration");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "performanceClass", name_len)) {
         int ret_val = field_performanceClass.JSON_decode(BasicVehicleContainerHighFrequency_performanceClass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "performanceClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "cenDsrcTollingZone", name_len)) {
         int ret_val = field_cenDsrcTollingZone.JSON_decode(BasicVehicleContainerHighFrequency_cenDsrcTollingZone_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "cenDsrcTollingZone");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_heading.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "heading");
    return JSON_ERROR_FATAL;
  }
if (!field_speed.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "speed");
    return JSON_ERROR_FATAL;
  }
if (!field_driveDirection.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "driveDirection");
    return JSON_ERROR_FATAL;
  }
if (!field_vehicleLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "vehicleLength");
    return JSON_ERROR_FATAL;
  }
if (!field_vehicleWidth.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "vehicleWidth");
    return JSON_ERROR_FATAL;
  }
if (!field_longitudinalAcceleration.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "longitudinalAcceleration");
    return JSON_ERROR_FATAL;
  }
if (!field_curvature.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "curvature");
    return JSON_ERROR_FATAL;
  }
if (!field_curvatureCalculationMode.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "curvatureCalculationMode");
    return JSON_ERROR_FATAL;
  }
if (!field_yawRate.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "yawRate");
    return JSON_ERROR_FATAL;
  }
if (!field_accelerationControl.is_bound()) {
    field_accelerationControl = OMIT_VALUE;
  }
if (!field_lanePosition.is_bound()) {
    field_lanePosition = OMIT_VALUE;
  }
if (!field_steeringWheelAngle.is_bound()) {
    field_steeringWheelAngle = OMIT_VALUE;
  }
if (!field_lateralAcceleration.is_bound()) {
    field_lateralAcceleration = OMIT_VALUE;
  }
if (!field_verticalAcceleration.is_bound()) {
    field_verticalAcceleration = OMIT_VALUE;
  }
if (!field_performanceClass.is_bound()) {
    field_performanceClass = OMIT_VALUE;
  }
if (!field_cenDsrcTollingZone.is_bound()) {
    field_cenDsrcTollingZone = OMIT_VALUE;
  }

  return dec_len;
}

struct BasicVehicleContainerHighFrequency_template::single_value_struct {
ITS__Container::Heading_template field_heading;
ITS__Container::Speed_template field_speed;
ITS__Container::DriveDirection_template field_driveDirection;
ITS__Container::VehicleLength_template field_vehicleLength;
INTEGER_template field_vehicleWidth;
ITS__Container::LongitudinalAcceleration_template field_longitudinalAcceleration;
ITS__Container::Curvature_template field_curvature;
ITS__Container::CurvatureCalculationMode_template field_curvatureCalculationMode;
ITS__Container::YawRate_template field_yawRate;
BITSTRING_template field_accelerationControl;
INTEGER_template field_lanePosition;
ITS__Container::SteeringWheelAngle_template field_steeringWheelAngle;
ITS__Container::LateralAcceleration_template field_lateralAcceleration;
ITS__Container::VerticalAcceleration_template field_verticalAcceleration;
INTEGER_template field_performanceClass;
ITS__Container::CenDsrcTollingZone_template field_cenDsrcTollingZone;
};

void BasicVehicleContainerHighFrequency_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_heading = ANY_VALUE;
single_value->field_speed = ANY_VALUE;
single_value->field_driveDirection = ANY_VALUE;
single_value->field_vehicleLength = ANY_VALUE;
single_value->field_vehicleWidth = ANY_VALUE;
single_value->field_longitudinalAcceleration = ANY_VALUE;
single_value->field_curvature = ANY_VALUE;
single_value->field_curvatureCalculationMode = ANY_VALUE;
single_value->field_yawRate = ANY_VALUE;
single_value->field_accelerationControl = ANY_OR_OMIT;
single_value->field_lanePosition = ANY_OR_OMIT;
single_value->field_steeringWheelAngle = ANY_OR_OMIT;
single_value->field_lateralAcceleration = ANY_OR_OMIT;
single_value->field_verticalAcceleration = ANY_OR_OMIT;
single_value->field_performanceClass = ANY_OR_OMIT;
single_value->field_cenDsrcTollingZone = ANY_OR_OMIT;
}
}
}

void BasicVehicleContainerHighFrequency_template::copy_value(const BasicVehicleContainerHighFrequency& other_value)
{
single_value = new single_value_struct;
if (other_value.heading().is_bound()) {
  single_value->field_heading = other_value.heading();
} else {
  single_value->field_heading.clean_up();
}
if (other_value.speed().is_bound()) {
  single_value->field_speed = other_value.speed();
} else {
  single_value->field_speed.clean_up();
}
if (other_value.driveDirection().is_bound()) {
  single_value->field_driveDirection = other_value.driveDirection();
} else {
  single_value->field_driveDirection.clean_up();
}
if (other_value.vehicleLength().is_bound()) {
  single_value->field_vehicleLength = other_value.vehicleLength();
} else {
  single_value->field_vehicleLength.clean_up();
}
if (other_value.vehicleWidth().is_bound()) {
  single_value->field_vehicleWidth = other_value.vehicleWidth();
} else {
  single_value->field_vehicleWidth.clean_up();
}
if (other_value.longitudinalAcceleration().is_bound()) {
  single_value->field_longitudinalAcceleration = other_value.longitudinalAcceleration();
} else {
  single_value->field_longitudinalAcceleration.clean_up();
}
if (other_value.curvature().is_bound()) {
  single_value->field_curvature = other_value.curvature();
} else {
  single_value->field_curvature.clean_up();
}
if (other_value.curvatureCalculationMode().is_bound()) {
  single_value->field_curvatureCalculationMode = other_value.curvatureCalculationMode();
} else {
  single_value->field_curvatureCalculationMode.clean_up();
}
if (other_value.yawRate().is_bound()) {
  single_value->field_yawRate = other_value.yawRate();
} else {
  single_value->field_yawRate.clean_up();
}
if (other_value.accelerationControl().is_bound()) {
  if (other_value.accelerationControl().ispresent()) single_value->field_accelerationControl = other_value.accelerationControl()();
  else single_value->field_accelerationControl = OMIT_VALUE;
} else {
  single_value->field_accelerationControl.clean_up();
}
if (other_value.lanePosition().is_bound()) {
  if (other_value.lanePosition().ispresent()) single_value->field_lanePosition = other_value.lanePosition()();
  else single_value->field_lanePosition = OMIT_VALUE;
} else {
  single_value->field_lanePosition.clean_up();
}
if (other_value.steeringWheelAngle().is_bound()) {
  if (other_value.steeringWheelAngle().ispresent()) single_value->field_steeringWheelAngle = other_value.steeringWheelAngle()();
  else single_value->field_steeringWheelAngle = OMIT_VALUE;
} else {
  single_value->field_steeringWheelAngle.clean_up();
}
if (other_value.lateralAcceleration().is_bound()) {
  if (other_value.lateralAcceleration().ispresent()) single_value->field_lateralAcceleration = other_value.lateralAcceleration()();
  else single_value->field_lateralAcceleration = OMIT_VALUE;
} else {
  single_value->field_lateralAcceleration.clean_up();
}
if (other_value.verticalAcceleration().is_bound()) {
  if (other_value.verticalAcceleration().ispresent()) single_value->field_verticalAcceleration = other_value.verticalAcceleration()();
  else single_value->field_verticalAcceleration = OMIT_VALUE;
} else {
  single_value->field_verticalAcceleration.clean_up();
}
if (other_value.performanceClass().is_bound()) {
  if (other_value.performanceClass().ispresent()) single_value->field_performanceClass = other_value.performanceClass()();
  else single_value->field_performanceClass = OMIT_VALUE;
} else {
  single_value->field_performanceClass.clean_up();
}
if (other_value.cenDsrcTollingZone().is_bound()) {
  if (other_value.cenDsrcTollingZone().ispresent()) single_value->field_cenDsrcTollingZone = other_value.cenDsrcTollingZone()();
  else single_value->field_cenDsrcTollingZone = OMIT_VALUE;
} else {
  single_value->field_cenDsrcTollingZone.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BasicVehicleContainerHighFrequency_template::copy_template(const BasicVehicleContainerHighFrequency_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.heading().get_selection()) {
single_value->field_heading = other_value.heading();
} else {
single_value->field_heading.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speed().get_selection()) {
single_value->field_speed = other_value.speed();
} else {
single_value->field_speed.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.driveDirection().get_selection()) {
single_value->field_driveDirection = other_value.driveDirection();
} else {
single_value->field_driveDirection.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.vehicleLength().get_selection()) {
single_value->field_vehicleLength = other_value.vehicleLength();
} else {
single_value->field_vehicleLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.vehicleWidth().get_selection()) {
single_value->field_vehicleWidth = other_value.vehicleWidth();
} else {
single_value->field_vehicleWidth.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.longitudinalAcceleration().get_selection()) {
single_value->field_longitudinalAcceleration = other_value.longitudinalAcceleration();
} else {
single_value->field_longitudinalAcceleration.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.curvature().get_selection()) {
single_value->field_curvature = other_value.curvature();
} else {
single_value->field_curvature.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.curvatureCalculationMode().get_selection()) {
single_value->field_curvatureCalculationMode = other_value.curvatureCalculationMode();
} else {
single_value->field_curvatureCalculationMode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.yawRate().get_selection()) {
single_value->field_yawRate = other_value.yawRate();
} else {
single_value->field_yawRate.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.accelerationControl().get_selection()) {
single_value->field_accelerationControl = other_value.accelerationControl();
} else {
single_value->field_accelerationControl.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lanePosition().get_selection()) {
single_value->field_lanePosition = other_value.lanePosition();
} else {
single_value->field_lanePosition.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.steeringWheelAngle().get_selection()) {
single_value->field_steeringWheelAngle = other_value.steeringWheelAngle();
} else {
single_value->field_steeringWheelAngle.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lateralAcceleration().get_selection()) {
single_value->field_lateralAcceleration = other_value.lateralAcceleration();
} else {
single_value->field_lateralAcceleration.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.verticalAcceleration().get_selection()) {
single_value->field_verticalAcceleration = other_value.verticalAcceleration();
} else {
single_value->field_verticalAcceleration.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.performanceClass().get_selection()) {
single_value->field_performanceClass = other_value.performanceClass();
} else {
single_value->field_performanceClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cenDsrcTollingZone().get_selection()) {
single_value->field_cenDsrcTollingZone = other_value.cenDsrcTollingZone();
} else {
single_value->field_cenDsrcTollingZone.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BasicVehicleContainerHighFrequency_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
break;
}
set_selection(other_value);
}

BasicVehicleContainerHighFrequency_template::BasicVehicleContainerHighFrequency_template()
{
}

BasicVehicleContainerHighFrequency_template::BasicVehicleContainerHighFrequency_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BasicVehicleContainerHighFrequency_template::BasicVehicleContainerHighFrequency_template(const BasicVehicleContainerHighFrequency& other_value)
{
copy_value(other_value);
}

BasicVehicleContainerHighFrequency_template::BasicVehicleContainerHighFrequency_template(const OPTIONAL<BasicVehicleContainerHighFrequency>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BasicVehicleContainerHighFrequency&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency from an unbound optional field.");
}
}

BasicVehicleContainerHighFrequency_template::BasicVehicleContainerHighFrequency_template(const BasicVehicleContainerHighFrequency_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BasicVehicleContainerHighFrequency_template::~BasicVehicleContainerHighFrequency_template()
{
clean_up();
}

BasicVehicleContainerHighFrequency_template& BasicVehicleContainerHighFrequency_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BasicVehicleContainerHighFrequency_template& BasicVehicleContainerHighFrequency_template::operator=(const BasicVehicleContainerHighFrequency& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BasicVehicleContainerHighFrequency_template& BasicVehicleContainerHighFrequency_template::operator=(const OPTIONAL<BasicVehicleContainerHighFrequency>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BasicVehicleContainerHighFrequency&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
}
return *this;
}

BasicVehicleContainerHighFrequency_template& BasicVehicleContainerHighFrequency_template::operator=(const BasicVehicleContainerHighFrequency_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BasicVehicleContainerHighFrequency_template::match(const BasicVehicleContainerHighFrequency& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.heading().is_bound()) return FALSE;
if(!single_value->field_heading.match(other_value.heading(), legacy))return FALSE;
if(!other_value.speed().is_bound()) return FALSE;
if(!single_value->field_speed.match(other_value.speed(), legacy))return FALSE;
if(!other_value.driveDirection().is_bound()) return FALSE;
if(!single_value->field_driveDirection.match(other_value.driveDirection(), legacy))return FALSE;
if(!other_value.vehicleLength().is_bound()) return FALSE;
if(!single_value->field_vehicleLength.match(other_value.vehicleLength(), legacy))return FALSE;
if(!other_value.vehicleWidth().is_bound()) return FALSE;
if(!single_value->field_vehicleWidth.match(other_value.vehicleWidth(), legacy))return FALSE;
if(!other_value.longitudinalAcceleration().is_bound()) return FALSE;
if(!single_value->field_longitudinalAcceleration.match(other_value.longitudinalAcceleration(), legacy))return FALSE;
if(!other_value.curvature().is_bound()) return FALSE;
if(!single_value->field_curvature.match(other_value.curvature(), legacy))return FALSE;
if(!other_value.curvatureCalculationMode().is_bound()) return FALSE;
if(!single_value->field_curvatureCalculationMode.match(other_value.curvatureCalculationMode(), legacy))return FALSE;
if(!other_value.yawRate().is_bound()) return FALSE;
if(!single_value->field_yawRate.match(other_value.yawRate(), legacy))return FALSE;
if(!other_value.accelerationControl().is_bound()) return FALSE;
if((other_value.accelerationControl().ispresent() ? !single_value->field_accelerationControl.match((const BITSTRING&)other_value.accelerationControl(), legacy) : !single_value->field_accelerationControl.match_omit(legacy)))return FALSE;
if(!other_value.lanePosition().is_bound()) return FALSE;
if((other_value.lanePosition().ispresent() ? !single_value->field_lanePosition.match((const INTEGER&)other_value.lanePosition(), legacy) : !single_value->field_lanePosition.match_omit(legacy)))return FALSE;
if(!other_value.steeringWheelAngle().is_bound()) return FALSE;
if((other_value.steeringWheelAngle().ispresent() ? !single_value->field_steeringWheelAngle.match((const ITS__Container::SteeringWheelAngle&)other_value.steeringWheelAngle(), legacy) : !single_value->field_steeringWheelAngle.match_omit(legacy)))return FALSE;
if(!other_value.lateralAcceleration().is_bound()) return FALSE;
if((other_value.lateralAcceleration().ispresent() ? !single_value->field_lateralAcceleration.match((const ITS__Container::LateralAcceleration&)other_value.lateralAcceleration(), legacy) : !single_value->field_lateralAcceleration.match_omit(legacy)))return FALSE;
if(!other_value.verticalAcceleration().is_bound()) return FALSE;
if((other_value.verticalAcceleration().ispresent() ? !single_value->field_verticalAcceleration.match((const ITS__Container::VerticalAcceleration&)other_value.verticalAcceleration(), legacy) : !single_value->field_verticalAcceleration.match_omit(legacy)))return FALSE;
if(!other_value.performanceClass().is_bound()) return FALSE;
if((other_value.performanceClass().ispresent() ? !single_value->field_performanceClass.match((const INTEGER&)other_value.performanceClass(), legacy) : !single_value->field_performanceClass.match_omit(legacy)))return FALSE;
if(!other_value.cenDsrcTollingZone().is_bound()) return FALSE;
if((other_value.cenDsrcTollingZone().ispresent() ? !single_value->field_cenDsrcTollingZone.match((const ITS__Container::CenDsrcTollingZone&)other_value.cenDsrcTollingZone(), legacy) : !single_value->field_cenDsrcTollingZone.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
}
return FALSE;
}

boolean BasicVehicleContainerHighFrequency_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_heading.is_bound()) return TRUE;
if (single_value->field_speed.is_bound()) return TRUE;
if (single_value->field_driveDirection.is_bound()) return TRUE;
if (single_value->field_vehicleLength.is_bound()) return TRUE;
if (single_value->field_vehicleWidth.is_bound()) return TRUE;
if (single_value->field_longitudinalAcceleration.is_bound()) return TRUE;
if (single_value->field_curvature.is_bound()) return TRUE;
if (single_value->field_curvatureCalculationMode.is_bound()) return TRUE;
if (single_value->field_yawRate.is_bound()) return TRUE;
if (single_value->field_accelerationControl.is_omit() || single_value->field_accelerationControl.is_bound()) return TRUE;
if (single_value->field_lanePosition.is_omit() || single_value->field_lanePosition.is_bound()) return TRUE;
if (single_value->field_steeringWheelAngle.is_omit() || single_value->field_steeringWheelAngle.is_bound()) return TRUE;
if (single_value->field_lateralAcceleration.is_omit() || single_value->field_lateralAcceleration.is_bound()) return TRUE;
if (single_value->field_verticalAcceleration.is_omit() || single_value->field_verticalAcceleration.is_bound()) return TRUE;
if (single_value->field_performanceClass.is_omit() || single_value->field_performanceClass.is_bound()) return TRUE;
if (single_value->field_cenDsrcTollingZone.is_omit() || single_value->field_cenDsrcTollingZone.is_bound()) return TRUE;
return FALSE;
}

boolean BasicVehicleContainerHighFrequency_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_heading.is_value()) return FALSE;
if (!single_value->field_speed.is_value()) return FALSE;
if (!single_value->field_driveDirection.is_value()) return FALSE;
if (!single_value->field_vehicleLength.is_value()) return FALSE;
if (!single_value->field_vehicleWidth.is_value()) return FALSE;
if (!single_value->field_longitudinalAcceleration.is_value()) return FALSE;
if (!single_value->field_curvature.is_value()) return FALSE;
if (!single_value->field_curvatureCalculationMode.is_value()) return FALSE;
if (!single_value->field_yawRate.is_value()) return FALSE;
if (!single_value->field_accelerationControl.is_omit() && !single_value->field_accelerationControl.is_value()) return FALSE;
if (!single_value->field_lanePosition.is_omit() && !single_value->field_lanePosition.is_value()) return FALSE;
if (!single_value->field_steeringWheelAngle.is_omit() && !single_value->field_steeringWheelAngle.is_value()) return FALSE;
if (!single_value->field_lateralAcceleration.is_omit() && !single_value->field_lateralAcceleration.is_value()) return FALSE;
if (!single_value->field_verticalAcceleration.is_omit() && !single_value->field_verticalAcceleration.is_value()) return FALSE;
if (!single_value->field_performanceClass.is_omit() && !single_value->field_performanceClass.is_value()) return FALSE;
if (!single_value->field_cenDsrcTollingZone.is_omit() && !single_value->field_cenDsrcTollingZone.is_value()) return FALSE;
return TRUE;
}

void BasicVehicleContainerHighFrequency_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BasicVehicleContainerHighFrequency BasicVehicleContainerHighFrequency_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
BasicVehicleContainerHighFrequency ret_val;
if (single_value->field_heading.is_bound()) {
ret_val.heading() = single_value->field_heading.valueof();
}
if (single_value->field_speed.is_bound()) {
ret_val.speed() = single_value->field_speed.valueof();
}
if (single_value->field_driveDirection.is_bound()) {
ret_val.driveDirection() = single_value->field_driveDirection.valueof();
}
if (single_value->field_vehicleLength.is_bound()) {
ret_val.vehicleLength() = single_value->field_vehicleLength.valueof();
}
if (single_value->field_vehicleWidth.is_bound()) {
ret_val.vehicleWidth() = single_value->field_vehicleWidth.valueof();
}
if (single_value->field_longitudinalAcceleration.is_bound()) {
ret_val.longitudinalAcceleration() = single_value->field_longitudinalAcceleration.valueof();
}
if (single_value->field_curvature.is_bound()) {
ret_val.curvature() = single_value->field_curvature.valueof();
}
if (single_value->field_curvatureCalculationMode.is_bound()) {
ret_val.curvatureCalculationMode() = single_value->field_curvatureCalculationMode.valueof();
}
if (single_value->field_yawRate.is_bound()) {
ret_val.yawRate() = single_value->field_yawRate.valueof();
}
if (single_value->field_accelerationControl.is_omit()) ret_val.accelerationControl() = OMIT_VALUE;
else if (single_value->field_accelerationControl.is_bound()) {
ret_val.accelerationControl() = single_value->field_accelerationControl.valueof();
}
if (single_value->field_lanePosition.is_omit()) ret_val.lanePosition() = OMIT_VALUE;
else if (single_value->field_lanePosition.is_bound()) {
ret_val.lanePosition() = single_value->field_lanePosition.valueof();
}
if (single_value->field_steeringWheelAngle.is_omit()) ret_val.steeringWheelAngle() = OMIT_VALUE;
else if (single_value->field_steeringWheelAngle.is_bound()) {
ret_val.steeringWheelAngle() = single_value->field_steeringWheelAngle.valueof();
}
if (single_value->field_lateralAcceleration.is_omit()) ret_val.lateralAcceleration() = OMIT_VALUE;
else if (single_value->field_lateralAcceleration.is_bound()) {
ret_val.lateralAcceleration() = single_value->field_lateralAcceleration.valueof();
}
if (single_value->field_verticalAcceleration.is_omit()) ret_val.verticalAcceleration() = OMIT_VALUE;
else if (single_value->field_verticalAcceleration.is_bound()) {
ret_val.verticalAcceleration() = single_value->field_verticalAcceleration.valueof();
}
if (single_value->field_performanceClass.is_omit()) ret_val.performanceClass() = OMIT_VALUE;
else if (single_value->field_performanceClass.is_bound()) {
ret_val.performanceClass() = single_value->field_performanceClass.valueof();
}
if (single_value->field_cenDsrcTollingZone.is_omit()) ret_val.cenDsrcTollingZone() = OMIT_VALUE;
else if (single_value->field_cenDsrcTollingZone.is_bound()) {
ret_val.cenDsrcTollingZone() = single_value->field_cenDsrcTollingZone.valueof();
}
return ret_val;
}

void BasicVehicleContainerHighFrequency_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BasicVehicleContainerHighFrequency_template[list_length];
}

BasicVehicleContainerHighFrequency_template& BasicVehicleContainerHighFrequency_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return value_list.list_value[list_index];
}

ITS__Container::Heading_template& BasicVehicleContainerHighFrequency_template::heading()
{
set_specific();
return single_value->field_heading;
}

const ITS__Container::Heading_template& BasicVehicleContainerHighFrequency_template::heading() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field heading of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_heading;
}

ITS__Container::Speed_template& BasicVehicleContainerHighFrequency_template::speed()
{
set_specific();
return single_value->field_speed;
}

const ITS__Container::Speed_template& BasicVehicleContainerHighFrequency_template::speed() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speed of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_speed;
}

ITS__Container::DriveDirection_template& BasicVehicleContainerHighFrequency_template::driveDirection()
{
set_specific();
return single_value->field_driveDirection;
}

const ITS__Container::DriveDirection_template& BasicVehicleContainerHighFrequency_template::driveDirection() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field driveDirection of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_driveDirection;
}

ITS__Container::VehicleLength_template& BasicVehicleContainerHighFrequency_template::vehicleLength()
{
set_specific();
return single_value->field_vehicleLength;
}

const ITS__Container::VehicleLength_template& BasicVehicleContainerHighFrequency_template::vehicleLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field vehicleLength of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_vehicleLength;
}

INTEGER_template& BasicVehicleContainerHighFrequency_template::vehicleWidth()
{
set_specific();
return single_value->field_vehicleWidth;
}

const INTEGER_template& BasicVehicleContainerHighFrequency_template::vehicleWidth() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field vehicleWidth of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_vehicleWidth;
}

ITS__Container::LongitudinalAcceleration_template& BasicVehicleContainerHighFrequency_template::longitudinalAcceleration()
{
set_specific();
return single_value->field_longitudinalAcceleration;
}

const ITS__Container::LongitudinalAcceleration_template& BasicVehicleContainerHighFrequency_template::longitudinalAcceleration() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field longitudinalAcceleration of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_longitudinalAcceleration;
}

ITS__Container::Curvature_template& BasicVehicleContainerHighFrequency_template::curvature()
{
set_specific();
return single_value->field_curvature;
}

const ITS__Container::Curvature_template& BasicVehicleContainerHighFrequency_template::curvature() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field curvature of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_curvature;
}

ITS__Container::CurvatureCalculationMode_template& BasicVehicleContainerHighFrequency_template::curvatureCalculationMode()
{
set_specific();
return single_value->field_curvatureCalculationMode;
}

const ITS__Container::CurvatureCalculationMode_template& BasicVehicleContainerHighFrequency_template::curvatureCalculationMode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field curvatureCalculationMode of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_curvatureCalculationMode;
}

ITS__Container::YawRate_template& BasicVehicleContainerHighFrequency_template::yawRate()
{
set_specific();
return single_value->field_yawRate;
}

const ITS__Container::YawRate_template& BasicVehicleContainerHighFrequency_template::yawRate() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field yawRate of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_yawRate;
}

BITSTRING_template& BasicVehicleContainerHighFrequency_template::accelerationControl()
{
set_specific();
return single_value->field_accelerationControl;
}

const BITSTRING_template& BasicVehicleContainerHighFrequency_template::accelerationControl() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field accelerationControl of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_accelerationControl;
}

INTEGER_template& BasicVehicleContainerHighFrequency_template::lanePosition()
{
set_specific();
return single_value->field_lanePosition;
}

const INTEGER_template& BasicVehicleContainerHighFrequency_template::lanePosition() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lanePosition of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_lanePosition;
}

ITS__Container::SteeringWheelAngle_template& BasicVehicleContainerHighFrequency_template::steeringWheelAngle()
{
set_specific();
return single_value->field_steeringWheelAngle;
}

const ITS__Container::SteeringWheelAngle_template& BasicVehicleContainerHighFrequency_template::steeringWheelAngle() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field steeringWheelAngle of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_steeringWheelAngle;
}

ITS__Container::LateralAcceleration_template& BasicVehicleContainerHighFrequency_template::lateralAcceleration()
{
set_specific();
return single_value->field_lateralAcceleration;
}

const ITS__Container::LateralAcceleration_template& BasicVehicleContainerHighFrequency_template::lateralAcceleration() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lateralAcceleration of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_lateralAcceleration;
}

ITS__Container::VerticalAcceleration_template& BasicVehicleContainerHighFrequency_template::verticalAcceleration()
{
set_specific();
return single_value->field_verticalAcceleration;
}

const ITS__Container::VerticalAcceleration_template& BasicVehicleContainerHighFrequency_template::verticalAcceleration() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field verticalAcceleration of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_verticalAcceleration;
}

INTEGER_template& BasicVehicleContainerHighFrequency_template::performanceClass()
{
set_specific();
return single_value->field_performanceClass;
}

const INTEGER_template& BasicVehicleContainerHighFrequency_template::performanceClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field performanceClass of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_performanceClass;
}

ITS__Container::CenDsrcTollingZone_template& BasicVehicleContainerHighFrequency_template::cenDsrcTollingZone()
{
set_specific();
return single_value->field_cenDsrcTollingZone;
}

const ITS__Container::CenDsrcTollingZone_template& BasicVehicleContainerHighFrequency_template::cenDsrcTollingZone() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cenDsrcTollingZone of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
return single_value->field_cenDsrcTollingZone;
}

int BasicVehicleContainerHighFrequency_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 9;
      if (single_value->field_accelerationControl.is_present()) ret_val++;
      if (single_value->field_lanePosition.is_present()) ret_val++;
      if (single_value->field_steeringWheelAngle.is_present()) ret_val++;
      if (single_value->field_lateralAcceleration.is_present()) ret_val++;
      if (single_value->field_verticalAcceleration.is_present()) ret_val++;
      if (single_value->field_performanceClass.is_present()) ret_val++;
      if (single_value->field_cenDsrcTollingZone.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
  }
  return 0;
}

void BasicVehicleContainerHighFrequency_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ heading := ");
single_value->field_heading.log();
TTCN_Logger::log_event_str(", speed := ");
single_value->field_speed.log();
TTCN_Logger::log_event_str(", driveDirection := ");
single_value->field_driveDirection.log();
TTCN_Logger::log_event_str(", vehicleLength := ");
single_value->field_vehicleLength.log();
TTCN_Logger::log_event_str(", vehicleWidth := ");
single_value->field_vehicleWidth.log();
TTCN_Logger::log_event_str(", longitudinalAcceleration := ");
single_value->field_longitudinalAcceleration.log();
TTCN_Logger::log_event_str(", curvature := ");
single_value->field_curvature.log();
TTCN_Logger::log_event_str(", curvatureCalculationMode := ");
single_value->field_curvatureCalculationMode.log();
TTCN_Logger::log_event_str(", yawRate := ");
single_value->field_yawRate.log();
TTCN_Logger::log_event_str(", accelerationControl := ");
single_value->field_accelerationControl.log();
TTCN_Logger::log_event_str(", lanePosition := ");
single_value->field_lanePosition.log();
TTCN_Logger::log_event_str(", steeringWheelAngle := ");
single_value->field_steeringWheelAngle.log();
TTCN_Logger::log_event_str(", lateralAcceleration := ");
single_value->field_lateralAcceleration.log();
TTCN_Logger::log_event_str(", verticalAcceleration := ");
single_value->field_verticalAcceleration.log();
TTCN_Logger::log_event_str(", performanceClass := ");
single_value->field_performanceClass.log();
TTCN_Logger::log_event_str(", cenDsrcTollingZone := ");
single_value->field_cenDsrcTollingZone.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BasicVehicleContainerHighFrequency_template::log_match(const BasicVehicleContainerHighFrequency& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_heading.match(match_value.heading(), legacy)){
TTCN_Logger::log_logmatch_info(".heading");
single_value->field_heading.log_match(match_value.heading(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_speed.match(match_value.speed(), legacy)){
TTCN_Logger::log_logmatch_info(".speed");
single_value->field_speed.log_match(match_value.speed(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_driveDirection.match(match_value.driveDirection(), legacy)){
TTCN_Logger::log_logmatch_info(".driveDirection");
single_value->field_driveDirection.log_match(match_value.driveDirection(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_vehicleLength.match(match_value.vehicleLength(), legacy)){
TTCN_Logger::log_logmatch_info(".vehicleLength");
single_value->field_vehicleLength.log_match(match_value.vehicleLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_vehicleWidth.match(match_value.vehicleWidth(), legacy)){
TTCN_Logger::log_logmatch_info(".vehicleWidth");
single_value->field_vehicleWidth.log_match(match_value.vehicleWidth(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_longitudinalAcceleration.match(match_value.longitudinalAcceleration(), legacy)){
TTCN_Logger::log_logmatch_info(".longitudinalAcceleration");
single_value->field_longitudinalAcceleration.log_match(match_value.longitudinalAcceleration(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_curvature.match(match_value.curvature(), legacy)){
TTCN_Logger::log_logmatch_info(".curvature");
single_value->field_curvature.log_match(match_value.curvature(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_curvatureCalculationMode.match(match_value.curvatureCalculationMode(), legacy)){
TTCN_Logger::log_logmatch_info(".curvatureCalculationMode");
single_value->field_curvatureCalculationMode.log_match(match_value.curvatureCalculationMode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_yawRate.match(match_value.yawRate(), legacy)){
TTCN_Logger::log_logmatch_info(".yawRate");
single_value->field_yawRate.log_match(match_value.yawRate(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.accelerationControl().ispresent()){
if(!single_value->field_accelerationControl.match(match_value.accelerationControl(), legacy)){
TTCN_Logger::log_logmatch_info(".accelerationControl");
single_value->field_accelerationControl.log_match(match_value.accelerationControl(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_accelerationControl.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".accelerationControl := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_accelerationControl.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.lanePosition().ispresent()){
if(!single_value->field_lanePosition.match(match_value.lanePosition(), legacy)){
TTCN_Logger::log_logmatch_info(".lanePosition");
single_value->field_lanePosition.log_match(match_value.lanePosition(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_lanePosition.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".lanePosition := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_lanePosition.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.steeringWheelAngle().ispresent()){
if(!single_value->field_steeringWheelAngle.match(match_value.steeringWheelAngle(), legacy)){
TTCN_Logger::log_logmatch_info(".steeringWheelAngle");
single_value->field_steeringWheelAngle.log_match(match_value.steeringWheelAngle(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_steeringWheelAngle.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".steeringWheelAngle := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_steeringWheelAngle.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.lateralAcceleration().ispresent()){
if(!single_value->field_lateralAcceleration.match(match_value.lateralAcceleration(), legacy)){
TTCN_Logger::log_logmatch_info(".lateralAcceleration");
single_value->field_lateralAcceleration.log_match(match_value.lateralAcceleration(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_lateralAcceleration.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".lateralAcceleration := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_lateralAcceleration.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.verticalAcceleration().ispresent()){
if(!single_value->field_verticalAcceleration.match(match_value.verticalAcceleration(), legacy)){
TTCN_Logger::log_logmatch_info(".verticalAcceleration");
single_value->field_verticalAcceleration.log_match(match_value.verticalAcceleration(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_verticalAcceleration.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".verticalAcceleration := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_verticalAcceleration.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.performanceClass().ispresent()){
if(!single_value->field_performanceClass.match(match_value.performanceClass(), legacy)){
TTCN_Logger::log_logmatch_info(".performanceClass");
single_value->field_performanceClass.log_match(match_value.performanceClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_performanceClass.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".performanceClass := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_performanceClass.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.cenDsrcTollingZone().ispresent()){
if(!single_value->field_cenDsrcTollingZone.match(match_value.cenDsrcTollingZone(), legacy)){
TTCN_Logger::log_logmatch_info(".cenDsrcTollingZone");
single_value->field_cenDsrcTollingZone.log_match(match_value.cenDsrcTollingZone(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_cenDsrcTollingZone.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".cenDsrcTollingZone := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_cenDsrcTollingZone.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ heading := ");
single_value->field_heading.log_match(match_value.heading(), legacy);
TTCN_Logger::log_event_str(", speed := ");
single_value->field_speed.log_match(match_value.speed(), legacy);
TTCN_Logger::log_event_str(", driveDirection := ");
single_value->field_driveDirection.log_match(match_value.driveDirection(), legacy);
TTCN_Logger::log_event_str(", vehicleLength := ");
single_value->field_vehicleLength.log_match(match_value.vehicleLength(), legacy);
TTCN_Logger::log_event_str(", vehicleWidth := ");
single_value->field_vehicleWidth.log_match(match_value.vehicleWidth(), legacy);
TTCN_Logger::log_event_str(", longitudinalAcceleration := ");
single_value->field_longitudinalAcceleration.log_match(match_value.longitudinalAcceleration(), legacy);
TTCN_Logger::log_event_str(", curvature := ");
single_value->field_curvature.log_match(match_value.curvature(), legacy);
TTCN_Logger::log_event_str(", curvatureCalculationMode := ");
single_value->field_curvatureCalculationMode.log_match(match_value.curvatureCalculationMode(), legacy);
TTCN_Logger::log_event_str(", yawRate := ");
single_value->field_yawRate.log_match(match_value.yawRate(), legacy);
TTCN_Logger::log_event_str(", accelerationControl := ");
if (match_value.accelerationControl().ispresent()) single_value->field_accelerationControl.log_match(match_value.accelerationControl(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_accelerationControl.log();
if (single_value->field_accelerationControl.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", lanePosition := ");
if (match_value.lanePosition().ispresent()) single_value->field_lanePosition.log_match(match_value.lanePosition(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_lanePosition.log();
if (single_value->field_lanePosition.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", steeringWheelAngle := ");
if (match_value.steeringWheelAngle().ispresent()) single_value->field_steeringWheelAngle.log_match(match_value.steeringWheelAngle(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_steeringWheelAngle.log();
if (single_value->field_steeringWheelAngle.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", lateralAcceleration := ");
if (match_value.lateralAcceleration().ispresent()) single_value->field_lateralAcceleration.log_match(match_value.lateralAcceleration(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_lateralAcceleration.log();
if (single_value->field_lateralAcceleration.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", verticalAcceleration := ");
if (match_value.verticalAcceleration().ispresent()) single_value->field_verticalAcceleration.log_match(match_value.verticalAcceleration(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_verticalAcceleration.log();
if (single_value->field_verticalAcceleration.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", performanceClass := ");
if (match_value.performanceClass().ispresent()) single_value->field_performanceClass.log_match(match_value.performanceClass(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_performanceClass.log();
if (single_value->field_performanceClass.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", cenDsrcTollingZone := ");
if (match_value.cenDsrcTollingZone().ispresent()) single_value->field_cenDsrcTollingZone.log_match(match_value.cenDsrcTollingZone(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_cenDsrcTollingZone.log();
if (single_value->field_cenDsrcTollingZone.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BasicVehicleContainerHighFrequency_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_heading.encode_text(text_buf);
single_value->field_speed.encode_text(text_buf);
single_value->field_driveDirection.encode_text(text_buf);
single_value->field_vehicleLength.encode_text(text_buf);
single_value->field_vehicleWidth.encode_text(text_buf);
single_value->field_longitudinalAcceleration.encode_text(text_buf);
single_value->field_curvature.encode_text(text_buf);
single_value->field_curvatureCalculationMode.encode_text(text_buf);
single_value->field_yawRate.encode_text(text_buf);
single_value->field_accelerationControl.encode_text(text_buf);
single_value->field_lanePosition.encode_text(text_buf);
single_value->field_steeringWheelAngle.encode_text(text_buf);
single_value->field_lateralAcceleration.encode_text(text_buf);
single_value->field_verticalAcceleration.encode_text(text_buf);
single_value->field_performanceClass.encode_text(text_buf);
single_value->field_cenDsrcTollingZone.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
}
}

void BasicVehicleContainerHighFrequency_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_heading.decode_text(text_buf);
single_value->field_speed.decode_text(text_buf);
single_value->field_driveDirection.decode_text(text_buf);
single_value->field_vehicleLength.decode_text(text_buf);
single_value->field_vehicleWidth.decode_text(text_buf);
single_value->field_longitudinalAcceleration.decode_text(text_buf);
single_value->field_curvature.decode_text(text_buf);
single_value->field_curvatureCalculationMode.decode_text(text_buf);
single_value->field_yawRate.decode_text(text_buf);
single_value->field_accelerationControl.decode_text(text_buf);
single_value->field_lanePosition.decode_text(text_buf);
single_value->field_steeringWheelAngle.decode_text(text_buf);
single_value->field_lateralAcceleration.decode_text(text_buf);
single_value->field_verticalAcceleration.decode_text(text_buf);
single_value->field_performanceClass.decode_text(text_buf);
single_value->field_cenDsrcTollingZone.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BasicVehicleContainerHighFrequency_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency.");
}
}

void BasicVehicleContainerHighFrequency_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency'");
    }
    if (strcmp("heading", param_field) == 0) {
      heading().set_param(param);
      return;
    } else if (strcmp("speed", param_field) == 0) {
      speed().set_param(param);
      return;
    } else if (strcmp("driveDirection", param_field) == 0) {
      driveDirection().set_param(param);
      return;
    } else if (strcmp("vehicleLength", param_field) == 0) {
      vehicleLength().set_param(param);
      return;
    } else if (strcmp("vehicleWidth", param_field) == 0) {
      vehicleWidth().set_param(param);
      return;
    } else if (strcmp("longitudinalAcceleration", param_field) == 0) {
      longitudinalAcceleration().set_param(param);
      return;
    } else if (strcmp("curvature", param_field) == 0) {
      curvature().set_param(param);
      return;
    } else if (strcmp("curvatureCalculationMode", param_field) == 0) {
      curvatureCalculationMode().set_param(param);
      return;
    } else if (strcmp("yawRate", param_field) == 0) {
      yawRate().set_param(param);
      return;
    } else if (strcmp("accelerationControl", param_field) == 0) {
      accelerationControl().set_param(param);
      return;
    } else if (strcmp("lanePosition", param_field) == 0) {
      lanePosition().set_param(param);
      return;
    } else if (strcmp("steeringWheelAngle", param_field) == 0) {
      steeringWheelAngle().set_param(param);
      return;
    } else if (strcmp("lateralAcceleration", param_field) == 0) {
      lateralAcceleration().set_param(param);
      return;
    } else if (strcmp("verticalAcceleration", param_field) == 0) {
      verticalAcceleration().set_param(param);
      return;
    } else if (strcmp("performanceClass", param_field) == 0) {
      performanceClass().set_param(param);
      return;
    } else if (strcmp("cenDsrcTollingZone", param_field) == 0) {
      cenDsrcTollingZone().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BasicVehicleContainerHighFrequency_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (16<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency has 16 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) heading().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) speed().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) driveDirection().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) vehicleLength().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) vehicleWidth().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) longitudinalAcceleration().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) curvature().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) curvatureCalculationMode().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) yawRate().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) accelerationControl().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) lanePosition().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) steeringWheelAngle().set_param(*mp->get_elem(11));
    if (mp->get_size()>12 && mp->get_elem(12)->get_type()!=Module_Param::MP_NotUsed) lateralAcceleration().set_param(*mp->get_elem(12));
    if (mp->get_size()>13 && mp->get_elem(13)->get_type()!=Module_Param::MP_NotUsed) verticalAcceleration().set_param(*mp->get_elem(13));
    if (mp->get_size()>14 && mp->get_elem(14)->get_type()!=Module_Param::MP_NotUsed) performanceClass().set_param(*mp->get_elem(14));
    if (mp->get_size()>15 && mp->get_elem(15)->get_type()!=Module_Param::MP_NotUsed) cenDsrcTollingZone().set_param(*mp->get_elem(15));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "heading")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          heading().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "driveDirection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          driveDirection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleWidth")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleWidth().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitudinalAcceleration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitudinalAcceleration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curvature")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curvature().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curvatureCalculationMode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curvatureCalculationMode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "yawRate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          yawRate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "accelerationControl")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          accelerationControl().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lanePosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lanePosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "steeringWheelAngle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          steeringWheelAngle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lateralAcceleration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lateralAcceleration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "verticalAcceleration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          verticalAcceleration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "performanceClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          performanceClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cenDsrcTollingZone")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cenDsrcTollingZone().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BasicVehicleContainerHighFrequency_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency'");
    }
    if (strcmp("heading", param_field) == 0) {
      return heading().get_param(param_name);
    } else if (strcmp("speed", param_field) == 0) {
      return speed().get_param(param_name);
    } else if (strcmp("driveDirection", param_field) == 0) {
      return driveDirection().get_param(param_name);
    } else if (strcmp("vehicleLength", param_field) == 0) {
      return vehicleLength().get_param(param_name);
    } else if (strcmp("vehicleWidth", param_field) == 0) {
      return vehicleWidth().get_param(param_name);
    } else if (strcmp("longitudinalAcceleration", param_field) == 0) {
      return longitudinalAcceleration().get_param(param_name);
    } else if (strcmp("curvature", param_field) == 0) {
      return curvature().get_param(param_name);
    } else if (strcmp("curvatureCalculationMode", param_field) == 0) {
      return curvatureCalculationMode().get_param(param_name);
    } else if (strcmp("yawRate", param_field) == 0) {
      return yawRate().get_param(param_name);
    } else if (strcmp("accelerationControl", param_field) == 0) {
      return accelerationControl().get_param(param_name);
    } else if (strcmp("lanePosition", param_field) == 0) {
      return lanePosition().get_param(param_name);
    } else if (strcmp("steeringWheelAngle", param_field) == 0) {
      return steeringWheelAngle().get_param(param_name);
    } else if (strcmp("lateralAcceleration", param_field) == 0) {
      return lateralAcceleration().get_param(param_name);
    } else if (strcmp("verticalAcceleration", param_field) == 0) {
      return verticalAcceleration().get_param(param_name);
    } else if (strcmp("performanceClass", param_field) == 0) {
      return performanceClass().get_param(param_name);
    } else if (strcmp("cenDsrcTollingZone", param_field) == 0) {
      return cenDsrcTollingZone().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_heading = single_value->field_heading.get_param(param_name);
    mp_field_heading->set_id(new Module_Param_FieldName(mcopystr("heading")));
    mp->add_elem(mp_field_heading);
    Module_Param* mp_field_speed = single_value->field_speed.get_param(param_name);
    mp_field_speed->set_id(new Module_Param_FieldName(mcopystr("speed")));
    mp->add_elem(mp_field_speed);
    Module_Param* mp_field_driveDirection = single_value->field_driveDirection.get_param(param_name);
    mp_field_driveDirection->set_id(new Module_Param_FieldName(mcopystr("driveDirection")));
    mp->add_elem(mp_field_driveDirection);
    Module_Param* mp_field_vehicleLength = single_value->field_vehicleLength.get_param(param_name);
    mp_field_vehicleLength->set_id(new Module_Param_FieldName(mcopystr("vehicleLength")));
    mp->add_elem(mp_field_vehicleLength);
    Module_Param* mp_field_vehicleWidth = single_value->field_vehicleWidth.get_param(param_name);
    mp_field_vehicleWidth->set_id(new Module_Param_FieldName(mcopystr("vehicleWidth")));
    mp->add_elem(mp_field_vehicleWidth);
    Module_Param* mp_field_longitudinalAcceleration = single_value->field_longitudinalAcceleration.get_param(param_name);
    mp_field_longitudinalAcceleration->set_id(new Module_Param_FieldName(mcopystr("longitudinalAcceleration")));
    mp->add_elem(mp_field_longitudinalAcceleration);
    Module_Param* mp_field_curvature = single_value->field_curvature.get_param(param_name);
    mp_field_curvature->set_id(new Module_Param_FieldName(mcopystr("curvature")));
    mp->add_elem(mp_field_curvature);
    Module_Param* mp_field_curvatureCalculationMode = single_value->field_curvatureCalculationMode.get_param(param_name);
    mp_field_curvatureCalculationMode->set_id(new Module_Param_FieldName(mcopystr("curvatureCalculationMode")));
    mp->add_elem(mp_field_curvatureCalculationMode);
    Module_Param* mp_field_yawRate = single_value->field_yawRate.get_param(param_name);
    mp_field_yawRate->set_id(new Module_Param_FieldName(mcopystr("yawRate")));
    mp->add_elem(mp_field_yawRate);
    Module_Param* mp_field_accelerationControl = single_value->field_accelerationControl.get_param(param_name);
    mp_field_accelerationControl->set_id(new Module_Param_FieldName(mcopystr("accelerationControl")));
    mp->add_elem(mp_field_accelerationControl);
    Module_Param* mp_field_lanePosition = single_value->field_lanePosition.get_param(param_name);
    mp_field_lanePosition->set_id(new Module_Param_FieldName(mcopystr("lanePosition")));
    mp->add_elem(mp_field_lanePosition);
    Module_Param* mp_field_steeringWheelAngle = single_value->field_steeringWheelAngle.get_param(param_name);
    mp_field_steeringWheelAngle->set_id(new Module_Param_FieldName(mcopystr("steeringWheelAngle")));
    mp->add_elem(mp_field_steeringWheelAngle);
    Module_Param* mp_field_lateralAcceleration = single_value->field_lateralAcceleration.get_param(param_name);
    mp_field_lateralAcceleration->set_id(new Module_Param_FieldName(mcopystr("lateralAcceleration")));
    mp->add_elem(mp_field_lateralAcceleration);
    Module_Param* mp_field_verticalAcceleration = single_value->field_verticalAcceleration.get_param(param_name);
    mp_field_verticalAcceleration->set_id(new Module_Param_FieldName(mcopystr("verticalAcceleration")));
    mp->add_elem(mp_field_verticalAcceleration);
    Module_Param* mp_field_performanceClass = single_value->field_performanceClass.get_param(param_name);
    mp_field_performanceClass->set_id(new Module_Param_FieldName(mcopystr("performanceClass")));
    mp->add_elem(mp_field_performanceClass);
    Module_Param* mp_field_cenDsrcTollingZone = single_value->field_cenDsrcTollingZone.get_param(param_name);
    mp_field_cenDsrcTollingZone->set_id(new Module_Param_FieldName(mcopystr("cenDsrcTollingZone")));
    mp->add_elem(mp_field_cenDsrcTollingZone);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BasicVehicleContainerHighFrequency_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_heading.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_speed.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_driveDirection.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_vehicleLength.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_vehicleWidth.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_longitudinalAcceleration.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_curvature.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_curvatureCalculationMode.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_yawRate.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_accelerationControl.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_lanePosition.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_steeringWheelAngle.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_lateralAcceleration.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_verticalAcceleration.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_performanceClass.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
single_value->field_cenDsrcTollingZone.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerHighFrequency");
}

boolean BasicVehicleContainerHighFrequency_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BasicVehicleContainerHighFrequency_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

RSUContainerHighFrequency::RSUContainerHighFrequency()
{
  bound_flag = FALSE;
}

RSUContainerHighFrequency::RSUContainerHighFrequency(const OPTIONAL<ITS__Container::ProtectedCommunicationZonesRSU>& par_protectedCommunicationZonesRSU)
  :   field_protectedCommunicationZonesRSU(par_protectedCommunicationZonesRSU)
{
  bound_flag = TRUE;
}

RSUContainerHighFrequency::RSUContainerHighFrequency(const RSUContainerHighFrequency& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
bound_flag = TRUE;
if (other_value.protectedCommunicationZonesRSU().is_bound()) field_protectedCommunicationZonesRSU = other_value.protectedCommunicationZonesRSU();
else field_protectedCommunicationZonesRSU.clean_up();
}

void RSUContainerHighFrequency::clean_up()
{
field_protectedCommunicationZonesRSU.clean_up();
bound_flag = FALSE;
}

RSUContainerHighFrequency& RSUContainerHighFrequency::operator=(const RSUContainerHighFrequency& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
  bound_flag = TRUE;
  if (other_value.protectedCommunicationZonesRSU().is_bound()) field_protectedCommunicationZonesRSU = other_value.protectedCommunicationZonesRSU();
  else field_protectedCommunicationZonesRSU.clean_up();
}
return *this;
}

boolean RSUContainerHighFrequency::operator==(const RSUContainerHighFrequency& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_protectedCommunicationZonesRSU==other_value.field_protectedCommunicationZonesRSU;
}

boolean RSUContainerHighFrequency::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_protectedCommunicationZonesRSU.get_selection() || field_protectedCommunicationZonesRSU.is_bound()) return TRUE;
return FALSE;
}
boolean RSUContainerHighFrequency::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_protectedCommunicationZonesRSU.get_selection() && !field_protectedCommunicationZonesRSU.is_value()) return FALSE;
return TRUE;
}
int RSUContainerHighFrequency::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.RSUContainerHighFrequency");
  int ret_val = 0;
  if (field_protectedCommunicationZonesRSU.ispresent()) ret_val++;
  return ret_val;
}

void RSUContainerHighFrequency::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ protectedCommunicationZonesRSU := ");
field_protectedCommunicationZonesRSU.log();
TTCN_Logger::log_event_str(" }");
}

void RSUContainerHighFrequency::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.RSUContainerHighFrequency'");
    }
    if (strcmp("protectedCommunicationZonesRSU", param_field) == 0) {
      protectedCommunicationZonesRSU().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.RSUContainerHighFrequency'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.RSUContainerHighFrequency has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protectedCommunicationZonesRSU().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedCommunicationZonesRSU")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedCommunicationZonesRSU().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.RSUContainerHighFrequency: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.RSUContainerHighFrequency");
  }
}

Module_Param* RSUContainerHighFrequency::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.RSUContainerHighFrequency'");
    }
    if (strcmp("protectedCommunicationZonesRSU", param_field) == 0) {
      return protectedCommunicationZonesRSU().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.RSUContainerHighFrequency'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_protectedCommunicationZonesRSU = field_protectedCommunicationZonesRSU.get_param(param_name);
  mp_field_protectedCommunicationZonesRSU->set_id(new Module_Param_FieldName(mcopystr("protectedCommunicationZonesRSU")));
  mp->add_elem(mp_field_protectedCommunicationZonesRSU);
  return mp;
  }

void RSUContainerHighFrequency::set_implicit_omit()
{
if (!protectedCommunicationZonesRSU().is_bound()) protectedCommunicationZonesRSU() = OMIT_VALUE;
else protectedCommunicationZonesRSU().set_implicit_omit();
}

void RSUContainerHighFrequency::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
field_protectedCommunicationZonesRSU.encode_text(text_buf);
}

void RSUContainerHighFrequency::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_protectedCommunicationZonesRSU.decode_text(text_buf);
}

void RSUContainerHighFrequency::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RSUContainerHighFrequency::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RSUContainerHighFrequency::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("protectedCommunicationZonesRSU': ");
  new_tlv->add_TLV(field_protectedCommunicationZonesRSU.BER_encode_TLV(RSUContainerHighFrequency_protectedCommunicationZonesRSU_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RSUContainerHighFrequency::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.RSUContainerHighFrequency' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("protectedCommunicationZonesRSU': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_protectedCommunicationZonesRSU=OMIT_VALUE;
    else {
      field_protectedCommunicationZonesRSU.BER_decode_TLV(RSUContainerHighFrequency_protectedCommunicationZonesRSU_descr_, tmp_tlv, L_form);
      if(field_protectedCommunicationZonesRSU.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int RSUContainerHighFrequency::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_protectedCommunicationZonesRSU.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protectedCommunicationZonesRSU");
    enc_len += field_protectedCommunicationZonesRSU.JSON_encode(RSUContainerHighFrequency_protectedCommunicationZonesRSU_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RSUContainerHighFrequency::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (30 == name_len && 0 == strncmp(fld_name, "protectedCommunicationZonesRSU", name_len)) {
         int ret_val = field_protectedCommunicationZonesRSU.JSON_decode(RSUContainerHighFrequency_protectedCommunicationZonesRSU_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protectedCommunicationZonesRSU");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_protectedCommunicationZonesRSU.is_bound()) {
    field_protectedCommunicationZonesRSU = OMIT_VALUE;
  }

  return dec_len;
}

struct RSUContainerHighFrequency_template::single_value_struct {
ITS__Container::ProtectedCommunicationZonesRSU_template field_protectedCommunicationZonesRSU;
};

void RSUContainerHighFrequency_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_protectedCommunicationZonesRSU = ANY_OR_OMIT;
}
}
}

void RSUContainerHighFrequency_template::copy_value(const RSUContainerHighFrequency& other_value)
{
single_value = new single_value_struct;
if (other_value.protectedCommunicationZonesRSU().is_bound()) {
  if (other_value.protectedCommunicationZonesRSU().ispresent()) single_value->field_protectedCommunicationZonesRSU = other_value.protectedCommunicationZonesRSU()();
  else single_value->field_protectedCommunicationZonesRSU = OMIT_VALUE;
} else {
  single_value->field_protectedCommunicationZonesRSU.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RSUContainerHighFrequency_template::copy_template(const RSUContainerHighFrequency_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.protectedCommunicationZonesRSU().get_selection()) {
single_value->field_protectedCommunicationZonesRSU = other_value.protectedCommunicationZonesRSU();
} else {
single_value->field_protectedCommunicationZonesRSU.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RSUContainerHighFrequency_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
break;
}
set_selection(other_value);
}

RSUContainerHighFrequency_template::RSUContainerHighFrequency_template()
{
}

RSUContainerHighFrequency_template::RSUContainerHighFrequency_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RSUContainerHighFrequency_template::RSUContainerHighFrequency_template(const RSUContainerHighFrequency& other_value)
{
copy_value(other_value);
}

RSUContainerHighFrequency_template::RSUContainerHighFrequency_template(const OPTIONAL<RSUContainerHighFrequency>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RSUContainerHighFrequency&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency from an unbound optional field.");
}
}

RSUContainerHighFrequency_template::RSUContainerHighFrequency_template(const RSUContainerHighFrequency_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RSUContainerHighFrequency_template::~RSUContainerHighFrequency_template()
{
clean_up();
}

RSUContainerHighFrequency_template& RSUContainerHighFrequency_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RSUContainerHighFrequency_template& RSUContainerHighFrequency_template::operator=(const RSUContainerHighFrequency& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RSUContainerHighFrequency_template& RSUContainerHighFrequency_template::operator=(const OPTIONAL<RSUContainerHighFrequency>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RSUContainerHighFrequency&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
}
return *this;
}

RSUContainerHighFrequency_template& RSUContainerHighFrequency_template::operator=(const RSUContainerHighFrequency_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RSUContainerHighFrequency_template::match(const RSUContainerHighFrequency& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.protectedCommunicationZonesRSU().is_bound()) return FALSE;
if((other_value.protectedCommunicationZonesRSU().ispresent() ? !single_value->field_protectedCommunicationZonesRSU.match((const ITS__Container::ProtectedCommunicationZonesRSU&)other_value.protectedCommunicationZonesRSU(), legacy) : !single_value->field_protectedCommunicationZonesRSU.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
}
return FALSE;
}

boolean RSUContainerHighFrequency_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_protectedCommunicationZonesRSU.is_omit() || single_value->field_protectedCommunicationZonesRSU.is_bound()) return TRUE;
return FALSE;
}

boolean RSUContainerHighFrequency_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_protectedCommunicationZonesRSU.is_omit() && !single_value->field_protectedCommunicationZonesRSU.is_value()) return FALSE;
return TRUE;
}

void RSUContainerHighFrequency_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RSUContainerHighFrequency RSUContainerHighFrequency_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
RSUContainerHighFrequency ret_val;
if (single_value->field_protectedCommunicationZonesRSU.is_omit()) ret_val.protectedCommunicationZonesRSU() = OMIT_VALUE;
else if (single_value->field_protectedCommunicationZonesRSU.is_bound()) {
ret_val.protectedCommunicationZonesRSU() = single_value->field_protectedCommunicationZonesRSU.valueof();
}
return ret_val;
}

void RSUContainerHighFrequency_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RSUContainerHighFrequency_template[list_length];
}

RSUContainerHighFrequency_template& RSUContainerHighFrequency_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
return value_list.list_value[list_index];
}

ITS__Container::ProtectedCommunicationZonesRSU_template& RSUContainerHighFrequency_template::protectedCommunicationZonesRSU()
{
set_specific();
return single_value->field_protectedCommunicationZonesRSU;
}

const ITS__Container::ProtectedCommunicationZonesRSU_template& RSUContainerHighFrequency_template::protectedCommunicationZonesRSU() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protectedCommunicationZonesRSU of a non-specific template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
return single_value->field_protectedCommunicationZonesRSU;
}

int RSUContainerHighFrequency_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_protectedCommunicationZonesRSU.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
  }
  return 0;
}

void RSUContainerHighFrequency_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ protectedCommunicationZonesRSU := ");
single_value->field_protectedCommunicationZonesRSU.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RSUContainerHighFrequency_template::log_match(const RSUContainerHighFrequency& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.protectedCommunicationZonesRSU().ispresent()){
if(!single_value->field_protectedCommunicationZonesRSU.match(match_value.protectedCommunicationZonesRSU(), legacy)){
TTCN_Logger::log_logmatch_info(".protectedCommunicationZonesRSU");
single_value->field_protectedCommunicationZonesRSU.log_match(match_value.protectedCommunicationZonesRSU(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_protectedCommunicationZonesRSU.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".protectedCommunicationZonesRSU := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_protectedCommunicationZonesRSU.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ protectedCommunicationZonesRSU := ");
if (match_value.protectedCommunicationZonesRSU().ispresent()) single_value->field_protectedCommunicationZonesRSU.log_match(match_value.protectedCommunicationZonesRSU(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_protectedCommunicationZonesRSU.log();
if (single_value->field_protectedCommunicationZonesRSU.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RSUContainerHighFrequency_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_protectedCommunicationZonesRSU.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
}
}

void RSUContainerHighFrequency_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_protectedCommunicationZonesRSU.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RSUContainerHighFrequency_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency.");
}
}

void RSUContainerHighFrequency_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.RSUContainerHighFrequency'");
    }
    if (strcmp("protectedCommunicationZonesRSU", param_field) == 0) {
      protectedCommunicationZonesRSU().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.RSUContainerHighFrequency'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RSUContainerHighFrequency_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.RSUContainerHighFrequency has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protectedCommunicationZonesRSU().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedCommunicationZonesRSU")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedCommunicationZonesRSU().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.RSUContainerHighFrequency: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.RSUContainerHighFrequency");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RSUContainerHighFrequency_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.RSUContainerHighFrequency'");
    }
    if (strcmp("protectedCommunicationZonesRSU", param_field) == 0) {
      return protectedCommunicationZonesRSU().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.RSUContainerHighFrequency'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_protectedCommunicationZonesRSU = single_value->field_protectedCommunicationZonesRSU.get_param(param_name);
    mp_field_protectedCommunicationZonesRSU->set_id(new Module_Param_FieldName(mcopystr("protectedCommunicationZonesRSU")));
    mp->add_elem(mp_field_protectedCommunicationZonesRSU);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RSUContainerHighFrequency_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_protectedCommunicationZonesRSU.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.RSUContainerHighFrequency");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.RSUContainerHighFrequency");
}

boolean RSUContainerHighFrequency_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RSUContainerHighFrequency_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

CamParameters::CamParameters()
{
  bound_flag = FALSE;
}

CamParameters::CamParameters(const BasicContainer& par_basicContainer,
    const HighFrequencyContainer& par_highFrequencyContainer,
    const OPTIONAL<LowFrequencyContainer>& par_lowFrequencyContainer,
    const OPTIONAL<SpecialVehicleContainer>& par_specialVehicleContainer)
  :   field_basicContainer(par_basicContainer),
  field_highFrequencyContainer(par_highFrequencyContainer),
  field_lowFrequencyContainer(par_lowFrequencyContainer),
  field_specialVehicleContainer(par_specialVehicleContainer)
{
  bound_flag = TRUE;
}

CamParameters::CamParameters(const CamParameters& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.CamParameters.");
bound_flag = TRUE;
if (other_value.basicContainer().is_bound()) field_basicContainer = other_value.basicContainer();
else field_basicContainer.clean_up();
if (other_value.highFrequencyContainer().is_bound()) field_highFrequencyContainer = other_value.highFrequencyContainer();
else field_highFrequencyContainer.clean_up();
if (other_value.lowFrequencyContainer().is_bound()) field_lowFrequencyContainer = other_value.lowFrequencyContainer();
else field_lowFrequencyContainer.clean_up();
if (other_value.specialVehicleContainer().is_bound()) field_specialVehicleContainer = other_value.specialVehicleContainer();
else field_specialVehicleContainer.clean_up();
}

void CamParameters::clean_up()
{
field_basicContainer.clean_up();
field_highFrequencyContainer.clean_up();
field_lowFrequencyContainer.clean_up();
field_specialVehicleContainer.clean_up();
bound_flag = FALSE;
}

CamParameters& CamParameters::operator=(const CamParameters& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.CamParameters.");
  bound_flag = TRUE;
  if (other_value.basicContainer().is_bound()) field_basicContainer = other_value.basicContainer();
  else field_basicContainer.clean_up();
  if (other_value.highFrequencyContainer().is_bound()) field_highFrequencyContainer = other_value.highFrequencyContainer();
  else field_highFrequencyContainer.clean_up();
  if (other_value.lowFrequencyContainer().is_bound()) field_lowFrequencyContainer = other_value.lowFrequencyContainer();
  else field_lowFrequencyContainer.clean_up();
  if (other_value.specialVehicleContainer().is_bound()) field_specialVehicleContainer = other_value.specialVehicleContainer();
  else field_specialVehicleContainer.clean_up();
}
return *this;
}

boolean CamParameters::operator==(const CamParameters& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_basicContainer==other_value.field_basicContainer
  && field_highFrequencyContainer==other_value.field_highFrequencyContainer
  && field_lowFrequencyContainer==other_value.field_lowFrequencyContainer
  && field_specialVehicleContainer==other_value.field_specialVehicleContainer;
}

boolean CamParameters::is_bound() const
{
if (bound_flag) return TRUE;
if(field_basicContainer.is_bound()) return TRUE;
if(field_highFrequencyContainer.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_lowFrequencyContainer.get_selection() || field_lowFrequencyContainer.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_specialVehicleContainer.get_selection() || field_specialVehicleContainer.is_bound()) return TRUE;
return FALSE;
}
boolean CamParameters::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_basicContainer.is_value()) return FALSE;
if(!field_highFrequencyContainer.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_lowFrequencyContainer.get_selection() && !field_lowFrequencyContainer.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_specialVehicleContainer.get_selection() && !field_specialVehicleContainer.is_value()) return FALSE;
return TRUE;
}
int CamParameters::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.CamParameters");
  int ret_val = 2;
  if (field_lowFrequencyContainer.ispresent()) ret_val++;
  if (field_specialVehicleContainer.ispresent()) ret_val++;
  return ret_val;
}

void CamParameters::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ basicContainer := ");
field_basicContainer.log();
TTCN_Logger::log_event_str(", highFrequencyContainer := ");
field_highFrequencyContainer.log();
TTCN_Logger::log_event_str(", lowFrequencyContainer := ");
field_lowFrequencyContainer.log();
TTCN_Logger::log_event_str(", specialVehicleContainer := ");
field_specialVehicleContainer.log();
TTCN_Logger::log_event_str(" }");
}

void CamParameters::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.CamParameters'");
    }
    if (strcmp("basicContainer", param_field) == 0) {
      basicContainer().set_param(param);
      return;
    } else if (strcmp("highFrequencyContainer", param_field) == 0) {
      highFrequencyContainer().set_param(param);
      return;
    } else if (strcmp("lowFrequencyContainer", param_field) == 0) {
      lowFrequencyContainer().set_param(param);
      return;
    } else if (strcmp("specialVehicleContainer", param_field) == 0) {
      specialVehicleContainer().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.CamParameters'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.CamParameters has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) basicContainer().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) highFrequencyContainer().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) lowFrequencyContainer().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) specialVehicleContainer().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "basicContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          basicContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "highFrequencyContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          highFrequencyContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lowFrequencyContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lowFrequencyContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "specialVehicleContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          specialVehicleContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.CamParameters: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.CamParameters");
  }
}

Module_Param* CamParameters::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.CamParameters'");
    }
    if (strcmp("basicContainer", param_field) == 0) {
      return basicContainer().get_param(param_name);
    } else if (strcmp("highFrequencyContainer", param_field) == 0) {
      return highFrequencyContainer().get_param(param_name);
    } else if (strcmp("lowFrequencyContainer", param_field) == 0) {
      return lowFrequencyContainer().get_param(param_name);
    } else if (strcmp("specialVehicleContainer", param_field) == 0) {
      return specialVehicleContainer().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.CamParameters'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_basicContainer = field_basicContainer.get_param(param_name);
  mp_field_basicContainer->set_id(new Module_Param_FieldName(mcopystr("basicContainer")));
  mp->add_elem(mp_field_basicContainer);
  Module_Param* mp_field_highFrequencyContainer = field_highFrequencyContainer.get_param(param_name);
  mp_field_highFrequencyContainer->set_id(new Module_Param_FieldName(mcopystr("highFrequencyContainer")));
  mp->add_elem(mp_field_highFrequencyContainer);
  Module_Param* mp_field_lowFrequencyContainer = field_lowFrequencyContainer.get_param(param_name);
  mp_field_lowFrequencyContainer->set_id(new Module_Param_FieldName(mcopystr("lowFrequencyContainer")));
  mp->add_elem(mp_field_lowFrequencyContainer);
  Module_Param* mp_field_specialVehicleContainer = field_specialVehicleContainer.get_param(param_name);
  mp_field_specialVehicleContainer->set_id(new Module_Param_FieldName(mcopystr("specialVehicleContainer")));
  mp->add_elem(mp_field_specialVehicleContainer);
  return mp;
  }

void CamParameters::set_implicit_omit()
{
if (basicContainer().is_bound()) basicContainer().set_implicit_omit();
if (highFrequencyContainer().is_bound()) highFrequencyContainer().set_implicit_omit();
if (!lowFrequencyContainer().is_bound()) lowFrequencyContainer() = OMIT_VALUE;
else lowFrequencyContainer().set_implicit_omit();
if (!specialVehicleContainer().is_bound()) specialVehicleContainer() = OMIT_VALUE;
else specialVehicleContainer().set_implicit_omit();
}

void CamParameters::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.CamParameters.");
field_basicContainer.encode_text(text_buf);
field_highFrequencyContainer.encode_text(text_buf);
field_lowFrequencyContainer.encode_text(text_buf);
field_specialVehicleContainer.encode_text(text_buf);
}

void CamParameters::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_basicContainer.decode_text(text_buf);
field_highFrequencyContainer.decode_text(text_buf);
field_lowFrequencyContainer.decode_text(text_buf);
field_specialVehicleContainer.decode_text(text_buf);
}

void CamParameters::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CamParameters::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* CamParameters::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("basicContainer': ");
  new_tlv->add_TLV(field_basicContainer.BER_encode_TLV(CamParameters_basicContainer_descr_, p_coding));
  ec_1.set_msg("highFrequencyContainer': ");
  new_tlv->add_TLV(field_highFrequencyContainer.BER_encode_TLV(CamParameters_highFrequencyContainer_descr_, p_coding));
  ec_1.set_msg("lowFrequencyContainer': ");
  new_tlv->add_TLV(field_lowFrequencyContainer.BER_encode_TLV(CamParameters_lowFrequencyContainer_descr_, p_coding));
  ec_1.set_msg("specialVehicleContainer': ");
  new_tlv->add_TLV(field_specialVehicleContainer.BER_encode_TLV(CamParameters_specialVehicleContainer_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean CamParameters::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.CamParameters' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("basicContainer': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_basicContainer.BER_decode_TLV(CamParameters_basicContainer_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("highFrequencyContainer': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_highFrequencyContainer.BER_decode_TLV(CamParameters_highFrequencyContainer_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("lowFrequencyContainer': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_lowFrequencyContainer=OMIT_VALUE;
    else {
      field_lowFrequencyContainer.BER_decode_TLV(CamParameters_lowFrequencyContainer_descr_, tmp_tlv, L_form);
      if(field_lowFrequencyContainer.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("specialVehicleContainer': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_specialVehicleContainer=OMIT_VALUE;
    else {
      field_specialVehicleContainer.BER_decode_TLV(CamParameters_specialVehicleContainer_descr_, tmp_tlv, L_form);
      if(field_specialVehicleContainer.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int CamParameters::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.CamParameters.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "basicContainer");
    enc_len += field_basicContainer.JSON_encode(CamParameters_basicContainer_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "highFrequencyContainer");
    enc_len += field_highFrequencyContainer.JSON_encode(CamParameters_highFrequencyContainer_descr_, p_tok);
  }

  if (field_lowFrequencyContainer.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lowFrequencyContainer");
    enc_len += field_lowFrequencyContainer.JSON_encode(CamParameters_lowFrequencyContainer_descr_, p_tok);
  }

  if (field_specialVehicleContainer.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "specialVehicleContainer");
    enc_len += field_specialVehicleContainer.JSON_encode(CamParameters_specialVehicleContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CamParameters::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (14 == name_len && 0 == strncmp(fld_name, "basicContainer", name_len)) {
         int ret_val = field_basicContainer.JSON_decode(CamParameters_basicContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "basicContainer");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (22 == name_len && 0 == strncmp(fld_name, "highFrequencyContainer", name_len)) {
         int ret_val = field_highFrequencyContainer.JSON_decode(CamParameters_highFrequencyContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "highFrequencyContainer");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (21 == name_len && 0 == strncmp(fld_name, "lowFrequencyContainer", name_len)) {
         int ret_val = field_lowFrequencyContainer.JSON_decode(CamParameters_lowFrequencyContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lowFrequencyContainer");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (23 == name_len && 0 == strncmp(fld_name, "specialVehicleContainer", name_len)) {
         int ret_val = field_specialVehicleContainer.JSON_decode(CamParameters_specialVehicleContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "specialVehicleContainer");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_basicContainer.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "basicContainer");
    return JSON_ERROR_FATAL;
  }
if (!field_highFrequencyContainer.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "highFrequencyContainer");
    return JSON_ERROR_FATAL;
  }
if (!field_lowFrequencyContainer.is_bound()) {
    field_lowFrequencyContainer = OMIT_VALUE;
  }
if (!field_specialVehicleContainer.is_bound()) {
    field_specialVehicleContainer = OMIT_VALUE;
  }

  return dec_len;
}

struct CamParameters_template::single_value_struct {
BasicContainer_template field_basicContainer;
HighFrequencyContainer_template field_highFrequencyContainer;
LowFrequencyContainer_template field_lowFrequencyContainer;
SpecialVehicleContainer_template field_specialVehicleContainer;
};

void CamParameters_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_basicContainer = ANY_VALUE;
single_value->field_highFrequencyContainer = ANY_VALUE;
single_value->field_lowFrequencyContainer = ANY_OR_OMIT;
single_value->field_specialVehicleContainer = ANY_OR_OMIT;
}
}
}

void CamParameters_template::copy_value(const CamParameters& other_value)
{
single_value = new single_value_struct;
if (other_value.basicContainer().is_bound()) {
  single_value->field_basicContainer = other_value.basicContainer();
} else {
  single_value->field_basicContainer.clean_up();
}
if (other_value.highFrequencyContainer().is_bound()) {
  single_value->field_highFrequencyContainer = other_value.highFrequencyContainer();
} else {
  single_value->field_highFrequencyContainer.clean_up();
}
if (other_value.lowFrequencyContainer().is_bound()) {
  if (other_value.lowFrequencyContainer().ispresent()) single_value->field_lowFrequencyContainer = other_value.lowFrequencyContainer()();
  else single_value->field_lowFrequencyContainer = OMIT_VALUE;
} else {
  single_value->field_lowFrequencyContainer.clean_up();
}
if (other_value.specialVehicleContainer().is_bound()) {
  if (other_value.specialVehicleContainer().ispresent()) single_value->field_specialVehicleContainer = other_value.specialVehicleContainer()();
  else single_value->field_specialVehicleContainer = OMIT_VALUE;
} else {
  single_value->field_specialVehicleContainer.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CamParameters_template::copy_template(const CamParameters_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.basicContainer().get_selection()) {
single_value->field_basicContainer = other_value.basicContainer();
} else {
single_value->field_basicContainer.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.highFrequencyContainer().get_selection()) {
single_value->field_highFrequencyContainer = other_value.highFrequencyContainer();
} else {
single_value->field_highFrequencyContainer.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lowFrequencyContainer().get_selection()) {
single_value->field_lowFrequencyContainer = other_value.lowFrequencyContainer();
} else {
single_value->field_lowFrequencyContainer.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.specialVehicleContainer().get_selection()) {
single_value->field_specialVehicleContainer = other_value.specialVehicleContainer();
} else {
single_value->field_specialVehicleContainer.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CamParameters_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CamParameters.");
break;
}
set_selection(other_value);
}

CamParameters_template::CamParameters_template()
{
}

CamParameters_template::CamParameters_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CamParameters_template::CamParameters_template(const CamParameters& other_value)
{
copy_value(other_value);
}

CamParameters_template::CamParameters_template(const OPTIONAL<CamParameters>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CamParameters&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.CamParameters from an unbound optional field.");
}
}

CamParameters_template::CamParameters_template(const CamParameters_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CamParameters_template::~CamParameters_template()
{
clean_up();
}

CamParameters_template& CamParameters_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CamParameters_template& CamParameters_template::operator=(const CamParameters& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CamParameters_template& CamParameters_template::operator=(const OPTIONAL<CamParameters>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CamParameters&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.CamParameters.");
}
return *this;
}

CamParameters_template& CamParameters_template::operator=(const CamParameters_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CamParameters_template::match(const CamParameters& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.basicContainer().is_bound()) return FALSE;
if(!single_value->field_basicContainer.match(other_value.basicContainer(), legacy))return FALSE;
if(!other_value.highFrequencyContainer().is_bound()) return FALSE;
if(!single_value->field_highFrequencyContainer.match(other_value.highFrequencyContainer(), legacy))return FALSE;
if(!other_value.lowFrequencyContainer().is_bound()) return FALSE;
if((other_value.lowFrequencyContainer().ispresent() ? !single_value->field_lowFrequencyContainer.match((const LowFrequencyContainer&)other_value.lowFrequencyContainer(), legacy) : !single_value->field_lowFrequencyContainer.match_omit(legacy)))return FALSE;
if(!other_value.specialVehicleContainer().is_bound()) return FALSE;
if((other_value.specialVehicleContainer().ispresent() ? !single_value->field_specialVehicleContainer.match((const SpecialVehicleContainer&)other_value.specialVehicleContainer(), legacy) : !single_value->field_specialVehicleContainer.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CamParameters.");
}
return FALSE;
}

boolean CamParameters_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_basicContainer.is_bound()) return TRUE;
if (single_value->field_highFrequencyContainer.is_bound()) return TRUE;
if (single_value->field_lowFrequencyContainer.is_omit() || single_value->field_lowFrequencyContainer.is_bound()) return TRUE;
if (single_value->field_specialVehicleContainer.is_omit() || single_value->field_specialVehicleContainer.is_bound()) return TRUE;
return FALSE;
}

boolean CamParameters_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_basicContainer.is_value()) return FALSE;
if (!single_value->field_highFrequencyContainer.is_value()) return FALSE;
if (!single_value->field_lowFrequencyContainer.is_omit() && !single_value->field_lowFrequencyContainer.is_value()) return FALSE;
if (!single_value->field_specialVehicleContainer.is_omit() && !single_value->field_specialVehicleContainer.is_value()) return FALSE;
return TRUE;
}

void CamParameters_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CamParameters CamParameters_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.CamParameters.");
CamParameters ret_val;
if (single_value->field_basicContainer.is_bound()) {
ret_val.basicContainer() = single_value->field_basicContainer.valueof();
}
if (single_value->field_highFrequencyContainer.is_bound()) {
ret_val.highFrequencyContainer() = single_value->field_highFrequencyContainer.valueof();
}
if (single_value->field_lowFrequencyContainer.is_omit()) ret_val.lowFrequencyContainer() = OMIT_VALUE;
else if (single_value->field_lowFrequencyContainer.is_bound()) {
ret_val.lowFrequencyContainer() = single_value->field_lowFrequencyContainer.valueof();
}
if (single_value->field_specialVehicleContainer.is_omit()) ret_val.specialVehicleContainer() = OMIT_VALUE;
else if (single_value->field_specialVehicleContainer.is_bound()) {
ret_val.specialVehicleContainer() = single_value->field_specialVehicleContainer.valueof();
}
return ret_val;
}

void CamParameters_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.CamParameters.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CamParameters_template[list_length];
}

CamParameters_template& CamParameters_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.CamParameters.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.CamParameters.");
return value_list.list_value[list_index];
}

BasicContainer_template& CamParameters_template::basicContainer()
{
set_specific();
return single_value->field_basicContainer;
}

const BasicContainer_template& CamParameters_template::basicContainer() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field basicContainer of a non-specific template of type @CAM-PDU-Descriptions.CamParameters.");
return single_value->field_basicContainer;
}

HighFrequencyContainer_template& CamParameters_template::highFrequencyContainer()
{
set_specific();
return single_value->field_highFrequencyContainer;
}

const HighFrequencyContainer_template& CamParameters_template::highFrequencyContainer() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field highFrequencyContainer of a non-specific template of type @CAM-PDU-Descriptions.CamParameters.");
return single_value->field_highFrequencyContainer;
}

LowFrequencyContainer_template& CamParameters_template::lowFrequencyContainer()
{
set_specific();
return single_value->field_lowFrequencyContainer;
}

const LowFrequencyContainer_template& CamParameters_template::lowFrequencyContainer() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lowFrequencyContainer of a non-specific template of type @CAM-PDU-Descriptions.CamParameters.");
return single_value->field_lowFrequencyContainer;
}

SpecialVehicleContainer_template& CamParameters_template::specialVehicleContainer()
{
set_specific();
return single_value->field_specialVehicleContainer;
}

const SpecialVehicleContainer_template& CamParameters_template::specialVehicleContainer() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field specialVehicleContainer of a non-specific template of type @CAM-PDU-Descriptions.CamParameters.");
return single_value->field_specialVehicleContainer;
}

int CamParameters_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CamParameters which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_lowFrequencyContainer.is_present()) ret_val++;
      if (single_value->field_specialVehicleContainer.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CamParameters containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CamParameters containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CamParameters containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CamParameters containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CamParameters containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CamParameters.");
  }
  return 0;
}

void CamParameters_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ basicContainer := ");
single_value->field_basicContainer.log();
TTCN_Logger::log_event_str(", highFrequencyContainer := ");
single_value->field_highFrequencyContainer.log();
TTCN_Logger::log_event_str(", lowFrequencyContainer := ");
single_value->field_lowFrequencyContainer.log();
TTCN_Logger::log_event_str(", specialVehicleContainer := ");
single_value->field_specialVehicleContainer.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CamParameters_template::log_match(const CamParameters& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_basicContainer.match(match_value.basicContainer(), legacy)){
TTCN_Logger::log_logmatch_info(".basicContainer");
single_value->field_basicContainer.log_match(match_value.basicContainer(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_highFrequencyContainer.match(match_value.highFrequencyContainer(), legacy)){
TTCN_Logger::log_logmatch_info(".highFrequencyContainer");
single_value->field_highFrequencyContainer.log_match(match_value.highFrequencyContainer(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.lowFrequencyContainer().ispresent()){
if(!single_value->field_lowFrequencyContainer.match(match_value.lowFrequencyContainer(), legacy)){
TTCN_Logger::log_logmatch_info(".lowFrequencyContainer");
single_value->field_lowFrequencyContainer.log_match(match_value.lowFrequencyContainer(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_lowFrequencyContainer.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".lowFrequencyContainer := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_lowFrequencyContainer.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.specialVehicleContainer().ispresent()){
if(!single_value->field_specialVehicleContainer.match(match_value.specialVehicleContainer(), legacy)){
TTCN_Logger::log_logmatch_info(".specialVehicleContainer");
single_value->field_specialVehicleContainer.log_match(match_value.specialVehicleContainer(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_specialVehicleContainer.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".specialVehicleContainer := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_specialVehicleContainer.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ basicContainer := ");
single_value->field_basicContainer.log_match(match_value.basicContainer(), legacy);
TTCN_Logger::log_event_str(", highFrequencyContainer := ");
single_value->field_highFrequencyContainer.log_match(match_value.highFrequencyContainer(), legacy);
TTCN_Logger::log_event_str(", lowFrequencyContainer := ");
if (match_value.lowFrequencyContainer().ispresent()) single_value->field_lowFrequencyContainer.log_match(match_value.lowFrequencyContainer(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_lowFrequencyContainer.log();
if (single_value->field_lowFrequencyContainer.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", specialVehicleContainer := ");
if (match_value.specialVehicleContainer().ispresent()) single_value->field_specialVehicleContainer.log_match(match_value.specialVehicleContainer(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_specialVehicleContainer.log();
if (single_value->field_specialVehicleContainer.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CamParameters_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_basicContainer.encode_text(text_buf);
single_value->field_highFrequencyContainer.encode_text(text_buf);
single_value->field_lowFrequencyContainer.encode_text(text_buf);
single_value->field_specialVehicleContainer.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CamParameters.");
}
}

void CamParameters_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_basicContainer.decode_text(text_buf);
single_value->field_highFrequencyContainer.decode_text(text_buf);
single_value->field_lowFrequencyContainer.decode_text(text_buf);
single_value->field_specialVehicleContainer.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CamParameters_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.CamParameters.");
}
}

void CamParameters_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.CamParameters'");
    }
    if (strcmp("basicContainer", param_field) == 0) {
      basicContainer().set_param(param);
      return;
    } else if (strcmp("highFrequencyContainer", param_field) == 0) {
      highFrequencyContainer().set_param(param);
      return;
    } else if (strcmp("lowFrequencyContainer", param_field) == 0) {
      lowFrequencyContainer().set_param(param);
      return;
    } else if (strcmp("specialVehicleContainer", param_field) == 0) {
      specialVehicleContainer().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.CamParameters'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CamParameters_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.CamParameters has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) basicContainer().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) highFrequencyContainer().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) lowFrequencyContainer().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) specialVehicleContainer().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "basicContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          basicContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "highFrequencyContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          highFrequencyContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lowFrequencyContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lowFrequencyContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "specialVehicleContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          specialVehicleContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.CamParameters: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.CamParameters");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CamParameters_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.CamParameters'");
    }
    if (strcmp("basicContainer", param_field) == 0) {
      return basicContainer().get_param(param_name);
    } else if (strcmp("highFrequencyContainer", param_field) == 0) {
      return highFrequencyContainer().get_param(param_name);
    } else if (strcmp("lowFrequencyContainer", param_field) == 0) {
      return lowFrequencyContainer().get_param(param_name);
    } else if (strcmp("specialVehicleContainer", param_field) == 0) {
      return specialVehicleContainer().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.CamParameters'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_basicContainer = single_value->field_basicContainer.get_param(param_name);
    mp_field_basicContainer->set_id(new Module_Param_FieldName(mcopystr("basicContainer")));
    mp->add_elem(mp_field_basicContainer);
    Module_Param* mp_field_highFrequencyContainer = single_value->field_highFrequencyContainer.get_param(param_name);
    mp_field_highFrequencyContainer->set_id(new Module_Param_FieldName(mcopystr("highFrequencyContainer")));
    mp->add_elem(mp_field_highFrequencyContainer);
    Module_Param* mp_field_lowFrequencyContainer = single_value->field_lowFrequencyContainer.get_param(param_name);
    mp_field_lowFrequencyContainer->set_id(new Module_Param_FieldName(mcopystr("lowFrequencyContainer")));
    mp->add_elem(mp_field_lowFrequencyContainer);
    Module_Param* mp_field_specialVehicleContainer = single_value->field_specialVehicleContainer.get_param(param_name);
    mp_field_specialVehicleContainer->set_id(new Module_Param_FieldName(mcopystr("specialVehicleContainer")));
    mp->add_elem(mp_field_specialVehicleContainer);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CamParameters_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_basicContainer.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.CamParameters");
single_value->field_highFrequencyContainer.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.CamParameters");
single_value->field_lowFrequencyContainer.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.CamParameters");
single_value->field_specialVehicleContainer.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.CamParameters");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.CamParameters");
}

boolean CamParameters_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CamParameters_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void LowFrequencyContainer::copy_value(const LowFrequencyContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_basicVehicleContainerLowFrequency:
field_basicVehicleContainerLowFrequency = new BasicVehicleContainerLowFrequency(*other_value.field_basicVehicleContainerLowFrequency);
break;
default:
TTCN_error("Assignment of an unbound union value of type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
union_selection = other_value.union_selection;
}

LowFrequencyContainer::LowFrequencyContainer()
{
union_selection = UNBOUND_VALUE;
}

LowFrequencyContainer::LowFrequencyContainer(const LowFrequencyContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

LowFrequencyContainer::~LowFrequencyContainer()
{
clean_up();
}

LowFrequencyContainer& LowFrequencyContainer::operator=(const LowFrequencyContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean LowFrequencyContainer::operator==(const LowFrequencyContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_basicVehicleContainerLowFrequency:
return *field_basicVehicleContainerLowFrequency == *other_value.field_basicVehicleContainerLowFrequency;
default:
return FALSE;
}
}

BasicVehicleContainerLowFrequency& LowFrequencyContainer::basicVehicleContainerLowFrequency()
{
if (union_selection != ALT_basicVehicleContainerLowFrequency) {
clean_up();
field_basicVehicleContainerLowFrequency = new BasicVehicleContainerLowFrequency;
union_selection = ALT_basicVehicleContainerLowFrequency;
}
return *field_basicVehicleContainerLowFrequency;
}

const BasicVehicleContainerLowFrequency& LowFrequencyContainer::basicVehicleContainerLowFrequency() const
{
if (union_selection != ALT_basicVehicleContainerLowFrequency) TTCN_error("Using non-selected field basicVehicleContainerLowFrequency in a value of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
return *field_basicVehicleContainerLowFrequency;
}

boolean LowFrequencyContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
return union_selection == checked_selection;
}

boolean LowFrequencyContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean LowFrequencyContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_basicVehicleContainerLowFrequency: return field_basicVehicleContainerLowFrequency->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void LowFrequencyContainer::clean_up()
{
switch (union_selection) {
case ALT_basicVehicleContainerLowFrequency:
  delete field_basicVehicleContainerLowFrequency;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void LowFrequencyContainer::log() const
{
switch (union_selection) {
case ALT_basicVehicleContainerLowFrequency:
TTCN_Logger::log_event_str("{ basicVehicleContainerLowFrequency := ");
field_basicVehicleContainerLowFrequency->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void LowFrequencyContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@CAM-PDU-Descriptions.LowFrequencyContainer'");
    }
    if (strcmp("basicVehicleContainerLowFrequency", param_field) == 0) {
      basicVehicleContainerLowFrequency().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@CAM-PDU-Descriptions.LowFrequencyContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "basicVehicleContainerLowFrequency")) {
    basicVehicleContainerLowFrequency().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @CAM-PDU-Descriptions.LowFrequencyContainer.", mp_last->get_id()->get_name());
}

Module_Param* LowFrequencyContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@CAM-PDU-Descriptions.LowFrequencyContainer'");
    }
    if (strcmp("basicVehicleContainerLowFrequency", param_field) == 0) {
      return basicVehicleContainerLowFrequency().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `LowFrequencyContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_basicVehicleContainerLowFrequency:
    mp_field = field_basicVehicleContainerLowFrequency->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("basicVehicleContainerLowFrequency")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void LowFrequencyContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_basicVehicleContainerLowFrequency:
field_basicVehicleContainerLowFrequency->set_implicit_omit(); break;
default: break;
}
}

void LowFrequencyContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_basicVehicleContainerLowFrequency:
field_basicVehicleContainerLowFrequency->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
}

void LowFrequencyContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_basicVehicleContainerLowFrequency:
basicVehicleContainerLowFrequency().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
}

void LowFrequencyContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LowFrequencyContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t *LowFrequencyContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv;
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  switch (union_selection) {
  case ALT_basicVehicleContainerLowFrequency:
    ec_1.set_msg("basicVehicleContainerLowFrequency': ");
    new_tlv = field_basicVehicleContainerLowFrequency->BER_encode_TLV(LowFrequencyContainer_basicVehicleContainerLowFrequency_descr_, p_coding);
    break;
  case UNBOUND_VALUE:
    new_tlv = BER_encode_chk_bound(FALSE);
    break;
  default:
    TTCN_EncDec_ErrorContext::error_internal("Unknown selection.");
    new_tlv = NULL;
  }
  return ASN_BER_V2TLV(new_tlv, p_td, p_coding);
}

boolean LowFrequencyContainer::BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv)
{
  clean_up();
  field_basicVehicleContainerLowFrequency = new BasicVehicleContainerLowFrequency;
  union_selection = ALT_basicVehicleContainerLowFrequency;
  if (field_basicVehicleContainerLowFrequency->BER_decode_isMyMsg(LowFrequencyContainer_basicVehicleContainerLowFrequency_descr_, p_tlv)) return TRUE;
  delete field_basicVehicleContainerLowFrequency;
  union_selection = UNBOUND_VALUE;
  return FALSE;
}

boolean LowFrequencyContainer::BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv)
{
  if (p_td.ber->n_tags == 0) {
    LowFrequencyContainer tmp_type;
    return tmp_type.BER_decode_set_selection(p_tlv);
  } else return Base_Type::BER_decode_isMyMsg(p_td, p_tlv);
}

boolean LowFrequencyContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.LowFrequencyContainer' type: ");
  ASN_BER_TLV_t tmp_tlv;
  if (!BER_decode_TLV_CHOICE(*p_td.ber, stripped_tlv, L_form, tmp_tlv) || !BER_decode_CHOICE_selection(BER_decode_set_selection(tmp_tlv), tmp_tlv)) return FALSE;
  TTCN_EncDec_ErrorContext ec_1("Alternative '");
  TTCN_EncDec_ErrorContext ec_2;
  switch (union_selection) {
  case ALT_basicVehicleContainerLowFrequency:
    ec_2.set_msg("basicVehicleContainerLowFrequency': ");
    field_basicVehicleContainerLowFrequency->BER_decode_TLV(LowFrequencyContainer_basicVehicleContainerLowFrequency_descr_, tmp_tlv, L_form);
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

int LowFrequencyContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_basicVehicleContainerLowFrequency:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "basicVehicleContainerLowFrequency");
    enc_len += field_basicVehicleContainerLowFrequency->JSON_encode(LowFrequencyContainer_basicVehicleContainerLowFrequency_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @CAM-PDU-Descriptions.LowFrequencyContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LowFrequencyContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "basicVehicleContainerLowFrequency", name_len)) {
      int ret_val = basicVehicleContainerLowFrequency().JSON_decode(LowFrequencyContainer_basicVehicleContainerLowFrequency_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "basicVehicleContainerLowFrequency");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void LowFrequencyContainer_template::copy_value(const LowFrequencyContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
single_value.field_basicVehicleContainerLowFrequency = new BasicVehicleContainerLowFrequency_template(other_value.basicVehicleContainerLowFrequency());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void LowFrequencyContainer_template::copy_template(const LowFrequencyContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
single_value.field_basicVehicleContainerLowFrequency = new BasicVehicleContainerLowFrequency_template(*other_value.single_value.field_basicVehicleContainerLowFrequency);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LowFrequencyContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
set_selection(other_value);
}

LowFrequencyContainer_template::LowFrequencyContainer_template()
{
}

LowFrequencyContainer_template::LowFrequencyContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LowFrequencyContainer_template::LowFrequencyContainer_template(const LowFrequencyContainer& other_value)
{
copy_value(other_value);
}

LowFrequencyContainer_template::LowFrequencyContainer_template(const OPTIONAL<LowFrequencyContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LowFrequencyContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer from an unbound optional field.");
}
}

LowFrequencyContainer_template::LowFrequencyContainer_template(const LowFrequencyContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

LowFrequencyContainer_template::~LowFrequencyContainer_template()
{
clean_up();
}

void LowFrequencyContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
delete single_value.field_basicVehicleContainerLowFrequency;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LowFrequencyContainer_template& LowFrequencyContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LowFrequencyContainer_template& LowFrequencyContainer_template::operator=(const LowFrequencyContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LowFrequencyContainer_template& LowFrequencyContainer_template::operator=(const OPTIONAL<LowFrequencyContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LowFrequencyContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
return *this;
}

LowFrequencyContainer_template& LowFrequencyContainer_template::operator=(const LowFrequencyContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LowFrequencyContainer_template::match(const LowFrequencyContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
LowFrequencyContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == LowFrequencyContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
return single_value.field_basicVehicleContainerLowFrequency->match(other_value.basicVehicleContainerLowFrequency(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
return FALSE;
}

boolean LowFrequencyContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
return single_value.field_basicVehicleContainerLowFrequency->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
}

LowFrequencyContainer LowFrequencyContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
LowFrequencyContainer ret_val;
switch (single_value.union_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
ret_val.basicVehicleContainerLowFrequency() = single_value.field_basicVehicleContainerLowFrequency->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
return ret_val;
}

LowFrequencyContainer_template& LowFrequencyContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
return value_list.list_value[list_index];
}
void LowFrequencyContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LowFrequencyContainer_template[list_length];
}

BasicVehicleContainerLowFrequency_template& LowFrequencyContainer_template::basicVehicleContainerLowFrequency()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_basicVehicleContainerLowFrequency = new BasicVehicleContainerLowFrequency_template(ANY_VALUE);
else single_value.field_basicVehicleContainerLowFrequency = new BasicVehicleContainerLowFrequency_template;
single_value.union_selection = LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_basicVehicleContainerLowFrequency;
}

const BasicVehicleContainerLowFrequency_template& LowFrequencyContainer_template::basicVehicleContainerLowFrequency() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field basicVehicleContainerLowFrequency in a non-specific template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
if (single_value.union_selection != LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency) TTCN_error("Accessing non-selected field basicVehicleContainerLowFrequency in a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
return *single_value.field_basicVehicleContainerLowFrequency;
}

boolean LowFrequencyContainer_template::ischosen(LowFrequencyContainer::union_selection_type checked_selection) const
{
if (checked_selection == LowFrequencyContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == LowFrequencyContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @CAM-PDU-Descriptions.LowFrequencyContainer");
}
return FALSE;
}

void LowFrequencyContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
TTCN_Logger::log_event_str("{ basicVehicleContainerLowFrequency := ");
single_value.field_basicVehicleContainerLowFrequency->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LowFrequencyContainer_template::log_match(const LowFrequencyContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".basicVehicleContainerLowFrequency");
single_value.field_basicVehicleContainerLowFrequency->log_match(match_value.basicVehicleContainerLowFrequency(), legacy);
} else {
TTCN_Logger::log_event_str("{ basicVehicleContainerLowFrequency := ");
single_value.field_basicVehicleContainerLowFrequency->log_match(match_value.basicVehicleContainerLowFrequency(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LowFrequencyContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
single_value.field_basicVehicleContainerLowFrequency->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
}

void LowFrequencyContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = LowFrequencyContainer::UNBOUND_VALUE;
LowFrequencyContainer::union_selection_type new_selection = (LowFrequencyContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
single_value.field_basicVehicleContainerLowFrequency = new BasicVehicleContainerLowFrequency_template;
single_value.field_basicVehicleContainerLowFrequency->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LowFrequencyContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
}

boolean LowFrequencyContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LowFrequencyContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void LowFrequencyContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@CAM-PDU-Descriptions.LowFrequencyContainer'");
    }
    if (strcmp("basicVehicleContainerLowFrequency", param_field) == 0) {
      basicVehicleContainerLowFrequency().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@CAM-PDU-Descriptions.LowFrequencyContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LowFrequencyContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@CAM-PDU-Descriptions.LowFrequencyContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "basicVehicleContainerLowFrequency")) {
      basicVehicleContainerLowFrequency().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @CAM-PDU-Descriptions.LowFrequencyContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@CAM-PDU-Descriptions.LowFrequencyContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LowFrequencyContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@CAM-PDU-Descriptions.LowFrequencyContainer'");
    }
    if (strcmp("basicVehicleContainerLowFrequency", param_field) == 0) {
      return basicVehicleContainerLowFrequency().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `LowFrequencyContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
      mp_field = single_value.field_basicVehicleContainerLowFrequency->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("basicVehicleContainerLowFrequency")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LowFrequencyContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case LowFrequencyContainer::ALT_basicVehicleContainerLowFrequency:
single_value.field_basicVehicleContainerLowFrequency->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.LowFrequencyContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @CAM-PDU-Descriptions.LowFrequencyContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.LowFrequencyContainer");
}

BasicVehicleContainerLowFrequency::BasicVehicleContainerLowFrequency()
{
  bound_flag = FALSE;
}

BasicVehicleContainerLowFrequency::BasicVehicleContainerLowFrequency(const ITS__Container::VehicleRole& par_vehicleRole,
    const BITSTRING& par_exteriorLights,
    const ITS__Container::PathHistory& par_pathHistory)
  :   field_vehicleRole(par_vehicleRole),
  field_exteriorLights(par_exteriorLights),
  field_pathHistory(par_pathHistory)
{
  bound_flag = TRUE;
}

BasicVehicleContainerLowFrequency::BasicVehicleContainerLowFrequency(const BasicVehicleContainerLowFrequency& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
bound_flag = TRUE;
if (other_value.vehicleRole().is_bound()) field_vehicleRole = other_value.vehicleRole();
else field_vehicleRole.clean_up();
if (other_value.exteriorLights().is_bound()) field_exteriorLights = other_value.exteriorLights();
else field_exteriorLights.clean_up();
if (other_value.pathHistory().is_bound()) field_pathHistory = other_value.pathHistory();
else field_pathHistory.clean_up();
}

void BasicVehicleContainerLowFrequency::clean_up()
{
field_vehicleRole.clean_up();
field_exteriorLights.clean_up();
field_pathHistory.clean_up();
bound_flag = FALSE;
}

BasicVehicleContainerLowFrequency& BasicVehicleContainerLowFrequency::operator=(const BasicVehicleContainerLowFrequency& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
  bound_flag = TRUE;
  if (other_value.vehicleRole().is_bound()) field_vehicleRole = other_value.vehicleRole();
  else field_vehicleRole.clean_up();
  if (other_value.exteriorLights().is_bound()) field_exteriorLights = other_value.exteriorLights();
  else field_exteriorLights.clean_up();
  if (other_value.pathHistory().is_bound()) field_pathHistory = other_value.pathHistory();
  else field_pathHistory.clean_up();
}
return *this;
}

boolean BasicVehicleContainerLowFrequency::operator==(const BasicVehicleContainerLowFrequency& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_vehicleRole==other_value.field_vehicleRole
  && field_exteriorLights==other_value.field_exteriorLights
  && field_pathHistory==other_value.field_pathHistory;
}

boolean BasicVehicleContainerLowFrequency::is_bound() const
{
if (bound_flag) return TRUE;
if(field_vehicleRole.is_bound()) return TRUE;
if(field_exteriorLights.is_bound()) return TRUE;
if(field_pathHistory.is_bound()) return TRUE;
return FALSE;
}
boolean BasicVehicleContainerLowFrequency::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_vehicleRole.is_value()) return FALSE;
if(!field_exteriorLights.is_value()) return FALSE;
if(!field_pathHistory.is_value()) return FALSE;
return TRUE;
}
int BasicVehicleContainerLowFrequency::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency");
  return 3;
}

void BasicVehicleContainerLowFrequency::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ vehicleRole := ");
field_vehicleRole.log();
TTCN_Logger::log_event_str(", exteriorLights := ");
field_exteriorLights.log();
TTCN_Logger::log_event_str(", pathHistory := ");
field_pathHistory.log();
TTCN_Logger::log_event_str(" }");
}

void BasicVehicleContainerLowFrequency::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency'");
    }
    if (strcmp("vehicleRole", param_field) == 0) {
      vehicleRole().set_param(param);
      return;
    } else if (strcmp("exteriorLights", param_field) == 0) {
      exteriorLights().set_param(param);
      return;
    } else if (strcmp("pathHistory", param_field) == 0) {
      pathHistory().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) vehicleRole().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) exteriorLights().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) pathHistory().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleRole")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleRole().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "exteriorLights")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          exteriorLights().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pathHistory")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pathHistory().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency");
  }
}

Module_Param* BasicVehicleContainerLowFrequency::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency'");
    }
    if (strcmp("vehicleRole", param_field) == 0) {
      return vehicleRole().get_param(param_name);
    } else if (strcmp("exteriorLights", param_field) == 0) {
      return exteriorLights().get_param(param_name);
    } else if (strcmp("pathHistory", param_field) == 0) {
      return pathHistory().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_vehicleRole = field_vehicleRole.get_param(param_name);
  mp_field_vehicleRole->set_id(new Module_Param_FieldName(mcopystr("vehicleRole")));
  mp->add_elem(mp_field_vehicleRole);
  Module_Param* mp_field_exteriorLights = field_exteriorLights.get_param(param_name);
  mp_field_exteriorLights->set_id(new Module_Param_FieldName(mcopystr("exteriorLights")));
  mp->add_elem(mp_field_exteriorLights);
  Module_Param* mp_field_pathHistory = field_pathHistory.get_param(param_name);
  mp_field_pathHistory->set_id(new Module_Param_FieldName(mcopystr("pathHistory")));
  mp->add_elem(mp_field_pathHistory);
  return mp;
  }

void BasicVehicleContainerLowFrequency::set_implicit_omit()
{
if (vehicleRole().is_bound()) vehicleRole().set_implicit_omit();
if (exteriorLights().is_bound()) exteriorLights().set_implicit_omit();
if (pathHistory().is_bound()) pathHistory().set_implicit_omit();
}

void BasicVehicleContainerLowFrequency::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
field_vehicleRole.encode_text(text_buf);
field_exteriorLights.encode_text(text_buf);
field_pathHistory.encode_text(text_buf);
}

void BasicVehicleContainerLowFrequency::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_vehicleRole.decode_text(text_buf);
field_exteriorLights.decode_text(text_buf);
field_pathHistory.decode_text(text_buf);
}

void BasicVehicleContainerLowFrequency::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BasicVehicleContainerLowFrequency::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* BasicVehicleContainerLowFrequency::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("vehicleRole': ");
  new_tlv->add_TLV(field_vehicleRole.BER_encode_TLV(BasicVehicleContainerLowFrequency_vehicleRole_descr_, p_coding));
  ec_1.set_msg("exteriorLights': ");
  new_tlv->add_TLV(field_exteriorLights.BER_encode_TLV(BasicVehicleContainerLowFrequency_exteriorLights_descr_, p_coding));
  ec_1.set_msg("pathHistory': ");
  new_tlv->add_TLV(field_pathHistory.BER_encode_TLV(BasicVehicleContainerLowFrequency_pathHistory_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean BasicVehicleContainerLowFrequency::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("vehicleRole': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_vehicleRole.BER_decode_TLV(BasicVehicleContainerLowFrequency_vehicleRole_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("exteriorLights': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_exteriorLights.BER_decode_TLV(BasicVehicleContainerLowFrequency_exteriorLights_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("pathHistory': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_pathHistory.BER_decode_TLV(BasicVehicleContainerLowFrequency_pathHistory_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int BasicVehicleContainerLowFrequency::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vehicleRole");
    enc_len += field_vehicleRole.JSON_encode(BasicVehicleContainerLowFrequency_vehicleRole_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "exteriorLights");
    enc_len += field_exteriorLights.JSON_encode(BasicVehicleContainerLowFrequency_exteriorLights_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "pathHistory");
    enc_len += field_pathHistory.JSON_encode(BasicVehicleContainerLowFrequency_pathHistory_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BasicVehicleContainerLowFrequency::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (11 == name_len && 0 == strncmp(fld_name, "vehicleRole", name_len)) {
         int ret_val = field_vehicleRole.JSON_decode(BasicVehicleContainerLowFrequency_vehicleRole_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vehicleRole");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "exteriorLights", name_len)) {
         int ret_val = field_exteriorLights.JSON_decode(BasicVehicleContainerLowFrequency_exteriorLights_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "exteriorLights");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "pathHistory", name_len)) {
         int ret_val = field_pathHistory.JSON_decode(BasicVehicleContainerLowFrequency_pathHistory_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "pathHistory");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_vehicleRole.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "vehicleRole");
    return JSON_ERROR_FATAL;
  }
if (!field_exteriorLights.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "exteriorLights");
    return JSON_ERROR_FATAL;
  }
if (!field_pathHistory.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "pathHistory");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct BasicVehicleContainerLowFrequency_template::single_value_struct {
ITS__Container::VehicleRole_template field_vehicleRole;
BITSTRING_template field_exteriorLights;
ITS__Container::PathHistory_template field_pathHistory;
};

void BasicVehicleContainerLowFrequency_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_vehicleRole = ANY_VALUE;
single_value->field_exteriorLights = ANY_VALUE;
single_value->field_pathHistory = ANY_VALUE;
}
}
}

void BasicVehicleContainerLowFrequency_template::copy_value(const BasicVehicleContainerLowFrequency& other_value)
{
single_value = new single_value_struct;
if (other_value.vehicleRole().is_bound()) {
  single_value->field_vehicleRole = other_value.vehicleRole();
} else {
  single_value->field_vehicleRole.clean_up();
}
if (other_value.exteriorLights().is_bound()) {
  single_value->field_exteriorLights = other_value.exteriorLights();
} else {
  single_value->field_exteriorLights.clean_up();
}
if (other_value.pathHistory().is_bound()) {
  single_value->field_pathHistory = other_value.pathHistory();
} else {
  single_value->field_pathHistory.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BasicVehicleContainerLowFrequency_template::copy_template(const BasicVehicleContainerLowFrequency_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.vehicleRole().get_selection()) {
single_value->field_vehicleRole = other_value.vehicleRole();
} else {
single_value->field_vehicleRole.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.exteriorLights().get_selection()) {
single_value->field_exteriorLights = other_value.exteriorLights();
} else {
single_value->field_exteriorLights.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.pathHistory().get_selection()) {
single_value->field_pathHistory = other_value.pathHistory();
} else {
single_value->field_pathHistory.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BasicVehicleContainerLowFrequency_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
break;
}
set_selection(other_value);
}

BasicVehicleContainerLowFrequency_template::BasicVehicleContainerLowFrequency_template()
{
}

BasicVehicleContainerLowFrequency_template::BasicVehicleContainerLowFrequency_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BasicVehicleContainerLowFrequency_template::BasicVehicleContainerLowFrequency_template(const BasicVehicleContainerLowFrequency& other_value)
{
copy_value(other_value);
}

BasicVehicleContainerLowFrequency_template::BasicVehicleContainerLowFrequency_template(const OPTIONAL<BasicVehicleContainerLowFrequency>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BasicVehicleContainerLowFrequency&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency from an unbound optional field.");
}
}

BasicVehicleContainerLowFrequency_template::BasicVehicleContainerLowFrequency_template(const BasicVehicleContainerLowFrequency_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BasicVehicleContainerLowFrequency_template::~BasicVehicleContainerLowFrequency_template()
{
clean_up();
}

BasicVehicleContainerLowFrequency_template& BasicVehicleContainerLowFrequency_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BasicVehicleContainerLowFrequency_template& BasicVehicleContainerLowFrequency_template::operator=(const BasicVehicleContainerLowFrequency& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BasicVehicleContainerLowFrequency_template& BasicVehicleContainerLowFrequency_template::operator=(const OPTIONAL<BasicVehicleContainerLowFrequency>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BasicVehicleContainerLowFrequency&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
}
return *this;
}

BasicVehicleContainerLowFrequency_template& BasicVehicleContainerLowFrequency_template::operator=(const BasicVehicleContainerLowFrequency_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BasicVehicleContainerLowFrequency_template::match(const BasicVehicleContainerLowFrequency& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.vehicleRole().is_bound()) return FALSE;
if(!single_value->field_vehicleRole.match(other_value.vehicleRole(), legacy))return FALSE;
if(!other_value.exteriorLights().is_bound()) return FALSE;
if(!single_value->field_exteriorLights.match(other_value.exteriorLights(), legacy))return FALSE;
if(!other_value.pathHistory().is_bound()) return FALSE;
if(!single_value->field_pathHistory.match(other_value.pathHistory(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
}
return FALSE;
}

boolean BasicVehicleContainerLowFrequency_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_vehicleRole.is_bound()) return TRUE;
if (single_value->field_exteriorLights.is_bound()) return TRUE;
if (single_value->field_pathHistory.is_bound()) return TRUE;
return FALSE;
}

boolean BasicVehicleContainerLowFrequency_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_vehicleRole.is_value()) return FALSE;
if (!single_value->field_exteriorLights.is_value()) return FALSE;
if (!single_value->field_pathHistory.is_value()) return FALSE;
return TRUE;
}

void BasicVehicleContainerLowFrequency_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BasicVehicleContainerLowFrequency BasicVehicleContainerLowFrequency_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
BasicVehicleContainerLowFrequency ret_val;
if (single_value->field_vehicleRole.is_bound()) {
ret_val.vehicleRole() = single_value->field_vehicleRole.valueof();
}
if (single_value->field_exteriorLights.is_bound()) {
ret_val.exteriorLights() = single_value->field_exteriorLights.valueof();
}
if (single_value->field_pathHistory.is_bound()) {
ret_val.pathHistory() = single_value->field_pathHistory.valueof();
}
return ret_val;
}

void BasicVehicleContainerLowFrequency_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BasicVehicleContainerLowFrequency_template[list_length];
}

BasicVehicleContainerLowFrequency_template& BasicVehicleContainerLowFrequency_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
return value_list.list_value[list_index];
}

ITS__Container::VehicleRole_template& BasicVehicleContainerLowFrequency_template::vehicleRole()
{
set_specific();
return single_value->field_vehicleRole;
}

const ITS__Container::VehicleRole_template& BasicVehicleContainerLowFrequency_template::vehicleRole() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field vehicleRole of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
return single_value->field_vehicleRole;
}

BITSTRING_template& BasicVehicleContainerLowFrequency_template::exteriorLights()
{
set_specific();
return single_value->field_exteriorLights;
}

const BITSTRING_template& BasicVehicleContainerLowFrequency_template::exteriorLights() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field exteriorLights of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
return single_value->field_exteriorLights;
}

ITS__Container::PathHistory_template& BasicVehicleContainerLowFrequency_template::pathHistory()
{
set_specific();
return single_value->field_pathHistory;
}

const ITS__Container::PathHistory_template& BasicVehicleContainerLowFrequency_template::pathHistory() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field pathHistory of a non-specific template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
return single_value->field_pathHistory;
}

int BasicVehicleContainerLowFrequency_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
  }
  return 0;
}

void BasicVehicleContainerLowFrequency_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ vehicleRole := ");
single_value->field_vehicleRole.log();
TTCN_Logger::log_event_str(", exteriorLights := ");
single_value->field_exteriorLights.log();
TTCN_Logger::log_event_str(", pathHistory := ");
single_value->field_pathHistory.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BasicVehicleContainerLowFrequency_template::log_match(const BasicVehicleContainerLowFrequency& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_vehicleRole.match(match_value.vehicleRole(), legacy)){
TTCN_Logger::log_logmatch_info(".vehicleRole");
single_value->field_vehicleRole.log_match(match_value.vehicleRole(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_exteriorLights.match(match_value.exteriorLights(), legacy)){
TTCN_Logger::log_logmatch_info(".exteriorLights");
single_value->field_exteriorLights.log_match(match_value.exteriorLights(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_pathHistory.match(match_value.pathHistory(), legacy)){
TTCN_Logger::log_logmatch_info(".pathHistory");
single_value->field_pathHistory.log_match(match_value.pathHistory(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ vehicleRole := ");
single_value->field_vehicleRole.log_match(match_value.vehicleRole(), legacy);
TTCN_Logger::log_event_str(", exteriorLights := ");
single_value->field_exteriorLights.log_match(match_value.exteriorLights(), legacy);
TTCN_Logger::log_event_str(", pathHistory := ");
single_value->field_pathHistory.log_match(match_value.pathHistory(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BasicVehicleContainerLowFrequency_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_vehicleRole.encode_text(text_buf);
single_value->field_exteriorLights.encode_text(text_buf);
single_value->field_pathHistory.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
}
}

void BasicVehicleContainerLowFrequency_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_vehicleRole.decode_text(text_buf);
single_value->field_exteriorLights.decode_text(text_buf);
single_value->field_pathHistory.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BasicVehicleContainerLowFrequency_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency.");
}
}

void BasicVehicleContainerLowFrequency_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency'");
    }
    if (strcmp("vehicleRole", param_field) == 0) {
      vehicleRole().set_param(param);
      return;
    } else if (strcmp("exteriorLights", param_field) == 0) {
      exteriorLights().set_param(param);
      return;
    } else if (strcmp("pathHistory", param_field) == 0) {
      pathHistory().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BasicVehicleContainerLowFrequency_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) vehicleRole().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) exteriorLights().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) pathHistory().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleRole")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleRole().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "exteriorLights")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          exteriorLights().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pathHistory")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pathHistory().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BasicVehicleContainerLowFrequency_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency'");
    }
    if (strcmp("vehicleRole", param_field) == 0) {
      return vehicleRole().get_param(param_name);
    } else if (strcmp("exteriorLights", param_field) == 0) {
      return exteriorLights().get_param(param_name);
    } else if (strcmp("pathHistory", param_field) == 0) {
      return pathHistory().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_vehicleRole = single_value->field_vehicleRole.get_param(param_name);
    mp_field_vehicleRole->set_id(new Module_Param_FieldName(mcopystr("vehicleRole")));
    mp->add_elem(mp_field_vehicleRole);
    Module_Param* mp_field_exteriorLights = single_value->field_exteriorLights.get_param(param_name);
    mp_field_exteriorLights->set_id(new Module_Param_FieldName(mcopystr("exteriorLights")));
    mp->add_elem(mp_field_exteriorLights);
    Module_Param* mp_field_pathHistory = single_value->field_pathHistory.get_param(param_name);
    mp_field_pathHistory->set_id(new Module_Param_FieldName(mcopystr("pathHistory")));
    mp->add_elem(mp_field_pathHistory);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BasicVehicleContainerLowFrequency_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_vehicleRole.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency");
single_value->field_exteriorLights.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency");
single_value->field_pathHistory.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.BasicVehicleContainerLowFrequency");
}

boolean BasicVehicleContainerLowFrequency_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BasicVehicleContainerLowFrequency_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SpecialVehicleContainer::copy_value(const SpecialVehicleContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_publicTransportContainer:
field_publicTransportContainer = new PublicTransportContainer(*other_value.field_publicTransportContainer);
break;
case ALT_specialTransportContainer:
field_specialTransportContainer = new SpecialTransportContainer(*other_value.field_specialTransportContainer);
break;
case ALT_dangerousGoodsContainer:
field_dangerousGoodsContainer = new DangerousGoodsContainer(*other_value.field_dangerousGoodsContainer);
break;
case ALT_roadWorksContainerBasic:
field_roadWorksContainerBasic = new RoadWorksContainerBasic(*other_value.field_roadWorksContainerBasic);
break;
case ALT_rescueContainer:
field_rescueContainer = new RescueContainer(*other_value.field_rescueContainer);
break;
case ALT_emergencyContainer:
field_emergencyContainer = new EmergencyContainer(*other_value.field_emergencyContainer);
break;
case ALT_safetyCarContainer:
field_safetyCarContainer = new SafetyCarContainer(*other_value.field_safetyCarContainer);
break;
default:
TTCN_error("Assignment of an unbound union value of type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
union_selection = other_value.union_selection;
}

SpecialVehicleContainer::SpecialVehicleContainer()
{
union_selection = UNBOUND_VALUE;
}

SpecialVehicleContainer::SpecialVehicleContainer(const SpecialVehicleContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

SpecialVehicleContainer::~SpecialVehicleContainer()
{
clean_up();
}

SpecialVehicleContainer& SpecialVehicleContainer::operator=(const SpecialVehicleContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean SpecialVehicleContainer::operator==(const SpecialVehicleContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_publicTransportContainer:
return *field_publicTransportContainer == *other_value.field_publicTransportContainer;
case ALT_specialTransportContainer:
return *field_specialTransportContainer == *other_value.field_specialTransportContainer;
case ALT_dangerousGoodsContainer:
return *field_dangerousGoodsContainer == *other_value.field_dangerousGoodsContainer;
case ALT_roadWorksContainerBasic:
return *field_roadWorksContainerBasic == *other_value.field_roadWorksContainerBasic;
case ALT_rescueContainer:
return *field_rescueContainer == *other_value.field_rescueContainer;
case ALT_emergencyContainer:
return *field_emergencyContainer == *other_value.field_emergencyContainer;
case ALT_safetyCarContainer:
return *field_safetyCarContainer == *other_value.field_safetyCarContainer;
default:
return FALSE;
}
}

PublicTransportContainer& SpecialVehicleContainer::publicTransportContainer()
{
if (union_selection != ALT_publicTransportContainer) {
clean_up();
field_publicTransportContainer = new PublicTransportContainer;
union_selection = ALT_publicTransportContainer;
}
return *field_publicTransportContainer;
}

const PublicTransportContainer& SpecialVehicleContainer::publicTransportContainer() const
{
if (union_selection != ALT_publicTransportContainer) TTCN_error("Using non-selected field publicTransportContainer in a value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *field_publicTransportContainer;
}

SpecialTransportContainer& SpecialVehicleContainer::specialTransportContainer()
{
if (union_selection != ALT_specialTransportContainer) {
clean_up();
field_specialTransportContainer = new SpecialTransportContainer;
union_selection = ALT_specialTransportContainer;
}
return *field_specialTransportContainer;
}

const SpecialTransportContainer& SpecialVehicleContainer::specialTransportContainer() const
{
if (union_selection != ALT_specialTransportContainer) TTCN_error("Using non-selected field specialTransportContainer in a value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *field_specialTransportContainer;
}

DangerousGoodsContainer& SpecialVehicleContainer::dangerousGoodsContainer()
{
if (union_selection != ALT_dangerousGoodsContainer) {
clean_up();
field_dangerousGoodsContainer = new DangerousGoodsContainer;
union_selection = ALT_dangerousGoodsContainer;
}
return *field_dangerousGoodsContainer;
}

const DangerousGoodsContainer& SpecialVehicleContainer::dangerousGoodsContainer() const
{
if (union_selection != ALT_dangerousGoodsContainer) TTCN_error("Using non-selected field dangerousGoodsContainer in a value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *field_dangerousGoodsContainer;
}

RoadWorksContainerBasic& SpecialVehicleContainer::roadWorksContainerBasic()
{
if (union_selection != ALT_roadWorksContainerBasic) {
clean_up();
field_roadWorksContainerBasic = new RoadWorksContainerBasic;
union_selection = ALT_roadWorksContainerBasic;
}
return *field_roadWorksContainerBasic;
}

const RoadWorksContainerBasic& SpecialVehicleContainer::roadWorksContainerBasic() const
{
if (union_selection != ALT_roadWorksContainerBasic) TTCN_error("Using non-selected field roadWorksContainerBasic in a value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *field_roadWorksContainerBasic;
}

RescueContainer& SpecialVehicleContainer::rescueContainer()
{
if (union_selection != ALT_rescueContainer) {
clean_up();
field_rescueContainer = new RescueContainer;
union_selection = ALT_rescueContainer;
}
return *field_rescueContainer;
}

const RescueContainer& SpecialVehicleContainer::rescueContainer() const
{
if (union_selection != ALT_rescueContainer) TTCN_error("Using non-selected field rescueContainer in a value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *field_rescueContainer;
}

EmergencyContainer& SpecialVehicleContainer::emergencyContainer()
{
if (union_selection != ALT_emergencyContainer) {
clean_up();
field_emergencyContainer = new EmergencyContainer;
union_selection = ALT_emergencyContainer;
}
return *field_emergencyContainer;
}

const EmergencyContainer& SpecialVehicleContainer::emergencyContainer() const
{
if (union_selection != ALT_emergencyContainer) TTCN_error("Using non-selected field emergencyContainer in a value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *field_emergencyContainer;
}

SafetyCarContainer& SpecialVehicleContainer::safetyCarContainer()
{
if (union_selection != ALT_safetyCarContainer) {
clean_up();
field_safetyCarContainer = new SafetyCarContainer;
union_selection = ALT_safetyCarContainer;
}
return *field_safetyCarContainer;
}

const SafetyCarContainer& SpecialVehicleContainer::safetyCarContainer() const
{
if (union_selection != ALT_safetyCarContainer) TTCN_error("Using non-selected field safetyCarContainer in a value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *field_safetyCarContainer;
}

boolean SpecialVehicleContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return union_selection == checked_selection;
}

boolean SpecialVehicleContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean SpecialVehicleContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_publicTransportContainer: return field_publicTransportContainer->is_value();
case ALT_specialTransportContainer: return field_specialTransportContainer->is_value();
case ALT_dangerousGoodsContainer: return field_dangerousGoodsContainer->is_value();
case ALT_roadWorksContainerBasic: return field_roadWorksContainerBasic->is_value();
case ALT_rescueContainer: return field_rescueContainer->is_value();
case ALT_emergencyContainer: return field_emergencyContainer->is_value();
case ALT_safetyCarContainer: return field_safetyCarContainer->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void SpecialVehicleContainer::clean_up()
{
switch (union_selection) {
case ALT_publicTransportContainer:
  delete field_publicTransportContainer;
  break;
case ALT_specialTransportContainer:
  delete field_specialTransportContainer;
  break;
case ALT_dangerousGoodsContainer:
  delete field_dangerousGoodsContainer;
  break;
case ALT_roadWorksContainerBasic:
  delete field_roadWorksContainerBasic;
  break;
case ALT_rescueContainer:
  delete field_rescueContainer;
  break;
case ALT_emergencyContainer:
  delete field_emergencyContainer;
  break;
case ALT_safetyCarContainer:
  delete field_safetyCarContainer;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void SpecialVehicleContainer::log() const
{
switch (union_selection) {
case ALT_publicTransportContainer:
TTCN_Logger::log_event_str("{ publicTransportContainer := ");
field_publicTransportContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_specialTransportContainer:
TTCN_Logger::log_event_str("{ specialTransportContainer := ");
field_specialTransportContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_dangerousGoodsContainer:
TTCN_Logger::log_event_str("{ dangerousGoodsContainer := ");
field_dangerousGoodsContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_roadWorksContainerBasic:
TTCN_Logger::log_event_str("{ roadWorksContainerBasic := ");
field_roadWorksContainerBasic->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_rescueContainer:
TTCN_Logger::log_event_str("{ rescueContainer := ");
field_rescueContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_emergencyContainer:
TTCN_Logger::log_event_str("{ emergencyContainer := ");
field_emergencyContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_safetyCarContainer:
TTCN_Logger::log_event_str("{ safetyCarContainer := ");
field_safetyCarContainer->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void SpecialVehicleContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@CAM-PDU-Descriptions.SpecialVehicleContainer'");
    }
    if (strcmp("publicTransportContainer", param_field) == 0) {
      publicTransportContainer().set_param(param);
      return;
    } else if (strcmp("specialTransportContainer", param_field) == 0) {
      specialTransportContainer().set_param(param);
      return;
    } else if (strcmp("dangerousGoodsContainer", param_field) == 0) {
      dangerousGoodsContainer().set_param(param);
      return;
    } else if (strcmp("roadWorksContainerBasic", param_field) == 0) {
      roadWorksContainerBasic().set_param(param);
      return;
    } else if (strcmp("rescueContainer", param_field) == 0) {
      rescueContainer().set_param(param);
      return;
    } else if (strcmp("emergencyContainer", param_field) == 0) {
      emergencyContainer().set_param(param);
      return;
    } else if (strcmp("safetyCarContainer", param_field) == 0) {
      safetyCarContainer().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@CAM-PDU-Descriptions.SpecialVehicleContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "publicTransportContainer")) {
    publicTransportContainer().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "specialTransportContainer")) {
    specialTransportContainer().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "dangerousGoodsContainer")) {
    dangerousGoodsContainer().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "roadWorksContainerBasic")) {
    roadWorksContainerBasic().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "rescueContainer")) {
    rescueContainer().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "emergencyContainer")) {
    emergencyContainer().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "safetyCarContainer")) {
    safetyCarContainer().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @CAM-PDU-Descriptions.SpecialVehicleContainer.", mp_last->get_id()->get_name());
}

Module_Param* SpecialVehicleContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@CAM-PDU-Descriptions.SpecialVehicleContainer'");
    }
    if (strcmp("publicTransportContainer", param_field) == 0) {
      return publicTransportContainer().get_param(param_name);
    } else if (strcmp("specialTransportContainer", param_field) == 0) {
      return specialTransportContainer().get_param(param_name);
    } else if (strcmp("dangerousGoodsContainer", param_field) == 0) {
      return dangerousGoodsContainer().get_param(param_name);
    } else if (strcmp("roadWorksContainerBasic", param_field) == 0) {
      return roadWorksContainerBasic().get_param(param_name);
    } else if (strcmp("rescueContainer", param_field) == 0) {
      return rescueContainer().get_param(param_name);
    } else if (strcmp("emergencyContainer", param_field) == 0) {
      return emergencyContainer().get_param(param_name);
    } else if (strcmp("safetyCarContainer", param_field) == 0) {
      return safetyCarContainer().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `SpecialVehicleContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_publicTransportContainer:
    mp_field = field_publicTransportContainer->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("publicTransportContainer")));
    break;
  case ALT_specialTransportContainer:
    mp_field = field_specialTransportContainer->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("specialTransportContainer")));
    break;
  case ALT_dangerousGoodsContainer:
    mp_field = field_dangerousGoodsContainer->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("dangerousGoodsContainer")));
    break;
  case ALT_roadWorksContainerBasic:
    mp_field = field_roadWorksContainerBasic->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("roadWorksContainerBasic")));
    break;
  case ALT_rescueContainer:
    mp_field = field_rescueContainer->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("rescueContainer")));
    break;
  case ALT_emergencyContainer:
    mp_field = field_emergencyContainer->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("emergencyContainer")));
    break;
  case ALT_safetyCarContainer:
    mp_field = field_safetyCarContainer->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("safetyCarContainer")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void SpecialVehicleContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_publicTransportContainer:
field_publicTransportContainer->set_implicit_omit(); break;
case ALT_specialTransportContainer:
field_specialTransportContainer->set_implicit_omit(); break;
case ALT_dangerousGoodsContainer:
field_dangerousGoodsContainer->set_implicit_omit(); break;
case ALT_roadWorksContainerBasic:
field_roadWorksContainerBasic->set_implicit_omit(); break;
case ALT_rescueContainer:
field_rescueContainer->set_implicit_omit(); break;
case ALT_emergencyContainer:
field_emergencyContainer->set_implicit_omit(); break;
case ALT_safetyCarContainer:
field_safetyCarContainer->set_implicit_omit(); break;
default: break;
}
}

void SpecialVehicleContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_publicTransportContainer:
field_publicTransportContainer->encode_text(text_buf);
break;
case ALT_specialTransportContainer:
field_specialTransportContainer->encode_text(text_buf);
break;
case ALT_dangerousGoodsContainer:
field_dangerousGoodsContainer->encode_text(text_buf);
break;
case ALT_roadWorksContainerBasic:
field_roadWorksContainerBasic->encode_text(text_buf);
break;
case ALT_rescueContainer:
field_rescueContainer->encode_text(text_buf);
break;
case ALT_emergencyContainer:
field_emergencyContainer->encode_text(text_buf);
break;
case ALT_safetyCarContainer:
field_safetyCarContainer->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
}

void SpecialVehicleContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_publicTransportContainer:
publicTransportContainer().decode_text(text_buf);
break;
case ALT_specialTransportContainer:
specialTransportContainer().decode_text(text_buf);
break;
case ALT_dangerousGoodsContainer:
dangerousGoodsContainer().decode_text(text_buf);
break;
case ALT_roadWorksContainerBasic:
roadWorksContainerBasic().decode_text(text_buf);
break;
case ALT_rescueContainer:
rescueContainer().decode_text(text_buf);
break;
case ALT_emergencyContainer:
emergencyContainer().decode_text(text_buf);
break;
case ALT_safetyCarContainer:
safetyCarContainer().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
}

void SpecialVehicleContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SpecialVehicleContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t *SpecialVehicleContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv;
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  switch (union_selection) {
  case ALT_publicTransportContainer:
    ec_1.set_msg("publicTransportContainer': ");
    new_tlv = field_publicTransportContainer->BER_encode_TLV(SpecialVehicleContainer_publicTransportContainer_descr_, p_coding);
    break;
  case ALT_specialTransportContainer:
    ec_1.set_msg("specialTransportContainer': ");
    new_tlv = field_specialTransportContainer->BER_encode_TLV(SpecialVehicleContainer_specialTransportContainer_descr_, p_coding);
    break;
  case ALT_dangerousGoodsContainer:
    ec_1.set_msg("dangerousGoodsContainer': ");
    new_tlv = field_dangerousGoodsContainer->BER_encode_TLV(SpecialVehicleContainer_dangerousGoodsContainer_descr_, p_coding);
    break;
  case ALT_roadWorksContainerBasic:
    ec_1.set_msg("roadWorksContainerBasic': ");
    new_tlv = field_roadWorksContainerBasic->BER_encode_TLV(SpecialVehicleContainer_roadWorksContainerBasic_descr_, p_coding);
    break;
  case ALT_rescueContainer:
    ec_1.set_msg("rescueContainer': ");
    new_tlv = field_rescueContainer->BER_encode_TLV(SpecialVehicleContainer_rescueContainer_descr_, p_coding);
    break;
  case ALT_emergencyContainer:
    ec_1.set_msg("emergencyContainer': ");
    new_tlv = field_emergencyContainer->BER_encode_TLV(SpecialVehicleContainer_emergencyContainer_descr_, p_coding);
    break;
  case ALT_safetyCarContainer:
    ec_1.set_msg("safetyCarContainer': ");
    new_tlv = field_safetyCarContainer->BER_encode_TLV(SpecialVehicleContainer_safetyCarContainer_descr_, p_coding);
    break;
  case UNBOUND_VALUE:
    new_tlv = BER_encode_chk_bound(FALSE);
    break;
  default:
    TTCN_EncDec_ErrorContext::error_internal("Unknown selection.");
    new_tlv = NULL;
  }
  return ASN_BER_V2TLV(new_tlv, p_td, p_coding);
}

boolean SpecialVehicleContainer::BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv)
{
  clean_up();
  field_publicTransportContainer = new PublicTransportContainer;
  union_selection = ALT_publicTransportContainer;
  if (field_publicTransportContainer->BER_decode_isMyMsg(SpecialVehicleContainer_publicTransportContainer_descr_, p_tlv)) return TRUE;
  delete field_publicTransportContainer;
  field_specialTransportContainer = new SpecialTransportContainer;
  union_selection = ALT_specialTransportContainer;
  if (field_specialTransportContainer->BER_decode_isMyMsg(SpecialVehicleContainer_specialTransportContainer_descr_, p_tlv)) return TRUE;
  delete field_specialTransportContainer;
  field_dangerousGoodsContainer = new DangerousGoodsContainer;
  union_selection = ALT_dangerousGoodsContainer;
  if (field_dangerousGoodsContainer->BER_decode_isMyMsg(SpecialVehicleContainer_dangerousGoodsContainer_descr_, p_tlv)) return TRUE;
  delete field_dangerousGoodsContainer;
  field_roadWorksContainerBasic = new RoadWorksContainerBasic;
  union_selection = ALT_roadWorksContainerBasic;
  if (field_roadWorksContainerBasic->BER_decode_isMyMsg(SpecialVehicleContainer_roadWorksContainerBasic_descr_, p_tlv)) return TRUE;
  delete field_roadWorksContainerBasic;
  field_rescueContainer = new RescueContainer;
  union_selection = ALT_rescueContainer;
  if (field_rescueContainer->BER_decode_isMyMsg(SpecialVehicleContainer_rescueContainer_descr_, p_tlv)) return TRUE;
  delete field_rescueContainer;
  field_emergencyContainer = new EmergencyContainer;
  union_selection = ALT_emergencyContainer;
  if (field_emergencyContainer->BER_decode_isMyMsg(SpecialVehicleContainer_emergencyContainer_descr_, p_tlv)) return TRUE;
  delete field_emergencyContainer;
  field_safetyCarContainer = new SafetyCarContainer;
  union_selection = ALT_safetyCarContainer;
  if (field_safetyCarContainer->BER_decode_isMyMsg(SpecialVehicleContainer_safetyCarContainer_descr_, p_tlv)) return TRUE;
  delete field_safetyCarContainer;
  union_selection = UNBOUND_VALUE;
  return FALSE;
}

boolean SpecialVehicleContainer::BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv)
{
  if (p_td.ber->n_tags == 0) {
    SpecialVehicleContainer tmp_type;
    return tmp_type.BER_decode_set_selection(p_tlv);
  } else return Base_Type::BER_decode_isMyMsg(p_td, p_tlv);
}

boolean SpecialVehicleContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.SpecialVehicleContainer' type: ");
  ASN_BER_TLV_t tmp_tlv;
  if (!BER_decode_TLV_CHOICE(*p_td.ber, stripped_tlv, L_form, tmp_tlv) || !BER_decode_CHOICE_selection(BER_decode_set_selection(tmp_tlv), tmp_tlv)) return FALSE;
  TTCN_EncDec_ErrorContext ec_1("Alternative '");
  TTCN_EncDec_ErrorContext ec_2;
  switch (union_selection) {
  case ALT_publicTransportContainer:
    ec_2.set_msg("publicTransportContainer': ");
    field_publicTransportContainer->BER_decode_TLV(SpecialVehicleContainer_publicTransportContainer_descr_, tmp_tlv, L_form);
    break;
  case ALT_specialTransportContainer:
    ec_2.set_msg("specialTransportContainer': ");
    field_specialTransportContainer->BER_decode_TLV(SpecialVehicleContainer_specialTransportContainer_descr_, tmp_tlv, L_form);
    break;
  case ALT_dangerousGoodsContainer:
    ec_2.set_msg("dangerousGoodsContainer': ");
    field_dangerousGoodsContainer->BER_decode_TLV(SpecialVehicleContainer_dangerousGoodsContainer_descr_, tmp_tlv, L_form);
    break;
  case ALT_roadWorksContainerBasic:
    ec_2.set_msg("roadWorksContainerBasic': ");
    field_roadWorksContainerBasic->BER_decode_TLV(SpecialVehicleContainer_roadWorksContainerBasic_descr_, tmp_tlv, L_form);
    break;
  case ALT_rescueContainer:
    ec_2.set_msg("rescueContainer': ");
    field_rescueContainer->BER_decode_TLV(SpecialVehicleContainer_rescueContainer_descr_, tmp_tlv, L_form);
    break;
  case ALT_emergencyContainer:
    ec_2.set_msg("emergencyContainer': ");
    field_emergencyContainer->BER_decode_TLV(SpecialVehicleContainer_emergencyContainer_descr_, tmp_tlv, L_form);
    break;
  case ALT_safetyCarContainer:
    ec_2.set_msg("safetyCarContainer': ");
    field_safetyCarContainer->BER_decode_TLV(SpecialVehicleContainer_safetyCarContainer_descr_, tmp_tlv, L_form);
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

int SpecialVehicleContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_publicTransportContainer:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "publicTransportContainer");
    enc_len += field_publicTransportContainer->JSON_encode(SpecialVehicleContainer_publicTransportContainer_descr_, p_tok);
    break;
  case ALT_specialTransportContainer:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "specialTransportContainer");
    enc_len += field_specialTransportContainer->JSON_encode(SpecialVehicleContainer_specialTransportContainer_descr_, p_tok);
    break;
  case ALT_dangerousGoodsContainer:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dangerousGoodsContainer");
    enc_len += field_dangerousGoodsContainer->JSON_encode(SpecialVehicleContainer_dangerousGoodsContainer_descr_, p_tok);
    break;
  case ALT_roadWorksContainerBasic:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "roadWorksContainerBasic");
    enc_len += field_roadWorksContainerBasic->JSON_encode(SpecialVehicleContainer_roadWorksContainerBasic_descr_, p_tok);
    break;
  case ALT_rescueContainer:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rescueContainer");
    enc_len += field_rescueContainer->JSON_encode(SpecialVehicleContainer_rescueContainer_descr_, p_tok);
    break;
  case ALT_emergencyContainer:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "emergencyContainer");
    enc_len += field_emergencyContainer->JSON_encode(SpecialVehicleContainer_emergencyContainer_descr_, p_tok);
    break;
  case ALT_safetyCarContainer:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "safetyCarContainer");
    enc_len += field_safetyCarContainer->JSON_encode(SpecialVehicleContainer_safetyCarContainer_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SpecialVehicleContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "publicTransportContainer", name_len)) {
      int ret_val = publicTransportContainer().JSON_decode(SpecialVehicleContainer_publicTransportContainer_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "publicTransportContainer");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "specialTransportContainer", name_len)) {
      int ret_val = specialTransportContainer().JSON_decode(SpecialVehicleContainer_specialTransportContainer_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "specialTransportContainer");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "dangerousGoodsContainer", name_len)) {
      int ret_val = dangerousGoodsContainer().JSON_decode(SpecialVehicleContainer_dangerousGoodsContainer_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dangerousGoodsContainer");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "roadWorksContainerBasic", name_len)) {
      int ret_val = roadWorksContainerBasic().JSON_decode(SpecialVehicleContainer_roadWorksContainerBasic_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "roadWorksContainerBasic");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "rescueContainer", name_len)) {
      int ret_val = rescueContainer().JSON_decode(SpecialVehicleContainer_rescueContainer_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rescueContainer");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "emergencyContainer", name_len)) {
      int ret_val = emergencyContainer().JSON_decode(SpecialVehicleContainer_emergencyContainer_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "emergencyContainer");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "safetyCarContainer", name_len)) {
      int ret_val = safetyCarContainer().JSON_decode(SpecialVehicleContainer_safetyCarContainer_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "safetyCarContainer");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void SpecialVehicleContainer_template::copy_value(const SpecialVehicleContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
single_value.field_publicTransportContainer = new PublicTransportContainer_template(other_value.publicTransportContainer());
break;
case SpecialVehicleContainer::ALT_specialTransportContainer:
single_value.field_specialTransportContainer = new SpecialTransportContainer_template(other_value.specialTransportContainer());
break;
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
single_value.field_dangerousGoodsContainer = new DangerousGoodsContainer_template(other_value.dangerousGoodsContainer());
break;
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
single_value.field_roadWorksContainerBasic = new RoadWorksContainerBasic_template(other_value.roadWorksContainerBasic());
break;
case SpecialVehicleContainer::ALT_rescueContainer:
single_value.field_rescueContainer = new RescueContainer_template(other_value.rescueContainer());
break;
case SpecialVehicleContainer::ALT_emergencyContainer:
single_value.field_emergencyContainer = new EmergencyContainer_template(other_value.emergencyContainer());
break;
case SpecialVehicleContainer::ALT_safetyCarContainer:
single_value.field_safetyCarContainer = new SafetyCarContainer_template(other_value.safetyCarContainer());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void SpecialVehicleContainer_template::copy_template(const SpecialVehicleContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
single_value.field_publicTransportContainer = new PublicTransportContainer_template(*other_value.single_value.field_publicTransportContainer);
break;
case SpecialVehicleContainer::ALT_specialTransportContainer:
single_value.field_specialTransportContainer = new SpecialTransportContainer_template(*other_value.single_value.field_specialTransportContainer);
break;
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
single_value.field_dangerousGoodsContainer = new DangerousGoodsContainer_template(*other_value.single_value.field_dangerousGoodsContainer);
break;
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
single_value.field_roadWorksContainerBasic = new RoadWorksContainerBasic_template(*other_value.single_value.field_roadWorksContainerBasic);
break;
case SpecialVehicleContainer::ALT_rescueContainer:
single_value.field_rescueContainer = new RescueContainer_template(*other_value.single_value.field_rescueContainer);
break;
case SpecialVehicleContainer::ALT_emergencyContainer:
single_value.field_emergencyContainer = new EmergencyContainer_template(*other_value.single_value.field_emergencyContainer);
break;
case SpecialVehicleContainer::ALT_safetyCarContainer:
single_value.field_safetyCarContainer = new SafetyCarContainer_template(*other_value.single_value.field_safetyCarContainer);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SpecialVehicleContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
set_selection(other_value);
}

SpecialVehicleContainer_template::SpecialVehicleContainer_template()
{
}

SpecialVehicleContainer_template::SpecialVehicleContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SpecialVehicleContainer_template::SpecialVehicleContainer_template(const SpecialVehicleContainer& other_value)
{
copy_value(other_value);
}

SpecialVehicleContainer_template::SpecialVehicleContainer_template(const OPTIONAL<SpecialVehicleContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpecialVehicleContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer from an unbound optional field.");
}
}

SpecialVehicleContainer_template::SpecialVehicleContainer_template(const SpecialVehicleContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

SpecialVehicleContainer_template::~SpecialVehicleContainer_template()
{
clean_up();
}

void SpecialVehicleContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
delete single_value.field_publicTransportContainer;
break;
case SpecialVehicleContainer::ALT_specialTransportContainer:
delete single_value.field_specialTransportContainer;
break;
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
delete single_value.field_dangerousGoodsContainer;
break;
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
delete single_value.field_roadWorksContainerBasic;
break;
case SpecialVehicleContainer::ALT_rescueContainer:
delete single_value.field_rescueContainer;
break;
case SpecialVehicleContainer::ALT_emergencyContainer:
delete single_value.field_emergencyContainer;
break;
case SpecialVehicleContainer::ALT_safetyCarContainer:
delete single_value.field_safetyCarContainer;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SpecialVehicleContainer_template& SpecialVehicleContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SpecialVehicleContainer_template& SpecialVehicleContainer_template::operator=(const SpecialVehicleContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SpecialVehicleContainer_template& SpecialVehicleContainer_template::operator=(const OPTIONAL<SpecialVehicleContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpecialVehicleContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
return *this;
}

SpecialVehicleContainer_template& SpecialVehicleContainer_template::operator=(const SpecialVehicleContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SpecialVehicleContainer_template::match(const SpecialVehicleContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
SpecialVehicleContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == SpecialVehicleContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
return single_value.field_publicTransportContainer->match(other_value.publicTransportContainer(), legacy);
case SpecialVehicleContainer::ALT_specialTransportContainer:
return single_value.field_specialTransportContainer->match(other_value.specialTransportContainer(), legacy);
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
return single_value.field_dangerousGoodsContainer->match(other_value.dangerousGoodsContainer(), legacy);
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
return single_value.field_roadWorksContainerBasic->match(other_value.roadWorksContainerBasic(), legacy);
case SpecialVehicleContainer::ALT_rescueContainer:
return single_value.field_rescueContainer->match(other_value.rescueContainer(), legacy);
case SpecialVehicleContainer::ALT_emergencyContainer:
return single_value.field_emergencyContainer->match(other_value.emergencyContainer(), legacy);
case SpecialVehicleContainer::ALT_safetyCarContainer:
return single_value.field_safetyCarContainer->match(other_value.safetyCarContainer(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
return FALSE;
}

boolean SpecialVehicleContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
return single_value.field_publicTransportContainer->is_value();
case SpecialVehicleContainer::ALT_specialTransportContainer:
return single_value.field_specialTransportContainer->is_value();
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
return single_value.field_dangerousGoodsContainer->is_value();
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
return single_value.field_roadWorksContainerBasic->is_value();
case SpecialVehicleContainer::ALT_rescueContainer:
return single_value.field_rescueContainer->is_value();
case SpecialVehicleContainer::ALT_emergencyContainer:
return single_value.field_emergencyContainer->is_value();
case SpecialVehicleContainer::ALT_safetyCarContainer:
return single_value.field_safetyCarContainer->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
}

SpecialVehicleContainer SpecialVehicleContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
SpecialVehicleContainer ret_val;
switch (single_value.union_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
ret_val.publicTransportContainer() = single_value.field_publicTransportContainer->valueof();
break;
case SpecialVehicleContainer::ALT_specialTransportContainer:
ret_val.specialTransportContainer() = single_value.field_specialTransportContainer->valueof();
break;
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
ret_val.dangerousGoodsContainer() = single_value.field_dangerousGoodsContainer->valueof();
break;
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
ret_val.roadWorksContainerBasic() = single_value.field_roadWorksContainerBasic->valueof();
break;
case SpecialVehicleContainer::ALT_rescueContainer:
ret_val.rescueContainer() = single_value.field_rescueContainer->valueof();
break;
case SpecialVehicleContainer::ALT_emergencyContainer:
ret_val.emergencyContainer() = single_value.field_emergencyContainer->valueof();
break;
case SpecialVehicleContainer::ALT_safetyCarContainer:
ret_val.safetyCarContainer() = single_value.field_safetyCarContainer->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
return ret_val;
}

SpecialVehicleContainer_template& SpecialVehicleContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return value_list.list_value[list_index];
}
void SpecialVehicleContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SpecialVehicleContainer_template[list_length];
}

PublicTransportContainer_template& SpecialVehicleContainer_template::publicTransportContainer()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SpecialVehicleContainer::ALT_publicTransportContainer) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_publicTransportContainer = new PublicTransportContainer_template(ANY_VALUE);
else single_value.field_publicTransportContainer = new PublicTransportContainer_template;
single_value.union_selection = SpecialVehicleContainer::ALT_publicTransportContainer;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_publicTransportContainer;
}

const PublicTransportContainer_template& SpecialVehicleContainer_template::publicTransportContainer() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field publicTransportContainer in a non-specific template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (single_value.union_selection != SpecialVehicleContainer::ALT_publicTransportContainer) TTCN_error("Accessing non-selected field publicTransportContainer in a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *single_value.field_publicTransportContainer;
}

SpecialTransportContainer_template& SpecialVehicleContainer_template::specialTransportContainer()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SpecialVehicleContainer::ALT_specialTransportContainer) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_specialTransportContainer = new SpecialTransportContainer_template(ANY_VALUE);
else single_value.field_specialTransportContainer = new SpecialTransportContainer_template;
single_value.union_selection = SpecialVehicleContainer::ALT_specialTransportContainer;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_specialTransportContainer;
}

const SpecialTransportContainer_template& SpecialVehicleContainer_template::specialTransportContainer() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field specialTransportContainer in a non-specific template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (single_value.union_selection != SpecialVehicleContainer::ALT_specialTransportContainer) TTCN_error("Accessing non-selected field specialTransportContainer in a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *single_value.field_specialTransportContainer;
}

DangerousGoodsContainer_template& SpecialVehicleContainer_template::dangerousGoodsContainer()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SpecialVehicleContainer::ALT_dangerousGoodsContainer) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_dangerousGoodsContainer = new DangerousGoodsContainer_template(ANY_VALUE);
else single_value.field_dangerousGoodsContainer = new DangerousGoodsContainer_template;
single_value.union_selection = SpecialVehicleContainer::ALT_dangerousGoodsContainer;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_dangerousGoodsContainer;
}

const DangerousGoodsContainer_template& SpecialVehicleContainer_template::dangerousGoodsContainer() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field dangerousGoodsContainer in a non-specific template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (single_value.union_selection != SpecialVehicleContainer::ALT_dangerousGoodsContainer) TTCN_error("Accessing non-selected field dangerousGoodsContainer in a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *single_value.field_dangerousGoodsContainer;
}

RoadWorksContainerBasic_template& SpecialVehicleContainer_template::roadWorksContainerBasic()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SpecialVehicleContainer::ALT_roadWorksContainerBasic) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_roadWorksContainerBasic = new RoadWorksContainerBasic_template(ANY_VALUE);
else single_value.field_roadWorksContainerBasic = new RoadWorksContainerBasic_template;
single_value.union_selection = SpecialVehicleContainer::ALT_roadWorksContainerBasic;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_roadWorksContainerBasic;
}

const RoadWorksContainerBasic_template& SpecialVehicleContainer_template::roadWorksContainerBasic() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field roadWorksContainerBasic in a non-specific template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (single_value.union_selection != SpecialVehicleContainer::ALT_roadWorksContainerBasic) TTCN_error("Accessing non-selected field roadWorksContainerBasic in a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *single_value.field_roadWorksContainerBasic;
}

RescueContainer_template& SpecialVehicleContainer_template::rescueContainer()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SpecialVehicleContainer::ALT_rescueContainer) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_rescueContainer = new RescueContainer_template(ANY_VALUE);
else single_value.field_rescueContainer = new RescueContainer_template;
single_value.union_selection = SpecialVehicleContainer::ALT_rescueContainer;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_rescueContainer;
}

const RescueContainer_template& SpecialVehicleContainer_template::rescueContainer() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field rescueContainer in a non-specific template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (single_value.union_selection != SpecialVehicleContainer::ALT_rescueContainer) TTCN_error("Accessing non-selected field rescueContainer in a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *single_value.field_rescueContainer;
}

EmergencyContainer_template& SpecialVehicleContainer_template::emergencyContainer()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SpecialVehicleContainer::ALT_emergencyContainer) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_emergencyContainer = new EmergencyContainer_template(ANY_VALUE);
else single_value.field_emergencyContainer = new EmergencyContainer_template;
single_value.union_selection = SpecialVehicleContainer::ALT_emergencyContainer;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_emergencyContainer;
}

const EmergencyContainer_template& SpecialVehicleContainer_template::emergencyContainer() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field emergencyContainer in a non-specific template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (single_value.union_selection != SpecialVehicleContainer::ALT_emergencyContainer) TTCN_error("Accessing non-selected field emergencyContainer in a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *single_value.field_emergencyContainer;
}

SafetyCarContainer_template& SpecialVehicleContainer_template::safetyCarContainer()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SpecialVehicleContainer::ALT_safetyCarContainer) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_safetyCarContainer = new SafetyCarContainer_template(ANY_VALUE);
else single_value.field_safetyCarContainer = new SafetyCarContainer_template;
single_value.union_selection = SpecialVehicleContainer::ALT_safetyCarContainer;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_safetyCarContainer;
}

const SafetyCarContainer_template& SpecialVehicleContainer_template::safetyCarContainer() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field safetyCarContainer in a non-specific template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
if (single_value.union_selection != SpecialVehicleContainer::ALT_safetyCarContainer) TTCN_error("Accessing non-selected field safetyCarContainer in a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return *single_value.field_safetyCarContainer;
}

boolean SpecialVehicleContainer_template::ischosen(SpecialVehicleContainer::union_selection_type checked_selection) const
{
if (checked_selection == SpecialVehicleContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == SpecialVehicleContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer");
}
return FALSE;
}

void SpecialVehicleContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
TTCN_Logger::log_event_str("{ publicTransportContainer := ");
single_value.field_publicTransportContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case SpecialVehicleContainer::ALT_specialTransportContainer:
TTCN_Logger::log_event_str("{ specialTransportContainer := ");
single_value.field_specialTransportContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
TTCN_Logger::log_event_str("{ dangerousGoodsContainer := ");
single_value.field_dangerousGoodsContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
TTCN_Logger::log_event_str("{ roadWorksContainerBasic := ");
single_value.field_roadWorksContainerBasic->log();
TTCN_Logger::log_event_str(" }");
break;
case SpecialVehicleContainer::ALT_rescueContainer:
TTCN_Logger::log_event_str("{ rescueContainer := ");
single_value.field_rescueContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case SpecialVehicleContainer::ALT_emergencyContainer:
TTCN_Logger::log_event_str("{ emergencyContainer := ");
single_value.field_emergencyContainer->log();
TTCN_Logger::log_event_str(" }");
break;
case SpecialVehicleContainer::ALT_safetyCarContainer:
TTCN_Logger::log_event_str("{ safetyCarContainer := ");
single_value.field_safetyCarContainer->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SpecialVehicleContainer_template::log_match(const SpecialVehicleContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".publicTransportContainer");
single_value.field_publicTransportContainer->log_match(match_value.publicTransportContainer(), legacy);
} else {
TTCN_Logger::log_event_str("{ publicTransportContainer := ");
single_value.field_publicTransportContainer->log_match(match_value.publicTransportContainer(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SpecialVehicleContainer::ALT_specialTransportContainer:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".specialTransportContainer");
single_value.field_specialTransportContainer->log_match(match_value.specialTransportContainer(), legacy);
} else {
TTCN_Logger::log_event_str("{ specialTransportContainer := ");
single_value.field_specialTransportContainer->log_match(match_value.specialTransportContainer(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".dangerousGoodsContainer");
single_value.field_dangerousGoodsContainer->log_match(match_value.dangerousGoodsContainer(), legacy);
} else {
TTCN_Logger::log_event_str("{ dangerousGoodsContainer := ");
single_value.field_dangerousGoodsContainer->log_match(match_value.dangerousGoodsContainer(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".roadWorksContainerBasic");
single_value.field_roadWorksContainerBasic->log_match(match_value.roadWorksContainerBasic(), legacy);
} else {
TTCN_Logger::log_event_str("{ roadWorksContainerBasic := ");
single_value.field_roadWorksContainerBasic->log_match(match_value.roadWorksContainerBasic(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SpecialVehicleContainer::ALT_rescueContainer:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".rescueContainer");
single_value.field_rescueContainer->log_match(match_value.rescueContainer(), legacy);
} else {
TTCN_Logger::log_event_str("{ rescueContainer := ");
single_value.field_rescueContainer->log_match(match_value.rescueContainer(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SpecialVehicleContainer::ALT_emergencyContainer:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".emergencyContainer");
single_value.field_emergencyContainer->log_match(match_value.emergencyContainer(), legacy);
} else {
TTCN_Logger::log_event_str("{ emergencyContainer := ");
single_value.field_emergencyContainer->log_match(match_value.emergencyContainer(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SpecialVehicleContainer::ALT_safetyCarContainer:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".safetyCarContainer");
single_value.field_safetyCarContainer->log_match(match_value.safetyCarContainer(), legacy);
} else {
TTCN_Logger::log_event_str("{ safetyCarContainer := ");
single_value.field_safetyCarContainer->log_match(match_value.safetyCarContainer(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SpecialVehicleContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
single_value.field_publicTransportContainer->encode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_specialTransportContainer:
single_value.field_specialTransportContainer->encode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
single_value.field_dangerousGoodsContainer->encode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
single_value.field_roadWorksContainerBasic->encode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_rescueContainer:
single_value.field_rescueContainer->encode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_emergencyContainer:
single_value.field_emergencyContainer->encode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_safetyCarContainer:
single_value.field_safetyCarContainer->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
}

void SpecialVehicleContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = SpecialVehicleContainer::UNBOUND_VALUE;
SpecialVehicleContainer::union_selection_type new_selection = (SpecialVehicleContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
single_value.field_publicTransportContainer = new PublicTransportContainer_template;
single_value.field_publicTransportContainer->decode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_specialTransportContainer:
single_value.field_specialTransportContainer = new SpecialTransportContainer_template;
single_value.field_specialTransportContainer->decode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
single_value.field_dangerousGoodsContainer = new DangerousGoodsContainer_template;
single_value.field_dangerousGoodsContainer->decode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
single_value.field_roadWorksContainerBasic = new RoadWorksContainerBasic_template;
single_value.field_roadWorksContainerBasic->decode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_rescueContainer:
single_value.field_rescueContainer = new RescueContainer_template;
single_value.field_rescueContainer->decode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_emergencyContainer:
single_value.field_emergencyContainer = new EmergencyContainer_template;
single_value.field_emergencyContainer->decode_text(text_buf);
break;
case SpecialVehicleContainer::ALT_safetyCarContainer:
single_value.field_safetyCarContainer = new SafetyCarContainer_template;
single_value.field_safetyCarContainer->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SpecialVehicleContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
}

boolean SpecialVehicleContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SpecialVehicleContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SpecialVehicleContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@CAM-PDU-Descriptions.SpecialVehicleContainer'");
    }
    if (strcmp("publicTransportContainer", param_field) == 0) {
      publicTransportContainer().set_param(param);
      return;
    } else if (strcmp("specialTransportContainer", param_field) == 0) {
      specialTransportContainer().set_param(param);
      return;
    } else if (strcmp("dangerousGoodsContainer", param_field) == 0) {
      dangerousGoodsContainer().set_param(param);
      return;
    } else if (strcmp("roadWorksContainerBasic", param_field) == 0) {
      roadWorksContainerBasic().set_param(param);
      return;
    } else if (strcmp("rescueContainer", param_field) == 0) {
      rescueContainer().set_param(param);
      return;
    } else if (strcmp("emergencyContainer", param_field) == 0) {
      emergencyContainer().set_param(param);
      return;
    } else if (strcmp("safetyCarContainer", param_field) == 0) {
      safetyCarContainer().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@CAM-PDU-Descriptions.SpecialVehicleContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SpecialVehicleContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@CAM-PDU-Descriptions.SpecialVehicleContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "publicTransportContainer")) {
      publicTransportContainer().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "specialTransportContainer")) {
      specialTransportContainer().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "dangerousGoodsContainer")) {
      dangerousGoodsContainer().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "roadWorksContainerBasic")) {
      roadWorksContainerBasic().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "rescueContainer")) {
      rescueContainer().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "emergencyContainer")) {
      emergencyContainer().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "safetyCarContainer")) {
      safetyCarContainer().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @CAM-PDU-Descriptions.SpecialVehicleContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@CAM-PDU-Descriptions.SpecialVehicleContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SpecialVehicleContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@CAM-PDU-Descriptions.SpecialVehicleContainer'");
    }
    if (strcmp("publicTransportContainer", param_field) == 0) {
      return publicTransportContainer().get_param(param_name);
    } else if (strcmp("specialTransportContainer", param_field) == 0) {
      return specialTransportContainer().get_param(param_name);
    } else if (strcmp("dangerousGoodsContainer", param_field) == 0) {
      return dangerousGoodsContainer().get_param(param_name);
    } else if (strcmp("roadWorksContainerBasic", param_field) == 0) {
      return roadWorksContainerBasic().get_param(param_name);
    } else if (strcmp("rescueContainer", param_field) == 0) {
      return rescueContainer().get_param(param_name);
    } else if (strcmp("emergencyContainer", param_field) == 0) {
      return emergencyContainer().get_param(param_name);
    } else if (strcmp("safetyCarContainer", param_field) == 0) {
      return safetyCarContainer().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `SpecialVehicleContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case SpecialVehicleContainer::ALT_publicTransportContainer:
      mp_field = single_value.field_publicTransportContainer->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("publicTransportContainer")));
      break;
    case SpecialVehicleContainer::ALT_specialTransportContainer:
      mp_field = single_value.field_specialTransportContainer->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("specialTransportContainer")));
      break;
    case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
      mp_field = single_value.field_dangerousGoodsContainer->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("dangerousGoodsContainer")));
      break;
    case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
      mp_field = single_value.field_roadWorksContainerBasic->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("roadWorksContainerBasic")));
      break;
    case SpecialVehicleContainer::ALT_rescueContainer:
      mp_field = single_value.field_rescueContainer->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("rescueContainer")));
      break;
    case SpecialVehicleContainer::ALT_emergencyContainer:
      mp_field = single_value.field_emergencyContainer->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("emergencyContainer")));
      break;
    case SpecialVehicleContainer::ALT_safetyCarContainer:
      mp_field = single_value.field_safetyCarContainer->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("safetyCarContainer")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SpecialVehicleContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case SpecialVehicleContainer::ALT_publicTransportContainer:
single_value.field_publicTransportContainer->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SpecialVehicleContainer");
return;
case SpecialVehicleContainer::ALT_specialTransportContainer:
single_value.field_specialTransportContainer->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SpecialVehicleContainer");
return;
case SpecialVehicleContainer::ALT_dangerousGoodsContainer:
single_value.field_dangerousGoodsContainer->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SpecialVehicleContainer");
return;
case SpecialVehicleContainer::ALT_roadWorksContainerBasic:
single_value.field_roadWorksContainerBasic->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SpecialVehicleContainer");
return;
case SpecialVehicleContainer::ALT_rescueContainer:
single_value.field_rescueContainer->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SpecialVehicleContainer");
return;
case SpecialVehicleContainer::ALT_emergencyContainer:
single_value.field_emergencyContainer->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SpecialVehicleContainer");
return;
case SpecialVehicleContainer::ALT_safetyCarContainer:
single_value.field_safetyCarContainer->check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SpecialVehicleContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @CAM-PDU-Descriptions.SpecialVehicleContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.SpecialVehicleContainer");
}

PublicTransportContainer::PublicTransportContainer()
{
  bound_flag = FALSE;
}

PublicTransportContainer::PublicTransportContainer(const BOOLEAN& par_embarkationStatus,
    const OPTIONAL<ITS__Container::PtActivation>& par_ptActivation)
  :   field_embarkationStatus(par_embarkationStatus),
  field_ptActivation(par_ptActivation)
{
  bound_flag = TRUE;
}

PublicTransportContainer::PublicTransportContainer(const PublicTransportContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.PublicTransportContainer.");
bound_flag = TRUE;
if (other_value.embarkationStatus().is_bound()) field_embarkationStatus = other_value.embarkationStatus();
else field_embarkationStatus.clean_up();
if (other_value.ptActivation().is_bound()) field_ptActivation = other_value.ptActivation();
else field_ptActivation.clean_up();
}

void PublicTransportContainer::clean_up()
{
field_embarkationStatus.clean_up();
field_ptActivation.clean_up();
bound_flag = FALSE;
}

PublicTransportContainer& PublicTransportContainer::operator=(const PublicTransportContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.PublicTransportContainer.");
  bound_flag = TRUE;
  if (other_value.embarkationStatus().is_bound()) field_embarkationStatus = other_value.embarkationStatus();
  else field_embarkationStatus.clean_up();
  if (other_value.ptActivation().is_bound()) field_ptActivation = other_value.ptActivation();
  else field_ptActivation.clean_up();
}
return *this;
}

boolean PublicTransportContainer::operator==(const PublicTransportContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_embarkationStatus==other_value.field_embarkationStatus
  && field_ptActivation==other_value.field_ptActivation;
}

boolean PublicTransportContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_embarkationStatus.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ptActivation.get_selection() || field_ptActivation.is_bound()) return TRUE;
return FALSE;
}
boolean PublicTransportContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_embarkationStatus.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ptActivation.get_selection() && !field_ptActivation.is_value()) return FALSE;
return TRUE;
}
int PublicTransportContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.PublicTransportContainer");
  int ret_val = 1;
  if (field_ptActivation.ispresent()) ret_val++;
  return ret_val;
}

void PublicTransportContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ embarkationStatus := ");
field_embarkationStatus.log();
TTCN_Logger::log_event_str(", ptActivation := ");
field_ptActivation.log();
TTCN_Logger::log_event_str(" }");
}

void PublicTransportContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.PublicTransportContainer'");
    }
    if (strcmp("embarkationStatus", param_field) == 0) {
      embarkationStatus().set_param(param);
      return;
    } else if (strcmp("ptActivation", param_field) == 0) {
      ptActivation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.PublicTransportContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.PublicTransportContainer has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) embarkationStatus().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ptActivation().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "embarkationStatus")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          embarkationStatus().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.PublicTransportContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.PublicTransportContainer");
  }
}

Module_Param* PublicTransportContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.PublicTransportContainer'");
    }
    if (strcmp("embarkationStatus", param_field) == 0) {
      return embarkationStatus().get_param(param_name);
    } else if (strcmp("ptActivation", param_field) == 0) {
      return ptActivation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.PublicTransportContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_embarkationStatus = field_embarkationStatus.get_param(param_name);
  mp_field_embarkationStatus->set_id(new Module_Param_FieldName(mcopystr("embarkationStatus")));
  mp->add_elem(mp_field_embarkationStatus);
  Module_Param* mp_field_ptActivation = field_ptActivation.get_param(param_name);
  mp_field_ptActivation->set_id(new Module_Param_FieldName(mcopystr("ptActivation")));
  mp->add_elem(mp_field_ptActivation);
  return mp;
  }

void PublicTransportContainer::set_implicit_omit()
{
if (embarkationStatus().is_bound()) embarkationStatus().set_implicit_omit();
if (!ptActivation().is_bound()) ptActivation() = OMIT_VALUE;
else ptActivation().set_implicit_omit();
}

void PublicTransportContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.PublicTransportContainer.");
field_embarkationStatus.encode_text(text_buf);
field_ptActivation.encode_text(text_buf);
}

void PublicTransportContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_embarkationStatus.decode_text(text_buf);
field_ptActivation.decode_text(text_buf);
}

void PublicTransportContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PublicTransportContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* PublicTransportContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("embarkationStatus': ");
  new_tlv->add_TLV(field_embarkationStatus.BER_encode_TLV(PublicTransportContainer_embarkationStatus_descr_, p_coding));
  ec_1.set_msg("ptActivation': ");
  new_tlv->add_TLV(field_ptActivation.BER_encode_TLV(PublicTransportContainer_ptActivation_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean PublicTransportContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.PublicTransportContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("embarkationStatus': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_embarkationStatus.BER_decode_TLV(PublicTransportContainer_embarkationStatus_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("ptActivation': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_ptActivation=OMIT_VALUE;
    else {
      field_ptActivation.BER_decode_TLV(PublicTransportContainer_ptActivation_descr_, tmp_tlv, L_form);
      if(field_ptActivation.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int PublicTransportContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.PublicTransportContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "embarkationStatus");
    enc_len += field_embarkationStatus.JSON_encode(PublicTransportContainer_embarkationStatus_descr_, p_tok);
  }

  if (field_ptActivation.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ptActivation");
    enc_len += field_ptActivation.JSON_encode(PublicTransportContainer_ptActivation_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int PublicTransportContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (17 == name_len && 0 == strncmp(fld_name, "embarkationStatus", name_len)) {
         int ret_val = field_embarkationStatus.JSON_decode(PublicTransportContainer_embarkationStatus_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "embarkationStatus");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "ptActivation", name_len)) {
         int ret_val = field_ptActivation.JSON_decode(PublicTransportContainer_ptActivation_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ptActivation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_embarkationStatus.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "embarkationStatus");
    return JSON_ERROR_FATAL;
  }
if (!field_ptActivation.is_bound()) {
    field_ptActivation = OMIT_VALUE;
  }

  return dec_len;
}

struct PublicTransportContainer_template::single_value_struct {
BOOLEAN_template field_embarkationStatus;
ITS__Container::PtActivation_template field_ptActivation;
};

void PublicTransportContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_embarkationStatus = ANY_VALUE;
single_value->field_ptActivation = ANY_OR_OMIT;
}
}
}

void PublicTransportContainer_template::copy_value(const PublicTransportContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.embarkationStatus().is_bound()) {
  single_value->field_embarkationStatus = other_value.embarkationStatus();
} else {
  single_value->field_embarkationStatus.clean_up();
}
if (other_value.ptActivation().is_bound()) {
  if (other_value.ptActivation().ispresent()) single_value->field_ptActivation = other_value.ptActivation()();
  else single_value->field_ptActivation = OMIT_VALUE;
} else {
  single_value->field_ptActivation.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PublicTransportContainer_template::copy_template(const PublicTransportContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.embarkationStatus().get_selection()) {
single_value->field_embarkationStatus = other_value.embarkationStatus();
} else {
single_value->field_embarkationStatus.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ptActivation().get_selection()) {
single_value->field_ptActivation = other_value.ptActivation();
} else {
single_value->field_ptActivation.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PublicTransportContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
break;
}
set_selection(other_value);
}

PublicTransportContainer_template::PublicTransportContainer_template()
{
}

PublicTransportContainer_template::PublicTransportContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PublicTransportContainer_template::PublicTransportContainer_template(const PublicTransportContainer& other_value)
{
copy_value(other_value);
}

PublicTransportContainer_template::PublicTransportContainer_template(const OPTIONAL<PublicTransportContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PublicTransportContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.PublicTransportContainer from an unbound optional field.");
}
}

PublicTransportContainer_template::PublicTransportContainer_template(const PublicTransportContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PublicTransportContainer_template::~PublicTransportContainer_template()
{
clean_up();
}

PublicTransportContainer_template& PublicTransportContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PublicTransportContainer_template& PublicTransportContainer_template::operator=(const PublicTransportContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PublicTransportContainer_template& PublicTransportContainer_template::operator=(const OPTIONAL<PublicTransportContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PublicTransportContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
}
return *this;
}

PublicTransportContainer_template& PublicTransportContainer_template::operator=(const PublicTransportContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PublicTransportContainer_template::match(const PublicTransportContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.embarkationStatus().is_bound()) return FALSE;
if(!single_value->field_embarkationStatus.match(other_value.embarkationStatus(), legacy))return FALSE;
if(!other_value.ptActivation().is_bound()) return FALSE;
if((other_value.ptActivation().ispresent() ? !single_value->field_ptActivation.match((const ITS__Container::PtActivation&)other_value.ptActivation(), legacy) : !single_value->field_ptActivation.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
}
return FALSE;
}

boolean PublicTransportContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_embarkationStatus.is_bound()) return TRUE;
if (single_value->field_ptActivation.is_omit() || single_value->field_ptActivation.is_bound()) return TRUE;
return FALSE;
}

boolean PublicTransportContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_embarkationStatus.is_value()) return FALSE;
if (!single_value->field_ptActivation.is_omit() && !single_value->field_ptActivation.is_value()) return FALSE;
return TRUE;
}

void PublicTransportContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PublicTransportContainer PublicTransportContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
PublicTransportContainer ret_val;
if (single_value->field_embarkationStatus.is_bound()) {
ret_val.embarkationStatus() = single_value->field_embarkationStatus.valueof();
}
if (single_value->field_ptActivation.is_omit()) ret_val.ptActivation() = OMIT_VALUE;
else if (single_value->field_ptActivation.is_bound()) {
ret_val.ptActivation() = single_value->field_ptActivation.valueof();
}
return ret_val;
}

void PublicTransportContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PublicTransportContainer_template[list_length];
}

PublicTransportContainer_template& PublicTransportContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
return value_list.list_value[list_index];
}

BOOLEAN_template& PublicTransportContainer_template::embarkationStatus()
{
set_specific();
return single_value->field_embarkationStatus;
}

const BOOLEAN_template& PublicTransportContainer_template::embarkationStatus() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field embarkationStatus of a non-specific template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
return single_value->field_embarkationStatus;
}

ITS__Container::PtActivation_template& PublicTransportContainer_template::ptActivation()
{
set_specific();
return single_value->field_ptActivation;
}

const ITS__Container::PtActivation_template& PublicTransportContainer_template::ptActivation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ptActivation of a non-specific template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
return single_value->field_ptActivation;
}

int PublicTransportContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.PublicTransportContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_ptActivation.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.PublicTransportContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.PublicTransportContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.PublicTransportContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.PublicTransportContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.PublicTransportContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
  }
  return 0;
}

void PublicTransportContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ embarkationStatus := ");
single_value->field_embarkationStatus.log();
TTCN_Logger::log_event_str(", ptActivation := ");
single_value->field_ptActivation.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PublicTransportContainer_template::log_match(const PublicTransportContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_embarkationStatus.match(match_value.embarkationStatus(), legacy)){
TTCN_Logger::log_logmatch_info(".embarkationStatus");
single_value->field_embarkationStatus.log_match(match_value.embarkationStatus(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.ptActivation().ispresent()){
if(!single_value->field_ptActivation.match(match_value.ptActivation(), legacy)){
TTCN_Logger::log_logmatch_info(".ptActivation");
single_value->field_ptActivation.log_match(match_value.ptActivation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ptActivation.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ptActivation := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ptActivation.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ embarkationStatus := ");
single_value->field_embarkationStatus.log_match(match_value.embarkationStatus(), legacy);
TTCN_Logger::log_event_str(", ptActivation := ");
if (match_value.ptActivation().ispresent()) single_value->field_ptActivation.log_match(match_value.ptActivation(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ptActivation.log();
if (single_value->field_ptActivation.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PublicTransportContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_embarkationStatus.encode_text(text_buf);
single_value->field_ptActivation.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
}
}

void PublicTransportContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_embarkationStatus.decode_text(text_buf);
single_value->field_ptActivation.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PublicTransportContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.PublicTransportContainer.");
}
}

void PublicTransportContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.PublicTransportContainer'");
    }
    if (strcmp("embarkationStatus", param_field) == 0) {
      embarkationStatus().set_param(param);
      return;
    } else if (strcmp("ptActivation", param_field) == 0) {
      ptActivation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.PublicTransportContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PublicTransportContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.PublicTransportContainer has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) embarkationStatus().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ptActivation().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "embarkationStatus")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          embarkationStatus().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.PublicTransportContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.PublicTransportContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PublicTransportContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.PublicTransportContainer'");
    }
    if (strcmp("embarkationStatus", param_field) == 0) {
      return embarkationStatus().get_param(param_name);
    } else if (strcmp("ptActivation", param_field) == 0) {
      return ptActivation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.PublicTransportContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_embarkationStatus = single_value->field_embarkationStatus.get_param(param_name);
    mp_field_embarkationStatus->set_id(new Module_Param_FieldName(mcopystr("embarkationStatus")));
    mp->add_elem(mp_field_embarkationStatus);
    Module_Param* mp_field_ptActivation = single_value->field_ptActivation.get_param(param_name);
    mp_field_ptActivation->set_id(new Module_Param_FieldName(mcopystr("ptActivation")));
    mp->add_elem(mp_field_ptActivation);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PublicTransportContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_embarkationStatus.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.PublicTransportContainer");
single_value->field_ptActivation.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.PublicTransportContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.PublicTransportContainer");
}

boolean PublicTransportContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PublicTransportContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SpecialTransportContainer::SpecialTransportContainer()
{
  bound_flag = FALSE;
}

SpecialTransportContainer::SpecialTransportContainer(const BITSTRING& par_specialTransportType,
    const BITSTRING& par_lightBarSirenInUse)
  :   field_specialTransportType(par_specialTransportType),
  field_lightBarSirenInUse(par_lightBarSirenInUse)
{
  bound_flag = TRUE;
}

SpecialTransportContainer::SpecialTransportContainer(const SpecialTransportContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
bound_flag = TRUE;
if (other_value.specialTransportType().is_bound()) field_specialTransportType = other_value.specialTransportType();
else field_specialTransportType.clean_up();
if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
else field_lightBarSirenInUse.clean_up();
}

void SpecialTransportContainer::clean_up()
{
field_specialTransportType.clean_up();
field_lightBarSirenInUse.clean_up();
bound_flag = FALSE;
}

SpecialTransportContainer& SpecialTransportContainer::operator=(const SpecialTransportContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
  bound_flag = TRUE;
  if (other_value.specialTransportType().is_bound()) field_specialTransportType = other_value.specialTransportType();
  else field_specialTransportType.clean_up();
  if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
  else field_lightBarSirenInUse.clean_up();
}
return *this;
}

boolean SpecialTransportContainer::operator==(const SpecialTransportContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_specialTransportType==other_value.field_specialTransportType
  && field_lightBarSirenInUse==other_value.field_lightBarSirenInUse;
}

boolean SpecialTransportContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_specialTransportType.is_bound()) return TRUE;
if(field_lightBarSirenInUse.is_bound()) return TRUE;
return FALSE;
}
boolean SpecialTransportContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_specialTransportType.is_value()) return FALSE;
if(!field_lightBarSirenInUse.is_value()) return FALSE;
return TRUE;
}
int SpecialTransportContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.SpecialTransportContainer");
  return 2;
}

void SpecialTransportContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ specialTransportType := ");
field_specialTransportType.log();
TTCN_Logger::log_event_str(", lightBarSirenInUse := ");
field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(" }");
}

void SpecialTransportContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.SpecialTransportContainer'");
    }
    if (strcmp("specialTransportType", param_field) == 0) {
      specialTransportType().set_param(param);
      return;
    } else if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.SpecialTransportContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.SpecialTransportContainer has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) specialTransportType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "specialTransportType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          specialTransportType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.SpecialTransportContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.SpecialTransportContainer");
  }
}

Module_Param* SpecialTransportContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.SpecialTransportContainer'");
    }
    if (strcmp("specialTransportType", param_field) == 0) {
      return specialTransportType().get_param(param_name);
    } else if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.SpecialTransportContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_specialTransportType = field_specialTransportType.get_param(param_name);
  mp_field_specialTransportType->set_id(new Module_Param_FieldName(mcopystr("specialTransportType")));
  mp->add_elem(mp_field_specialTransportType);
  Module_Param* mp_field_lightBarSirenInUse = field_lightBarSirenInUse.get_param(param_name);
  mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
  mp->add_elem(mp_field_lightBarSirenInUse);
  return mp;
  }

void SpecialTransportContainer::set_implicit_omit()
{
if (specialTransportType().is_bound()) specialTransportType().set_implicit_omit();
if (lightBarSirenInUse().is_bound()) lightBarSirenInUse().set_implicit_omit();
}

void SpecialTransportContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
field_specialTransportType.encode_text(text_buf);
field_lightBarSirenInUse.encode_text(text_buf);
}

void SpecialTransportContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_specialTransportType.decode_text(text_buf);
field_lightBarSirenInUse.decode_text(text_buf);
}

void SpecialTransportContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SpecialTransportContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* SpecialTransportContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("specialTransportType': ");
  new_tlv->add_TLV(field_specialTransportType.BER_encode_TLV(SpecialTransportContainer_specialTransportType_descr_, p_coding));
  ec_1.set_msg("lightBarSirenInUse': ");
  new_tlv->add_TLV(field_lightBarSirenInUse.BER_encode_TLV(SpecialTransportContainer_lightBarSirenInUse_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean SpecialTransportContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.SpecialTransportContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("specialTransportType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_specialTransportType.BER_decode_TLV(SpecialTransportContainer_specialTransportType_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("lightBarSirenInUse': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_lightBarSirenInUse.BER_decode_TLV(SpecialTransportContainer_lightBarSirenInUse_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int SpecialTransportContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "specialTransportType");
    enc_len += field_specialTransportType.JSON_encode(SpecialTransportContainer_specialTransportType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lightBarSirenInUse");
    enc_len += field_lightBarSirenInUse.JSON_encode(SpecialTransportContainer_lightBarSirenInUse_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SpecialTransportContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (20 == name_len && 0 == strncmp(fld_name, "specialTransportType", name_len)) {
         int ret_val = field_specialTransportType.JSON_decode(SpecialTransportContainer_specialTransportType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "specialTransportType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "lightBarSirenInUse", name_len)) {
         int ret_val = field_lightBarSirenInUse.JSON_decode(SpecialTransportContainer_lightBarSirenInUse_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lightBarSirenInUse");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_specialTransportType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "specialTransportType");
    return JSON_ERROR_FATAL;
  }
if (!field_lightBarSirenInUse.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lightBarSirenInUse");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SpecialTransportContainer_template::single_value_struct {
BITSTRING_template field_specialTransportType;
BITSTRING_template field_lightBarSirenInUse;
};

void SpecialTransportContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_specialTransportType = ANY_VALUE;
single_value->field_lightBarSirenInUse = ANY_VALUE;
}
}
}

void SpecialTransportContainer_template::copy_value(const SpecialTransportContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.specialTransportType().is_bound()) {
  single_value->field_specialTransportType = other_value.specialTransportType();
} else {
  single_value->field_specialTransportType.clean_up();
}
if (other_value.lightBarSirenInUse().is_bound()) {
  single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
  single_value->field_lightBarSirenInUse.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SpecialTransportContainer_template::copy_template(const SpecialTransportContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.specialTransportType().get_selection()) {
single_value->field_specialTransportType = other_value.specialTransportType();
} else {
single_value->field_specialTransportType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lightBarSirenInUse().get_selection()) {
single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
single_value->field_lightBarSirenInUse.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SpecialTransportContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
break;
}
set_selection(other_value);
}

SpecialTransportContainer_template::SpecialTransportContainer_template()
{
}

SpecialTransportContainer_template::SpecialTransportContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SpecialTransportContainer_template::SpecialTransportContainer_template(const SpecialTransportContainer& other_value)
{
copy_value(other_value);
}

SpecialTransportContainer_template::SpecialTransportContainer_template(const OPTIONAL<SpecialTransportContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpecialTransportContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.SpecialTransportContainer from an unbound optional field.");
}
}

SpecialTransportContainer_template::SpecialTransportContainer_template(const SpecialTransportContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SpecialTransportContainer_template::~SpecialTransportContainer_template()
{
clean_up();
}

SpecialTransportContainer_template& SpecialTransportContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SpecialTransportContainer_template& SpecialTransportContainer_template::operator=(const SpecialTransportContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SpecialTransportContainer_template& SpecialTransportContainer_template::operator=(const OPTIONAL<SpecialTransportContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpecialTransportContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
}
return *this;
}

SpecialTransportContainer_template& SpecialTransportContainer_template::operator=(const SpecialTransportContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SpecialTransportContainer_template::match(const SpecialTransportContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.specialTransportType().is_bound()) return FALSE;
if(!single_value->field_specialTransportType.match(other_value.specialTransportType(), legacy))return FALSE;
if(!other_value.lightBarSirenInUse().is_bound()) return FALSE;
if(!single_value->field_lightBarSirenInUse.match(other_value.lightBarSirenInUse(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
}
return FALSE;
}

boolean SpecialTransportContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_specialTransportType.is_bound()) return TRUE;
if (single_value->field_lightBarSirenInUse.is_bound()) return TRUE;
return FALSE;
}

boolean SpecialTransportContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_specialTransportType.is_value()) return FALSE;
if (!single_value->field_lightBarSirenInUse.is_value()) return FALSE;
return TRUE;
}

void SpecialTransportContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SpecialTransportContainer SpecialTransportContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
SpecialTransportContainer ret_val;
if (single_value->field_specialTransportType.is_bound()) {
ret_val.specialTransportType() = single_value->field_specialTransportType.valueof();
}
if (single_value->field_lightBarSirenInUse.is_bound()) {
ret_val.lightBarSirenInUse() = single_value->field_lightBarSirenInUse.valueof();
}
return ret_val;
}

void SpecialTransportContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SpecialTransportContainer_template[list_length];
}

SpecialTransportContainer_template& SpecialTransportContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
return value_list.list_value[list_index];
}

BITSTRING_template& SpecialTransportContainer_template::specialTransportType()
{
set_specific();
return single_value->field_specialTransportType;
}

const BITSTRING_template& SpecialTransportContainer_template::specialTransportType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field specialTransportType of a non-specific template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
return single_value->field_specialTransportType;
}

BITSTRING_template& SpecialTransportContainer_template::lightBarSirenInUse()
{
set_specific();
return single_value->field_lightBarSirenInUse;
}

const BITSTRING_template& SpecialTransportContainer_template::lightBarSirenInUse() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lightBarSirenInUse of a non-specific template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
return single_value->field_lightBarSirenInUse;
}

int SpecialTransportContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SpecialTransportContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SpecialTransportContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SpecialTransportContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SpecialTransportContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SpecialTransportContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SpecialTransportContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
  }
  return 0;
}

void SpecialTransportContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ specialTransportType := ");
single_value->field_specialTransportType.log();
TTCN_Logger::log_event_str(", lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SpecialTransportContainer_template::log_match(const SpecialTransportContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_specialTransportType.match(match_value.specialTransportType(), legacy)){
TTCN_Logger::log_logmatch_info(".specialTransportType");
single_value->field_specialTransportType.log_match(match_value.specialTransportType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lightBarSirenInUse.match(match_value.lightBarSirenInUse(), legacy)){
TTCN_Logger::log_logmatch_info(".lightBarSirenInUse");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ specialTransportType := ");
single_value->field_specialTransportType.log_match(match_value.specialTransportType(), legacy);
TTCN_Logger::log_event_str(", lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SpecialTransportContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_specialTransportType.encode_text(text_buf);
single_value->field_lightBarSirenInUse.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
}
}

void SpecialTransportContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_specialTransportType.decode_text(text_buf);
single_value->field_lightBarSirenInUse.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SpecialTransportContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.SpecialTransportContainer.");
}
}

void SpecialTransportContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.SpecialTransportContainer'");
    }
    if (strcmp("specialTransportType", param_field) == 0) {
      specialTransportType().set_param(param);
      return;
    } else if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.SpecialTransportContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SpecialTransportContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.SpecialTransportContainer has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) specialTransportType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "specialTransportType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          specialTransportType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.SpecialTransportContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.SpecialTransportContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SpecialTransportContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.SpecialTransportContainer'");
    }
    if (strcmp("specialTransportType", param_field) == 0) {
      return specialTransportType().get_param(param_name);
    } else if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.SpecialTransportContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_specialTransportType = single_value->field_specialTransportType.get_param(param_name);
    mp_field_specialTransportType->set_id(new Module_Param_FieldName(mcopystr("specialTransportType")));
    mp->add_elem(mp_field_specialTransportType);
    Module_Param* mp_field_lightBarSirenInUse = single_value->field_lightBarSirenInUse.get_param(param_name);
    mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
    mp->add_elem(mp_field_lightBarSirenInUse);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SpecialTransportContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_specialTransportType.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SpecialTransportContainer");
single_value->field_lightBarSirenInUse.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SpecialTransportContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.SpecialTransportContainer");
}

boolean SpecialTransportContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SpecialTransportContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

DangerousGoodsContainer::DangerousGoodsContainer()
{
  bound_flag = FALSE;
}

DangerousGoodsContainer::DangerousGoodsContainer(const ITS__Container::DangerousGoodsBasic& par_dangerousGoodsBasic)
  :   field_dangerousGoodsBasic(par_dangerousGoodsBasic)
{
  bound_flag = TRUE;
}

DangerousGoodsContainer::DangerousGoodsContainer(const DangerousGoodsContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
bound_flag = TRUE;
if (other_value.dangerousGoodsBasic().is_bound()) field_dangerousGoodsBasic = other_value.dangerousGoodsBasic();
else field_dangerousGoodsBasic.clean_up();
}

void DangerousGoodsContainer::clean_up()
{
field_dangerousGoodsBasic.clean_up();
bound_flag = FALSE;
}

DangerousGoodsContainer& DangerousGoodsContainer::operator=(const DangerousGoodsContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
  bound_flag = TRUE;
  if (other_value.dangerousGoodsBasic().is_bound()) field_dangerousGoodsBasic = other_value.dangerousGoodsBasic();
  else field_dangerousGoodsBasic.clean_up();
}
return *this;
}

boolean DangerousGoodsContainer::operator==(const DangerousGoodsContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_dangerousGoodsBasic==other_value.field_dangerousGoodsBasic;
}

boolean DangerousGoodsContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_dangerousGoodsBasic.is_bound()) return TRUE;
return FALSE;
}
boolean DangerousGoodsContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_dangerousGoodsBasic.is_value()) return FALSE;
return TRUE;
}
int DangerousGoodsContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.DangerousGoodsContainer");
  return 1;
}

void DangerousGoodsContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ dangerousGoodsBasic := ");
field_dangerousGoodsBasic.log();
TTCN_Logger::log_event_str(" }");
}

void DangerousGoodsContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.DangerousGoodsContainer'");
    }
    if (strcmp("dangerousGoodsBasic", param_field) == 0) {
      dangerousGoodsBasic().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.DangerousGoodsContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.DangerousGoodsContainer has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) dangerousGoodsBasic().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousGoodsBasic")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousGoodsBasic().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.DangerousGoodsContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.DangerousGoodsContainer");
  }
}

Module_Param* DangerousGoodsContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.DangerousGoodsContainer'");
    }
    if (strcmp("dangerousGoodsBasic", param_field) == 0) {
      return dangerousGoodsBasic().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.DangerousGoodsContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_dangerousGoodsBasic = field_dangerousGoodsBasic.get_param(param_name);
  mp_field_dangerousGoodsBasic->set_id(new Module_Param_FieldName(mcopystr("dangerousGoodsBasic")));
  mp->add_elem(mp_field_dangerousGoodsBasic);
  return mp;
  }

void DangerousGoodsContainer::set_implicit_omit()
{
if (dangerousGoodsBasic().is_bound()) dangerousGoodsBasic().set_implicit_omit();
}

void DangerousGoodsContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
field_dangerousGoodsBasic.encode_text(text_buf);
}

void DangerousGoodsContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_dangerousGoodsBasic.decode_text(text_buf);
}

void DangerousGoodsContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DangerousGoodsContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* DangerousGoodsContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("dangerousGoodsBasic': ");
  new_tlv->add_TLV(field_dangerousGoodsBasic.BER_encode_TLV(DangerousGoodsContainer_dangerousGoodsBasic_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean DangerousGoodsContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.DangerousGoodsContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("dangerousGoodsBasic': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_dangerousGoodsBasic.BER_decode_TLV(DangerousGoodsContainer_dangerousGoodsBasic_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int DangerousGoodsContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dangerousGoodsBasic");
    enc_len += field_dangerousGoodsBasic.JSON_encode(DangerousGoodsContainer_dangerousGoodsBasic_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DangerousGoodsContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (19 == name_len && 0 == strncmp(fld_name, "dangerousGoodsBasic", name_len)) {
         int ret_val = field_dangerousGoodsBasic.JSON_decode(DangerousGoodsContainer_dangerousGoodsBasic_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dangerousGoodsBasic");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_dangerousGoodsBasic.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dangerousGoodsBasic");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct DangerousGoodsContainer_template::single_value_struct {
ITS__Container::DangerousGoodsBasic_template field_dangerousGoodsBasic;
};

void DangerousGoodsContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_dangerousGoodsBasic = ANY_VALUE;
}
}
}

void DangerousGoodsContainer_template::copy_value(const DangerousGoodsContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.dangerousGoodsBasic().is_bound()) {
  single_value->field_dangerousGoodsBasic = other_value.dangerousGoodsBasic();
} else {
  single_value->field_dangerousGoodsBasic.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void DangerousGoodsContainer_template::copy_template(const DangerousGoodsContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.dangerousGoodsBasic().get_selection()) {
single_value->field_dangerousGoodsBasic = other_value.dangerousGoodsBasic();
} else {
single_value->field_dangerousGoodsBasic.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DangerousGoodsContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
break;
}
set_selection(other_value);
}

DangerousGoodsContainer_template::DangerousGoodsContainer_template()
{
}

DangerousGoodsContainer_template::DangerousGoodsContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DangerousGoodsContainer_template::DangerousGoodsContainer_template(const DangerousGoodsContainer& other_value)
{
copy_value(other_value);
}

DangerousGoodsContainer_template::DangerousGoodsContainer_template(const OPTIONAL<DangerousGoodsContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DangerousGoodsContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer from an unbound optional field.");
}
}

DangerousGoodsContainer_template::DangerousGoodsContainer_template(const DangerousGoodsContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

DangerousGoodsContainer_template::~DangerousGoodsContainer_template()
{
clean_up();
}

DangerousGoodsContainer_template& DangerousGoodsContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DangerousGoodsContainer_template& DangerousGoodsContainer_template::operator=(const DangerousGoodsContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DangerousGoodsContainer_template& DangerousGoodsContainer_template::operator=(const OPTIONAL<DangerousGoodsContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DangerousGoodsContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
}
return *this;
}

DangerousGoodsContainer_template& DangerousGoodsContainer_template::operator=(const DangerousGoodsContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DangerousGoodsContainer_template::match(const DangerousGoodsContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.dangerousGoodsBasic().is_bound()) return FALSE;
if(!single_value->field_dangerousGoodsBasic.match(other_value.dangerousGoodsBasic(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
}
return FALSE;
}

boolean DangerousGoodsContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_dangerousGoodsBasic.is_bound()) return TRUE;
return FALSE;
}

boolean DangerousGoodsContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_dangerousGoodsBasic.is_value()) return FALSE;
return TRUE;
}

void DangerousGoodsContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DangerousGoodsContainer DangerousGoodsContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
DangerousGoodsContainer ret_val;
if (single_value->field_dangerousGoodsBasic.is_bound()) {
ret_val.dangerousGoodsBasic() = single_value->field_dangerousGoodsBasic.valueof();
}
return ret_val;
}

void DangerousGoodsContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DangerousGoodsContainer_template[list_length];
}

DangerousGoodsContainer_template& DangerousGoodsContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
return value_list.list_value[list_index];
}

ITS__Container::DangerousGoodsBasic_template& DangerousGoodsContainer_template::dangerousGoodsBasic()
{
set_specific();
return single_value->field_dangerousGoodsBasic;
}

const ITS__Container::DangerousGoodsBasic_template& DangerousGoodsContainer_template::dangerousGoodsBasic() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dangerousGoodsBasic of a non-specific template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
return single_value->field_dangerousGoodsBasic;
}

int DangerousGoodsContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
  }
  return 0;
}

void DangerousGoodsContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ dangerousGoodsBasic := ");
single_value->field_dangerousGoodsBasic.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DangerousGoodsContainer_template::log_match(const DangerousGoodsContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_dangerousGoodsBasic.match(match_value.dangerousGoodsBasic(), legacy)){
TTCN_Logger::log_logmatch_info(".dangerousGoodsBasic");
single_value->field_dangerousGoodsBasic.log_match(match_value.dangerousGoodsBasic(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ dangerousGoodsBasic := ");
single_value->field_dangerousGoodsBasic.log_match(match_value.dangerousGoodsBasic(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DangerousGoodsContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_dangerousGoodsBasic.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
}
}

void DangerousGoodsContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_dangerousGoodsBasic.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DangerousGoodsContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.DangerousGoodsContainer.");
}
}

void DangerousGoodsContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.DangerousGoodsContainer'");
    }
    if (strcmp("dangerousGoodsBasic", param_field) == 0) {
      dangerousGoodsBasic().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.DangerousGoodsContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DangerousGoodsContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.DangerousGoodsContainer has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) dangerousGoodsBasic().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousGoodsBasic")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousGoodsBasic().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.DangerousGoodsContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.DangerousGoodsContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DangerousGoodsContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.DangerousGoodsContainer'");
    }
    if (strcmp("dangerousGoodsBasic", param_field) == 0) {
      return dangerousGoodsBasic().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.DangerousGoodsContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_dangerousGoodsBasic = single_value->field_dangerousGoodsBasic.get_param(param_name);
    mp_field_dangerousGoodsBasic->set_id(new Module_Param_FieldName(mcopystr("dangerousGoodsBasic")));
    mp->add_elem(mp_field_dangerousGoodsBasic);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DangerousGoodsContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_dangerousGoodsBasic.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.DangerousGoodsContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.DangerousGoodsContainer");
}

boolean DangerousGoodsContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DangerousGoodsContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

RoadWorksContainerBasic::RoadWorksContainerBasic()
{
  bound_flag = FALSE;
}

RoadWorksContainerBasic::RoadWorksContainerBasic(const OPTIONAL<INTEGER>& par_roadworksSubCauseCode,
    const BITSTRING& par_lightBarSirenInUse,
    const OPTIONAL<ITS__Container::ClosedLanes>& par_closedLanes)
  :   field_roadworksSubCauseCode(par_roadworksSubCauseCode),
  field_lightBarSirenInUse(par_lightBarSirenInUse),
  field_closedLanes(par_closedLanes)
{
  bound_flag = TRUE;
}

RoadWorksContainerBasic::RoadWorksContainerBasic(const RoadWorksContainerBasic& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
bound_flag = TRUE;
if (other_value.roadworksSubCauseCode().is_bound()) field_roadworksSubCauseCode = other_value.roadworksSubCauseCode();
else field_roadworksSubCauseCode.clean_up();
if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
else field_lightBarSirenInUse.clean_up();
if (other_value.closedLanes().is_bound()) field_closedLanes = other_value.closedLanes();
else field_closedLanes.clean_up();
}

void RoadWorksContainerBasic::clean_up()
{
field_roadworksSubCauseCode.clean_up();
field_lightBarSirenInUse.clean_up();
field_closedLanes.clean_up();
bound_flag = FALSE;
}

RoadWorksContainerBasic& RoadWorksContainerBasic::operator=(const RoadWorksContainerBasic& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
  bound_flag = TRUE;
  if (other_value.roadworksSubCauseCode().is_bound()) field_roadworksSubCauseCode = other_value.roadworksSubCauseCode();
  else field_roadworksSubCauseCode.clean_up();
  if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
  else field_lightBarSirenInUse.clean_up();
  if (other_value.closedLanes().is_bound()) field_closedLanes = other_value.closedLanes();
  else field_closedLanes.clean_up();
}
return *this;
}

boolean RoadWorksContainerBasic::operator==(const RoadWorksContainerBasic& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_roadworksSubCauseCode==other_value.field_roadworksSubCauseCode
  && field_lightBarSirenInUse==other_value.field_lightBarSirenInUse
  && field_closedLanes==other_value.field_closedLanes;
}

boolean RoadWorksContainerBasic::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_roadworksSubCauseCode.get_selection() || field_roadworksSubCauseCode.is_bound()) return TRUE;
if(field_lightBarSirenInUse.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_closedLanes.get_selection() || field_closedLanes.is_bound()) return TRUE;
return FALSE;
}
boolean RoadWorksContainerBasic::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_roadworksSubCauseCode.get_selection() && !field_roadworksSubCauseCode.is_value()) return FALSE;
if(!field_lightBarSirenInUse.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_closedLanes.get_selection() && !field_closedLanes.is_value()) return FALSE;
return TRUE;
}
int RoadWorksContainerBasic::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.RoadWorksContainerBasic");
  int ret_val = 1;
  if (field_roadworksSubCauseCode.ispresent()) ret_val++;
  if (field_closedLanes.ispresent()) ret_val++;
  return ret_val;
}

void RoadWorksContainerBasic::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ roadworksSubCauseCode := ");
field_roadworksSubCauseCode.log();
TTCN_Logger::log_event_str(", lightBarSirenInUse := ");
field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(", closedLanes := ");
field_closedLanes.log();
TTCN_Logger::log_event_str(" }");
}

void RoadWorksContainerBasic::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.RoadWorksContainerBasic'");
    }
    if (strcmp("roadworksSubCauseCode", param_field) == 0) {
      roadworksSubCauseCode().set_param(param);
      return;
    } else if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else if (strcmp("closedLanes", param_field) == 0) {
      closedLanes().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.RoadWorksContainerBasic'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.RoadWorksContainerBasic has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) roadworksSubCauseCode().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) closedLanes().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadworksSubCauseCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadworksSubCauseCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "closedLanes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          closedLanes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.RoadWorksContainerBasic: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.RoadWorksContainerBasic");
  }
}

Module_Param* RoadWorksContainerBasic::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.RoadWorksContainerBasic'");
    }
    if (strcmp("roadworksSubCauseCode", param_field) == 0) {
      return roadworksSubCauseCode().get_param(param_name);
    } else if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else if (strcmp("closedLanes", param_field) == 0) {
      return closedLanes().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.RoadWorksContainerBasic'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_roadworksSubCauseCode = field_roadworksSubCauseCode.get_param(param_name);
  mp_field_roadworksSubCauseCode->set_id(new Module_Param_FieldName(mcopystr("roadworksSubCauseCode")));
  mp->add_elem(mp_field_roadworksSubCauseCode);
  Module_Param* mp_field_lightBarSirenInUse = field_lightBarSirenInUse.get_param(param_name);
  mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
  mp->add_elem(mp_field_lightBarSirenInUse);
  Module_Param* mp_field_closedLanes = field_closedLanes.get_param(param_name);
  mp_field_closedLanes->set_id(new Module_Param_FieldName(mcopystr("closedLanes")));
  mp->add_elem(mp_field_closedLanes);
  return mp;
  }

void RoadWorksContainerBasic::set_implicit_omit()
{
if (!roadworksSubCauseCode().is_bound()) roadworksSubCauseCode() = OMIT_VALUE;
else roadworksSubCauseCode().set_implicit_omit();
if (lightBarSirenInUse().is_bound()) lightBarSirenInUse().set_implicit_omit();
if (!closedLanes().is_bound()) closedLanes() = OMIT_VALUE;
else closedLanes().set_implicit_omit();
}

void RoadWorksContainerBasic::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
field_roadworksSubCauseCode.encode_text(text_buf);
field_lightBarSirenInUse.encode_text(text_buf);
field_closedLanes.encode_text(text_buf);
}

void RoadWorksContainerBasic::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_roadworksSubCauseCode.decode_text(text_buf);
field_lightBarSirenInUse.decode_text(text_buf);
field_closedLanes.decode_text(text_buf);
}

void RoadWorksContainerBasic::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RoadWorksContainerBasic::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RoadWorksContainerBasic::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("roadworksSubCauseCode': ");
  new_tlv->add_TLV(field_roadworksSubCauseCode.BER_encode_TLV(RoadWorksContainerBasic_roadworksSubCauseCode_descr_, p_coding));
  ec_1.set_msg("lightBarSirenInUse': ");
  new_tlv->add_TLV(field_lightBarSirenInUse.BER_encode_TLV(RoadWorksContainerBasic_lightBarSirenInUse_descr_, p_coding));
  ec_1.set_msg("closedLanes': ");
  new_tlv->add_TLV(field_closedLanes.BER_encode_TLV(RoadWorksContainerBasic_closedLanes_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RoadWorksContainerBasic::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.RoadWorksContainerBasic' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("roadworksSubCauseCode': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_roadworksSubCauseCode=OMIT_VALUE;
    else {
      field_roadworksSubCauseCode.BER_decode_TLV(RoadWorksContainerBasic_roadworksSubCauseCode_descr_, tmp_tlv, L_form);
      if(field_roadworksSubCauseCode.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("lightBarSirenInUse': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_lightBarSirenInUse.BER_decode_TLV(RoadWorksContainerBasic_lightBarSirenInUse_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("closedLanes': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_closedLanes=OMIT_VALUE;
    else {
      field_closedLanes.BER_decode_TLV(RoadWorksContainerBasic_closedLanes_descr_, tmp_tlv, L_form);
      if(field_closedLanes.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int RoadWorksContainerBasic::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_roadworksSubCauseCode.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "roadworksSubCauseCode");
    enc_len += field_roadworksSubCauseCode.JSON_encode(RoadWorksContainerBasic_roadworksSubCauseCode_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lightBarSirenInUse");
    enc_len += field_lightBarSirenInUse.JSON_encode(RoadWorksContainerBasic_lightBarSirenInUse_descr_, p_tok);
  }

  if (field_closedLanes.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "closedLanes");
    enc_len += field_closedLanes.JSON_encode(RoadWorksContainerBasic_closedLanes_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RoadWorksContainerBasic::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (21 == name_len && 0 == strncmp(fld_name, "roadworksSubCauseCode", name_len)) {
         int ret_val = field_roadworksSubCauseCode.JSON_decode(RoadWorksContainerBasic_roadworksSubCauseCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "roadworksSubCauseCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "lightBarSirenInUse", name_len)) {
         int ret_val = field_lightBarSirenInUse.JSON_decode(RoadWorksContainerBasic_lightBarSirenInUse_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lightBarSirenInUse");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "closedLanes", name_len)) {
         int ret_val = field_closedLanes.JSON_decode(RoadWorksContainerBasic_closedLanes_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "closedLanes");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_roadworksSubCauseCode.is_bound()) {
    field_roadworksSubCauseCode = OMIT_VALUE;
  }
if (!field_lightBarSirenInUse.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lightBarSirenInUse");
    return JSON_ERROR_FATAL;
  }
if (!field_closedLanes.is_bound()) {
    field_closedLanes = OMIT_VALUE;
  }

  return dec_len;
}

struct RoadWorksContainerBasic_template::single_value_struct {
INTEGER_template field_roadworksSubCauseCode;
BITSTRING_template field_lightBarSirenInUse;
ITS__Container::ClosedLanes_template field_closedLanes;
};

void RoadWorksContainerBasic_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_roadworksSubCauseCode = ANY_OR_OMIT;
single_value->field_lightBarSirenInUse = ANY_VALUE;
single_value->field_closedLanes = ANY_OR_OMIT;
}
}
}

void RoadWorksContainerBasic_template::copy_value(const RoadWorksContainerBasic& other_value)
{
single_value = new single_value_struct;
if (other_value.roadworksSubCauseCode().is_bound()) {
  if (other_value.roadworksSubCauseCode().ispresent()) single_value->field_roadworksSubCauseCode = other_value.roadworksSubCauseCode()();
  else single_value->field_roadworksSubCauseCode = OMIT_VALUE;
} else {
  single_value->field_roadworksSubCauseCode.clean_up();
}
if (other_value.lightBarSirenInUse().is_bound()) {
  single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
  single_value->field_lightBarSirenInUse.clean_up();
}
if (other_value.closedLanes().is_bound()) {
  if (other_value.closedLanes().ispresent()) single_value->field_closedLanes = other_value.closedLanes()();
  else single_value->field_closedLanes = OMIT_VALUE;
} else {
  single_value->field_closedLanes.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RoadWorksContainerBasic_template::copy_template(const RoadWorksContainerBasic_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.roadworksSubCauseCode().get_selection()) {
single_value->field_roadworksSubCauseCode = other_value.roadworksSubCauseCode();
} else {
single_value->field_roadworksSubCauseCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lightBarSirenInUse().get_selection()) {
single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
single_value->field_lightBarSirenInUse.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.closedLanes().get_selection()) {
single_value->field_closedLanes = other_value.closedLanes();
} else {
single_value->field_closedLanes.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RoadWorksContainerBasic_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
break;
}
set_selection(other_value);
}

RoadWorksContainerBasic_template::RoadWorksContainerBasic_template()
{
}

RoadWorksContainerBasic_template::RoadWorksContainerBasic_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RoadWorksContainerBasic_template::RoadWorksContainerBasic_template(const RoadWorksContainerBasic& other_value)
{
copy_value(other_value);
}

RoadWorksContainerBasic_template::RoadWorksContainerBasic_template(const OPTIONAL<RoadWorksContainerBasic>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadWorksContainerBasic&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic from an unbound optional field.");
}
}

RoadWorksContainerBasic_template::RoadWorksContainerBasic_template(const RoadWorksContainerBasic_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RoadWorksContainerBasic_template::~RoadWorksContainerBasic_template()
{
clean_up();
}

RoadWorksContainerBasic_template& RoadWorksContainerBasic_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RoadWorksContainerBasic_template& RoadWorksContainerBasic_template::operator=(const RoadWorksContainerBasic& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RoadWorksContainerBasic_template& RoadWorksContainerBasic_template::operator=(const OPTIONAL<RoadWorksContainerBasic>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadWorksContainerBasic&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
}
return *this;
}

RoadWorksContainerBasic_template& RoadWorksContainerBasic_template::operator=(const RoadWorksContainerBasic_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RoadWorksContainerBasic_template::match(const RoadWorksContainerBasic& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.roadworksSubCauseCode().is_bound()) return FALSE;
if((other_value.roadworksSubCauseCode().ispresent() ? !single_value->field_roadworksSubCauseCode.match((const INTEGER&)other_value.roadworksSubCauseCode(), legacy) : !single_value->field_roadworksSubCauseCode.match_omit(legacy)))return FALSE;
if(!other_value.lightBarSirenInUse().is_bound()) return FALSE;
if(!single_value->field_lightBarSirenInUse.match(other_value.lightBarSirenInUse(), legacy))return FALSE;
if(!other_value.closedLanes().is_bound()) return FALSE;
if((other_value.closedLanes().ispresent() ? !single_value->field_closedLanes.match((const ITS__Container::ClosedLanes&)other_value.closedLanes(), legacy) : !single_value->field_closedLanes.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
}
return FALSE;
}

boolean RoadWorksContainerBasic_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_roadworksSubCauseCode.is_omit() || single_value->field_roadworksSubCauseCode.is_bound()) return TRUE;
if (single_value->field_lightBarSirenInUse.is_bound()) return TRUE;
if (single_value->field_closedLanes.is_omit() || single_value->field_closedLanes.is_bound()) return TRUE;
return FALSE;
}

boolean RoadWorksContainerBasic_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_roadworksSubCauseCode.is_omit() && !single_value->field_roadworksSubCauseCode.is_value()) return FALSE;
if (!single_value->field_lightBarSirenInUse.is_value()) return FALSE;
if (!single_value->field_closedLanes.is_omit() && !single_value->field_closedLanes.is_value()) return FALSE;
return TRUE;
}

void RoadWorksContainerBasic_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RoadWorksContainerBasic RoadWorksContainerBasic_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
RoadWorksContainerBasic ret_val;
if (single_value->field_roadworksSubCauseCode.is_omit()) ret_val.roadworksSubCauseCode() = OMIT_VALUE;
else if (single_value->field_roadworksSubCauseCode.is_bound()) {
ret_val.roadworksSubCauseCode() = single_value->field_roadworksSubCauseCode.valueof();
}
if (single_value->field_lightBarSirenInUse.is_bound()) {
ret_val.lightBarSirenInUse() = single_value->field_lightBarSirenInUse.valueof();
}
if (single_value->field_closedLanes.is_omit()) ret_val.closedLanes() = OMIT_VALUE;
else if (single_value->field_closedLanes.is_bound()) {
ret_val.closedLanes() = single_value->field_closedLanes.valueof();
}
return ret_val;
}

void RoadWorksContainerBasic_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RoadWorksContainerBasic_template[list_length];
}

RoadWorksContainerBasic_template& RoadWorksContainerBasic_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
return value_list.list_value[list_index];
}

INTEGER_template& RoadWorksContainerBasic_template::roadworksSubCauseCode()
{
set_specific();
return single_value->field_roadworksSubCauseCode;
}

const INTEGER_template& RoadWorksContainerBasic_template::roadworksSubCauseCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field roadworksSubCauseCode of a non-specific template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
return single_value->field_roadworksSubCauseCode;
}

BITSTRING_template& RoadWorksContainerBasic_template::lightBarSirenInUse()
{
set_specific();
return single_value->field_lightBarSirenInUse;
}

const BITSTRING_template& RoadWorksContainerBasic_template::lightBarSirenInUse() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lightBarSirenInUse of a non-specific template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
return single_value->field_lightBarSirenInUse;
}

ITS__Container::ClosedLanes_template& RoadWorksContainerBasic_template::closedLanes()
{
set_specific();
return single_value->field_closedLanes;
}

const ITS__Container::ClosedLanes_template& RoadWorksContainerBasic_template::closedLanes() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field closedLanes of a non-specific template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
return single_value->field_closedLanes;
}

int RoadWorksContainerBasic_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_roadworksSubCauseCode.is_present()) ret_val++;
      if (single_value->field_closedLanes.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
  }
  return 0;
}

void RoadWorksContainerBasic_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ roadworksSubCauseCode := ");
single_value->field_roadworksSubCauseCode.log();
TTCN_Logger::log_event_str(", lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(", closedLanes := ");
single_value->field_closedLanes.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RoadWorksContainerBasic_template::log_match(const RoadWorksContainerBasic& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.roadworksSubCauseCode().ispresent()){
if(!single_value->field_roadworksSubCauseCode.match(match_value.roadworksSubCauseCode(), legacy)){
TTCN_Logger::log_logmatch_info(".roadworksSubCauseCode");
single_value->field_roadworksSubCauseCode.log_match(match_value.roadworksSubCauseCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_roadworksSubCauseCode.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".roadworksSubCauseCode := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_roadworksSubCauseCode.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_lightBarSirenInUse.match(match_value.lightBarSirenInUse(), legacy)){
TTCN_Logger::log_logmatch_info(".lightBarSirenInUse");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.closedLanes().ispresent()){
if(!single_value->field_closedLanes.match(match_value.closedLanes(), legacy)){
TTCN_Logger::log_logmatch_info(".closedLanes");
single_value->field_closedLanes.log_match(match_value.closedLanes(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_closedLanes.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".closedLanes := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_closedLanes.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ roadworksSubCauseCode := ");
if (match_value.roadworksSubCauseCode().ispresent()) single_value->field_roadworksSubCauseCode.log_match(match_value.roadworksSubCauseCode(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_roadworksSubCauseCode.log();
if (single_value->field_roadworksSubCauseCode.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::log_event_str(", closedLanes := ");
if (match_value.closedLanes().ispresent()) single_value->field_closedLanes.log_match(match_value.closedLanes(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_closedLanes.log();
if (single_value->field_closedLanes.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RoadWorksContainerBasic_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_roadworksSubCauseCode.encode_text(text_buf);
single_value->field_lightBarSirenInUse.encode_text(text_buf);
single_value->field_closedLanes.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
}
}

void RoadWorksContainerBasic_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_roadworksSubCauseCode.decode_text(text_buf);
single_value->field_lightBarSirenInUse.decode_text(text_buf);
single_value->field_closedLanes.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RoadWorksContainerBasic_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic.");
}
}

void RoadWorksContainerBasic_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.RoadWorksContainerBasic'");
    }
    if (strcmp("roadworksSubCauseCode", param_field) == 0) {
      roadworksSubCauseCode().set_param(param);
      return;
    } else if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else if (strcmp("closedLanes", param_field) == 0) {
      closedLanes().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.RoadWorksContainerBasic'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RoadWorksContainerBasic_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.RoadWorksContainerBasic has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) roadworksSubCauseCode().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) closedLanes().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadworksSubCauseCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadworksSubCauseCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "closedLanes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          closedLanes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.RoadWorksContainerBasic: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.RoadWorksContainerBasic");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RoadWorksContainerBasic_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.RoadWorksContainerBasic'");
    }
    if (strcmp("roadworksSubCauseCode", param_field) == 0) {
      return roadworksSubCauseCode().get_param(param_name);
    } else if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else if (strcmp("closedLanes", param_field) == 0) {
      return closedLanes().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.RoadWorksContainerBasic'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_roadworksSubCauseCode = single_value->field_roadworksSubCauseCode.get_param(param_name);
    mp_field_roadworksSubCauseCode->set_id(new Module_Param_FieldName(mcopystr("roadworksSubCauseCode")));
    mp->add_elem(mp_field_roadworksSubCauseCode);
    Module_Param* mp_field_lightBarSirenInUse = single_value->field_lightBarSirenInUse.get_param(param_name);
    mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
    mp->add_elem(mp_field_lightBarSirenInUse);
    Module_Param* mp_field_closedLanes = single_value->field_closedLanes.get_param(param_name);
    mp_field_closedLanes->set_id(new Module_Param_FieldName(mcopystr("closedLanes")));
    mp->add_elem(mp_field_closedLanes);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RoadWorksContainerBasic_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_roadworksSubCauseCode.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.RoadWorksContainerBasic");
single_value->field_lightBarSirenInUse.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.RoadWorksContainerBasic");
single_value->field_closedLanes.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.RoadWorksContainerBasic");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.RoadWorksContainerBasic");
}

boolean RoadWorksContainerBasic_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RoadWorksContainerBasic_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

RescueContainer::RescueContainer()
{
  bound_flag = FALSE;
}

RescueContainer::RescueContainer(const BITSTRING& par_lightBarSirenInUse)
  :   field_lightBarSirenInUse(par_lightBarSirenInUse)
{
  bound_flag = TRUE;
}

RescueContainer::RescueContainer(const RescueContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.RescueContainer.");
bound_flag = TRUE;
if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
else field_lightBarSirenInUse.clean_up();
}

void RescueContainer::clean_up()
{
field_lightBarSirenInUse.clean_up();
bound_flag = FALSE;
}

RescueContainer& RescueContainer::operator=(const RescueContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.RescueContainer.");
  bound_flag = TRUE;
  if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
  else field_lightBarSirenInUse.clean_up();
}
return *this;
}

boolean RescueContainer::operator==(const RescueContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lightBarSirenInUse==other_value.field_lightBarSirenInUse;
}

boolean RescueContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_lightBarSirenInUse.is_bound()) return TRUE;
return FALSE;
}
boolean RescueContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_lightBarSirenInUse.is_value()) return FALSE;
return TRUE;
}
int RescueContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.RescueContainer");
  return 1;
}

void RescueContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(" }");
}

void RescueContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.RescueContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.RescueContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.RescueContainer has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.RescueContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.RescueContainer");
  }
}

Module_Param* RescueContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.RescueContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.RescueContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_lightBarSirenInUse = field_lightBarSirenInUse.get_param(param_name);
  mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
  mp->add_elem(mp_field_lightBarSirenInUse);
  return mp;
  }

void RescueContainer::set_implicit_omit()
{
if (lightBarSirenInUse().is_bound()) lightBarSirenInUse().set_implicit_omit();
}

void RescueContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.RescueContainer.");
field_lightBarSirenInUse.encode_text(text_buf);
}

void RescueContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lightBarSirenInUse.decode_text(text_buf);
}

void RescueContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RescueContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RescueContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("lightBarSirenInUse': ");
  new_tlv->add_TLV(field_lightBarSirenInUse.BER_encode_TLV(RescueContainer_lightBarSirenInUse_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RescueContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.RescueContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("lightBarSirenInUse': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_lightBarSirenInUse.BER_decode_TLV(RescueContainer_lightBarSirenInUse_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int RescueContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.RescueContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lightBarSirenInUse");
    enc_len += field_lightBarSirenInUse.JSON_encode(RescueContainer_lightBarSirenInUse_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RescueContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "lightBarSirenInUse", name_len)) {
         int ret_val = field_lightBarSirenInUse.JSON_decode(RescueContainer_lightBarSirenInUse_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lightBarSirenInUse");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lightBarSirenInUse.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lightBarSirenInUse");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct RescueContainer_template::single_value_struct {
BITSTRING_template field_lightBarSirenInUse;
};

void RescueContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lightBarSirenInUse = ANY_VALUE;
}
}
}

void RescueContainer_template::copy_value(const RescueContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.lightBarSirenInUse().is_bound()) {
  single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
  single_value->field_lightBarSirenInUse.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RescueContainer_template::copy_template(const RescueContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lightBarSirenInUse().get_selection()) {
single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
single_value->field_lightBarSirenInUse.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RescueContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RescueContainer.");
break;
}
set_selection(other_value);
}

RescueContainer_template::RescueContainer_template()
{
}

RescueContainer_template::RescueContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RescueContainer_template::RescueContainer_template(const RescueContainer& other_value)
{
copy_value(other_value);
}

RescueContainer_template::RescueContainer_template(const OPTIONAL<RescueContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RescueContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.RescueContainer from an unbound optional field.");
}
}

RescueContainer_template::RescueContainer_template(const RescueContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RescueContainer_template::~RescueContainer_template()
{
clean_up();
}

RescueContainer_template& RescueContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RescueContainer_template& RescueContainer_template::operator=(const RescueContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RescueContainer_template& RescueContainer_template::operator=(const OPTIONAL<RescueContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RescueContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.RescueContainer.");
}
return *this;
}

RescueContainer_template& RescueContainer_template::operator=(const RescueContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RescueContainer_template::match(const RescueContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lightBarSirenInUse().is_bound()) return FALSE;
if(!single_value->field_lightBarSirenInUse.match(other_value.lightBarSirenInUse(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RescueContainer.");
}
return FALSE;
}

boolean RescueContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lightBarSirenInUse.is_bound()) return TRUE;
return FALSE;
}

boolean RescueContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lightBarSirenInUse.is_value()) return FALSE;
return TRUE;
}

void RescueContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RescueContainer RescueContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.RescueContainer.");
RescueContainer ret_val;
if (single_value->field_lightBarSirenInUse.is_bound()) {
ret_val.lightBarSirenInUse() = single_value->field_lightBarSirenInUse.valueof();
}
return ret_val;
}

void RescueContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.RescueContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RescueContainer_template[list_length];
}

RescueContainer_template& RescueContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.RescueContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.RescueContainer.");
return value_list.list_value[list_index];
}

BITSTRING_template& RescueContainer_template::lightBarSirenInUse()
{
set_specific();
return single_value->field_lightBarSirenInUse;
}

const BITSTRING_template& RescueContainer_template::lightBarSirenInUse() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lightBarSirenInUse of a non-specific template of type @CAM-PDU-Descriptions.RescueContainer.");
return single_value->field_lightBarSirenInUse;
}

int RescueContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RescueContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RescueContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RescueContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RescueContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RescueContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.RescueContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RescueContainer.");
  }
  return 0;
}

void RescueContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RescueContainer_template::log_match(const RescueContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_lightBarSirenInUse.match(match_value.lightBarSirenInUse(), legacy)){
TTCN_Logger::log_logmatch_info(".lightBarSirenInUse");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RescueContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lightBarSirenInUse.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.RescueContainer.");
}
}

void RescueContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lightBarSirenInUse.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RescueContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.RescueContainer.");
}
}

void RescueContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.RescueContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.RescueContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RescueContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.RescueContainer has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.RescueContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.RescueContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RescueContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.RescueContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.RescueContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_lightBarSirenInUse = single_value->field_lightBarSirenInUse.get_param(param_name);
    mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
    mp->add_elem(mp_field_lightBarSirenInUse);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RescueContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lightBarSirenInUse.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.RescueContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.RescueContainer");
}

boolean RescueContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RescueContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

EmergencyContainer::EmergencyContainer()
{
  bound_flag = FALSE;
}

EmergencyContainer::EmergencyContainer(const BITSTRING& par_lightBarSirenInUse,
    const OPTIONAL<ITS__Container::CauseCode>& par_incidentIndication,
    const OPTIONAL<BITSTRING>& par_emergencyPriority)
  :   field_lightBarSirenInUse(par_lightBarSirenInUse),
  field_incidentIndication(par_incidentIndication),
  field_emergencyPriority(par_emergencyPriority)
{
  bound_flag = TRUE;
}

EmergencyContainer::EmergencyContainer(const EmergencyContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.EmergencyContainer.");
bound_flag = TRUE;
if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
else field_lightBarSirenInUse.clean_up();
if (other_value.incidentIndication().is_bound()) field_incidentIndication = other_value.incidentIndication();
else field_incidentIndication.clean_up();
if (other_value.emergencyPriority().is_bound()) field_emergencyPriority = other_value.emergencyPriority();
else field_emergencyPriority.clean_up();
}

void EmergencyContainer::clean_up()
{
field_lightBarSirenInUse.clean_up();
field_incidentIndication.clean_up();
field_emergencyPriority.clean_up();
bound_flag = FALSE;
}

EmergencyContainer& EmergencyContainer::operator=(const EmergencyContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.EmergencyContainer.");
  bound_flag = TRUE;
  if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
  else field_lightBarSirenInUse.clean_up();
  if (other_value.incidentIndication().is_bound()) field_incidentIndication = other_value.incidentIndication();
  else field_incidentIndication.clean_up();
  if (other_value.emergencyPriority().is_bound()) field_emergencyPriority = other_value.emergencyPriority();
  else field_emergencyPriority.clean_up();
}
return *this;
}

boolean EmergencyContainer::operator==(const EmergencyContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lightBarSirenInUse==other_value.field_lightBarSirenInUse
  && field_incidentIndication==other_value.field_incidentIndication
  && field_emergencyPriority==other_value.field_emergencyPriority;
}

boolean EmergencyContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_lightBarSirenInUse.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_incidentIndication.get_selection() || field_incidentIndication.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_emergencyPriority.get_selection() || field_emergencyPriority.is_bound()) return TRUE;
return FALSE;
}
boolean EmergencyContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_lightBarSirenInUse.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_incidentIndication.get_selection() && !field_incidentIndication.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_emergencyPriority.get_selection() && !field_emergencyPriority.is_value()) return FALSE;
return TRUE;
}
int EmergencyContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.EmergencyContainer");
  int ret_val = 1;
  if (field_incidentIndication.ispresent()) ret_val++;
  if (field_emergencyPriority.ispresent()) ret_val++;
  return ret_val;
}

void EmergencyContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(", incidentIndication := ");
field_incidentIndication.log();
TTCN_Logger::log_event_str(", emergencyPriority := ");
field_emergencyPriority.log();
TTCN_Logger::log_event_str(" }");
}

void EmergencyContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.EmergencyContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else if (strcmp("incidentIndication", param_field) == 0) {
      incidentIndication().set_param(param);
      return;
    } else if (strcmp("emergencyPriority", param_field) == 0) {
      emergencyPriority().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.EmergencyContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.EmergencyContainer has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) incidentIndication().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) emergencyPriority().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "incidentIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          incidentIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergencyPriority")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergencyPriority().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.EmergencyContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.EmergencyContainer");
  }
}

Module_Param* EmergencyContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.EmergencyContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else if (strcmp("incidentIndication", param_field) == 0) {
      return incidentIndication().get_param(param_name);
    } else if (strcmp("emergencyPriority", param_field) == 0) {
      return emergencyPriority().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.EmergencyContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_lightBarSirenInUse = field_lightBarSirenInUse.get_param(param_name);
  mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
  mp->add_elem(mp_field_lightBarSirenInUse);
  Module_Param* mp_field_incidentIndication = field_incidentIndication.get_param(param_name);
  mp_field_incidentIndication->set_id(new Module_Param_FieldName(mcopystr("incidentIndication")));
  mp->add_elem(mp_field_incidentIndication);
  Module_Param* mp_field_emergencyPriority = field_emergencyPriority.get_param(param_name);
  mp_field_emergencyPriority->set_id(new Module_Param_FieldName(mcopystr("emergencyPriority")));
  mp->add_elem(mp_field_emergencyPriority);
  return mp;
  }

void EmergencyContainer::set_implicit_omit()
{
if (lightBarSirenInUse().is_bound()) lightBarSirenInUse().set_implicit_omit();
if (!incidentIndication().is_bound()) incidentIndication() = OMIT_VALUE;
else incidentIndication().set_implicit_omit();
if (!emergencyPriority().is_bound()) emergencyPriority() = OMIT_VALUE;
else emergencyPriority().set_implicit_omit();
}

void EmergencyContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.EmergencyContainer.");
field_lightBarSirenInUse.encode_text(text_buf);
field_incidentIndication.encode_text(text_buf);
field_emergencyPriority.encode_text(text_buf);
}

void EmergencyContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lightBarSirenInUse.decode_text(text_buf);
field_incidentIndication.decode_text(text_buf);
field_emergencyPriority.decode_text(text_buf);
}

void EmergencyContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EmergencyContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* EmergencyContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("lightBarSirenInUse': ");
  new_tlv->add_TLV(field_lightBarSirenInUse.BER_encode_TLV(EmergencyContainer_lightBarSirenInUse_descr_, p_coding));
  ec_1.set_msg("incidentIndication': ");
  new_tlv->add_TLV(field_incidentIndication.BER_encode_TLV(EmergencyContainer_incidentIndication_descr_, p_coding));
  ec_1.set_msg("emergencyPriority': ");
  new_tlv->add_TLV(field_emergencyPriority.BER_encode_TLV(EmergencyContainer_emergencyPriority_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean EmergencyContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.EmergencyContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("lightBarSirenInUse': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_lightBarSirenInUse.BER_decode_TLV(EmergencyContainer_lightBarSirenInUse_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("incidentIndication': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_incidentIndication=OMIT_VALUE;
    else {
      field_incidentIndication.BER_decode_TLV(EmergencyContainer_incidentIndication_descr_, tmp_tlv, L_form);
      if(field_incidentIndication.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("emergencyPriority': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_emergencyPriority=OMIT_VALUE;
    else {
      field_emergencyPriority.BER_decode_TLV(EmergencyContainer_emergencyPriority_descr_, tmp_tlv, L_form);
      if(field_emergencyPriority.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int EmergencyContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.EmergencyContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lightBarSirenInUse");
    enc_len += field_lightBarSirenInUse.JSON_encode(EmergencyContainer_lightBarSirenInUse_descr_, p_tok);
  }

  if (field_incidentIndication.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "incidentIndication");
    enc_len += field_incidentIndication.JSON_encode(EmergencyContainer_incidentIndication_descr_, p_tok);
  }

  if (field_emergencyPriority.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "emergencyPriority");
    enc_len += field_emergencyPriority.JSON_encode(EmergencyContainer_emergencyPriority_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int EmergencyContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "lightBarSirenInUse", name_len)) {
         int ret_val = field_lightBarSirenInUse.JSON_decode(EmergencyContainer_lightBarSirenInUse_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lightBarSirenInUse");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "incidentIndication", name_len)) {
         int ret_val = field_incidentIndication.JSON_decode(EmergencyContainer_incidentIndication_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "incidentIndication");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "emergencyPriority", name_len)) {
         int ret_val = field_emergencyPriority.JSON_decode(EmergencyContainer_emergencyPriority_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "emergencyPriority");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lightBarSirenInUse.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lightBarSirenInUse");
    return JSON_ERROR_FATAL;
  }
if (!field_incidentIndication.is_bound()) {
    field_incidentIndication = OMIT_VALUE;
  }
if (!field_emergencyPriority.is_bound()) {
    field_emergencyPriority = OMIT_VALUE;
  }

  return dec_len;
}

struct EmergencyContainer_template::single_value_struct {
BITSTRING_template field_lightBarSirenInUse;
ITS__Container::CauseCode_template field_incidentIndication;
BITSTRING_template field_emergencyPriority;
};

void EmergencyContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lightBarSirenInUse = ANY_VALUE;
single_value->field_incidentIndication = ANY_OR_OMIT;
single_value->field_emergencyPriority = ANY_OR_OMIT;
}
}
}

void EmergencyContainer_template::copy_value(const EmergencyContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.lightBarSirenInUse().is_bound()) {
  single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
  single_value->field_lightBarSirenInUse.clean_up();
}
if (other_value.incidentIndication().is_bound()) {
  if (other_value.incidentIndication().ispresent()) single_value->field_incidentIndication = other_value.incidentIndication()();
  else single_value->field_incidentIndication = OMIT_VALUE;
} else {
  single_value->field_incidentIndication.clean_up();
}
if (other_value.emergencyPriority().is_bound()) {
  if (other_value.emergencyPriority().ispresent()) single_value->field_emergencyPriority = other_value.emergencyPriority()();
  else single_value->field_emergencyPriority = OMIT_VALUE;
} else {
  single_value->field_emergencyPriority.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void EmergencyContainer_template::copy_template(const EmergencyContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lightBarSirenInUse().get_selection()) {
single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
single_value->field_lightBarSirenInUse.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.incidentIndication().get_selection()) {
single_value->field_incidentIndication = other_value.incidentIndication();
} else {
single_value->field_incidentIndication.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.emergencyPriority().get_selection()) {
single_value->field_emergencyPriority = other_value.emergencyPriority();
} else {
single_value->field_emergencyPriority.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EmergencyContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.EmergencyContainer.");
break;
}
set_selection(other_value);
}

EmergencyContainer_template::EmergencyContainer_template()
{
}

EmergencyContainer_template::EmergencyContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

EmergencyContainer_template::EmergencyContainer_template(const EmergencyContainer& other_value)
{
copy_value(other_value);
}

EmergencyContainer_template::EmergencyContainer_template(const OPTIONAL<EmergencyContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EmergencyContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.EmergencyContainer from an unbound optional field.");
}
}

EmergencyContainer_template::EmergencyContainer_template(const EmergencyContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

EmergencyContainer_template::~EmergencyContainer_template()
{
clean_up();
}

EmergencyContainer_template& EmergencyContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EmergencyContainer_template& EmergencyContainer_template::operator=(const EmergencyContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

EmergencyContainer_template& EmergencyContainer_template::operator=(const OPTIONAL<EmergencyContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EmergencyContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.EmergencyContainer.");
}
return *this;
}

EmergencyContainer_template& EmergencyContainer_template::operator=(const EmergencyContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean EmergencyContainer_template::match(const EmergencyContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lightBarSirenInUse().is_bound()) return FALSE;
if(!single_value->field_lightBarSirenInUse.match(other_value.lightBarSirenInUse(), legacy))return FALSE;
if(!other_value.incidentIndication().is_bound()) return FALSE;
if((other_value.incidentIndication().ispresent() ? !single_value->field_incidentIndication.match((const ITS__Container::CauseCode&)other_value.incidentIndication(), legacy) : !single_value->field_incidentIndication.match_omit(legacy)))return FALSE;
if(!other_value.emergencyPriority().is_bound()) return FALSE;
if((other_value.emergencyPriority().ispresent() ? !single_value->field_emergencyPriority.match((const BITSTRING&)other_value.emergencyPriority(), legacy) : !single_value->field_emergencyPriority.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.EmergencyContainer.");
}
return FALSE;
}

boolean EmergencyContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lightBarSirenInUse.is_bound()) return TRUE;
if (single_value->field_incidentIndication.is_omit() || single_value->field_incidentIndication.is_bound()) return TRUE;
if (single_value->field_emergencyPriority.is_omit() || single_value->field_emergencyPriority.is_bound()) return TRUE;
return FALSE;
}

boolean EmergencyContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lightBarSirenInUse.is_value()) return FALSE;
if (!single_value->field_incidentIndication.is_omit() && !single_value->field_incidentIndication.is_value()) return FALSE;
if (!single_value->field_emergencyPriority.is_omit() && !single_value->field_emergencyPriority.is_value()) return FALSE;
return TRUE;
}

void EmergencyContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

EmergencyContainer EmergencyContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.EmergencyContainer.");
EmergencyContainer ret_val;
if (single_value->field_lightBarSirenInUse.is_bound()) {
ret_val.lightBarSirenInUse() = single_value->field_lightBarSirenInUse.valueof();
}
if (single_value->field_incidentIndication.is_omit()) ret_val.incidentIndication() = OMIT_VALUE;
else if (single_value->field_incidentIndication.is_bound()) {
ret_val.incidentIndication() = single_value->field_incidentIndication.valueof();
}
if (single_value->field_emergencyPriority.is_omit()) ret_val.emergencyPriority() = OMIT_VALUE;
else if (single_value->field_emergencyPriority.is_bound()) {
ret_val.emergencyPriority() = single_value->field_emergencyPriority.valueof();
}
return ret_val;
}

void EmergencyContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.EmergencyContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new EmergencyContainer_template[list_length];
}

EmergencyContainer_template& EmergencyContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.EmergencyContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.EmergencyContainer.");
return value_list.list_value[list_index];
}

BITSTRING_template& EmergencyContainer_template::lightBarSirenInUse()
{
set_specific();
return single_value->field_lightBarSirenInUse;
}

const BITSTRING_template& EmergencyContainer_template::lightBarSirenInUse() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lightBarSirenInUse of a non-specific template of type @CAM-PDU-Descriptions.EmergencyContainer.");
return single_value->field_lightBarSirenInUse;
}

ITS__Container::CauseCode_template& EmergencyContainer_template::incidentIndication()
{
set_specific();
return single_value->field_incidentIndication;
}

const ITS__Container::CauseCode_template& EmergencyContainer_template::incidentIndication() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field incidentIndication of a non-specific template of type @CAM-PDU-Descriptions.EmergencyContainer.");
return single_value->field_incidentIndication;
}

BITSTRING_template& EmergencyContainer_template::emergencyPriority()
{
set_specific();
return single_value->field_emergencyPriority;
}

const BITSTRING_template& EmergencyContainer_template::emergencyPriority() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field emergencyPriority of a non-specific template of type @CAM-PDU-Descriptions.EmergencyContainer.");
return single_value->field_emergencyPriority;
}

int EmergencyContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.EmergencyContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_incidentIndication.is_present()) ret_val++;
      if (single_value->field_emergencyPriority.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.EmergencyContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.EmergencyContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.EmergencyContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.EmergencyContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.EmergencyContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.EmergencyContainer.");
  }
  return 0;
}

void EmergencyContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(", incidentIndication := ");
single_value->field_incidentIndication.log();
TTCN_Logger::log_event_str(", emergencyPriority := ");
single_value->field_emergencyPriority.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void EmergencyContainer_template::log_match(const EmergencyContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_lightBarSirenInUse.match(match_value.lightBarSirenInUse(), legacy)){
TTCN_Logger::log_logmatch_info(".lightBarSirenInUse");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.incidentIndication().ispresent()){
if(!single_value->field_incidentIndication.match(match_value.incidentIndication(), legacy)){
TTCN_Logger::log_logmatch_info(".incidentIndication");
single_value->field_incidentIndication.log_match(match_value.incidentIndication(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_incidentIndication.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".incidentIndication := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_incidentIndication.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.emergencyPriority().ispresent()){
if(!single_value->field_emergencyPriority.match(match_value.emergencyPriority(), legacy)){
TTCN_Logger::log_logmatch_info(".emergencyPriority");
single_value->field_emergencyPriority.log_match(match_value.emergencyPriority(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_emergencyPriority.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".emergencyPriority := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_emergencyPriority.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::log_event_str(", incidentIndication := ");
if (match_value.incidentIndication().ispresent()) single_value->field_incidentIndication.log_match(match_value.incidentIndication(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_incidentIndication.log();
if (single_value->field_incidentIndication.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", emergencyPriority := ");
if (match_value.emergencyPriority().ispresent()) single_value->field_emergencyPriority.log_match(match_value.emergencyPriority(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_emergencyPriority.log();
if (single_value->field_emergencyPriority.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void EmergencyContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lightBarSirenInUse.encode_text(text_buf);
single_value->field_incidentIndication.encode_text(text_buf);
single_value->field_emergencyPriority.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.EmergencyContainer.");
}
}

void EmergencyContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lightBarSirenInUse.decode_text(text_buf);
single_value->field_incidentIndication.decode_text(text_buf);
single_value->field_emergencyPriority.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EmergencyContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.EmergencyContainer.");
}
}

void EmergencyContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.EmergencyContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else if (strcmp("incidentIndication", param_field) == 0) {
      incidentIndication().set_param(param);
      return;
    } else if (strcmp("emergencyPriority", param_field) == 0) {
      emergencyPriority().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.EmergencyContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EmergencyContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.EmergencyContainer has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) incidentIndication().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) emergencyPriority().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "incidentIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          incidentIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergencyPriority")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergencyPriority().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.EmergencyContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.EmergencyContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* EmergencyContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.EmergencyContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else if (strcmp("incidentIndication", param_field) == 0) {
      return incidentIndication().get_param(param_name);
    } else if (strcmp("emergencyPriority", param_field) == 0) {
      return emergencyPriority().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.EmergencyContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_lightBarSirenInUse = single_value->field_lightBarSirenInUse.get_param(param_name);
    mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
    mp->add_elem(mp_field_lightBarSirenInUse);
    Module_Param* mp_field_incidentIndication = single_value->field_incidentIndication.get_param(param_name);
    mp_field_incidentIndication->set_id(new Module_Param_FieldName(mcopystr("incidentIndication")));
    mp->add_elem(mp_field_incidentIndication);
    Module_Param* mp_field_emergencyPriority = single_value->field_emergencyPriority.get_param(param_name);
    mp_field_emergencyPriority->set_id(new Module_Param_FieldName(mcopystr("emergencyPriority")));
    mp->add_elem(mp_field_emergencyPriority);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void EmergencyContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lightBarSirenInUse.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.EmergencyContainer");
single_value->field_incidentIndication.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.EmergencyContainer");
single_value->field_emergencyPriority.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.EmergencyContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.EmergencyContainer");
}

boolean EmergencyContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EmergencyContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SafetyCarContainer::SafetyCarContainer()
{
  bound_flag = FALSE;
}

SafetyCarContainer::SafetyCarContainer(const BITSTRING& par_lightBarSirenInUse,
    const OPTIONAL<ITS__Container::CauseCode>& par_incidentIndication,
    const OPTIONAL<ITS__Container::TrafficRule>& par_trafficRule,
    const OPTIONAL<INTEGER>& par_speedLimit)
  :   field_lightBarSirenInUse(par_lightBarSirenInUse),
  field_incidentIndication(par_incidentIndication),
  field_trafficRule(par_trafficRule),
  field_speedLimit(par_speedLimit)
{
  bound_flag = TRUE;
}

SafetyCarContainer::SafetyCarContainer(const SafetyCarContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.SafetyCarContainer.");
bound_flag = TRUE;
if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
else field_lightBarSirenInUse.clean_up();
if (other_value.incidentIndication().is_bound()) field_incidentIndication = other_value.incidentIndication();
else field_incidentIndication.clean_up();
if (other_value.trafficRule().is_bound()) field_trafficRule = other_value.trafficRule();
else field_trafficRule.clean_up();
if (other_value.speedLimit().is_bound()) field_speedLimit = other_value.speedLimit();
else field_speedLimit.clean_up();
}

void SafetyCarContainer::clean_up()
{
field_lightBarSirenInUse.clean_up();
field_incidentIndication.clean_up();
field_trafficRule.clean_up();
field_speedLimit.clean_up();
bound_flag = FALSE;
}

SafetyCarContainer& SafetyCarContainer::operator=(const SafetyCarContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.SafetyCarContainer.");
  bound_flag = TRUE;
  if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
  else field_lightBarSirenInUse.clean_up();
  if (other_value.incidentIndication().is_bound()) field_incidentIndication = other_value.incidentIndication();
  else field_incidentIndication.clean_up();
  if (other_value.trafficRule().is_bound()) field_trafficRule = other_value.trafficRule();
  else field_trafficRule.clean_up();
  if (other_value.speedLimit().is_bound()) field_speedLimit = other_value.speedLimit();
  else field_speedLimit.clean_up();
}
return *this;
}

boolean SafetyCarContainer::operator==(const SafetyCarContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lightBarSirenInUse==other_value.field_lightBarSirenInUse
  && field_incidentIndication==other_value.field_incidentIndication
  && field_trafficRule==other_value.field_trafficRule
  && field_speedLimit==other_value.field_speedLimit;
}

boolean SafetyCarContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_lightBarSirenInUse.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_incidentIndication.get_selection() || field_incidentIndication.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_trafficRule.get_selection() || field_trafficRule.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_speedLimit.get_selection() || field_speedLimit.is_bound()) return TRUE;
return FALSE;
}
boolean SafetyCarContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_lightBarSirenInUse.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_incidentIndication.get_selection() && !field_incidentIndication.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_trafficRule.get_selection() && !field_trafficRule.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_speedLimit.get_selection() && !field_speedLimit.is_value()) return FALSE;
return TRUE;
}
int SafetyCarContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.SafetyCarContainer");
  int ret_val = 1;
  if (field_incidentIndication.ispresent()) ret_val++;
  if (field_trafficRule.ispresent()) ret_val++;
  if (field_speedLimit.ispresent()) ret_val++;
  return ret_val;
}

void SafetyCarContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(", incidentIndication := ");
field_incidentIndication.log();
TTCN_Logger::log_event_str(", trafficRule := ");
field_trafficRule.log();
TTCN_Logger::log_event_str(", speedLimit := ");
field_speedLimit.log();
TTCN_Logger::log_event_str(" }");
}

void SafetyCarContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.SafetyCarContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else if (strcmp("incidentIndication", param_field) == 0) {
      incidentIndication().set_param(param);
      return;
    } else if (strcmp("trafficRule", param_field) == 0) {
      trafficRule().set_param(param);
      return;
    } else if (strcmp("speedLimit", param_field) == 0) {
      speedLimit().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.SafetyCarContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.SafetyCarContainer has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) incidentIndication().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficRule().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) speedLimit().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "incidentIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          incidentIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficRule")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficRule().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.SafetyCarContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.SafetyCarContainer");
  }
}

Module_Param* SafetyCarContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.SafetyCarContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else if (strcmp("incidentIndication", param_field) == 0) {
      return incidentIndication().get_param(param_name);
    } else if (strcmp("trafficRule", param_field) == 0) {
      return trafficRule().get_param(param_name);
    } else if (strcmp("speedLimit", param_field) == 0) {
      return speedLimit().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.SafetyCarContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_lightBarSirenInUse = field_lightBarSirenInUse.get_param(param_name);
  mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
  mp->add_elem(mp_field_lightBarSirenInUse);
  Module_Param* mp_field_incidentIndication = field_incidentIndication.get_param(param_name);
  mp_field_incidentIndication->set_id(new Module_Param_FieldName(mcopystr("incidentIndication")));
  mp->add_elem(mp_field_incidentIndication);
  Module_Param* mp_field_trafficRule = field_trafficRule.get_param(param_name);
  mp_field_trafficRule->set_id(new Module_Param_FieldName(mcopystr("trafficRule")));
  mp->add_elem(mp_field_trafficRule);
  Module_Param* mp_field_speedLimit = field_speedLimit.get_param(param_name);
  mp_field_speedLimit->set_id(new Module_Param_FieldName(mcopystr("speedLimit")));
  mp->add_elem(mp_field_speedLimit);
  return mp;
  }

void SafetyCarContainer::set_implicit_omit()
{
if (lightBarSirenInUse().is_bound()) lightBarSirenInUse().set_implicit_omit();
if (!incidentIndication().is_bound()) incidentIndication() = OMIT_VALUE;
else incidentIndication().set_implicit_omit();
if (!trafficRule().is_bound()) trafficRule() = OMIT_VALUE;
else trafficRule().set_implicit_omit();
if (!speedLimit().is_bound()) speedLimit() = OMIT_VALUE;
else speedLimit().set_implicit_omit();
}

void SafetyCarContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.SafetyCarContainer.");
field_lightBarSirenInUse.encode_text(text_buf);
field_incidentIndication.encode_text(text_buf);
field_trafficRule.encode_text(text_buf);
field_speedLimit.encode_text(text_buf);
}

void SafetyCarContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lightBarSirenInUse.decode_text(text_buf);
field_incidentIndication.decode_text(text_buf);
field_trafficRule.decode_text(text_buf);
field_speedLimit.decode_text(text_buf);
}

void SafetyCarContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SafetyCarContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* SafetyCarContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("lightBarSirenInUse': ");
  new_tlv->add_TLV(field_lightBarSirenInUse.BER_encode_TLV(SafetyCarContainer_lightBarSirenInUse_descr_, p_coding));
  ec_1.set_msg("incidentIndication': ");
  new_tlv->add_TLV(field_incidentIndication.BER_encode_TLV(SafetyCarContainer_incidentIndication_descr_, p_coding));
  ec_1.set_msg("trafficRule': ");
  new_tlv->add_TLV(field_trafficRule.BER_encode_TLV(SafetyCarContainer_trafficRule_descr_, p_coding));
  ec_1.set_msg("speedLimit': ");
  new_tlv->add_TLV(field_speedLimit.BER_encode_TLV(SafetyCarContainer_speedLimit_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean SafetyCarContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.SafetyCarContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("lightBarSirenInUse': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_lightBarSirenInUse.BER_decode_TLV(SafetyCarContainer_lightBarSirenInUse_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("incidentIndication': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_incidentIndication=OMIT_VALUE;
    else {
      field_incidentIndication.BER_decode_TLV(SafetyCarContainer_incidentIndication_descr_, tmp_tlv, L_form);
      if(field_incidentIndication.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("trafficRule': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_trafficRule=OMIT_VALUE;
    else {
      field_trafficRule.BER_decode_TLV(SafetyCarContainer_trafficRule_descr_, tmp_tlv, L_form);
      if(field_trafficRule.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("speedLimit': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_speedLimit=OMIT_VALUE;
    else {
      field_speedLimit.BER_decode_TLV(SafetyCarContainer_speedLimit_descr_, tmp_tlv, L_form);
      if(field_speedLimit.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int SafetyCarContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.SafetyCarContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lightBarSirenInUse");
    enc_len += field_lightBarSirenInUse.JSON_encode(SafetyCarContainer_lightBarSirenInUse_descr_, p_tok);
  }

  if (field_incidentIndication.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "incidentIndication");
    enc_len += field_incidentIndication.JSON_encode(SafetyCarContainer_incidentIndication_descr_, p_tok);
  }

  if (field_trafficRule.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficRule");
    enc_len += field_trafficRule.JSON_encode(SafetyCarContainer_trafficRule_descr_, p_tok);
  }

  if (field_speedLimit.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speedLimit");
    enc_len += field_speedLimit.JSON_encode(SafetyCarContainer_speedLimit_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SafetyCarContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "lightBarSirenInUse", name_len)) {
         int ret_val = field_lightBarSirenInUse.JSON_decode(SafetyCarContainer_lightBarSirenInUse_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lightBarSirenInUse");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "incidentIndication", name_len)) {
         int ret_val = field_incidentIndication.JSON_decode(SafetyCarContainer_incidentIndication_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "incidentIndication");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "trafficRule", name_len)) {
         int ret_val = field_trafficRule.JSON_decode(SafetyCarContainer_trafficRule_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficRule");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "speedLimit", name_len)) {
         int ret_val = field_speedLimit.JSON_decode(SafetyCarContainer_speedLimit_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speedLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lightBarSirenInUse.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lightBarSirenInUse");
    return JSON_ERROR_FATAL;
  }
if (!field_incidentIndication.is_bound()) {
    field_incidentIndication = OMIT_VALUE;
  }
if (!field_trafficRule.is_bound()) {
    field_trafficRule = OMIT_VALUE;
  }
if (!field_speedLimit.is_bound()) {
    field_speedLimit = OMIT_VALUE;
  }

  return dec_len;
}

struct SafetyCarContainer_template::single_value_struct {
BITSTRING_template field_lightBarSirenInUse;
ITS__Container::CauseCode_template field_incidentIndication;
ITS__Container::TrafficRule_template field_trafficRule;
INTEGER_template field_speedLimit;
};

void SafetyCarContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lightBarSirenInUse = ANY_VALUE;
single_value->field_incidentIndication = ANY_OR_OMIT;
single_value->field_trafficRule = ANY_OR_OMIT;
single_value->field_speedLimit = ANY_OR_OMIT;
}
}
}

void SafetyCarContainer_template::copy_value(const SafetyCarContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.lightBarSirenInUse().is_bound()) {
  single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
  single_value->field_lightBarSirenInUse.clean_up();
}
if (other_value.incidentIndication().is_bound()) {
  if (other_value.incidentIndication().ispresent()) single_value->field_incidentIndication = other_value.incidentIndication()();
  else single_value->field_incidentIndication = OMIT_VALUE;
} else {
  single_value->field_incidentIndication.clean_up();
}
if (other_value.trafficRule().is_bound()) {
  if (other_value.trafficRule().ispresent()) single_value->field_trafficRule = other_value.trafficRule()();
  else single_value->field_trafficRule = OMIT_VALUE;
} else {
  single_value->field_trafficRule.clean_up();
}
if (other_value.speedLimit().is_bound()) {
  if (other_value.speedLimit().ispresent()) single_value->field_speedLimit = other_value.speedLimit()();
  else single_value->field_speedLimit = OMIT_VALUE;
} else {
  single_value->field_speedLimit.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SafetyCarContainer_template::copy_template(const SafetyCarContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lightBarSirenInUse().get_selection()) {
single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
single_value->field_lightBarSirenInUse.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.incidentIndication().get_selection()) {
single_value->field_incidentIndication = other_value.incidentIndication();
} else {
single_value->field_incidentIndication.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trafficRule().get_selection()) {
single_value->field_trafficRule = other_value.trafficRule();
} else {
single_value->field_trafficRule.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speedLimit().get_selection()) {
single_value->field_speedLimit = other_value.speedLimit();
} else {
single_value->field_speedLimit.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SafetyCarContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
break;
}
set_selection(other_value);
}

SafetyCarContainer_template::SafetyCarContainer_template()
{
}

SafetyCarContainer_template::SafetyCarContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SafetyCarContainer_template::SafetyCarContainer_template(const SafetyCarContainer& other_value)
{
copy_value(other_value);
}

SafetyCarContainer_template::SafetyCarContainer_template(const OPTIONAL<SafetyCarContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SafetyCarContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.SafetyCarContainer from an unbound optional field.");
}
}

SafetyCarContainer_template::SafetyCarContainer_template(const SafetyCarContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SafetyCarContainer_template::~SafetyCarContainer_template()
{
clean_up();
}

SafetyCarContainer_template& SafetyCarContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SafetyCarContainer_template& SafetyCarContainer_template::operator=(const SafetyCarContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SafetyCarContainer_template& SafetyCarContainer_template::operator=(const OPTIONAL<SafetyCarContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SafetyCarContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
}
return *this;
}

SafetyCarContainer_template& SafetyCarContainer_template::operator=(const SafetyCarContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SafetyCarContainer_template::match(const SafetyCarContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lightBarSirenInUse().is_bound()) return FALSE;
if(!single_value->field_lightBarSirenInUse.match(other_value.lightBarSirenInUse(), legacy))return FALSE;
if(!other_value.incidentIndication().is_bound()) return FALSE;
if((other_value.incidentIndication().ispresent() ? !single_value->field_incidentIndication.match((const ITS__Container::CauseCode&)other_value.incidentIndication(), legacy) : !single_value->field_incidentIndication.match_omit(legacy)))return FALSE;
if(!other_value.trafficRule().is_bound()) return FALSE;
if((other_value.trafficRule().ispresent() ? !single_value->field_trafficRule.match((const ITS__Container::TrafficRule&)other_value.trafficRule(), legacy) : !single_value->field_trafficRule.match_omit(legacy)))return FALSE;
if(!other_value.speedLimit().is_bound()) return FALSE;
if((other_value.speedLimit().ispresent() ? !single_value->field_speedLimit.match((const INTEGER&)other_value.speedLimit(), legacy) : !single_value->field_speedLimit.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
}
return FALSE;
}

boolean SafetyCarContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lightBarSirenInUse.is_bound()) return TRUE;
if (single_value->field_incidentIndication.is_omit() || single_value->field_incidentIndication.is_bound()) return TRUE;
if (single_value->field_trafficRule.is_omit() || single_value->field_trafficRule.is_bound()) return TRUE;
if (single_value->field_speedLimit.is_omit() || single_value->field_speedLimit.is_bound()) return TRUE;
return FALSE;
}

boolean SafetyCarContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lightBarSirenInUse.is_value()) return FALSE;
if (!single_value->field_incidentIndication.is_omit() && !single_value->field_incidentIndication.is_value()) return FALSE;
if (!single_value->field_trafficRule.is_omit() && !single_value->field_trafficRule.is_value()) return FALSE;
if (!single_value->field_speedLimit.is_omit() && !single_value->field_speedLimit.is_value()) return FALSE;
return TRUE;
}

void SafetyCarContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SafetyCarContainer SafetyCarContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
SafetyCarContainer ret_val;
if (single_value->field_lightBarSirenInUse.is_bound()) {
ret_val.lightBarSirenInUse() = single_value->field_lightBarSirenInUse.valueof();
}
if (single_value->field_incidentIndication.is_omit()) ret_val.incidentIndication() = OMIT_VALUE;
else if (single_value->field_incidentIndication.is_bound()) {
ret_val.incidentIndication() = single_value->field_incidentIndication.valueof();
}
if (single_value->field_trafficRule.is_omit()) ret_val.trafficRule() = OMIT_VALUE;
else if (single_value->field_trafficRule.is_bound()) {
ret_val.trafficRule() = single_value->field_trafficRule.valueof();
}
if (single_value->field_speedLimit.is_omit()) ret_val.speedLimit() = OMIT_VALUE;
else if (single_value->field_speedLimit.is_bound()) {
ret_val.speedLimit() = single_value->field_speedLimit.valueof();
}
return ret_val;
}

void SafetyCarContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SafetyCarContainer_template[list_length];
}

SafetyCarContainer_template& SafetyCarContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
return value_list.list_value[list_index];
}

BITSTRING_template& SafetyCarContainer_template::lightBarSirenInUse()
{
set_specific();
return single_value->field_lightBarSirenInUse;
}

const BITSTRING_template& SafetyCarContainer_template::lightBarSirenInUse() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lightBarSirenInUse of a non-specific template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
return single_value->field_lightBarSirenInUse;
}

ITS__Container::CauseCode_template& SafetyCarContainer_template::incidentIndication()
{
set_specific();
return single_value->field_incidentIndication;
}

const ITS__Container::CauseCode_template& SafetyCarContainer_template::incidentIndication() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field incidentIndication of a non-specific template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
return single_value->field_incidentIndication;
}

ITS__Container::TrafficRule_template& SafetyCarContainer_template::trafficRule()
{
set_specific();
return single_value->field_trafficRule;
}

const ITS__Container::TrafficRule_template& SafetyCarContainer_template::trafficRule() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficRule of a non-specific template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
return single_value->field_trafficRule;
}

INTEGER_template& SafetyCarContainer_template::speedLimit()
{
set_specific();
return single_value->field_speedLimit;
}

const INTEGER_template& SafetyCarContainer_template::speedLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speedLimit of a non-specific template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
return single_value->field_speedLimit;
}

int SafetyCarContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SafetyCarContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_incidentIndication.is_present()) ret_val++;
      if (single_value->field_trafficRule.is_present()) ret_val++;
      if (single_value->field_speedLimit.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SafetyCarContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SafetyCarContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SafetyCarContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SafetyCarContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.SafetyCarContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
  }
  return 0;
}

void SafetyCarContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(", incidentIndication := ");
single_value->field_incidentIndication.log();
TTCN_Logger::log_event_str(", trafficRule := ");
single_value->field_trafficRule.log();
TTCN_Logger::log_event_str(", speedLimit := ");
single_value->field_speedLimit.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SafetyCarContainer_template::log_match(const SafetyCarContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_lightBarSirenInUse.match(match_value.lightBarSirenInUse(), legacy)){
TTCN_Logger::log_logmatch_info(".lightBarSirenInUse");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.incidentIndication().ispresent()){
if(!single_value->field_incidentIndication.match(match_value.incidentIndication(), legacy)){
TTCN_Logger::log_logmatch_info(".incidentIndication");
single_value->field_incidentIndication.log_match(match_value.incidentIndication(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_incidentIndication.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".incidentIndication := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_incidentIndication.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.trafficRule().ispresent()){
if(!single_value->field_trafficRule.match(match_value.trafficRule(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficRule");
single_value->field_trafficRule.log_match(match_value.trafficRule(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_trafficRule.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".trafficRule := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_trafficRule.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.speedLimit().ispresent()){
if(!single_value->field_speedLimit.match(match_value.speedLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".speedLimit");
single_value->field_speedLimit.log_match(match_value.speedLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_speedLimit.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".speedLimit := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_speedLimit.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::log_event_str(", incidentIndication := ");
if (match_value.incidentIndication().ispresent()) single_value->field_incidentIndication.log_match(match_value.incidentIndication(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_incidentIndication.log();
if (single_value->field_incidentIndication.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", trafficRule := ");
if (match_value.trafficRule().ispresent()) single_value->field_trafficRule.log_match(match_value.trafficRule(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_trafficRule.log();
if (single_value->field_trafficRule.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", speedLimit := ");
if (match_value.speedLimit().ispresent()) single_value->field_speedLimit.log_match(match_value.speedLimit(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_speedLimit.log();
if (single_value->field_speedLimit.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SafetyCarContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lightBarSirenInUse.encode_text(text_buf);
single_value->field_incidentIndication.encode_text(text_buf);
single_value->field_trafficRule.encode_text(text_buf);
single_value->field_speedLimit.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
}
}

void SafetyCarContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lightBarSirenInUse.decode_text(text_buf);
single_value->field_incidentIndication.decode_text(text_buf);
single_value->field_trafficRule.decode_text(text_buf);
single_value->field_speedLimit.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SafetyCarContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.SafetyCarContainer.");
}
}

void SafetyCarContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.SafetyCarContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else if (strcmp("incidentIndication", param_field) == 0) {
      incidentIndication().set_param(param);
      return;
    } else if (strcmp("trafficRule", param_field) == 0) {
      trafficRule().set_param(param);
      return;
    } else if (strcmp("speedLimit", param_field) == 0) {
      speedLimit().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.SafetyCarContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SafetyCarContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.SafetyCarContainer has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) incidentIndication().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficRule().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) speedLimit().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "incidentIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          incidentIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficRule")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficRule().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.SafetyCarContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.SafetyCarContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SafetyCarContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.SafetyCarContainer'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else if (strcmp("incidentIndication", param_field) == 0) {
      return incidentIndication().get_param(param_name);
    } else if (strcmp("trafficRule", param_field) == 0) {
      return trafficRule().get_param(param_name);
    } else if (strcmp("speedLimit", param_field) == 0) {
      return speedLimit().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.SafetyCarContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_lightBarSirenInUse = single_value->field_lightBarSirenInUse.get_param(param_name);
    mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
    mp->add_elem(mp_field_lightBarSirenInUse);
    Module_Param* mp_field_incidentIndication = single_value->field_incidentIndication.get_param(param_name);
    mp_field_incidentIndication->set_id(new Module_Param_FieldName(mcopystr("incidentIndication")));
    mp->add_elem(mp_field_incidentIndication);
    Module_Param* mp_field_trafficRule = single_value->field_trafficRule.get_param(param_name);
    mp_field_trafficRule->set_id(new Module_Param_FieldName(mcopystr("trafficRule")));
    mp->add_elem(mp_field_trafficRule);
    Module_Param* mp_field_speedLimit = single_value->field_speedLimit.get_param(param_name);
    mp_field_speedLimit->set_id(new Module_Param_FieldName(mcopystr("speedLimit")));
    mp->add_elem(mp_field_speedLimit);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SafetyCarContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lightBarSirenInUse.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SafetyCarContainer");
single_value->field_incidentIndication.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SafetyCarContainer");
single_value->field_trafficRule.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SafetyCarContainer");
single_value->field_speedLimit.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.SafetyCarContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.SafetyCarContainer");
}

boolean SafetyCarContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SafetyCarContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

CoopAwareness::CoopAwareness()
{
  bound_flag = FALSE;
}

CoopAwareness::CoopAwareness(const INTEGER& par_generationDeltaTime,
    const CamParameters& par_camParameters)
  :   field_generationDeltaTime(par_generationDeltaTime),
  field_camParameters(par_camParameters)
{
  bound_flag = TRUE;
}

CoopAwareness::CoopAwareness(const CoopAwareness& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.CoopAwareness.");
bound_flag = TRUE;
if (other_value.generationDeltaTime().is_bound()) field_generationDeltaTime = other_value.generationDeltaTime();
else field_generationDeltaTime.clean_up();
if (other_value.camParameters().is_bound()) field_camParameters = other_value.camParameters();
else field_camParameters.clean_up();
}

void CoopAwareness::clean_up()
{
field_generationDeltaTime.clean_up();
field_camParameters.clean_up();
bound_flag = FALSE;
}

CoopAwareness& CoopAwareness::operator=(const CoopAwareness& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.CoopAwareness.");
  bound_flag = TRUE;
  if (other_value.generationDeltaTime().is_bound()) field_generationDeltaTime = other_value.generationDeltaTime();
  else field_generationDeltaTime.clean_up();
  if (other_value.camParameters().is_bound()) field_camParameters = other_value.camParameters();
  else field_camParameters.clean_up();
}
return *this;
}

boolean CoopAwareness::operator==(const CoopAwareness& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_generationDeltaTime==other_value.field_generationDeltaTime
  && field_camParameters==other_value.field_camParameters;
}

boolean CoopAwareness::is_bound() const
{
if (bound_flag) return TRUE;
if(field_generationDeltaTime.is_bound()) return TRUE;
if(field_camParameters.is_bound()) return TRUE;
return FALSE;
}
boolean CoopAwareness::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_generationDeltaTime.is_value()) return FALSE;
if(!field_camParameters.is_value()) return FALSE;
return TRUE;
}
int CoopAwareness::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.CoopAwareness");
  return 2;
}

void CoopAwareness::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ generationDeltaTime := ");
field_generationDeltaTime.log();
TTCN_Logger::log_event_str(", camParameters := ");
field_camParameters.log();
TTCN_Logger::log_event_str(" }");
}

void CoopAwareness::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.CoopAwareness'");
    }
    if (strcmp("generationDeltaTime", param_field) == 0) {
      generationDeltaTime().set_param(param);
      return;
    } else if (strcmp("camParameters", param_field) == 0) {
      camParameters().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.CoopAwareness'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.CoopAwareness has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) generationDeltaTime().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) camParameters().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "generationDeltaTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          generationDeltaTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "camParameters")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          camParameters().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.CoopAwareness: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.CoopAwareness");
  }
}

Module_Param* CoopAwareness::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.CoopAwareness'");
    }
    if (strcmp("generationDeltaTime", param_field) == 0) {
      return generationDeltaTime().get_param(param_name);
    } else if (strcmp("camParameters", param_field) == 0) {
      return camParameters().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.CoopAwareness'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_generationDeltaTime = field_generationDeltaTime.get_param(param_name);
  mp_field_generationDeltaTime->set_id(new Module_Param_FieldName(mcopystr("generationDeltaTime")));
  mp->add_elem(mp_field_generationDeltaTime);
  Module_Param* mp_field_camParameters = field_camParameters.get_param(param_name);
  mp_field_camParameters->set_id(new Module_Param_FieldName(mcopystr("camParameters")));
  mp->add_elem(mp_field_camParameters);
  return mp;
  }

void CoopAwareness::set_implicit_omit()
{
if (generationDeltaTime().is_bound()) generationDeltaTime().set_implicit_omit();
if (camParameters().is_bound()) camParameters().set_implicit_omit();
}

void CoopAwareness::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.CoopAwareness.");
field_generationDeltaTime.encode_text(text_buf);
field_camParameters.encode_text(text_buf);
}

void CoopAwareness::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_generationDeltaTime.decode_text(text_buf);
field_camParameters.decode_text(text_buf);
}

void CoopAwareness::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CoopAwareness::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* CoopAwareness::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("generationDeltaTime': ");
  new_tlv->add_TLV(field_generationDeltaTime.BER_encode_TLV(CoopAwareness_generationDeltaTime_descr_, p_coding));
  ec_1.set_msg("camParameters': ");
  new_tlv->add_TLV(field_camParameters.BER_encode_TLV(CoopAwareness_camParameters_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean CoopAwareness::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.CoopAwareness' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("generationDeltaTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_generationDeltaTime.BER_decode_TLV(CoopAwareness_generationDeltaTime_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("camParameters': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_camParameters.BER_decode_TLV(CoopAwareness_camParameters_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int CoopAwareness::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.CoopAwareness.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "generationDeltaTime");
    enc_len += field_generationDeltaTime.JSON_encode(CoopAwareness_generationDeltaTime_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "camParameters");
    enc_len += field_camParameters.JSON_encode(CoopAwareness_camParameters_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CoopAwareness::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (19 == name_len && 0 == strncmp(fld_name, "generationDeltaTime", name_len)) {
         int ret_val = field_generationDeltaTime.JSON_decode(CoopAwareness_generationDeltaTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "generationDeltaTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "camParameters", name_len)) {
         int ret_val = field_camParameters.JSON_decode(CoopAwareness_camParameters_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "camParameters");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_generationDeltaTime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "generationDeltaTime");
    return JSON_ERROR_FATAL;
  }
if (!field_camParameters.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "camParameters");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct CoopAwareness_template::single_value_struct {
INTEGER_template field_generationDeltaTime;
CamParameters_template field_camParameters;
};

void CoopAwareness_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_generationDeltaTime = ANY_VALUE;
single_value->field_camParameters = ANY_VALUE;
}
}
}

void CoopAwareness_template::copy_value(const CoopAwareness& other_value)
{
single_value = new single_value_struct;
if (other_value.generationDeltaTime().is_bound()) {
  single_value->field_generationDeltaTime = other_value.generationDeltaTime();
} else {
  single_value->field_generationDeltaTime.clean_up();
}
if (other_value.camParameters().is_bound()) {
  single_value->field_camParameters = other_value.camParameters();
} else {
  single_value->field_camParameters.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CoopAwareness_template::copy_template(const CoopAwareness_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.generationDeltaTime().get_selection()) {
single_value->field_generationDeltaTime = other_value.generationDeltaTime();
} else {
single_value->field_generationDeltaTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.camParameters().get_selection()) {
single_value->field_camParameters = other_value.camParameters();
} else {
single_value->field_camParameters.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CoopAwareness_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CoopAwareness.");
break;
}
set_selection(other_value);
}

CoopAwareness_template::CoopAwareness_template()
{
}

CoopAwareness_template::CoopAwareness_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CoopAwareness_template::CoopAwareness_template(const CoopAwareness& other_value)
{
copy_value(other_value);
}

CoopAwareness_template::CoopAwareness_template(const OPTIONAL<CoopAwareness>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoopAwareness&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.CoopAwareness from an unbound optional field.");
}
}

CoopAwareness_template::CoopAwareness_template(const CoopAwareness_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CoopAwareness_template::~CoopAwareness_template()
{
clean_up();
}

CoopAwareness_template& CoopAwareness_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CoopAwareness_template& CoopAwareness_template::operator=(const CoopAwareness& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CoopAwareness_template& CoopAwareness_template::operator=(const OPTIONAL<CoopAwareness>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoopAwareness&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.CoopAwareness.");
}
return *this;
}

CoopAwareness_template& CoopAwareness_template::operator=(const CoopAwareness_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CoopAwareness_template::match(const CoopAwareness& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.generationDeltaTime().is_bound()) return FALSE;
if(!single_value->field_generationDeltaTime.match(other_value.generationDeltaTime(), legacy))return FALSE;
if(!other_value.camParameters().is_bound()) return FALSE;
if(!single_value->field_camParameters.match(other_value.camParameters(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CoopAwareness.");
}
return FALSE;
}

boolean CoopAwareness_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_generationDeltaTime.is_bound()) return TRUE;
if (single_value->field_camParameters.is_bound()) return TRUE;
return FALSE;
}

boolean CoopAwareness_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_generationDeltaTime.is_value()) return FALSE;
if (!single_value->field_camParameters.is_value()) return FALSE;
return TRUE;
}

void CoopAwareness_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CoopAwareness CoopAwareness_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.CoopAwareness.");
CoopAwareness ret_val;
if (single_value->field_generationDeltaTime.is_bound()) {
ret_val.generationDeltaTime() = single_value->field_generationDeltaTime.valueof();
}
if (single_value->field_camParameters.is_bound()) {
ret_val.camParameters() = single_value->field_camParameters.valueof();
}
return ret_val;
}

void CoopAwareness_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.CoopAwareness.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CoopAwareness_template[list_length];
}

CoopAwareness_template& CoopAwareness_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.CoopAwareness.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.CoopAwareness.");
return value_list.list_value[list_index];
}

INTEGER_template& CoopAwareness_template::generationDeltaTime()
{
set_specific();
return single_value->field_generationDeltaTime;
}

const INTEGER_template& CoopAwareness_template::generationDeltaTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field generationDeltaTime of a non-specific template of type @CAM-PDU-Descriptions.CoopAwareness.");
return single_value->field_generationDeltaTime;
}

CamParameters_template& CoopAwareness_template::camParameters()
{
set_specific();
return single_value->field_camParameters;
}

const CamParameters_template& CoopAwareness_template::camParameters() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field camParameters of a non-specific template of type @CAM-PDU-Descriptions.CoopAwareness.");
return single_value->field_camParameters;
}

int CoopAwareness_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CoopAwareness which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CoopAwareness containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CoopAwareness containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CoopAwareness containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CoopAwareness containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CoopAwareness containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CoopAwareness.");
  }
  return 0;
}

void CoopAwareness_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ generationDeltaTime := ");
single_value->field_generationDeltaTime.log();
TTCN_Logger::log_event_str(", camParameters := ");
single_value->field_camParameters.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CoopAwareness_template::log_match(const CoopAwareness& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_generationDeltaTime.match(match_value.generationDeltaTime(), legacy)){
TTCN_Logger::log_logmatch_info(".generationDeltaTime");
single_value->field_generationDeltaTime.log_match(match_value.generationDeltaTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_camParameters.match(match_value.camParameters(), legacy)){
TTCN_Logger::log_logmatch_info(".camParameters");
single_value->field_camParameters.log_match(match_value.camParameters(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ generationDeltaTime := ");
single_value->field_generationDeltaTime.log_match(match_value.generationDeltaTime(), legacy);
TTCN_Logger::log_event_str(", camParameters := ");
single_value->field_camParameters.log_match(match_value.camParameters(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CoopAwareness_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_generationDeltaTime.encode_text(text_buf);
single_value->field_camParameters.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CoopAwareness.");
}
}

void CoopAwareness_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_generationDeltaTime.decode_text(text_buf);
single_value->field_camParameters.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CoopAwareness_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.CoopAwareness.");
}
}

void CoopAwareness_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.CoopAwareness'");
    }
    if (strcmp("generationDeltaTime", param_field) == 0) {
      generationDeltaTime().set_param(param);
      return;
    } else if (strcmp("camParameters", param_field) == 0) {
      camParameters().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.CoopAwareness'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CoopAwareness_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.CoopAwareness has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) generationDeltaTime().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) camParameters().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "generationDeltaTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          generationDeltaTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "camParameters")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          camParameters().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.CoopAwareness: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.CoopAwareness");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CoopAwareness_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.CoopAwareness'");
    }
    if (strcmp("generationDeltaTime", param_field) == 0) {
      return generationDeltaTime().get_param(param_name);
    } else if (strcmp("camParameters", param_field) == 0) {
      return camParameters().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.CoopAwareness'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_generationDeltaTime = single_value->field_generationDeltaTime.get_param(param_name);
    mp_field_generationDeltaTime->set_id(new Module_Param_FieldName(mcopystr("generationDeltaTime")));
    mp->add_elem(mp_field_generationDeltaTime);
    Module_Param* mp_field_camParameters = single_value->field_camParameters.get_param(param_name);
    mp_field_camParameters->set_id(new Module_Param_FieldName(mcopystr("camParameters")));
    mp->add_elem(mp_field_camParameters);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CoopAwareness_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_generationDeltaTime.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.CoopAwareness");
single_value->field_camParameters.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.CoopAwareness");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.CoopAwareness");
}

boolean CoopAwareness_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CoopAwareness_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

CAM::CAM()
{
  bound_flag = FALSE;
}

CAM::CAM(const ITS__Container::ItsPduHeader& par_header,
    const CoopAwareness& par_cam)
  :   field_header(par_header),
  field_cam(par_cam)
{
  bound_flag = TRUE;
}

CAM::CAM(const CAM& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CAM-PDU-Descriptions.CAM.");
bound_flag = TRUE;
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.cam().is_bound()) field_cam = other_value.cam();
else field_cam.clean_up();
}

void CAM::clean_up()
{
field_header.clean_up();
field_cam.clean_up();
bound_flag = FALSE;
}

CAM& CAM::operator=(const CAM& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CAM-PDU-Descriptions.CAM.");
  bound_flag = TRUE;
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.cam().is_bound()) field_cam = other_value.cam();
  else field_cam.clean_up();
}
return *this;
}

boolean CAM::operator==(const CAM& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_header==other_value.field_header
  && field_cam==other_value.field_cam;
}

boolean CAM::is_bound() const
{
if (bound_flag) return TRUE;
if(field_header.is_bound()) return TRUE;
if(field_cam.is_bound()) return TRUE;
return FALSE;
}
boolean CAM::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_header.is_value()) return FALSE;
if(!field_cam.is_value()) return FALSE;
return TRUE;
}
int CAM::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @CAM-PDU-Descriptions.CAM");
  return 2;
}

void CAM::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", cam := ");
field_cam.log();
TTCN_Logger::log_event_str(" }");
}

void CAM::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@CAM-PDU-Descriptions.CAM'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("cam", param_field) == 0) {
      cam().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@CAM-PDU-Descriptions.CAM'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @CAM-PDU-Descriptions.CAM has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) cam().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cam")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cam().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.CAM: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CAM-PDU-Descriptions.CAM");
  }
}

Module_Param* CAM::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@CAM-PDU-Descriptions.CAM'");
    }
    if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("cam", param_field) == 0) {
      return cam().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.CAM'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_header = field_header.get_param(param_name);
  mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
  mp->add_elem(mp_field_header);
  Module_Param* mp_field_cam = field_cam.get_param(param_name);
  mp_field_cam->set_id(new Module_Param_FieldName(mcopystr("cam")));
  mp->add_elem(mp_field_cam);
  return mp;
  }

void CAM::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (cam().is_bound()) cam().set_implicit_omit();
}

void CAM::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @CAM-PDU-Descriptions.CAM.");
field_header.encode_text(text_buf);
field_cam.encode_text(text_buf);
}

void CAM::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_header.decode_text(text_buf);
field_cam.decode_text(text_buf);
}

void CAM::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CAM::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* CAM::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("header': ");
  new_tlv->add_TLV(field_header.BER_encode_TLV(CAM_header_descr_, p_coding));
  ec_1.set_msg("cam': ");
  new_tlv->add_TLV(field_cam.BER_encode_TLV(CAM_cam_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean CAM::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@CAM-PDU-Descriptions.CAM' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("header': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_header.BER_decode_TLV(CAM_header_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("cam': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_cam.BER_decode_TLV(CAM_cam_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int CAM::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @CAM-PDU-Descriptions.CAM.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header");
    enc_len += field_header.JSON_encode(CAM_header_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "cam");
    enc_len += field_cam.JSON_encode(CAM_cam_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CAM::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "header", name_len)) {
         int ret_val = field_header.JSON_decode(CAM_header_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (3 == name_len && 0 == strncmp(fld_name, "cam", name_len)) {
         int ret_val = field_cam.JSON_decode(CAM_cam_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "cam");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_header.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header");
    return JSON_ERROR_FATAL;
  }
if (!field_cam.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "cam");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct CAM_template::single_value_struct {
ITS__Container::ItsPduHeader_template field_header;
CoopAwareness_template field_cam;
};

void CAM_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_cam = ANY_VALUE;
}
}
}

void CAM_template::copy_value(const CAM& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.cam().is_bound()) {
  single_value->field_cam = other_value.cam();
} else {
  single_value->field_cam.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CAM_template::copy_template(const CAM_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cam().get_selection()) {
single_value->field_cam = other_value.cam();
} else {
single_value->field_cam.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CAM_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CAM.");
break;
}
set_selection(other_value);
}

CAM_template::CAM_template()
{
}

CAM_template::CAM_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CAM_template::CAM_template(const CAM& other_value)
{
copy_value(other_value);
}

CAM_template::CAM_template(const OPTIONAL<CAM>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CAM&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CAM-PDU-Descriptions.CAM from an unbound optional field.");
}
}

CAM_template::CAM_template(const CAM_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CAM_template::~CAM_template()
{
clean_up();
}

CAM_template& CAM_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CAM_template& CAM_template::operator=(const CAM& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CAM_template& CAM_template::operator=(const OPTIONAL<CAM>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CAM&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CAM-PDU-Descriptions.CAM.");
}
return *this;
}

CAM_template& CAM_template::operator=(const CAM_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CAM_template::match(const CAM& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.cam().is_bound()) return FALSE;
if(!single_value->field_cam.match(other_value.cam(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CAM.");
}
return FALSE;
}

boolean CAM_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_cam.is_bound()) return TRUE;
return FALSE;
}

boolean CAM_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_cam.is_value()) return FALSE;
return TRUE;
}

void CAM_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CAM CAM_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @CAM-PDU-Descriptions.CAM.");
CAM ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_cam.is_bound()) {
ret_val.cam() = single_value->field_cam.valueof();
}
return ret_val;
}

void CAM_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CAM-PDU-Descriptions.CAM.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CAM_template[list_length];
}

CAM_template& CAM_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CAM-PDU-Descriptions.CAM.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CAM-PDU-Descriptions.CAM.");
return value_list.list_value[list_index];
}

ITS__Container::ItsPduHeader_template& CAM_template::header()
{
set_specific();
return single_value->field_header;
}

const ITS__Container::ItsPduHeader_template& CAM_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @CAM-PDU-Descriptions.CAM.");
return single_value->field_header;
}

CoopAwareness_template& CAM_template::cam()
{
set_specific();
return single_value->field_cam;
}

const CoopAwareness_template& CAM_template::cam() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cam of a non-specific template of type @CAM-PDU-Descriptions.CAM.");
return single_value->field_cam;
}

int CAM_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CAM which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CAM containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CAM containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CAM containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CAM containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CAM-PDU-Descriptions.CAM containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CAM.");
  }
  return 0;
}

void CAM_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", cam := ");
single_value->field_cam.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CAM_template::log_match(const CAM& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_cam.match(match_value.cam(), legacy)){
TTCN_Logger::log_logmatch_info(".cam");
single_value->field_cam.log_match(match_value.cam(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", cam := ");
single_value->field_cam.log_match(match_value.cam(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CAM_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_cam.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CAM-PDU-Descriptions.CAM.");
}
}

void CAM_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_cam.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CAM_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CAM-PDU-Descriptions.CAM.");
}
}

void CAM_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@CAM-PDU-Descriptions.CAM'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("cam", param_field) == 0) {
      cam().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@CAM-PDU-Descriptions.CAM'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CAM_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @CAM-PDU-Descriptions.CAM has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) cam().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cam")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cam().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @CAM-PDU-Descriptions.CAM: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CAM-PDU-Descriptions.CAM");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CAM_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@CAM-PDU-Descriptions.CAM'");
    }
    if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("cam", param_field) == 0) {
      return cam().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@CAM-PDU-Descriptions.CAM'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_header = single_value->field_header.get_param(param_name);
    mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
    mp->add_elem(mp_field_header);
    Module_Param* mp_field_cam = single_value->field_cam.get_param(param_name);
    mp_field_cam->set_id(new Module_Param_FieldName(mcopystr("cam")));
    mp->add_elem(mp_field_cam);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CAM_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.CAM");
single_value->field_cam.check_restriction(t_res, t_name ? t_name : "@CAM-PDU-Descriptions.CAM");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CAM-PDU-Descriptions.CAM");
}

boolean CAM_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CAM_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("CAM.asn", 0, TTCN_Location::LOCATION_UNKNOWN, "CAM-PDU-Descriptions");
ITS__Container::module_object.pre_init_module();
}


} /* end of namespace */
