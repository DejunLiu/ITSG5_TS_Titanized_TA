// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef LibItsSecurity__TypesAndValues_HH
#define LibItsSecurity__TypesAndValues_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "LibCommon_BasicTypesAndValues.hh"
#include "LibCommon_DataStrings.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef LibItsSecurity__TypesAndValues_HH
#endif

namespace LibItsSecurity__TypesAndValues {

/* Forward declarations of classes */

class PublicKeyAlgorithm;
class PublicKeyAlgorithm_template;
class SymmetricAlgorithm;
class SymmetricAlgorithm_template;
class PublicKeyContainer;
class PublicKeyContainer_template;
class EccPointType;
class EccPointType_template;
class EccPoint;
class EccPoint_template;
class EccPointContainer;
class EccPointContainer_template;
class AesCcm;
class AesCcm_template;
class PublicKey;
class PublicKey_template;
class EncryptionParametersContainer;
class EncryptionParametersContainer_template;
class EncryptionParameters;
class EncryptionParameters_template;
class SignatureContainer;
class SignatureContainer_template;
class EcdsaSignature;
class EcdsaSignature_template;
class Signature;
class Signature_template;
class SignerInfoType;
class SignerInfoType_template;
class SignerInfo;
class SignerInfo_template;
class SignerInfoContainer;
class SignerInfoContainer_template;
class SubjectType;
class SubjectType_template;
class SubjectInfo;
class SubjectInfo_template;
class SubjectAttributes;
class SubjectAttributes_template;
class SubjectAttributeType;
class SubjectAttributeType_template;
class SubjectAttributeContainer;
class SubjectAttributeContainer_template;
class SubjectAssurance;
class SubjectAssurance_template;
typedef PreGenRecordOf::PREGEN__SET__OF__INTEGER IntXs;
typedef PreGenRecordOf::PREGEN__SET__OF__INTEGER_template IntXs_template;
class ItsAidSsps;
class ItsAidSsps_template;
class ServiceSpecificPermissions;
class ServiceSpecificPermissions_template;
class ServiceSpecificPermissionsContainer;
class ServiceSpecificPermissionsContainer_template;
class SspCAM;
class SspCAM_template;
class SspDENM;
class SspDENM_template;
class ItsAidSsp;
class ItsAidSsp_template;
class SubjectAttribute;
class SubjectAttribute_template;
class ValidityRestrictions;
class ValidityRestrictions_template;
class ValidityRestrictionType;
class ValidityRestrictionType_template;
class ValidityRestrictionContainer;
class ValidityRestrictionContainer_template;
class TimeStartEnd;
class TimeStartEnd_template;
class DurationUnitType;
class DurationUnitType_template;
class Duration;
class Duration_template;
class TimeDuration;
class TimeDuration_template;
class RegionType;
class RegionType_template;
class GeographicRegion;
class GeographicRegion_template;
class GeographicRegionContainer;
class GeographicRegionContainer_template;
class TwoDLocation;
class TwoDLocation_template;
class CircularRegion;
class CircularRegion_template;
class RectangularRegions;
class RectangularRegions_template;
class RectangularRegion;
class RectangularRegion_template;
class PolygonalRegion;
class PolygonalRegion_template;
class RegionDictionary;
class RegionDictionary_template;
class IdentifiedRegion;
class IdentifiedRegion_template;
class ValidityRestriction;
class ValidityRestriction_template;
class Certificate;
class Certificate_template;
class CertificateChain;
class CertificateChain_template;
class CertificateWithAlgo;
class CertificateWithAlgo_template;
class Time64WithStandardDeviation;
class Time64WithStandardDeviation_template;
class ThreeDLocation;
class ThreeDLocation_template;
class ThreeDLocations;
class ThreeDLocations_template;
typedef PreGenRecordOf::PREGEN__SET__OF__INTEGER RegionIdentifiers;
typedef PreGenRecordOf::PREGEN__SET__OF__INTEGER_template RegionIdentifiers_template;
class HeaderFields;
class HeaderFields_template;
class HeaderFieldType;
class HeaderFieldType_template;
class HeaderFieldContainer;
class HeaderFieldContainer_template;
typedef PreGenRecordOf::PREGEN__SET__OF__OCTETSTRING HashedId3s;
typedef PreGenRecordOf::PREGEN__SET__OF__OCTETSTRING_template HashedId3s_template;
class RecipientInfos;
class RecipientInfos_template;
class RecipientInfoContainer;
class RecipientInfoContainer_template;
class EciesEncryptedKey;
class EciesEncryptedKey_template;
class RecipientInfo;
class RecipientInfo_template;
class HeaderField;
class HeaderField_template;
class SecPayloadType;
class SecPayloadType_template;
class SecPayload;
class SecPayload_template;
class TrailerFieldType;
class TrailerFieldType_template;
class ToBeSignedSecuredMessage;
class ToBeSignedSecuredMessage_template;
class TrailerFields;
class TrailerFields_template;
class TrailerFieldContainer;
class TrailerFieldContainer_template;
class TrailerField;
class TrailerField_template;
class SecuredMessage;
class SecuredMessage_template;
class ToBeSignedCertificate;
class ToBeSignedCertificate_template;
class TaConfig;
class TaConfig_template;
class TaConfigs;
class TaConfigs_template;
class AcEnableSecurity;
class AcEnableSecurity_template;
class AcDisableSecurity;
class AcDisableSecurity_template;

} /* end of namespace */

#ifndef LibItsSecurity__TypesAndValues_HH
#define LibItsSecurity__TypesAndValues_HH

namespace LibItsSecurity__TypesAndValues {

/* Type definitions */

typedef INTEGER IntX;
typedef INTEGER_template IntX_template;
typedef OCTETSTRING HashedId8;
typedef OCTETSTRING_template HashedId8_template;
typedef INTEGER Time32;
typedef INTEGER_template Time32_template;
typedef INTEGER WGSLatitude;
typedef INTEGER_template WGSLatitude_template;
typedef INTEGER WGSLongitude;
typedef INTEGER_template WGSLongitude_template;
typedef OCTETSTRING HashedId3;
typedef OCTETSTRING_template HashedId3_template;
typedef INTEGER Time64;
typedef INTEGER_template Time64_template;

/* Class definitions */

class PublicKeyAlgorithm : public Base_Type { // enum
friend class PublicKeyAlgorithm_template;
public:
enum enum_type { e__ecdsa__nistp256__with__sha256 = 0, e__ecies__nistp256 = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
PublicKeyAlgorithm();
PublicKeyAlgorithm(int other_value);
PublicKeyAlgorithm(enum_type other_value);
PublicKeyAlgorithm(const PublicKeyAlgorithm& other_value);

PublicKeyAlgorithm& operator=(int other_value);
PublicKeyAlgorithm& operator=(enum_type other_value);
PublicKeyAlgorithm& operator=(const PublicKeyAlgorithm& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const PublicKeyAlgorithm& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PublicKeyAlgorithm& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const PublicKeyAlgorithm& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const PublicKeyAlgorithm& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const PublicKeyAlgorithm& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const PublicKeyAlgorithm& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const PublicKeyAlgorithm& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PublicKeyAlgorithm_template : public Base_Template {
union {
PublicKeyAlgorithm::enum_type single_value;
struct {
unsigned int n_values;
PublicKeyAlgorithm_template *list_value;
} value_list;
};

void copy_template(const PublicKeyAlgorithm_template& other_value);

public:
PublicKeyAlgorithm_template();
PublicKeyAlgorithm_template(template_sel other_value);
PublicKeyAlgorithm_template(int other_value);
PublicKeyAlgorithm_template(PublicKeyAlgorithm::enum_type other_value);
PublicKeyAlgorithm_template(const PublicKeyAlgorithm& other_value);
PublicKeyAlgorithm_template(const OPTIONAL<PublicKeyAlgorithm>& other_value);
PublicKeyAlgorithm_template(const PublicKeyAlgorithm_template& other_value);
~PublicKeyAlgorithm_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
PublicKeyAlgorithm_template& operator=(template_sel other_value);
PublicKeyAlgorithm_template& operator=(int other_value);
PublicKeyAlgorithm_template& operator=(PublicKeyAlgorithm::enum_type other_value);
PublicKeyAlgorithm_template& operator=(const PublicKeyAlgorithm& other_value);
PublicKeyAlgorithm_template& operator=(const OPTIONAL<PublicKeyAlgorithm>& other_value);
PublicKeyAlgorithm_template& operator=(const PublicKeyAlgorithm_template& other_value);

boolean match(PublicKeyAlgorithm::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const PublicKeyAlgorithm& other_value, boolean legacy = FALSE) const;
PublicKeyAlgorithm::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PublicKeyAlgorithm_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PublicKeyAlgorithm& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SymmetricAlgorithm : public Base_Type { // enum
friend class SymmetricAlgorithm_template;
public:
enum enum_type { e__aes__128__ccm = 0, UNKNOWN_VALUE = 1, UNBOUND_VALUE = 2 };
private:
enum_type enum_value;

public:
SymmetricAlgorithm();
SymmetricAlgorithm(int other_value);
SymmetricAlgorithm(enum_type other_value);
SymmetricAlgorithm(const SymmetricAlgorithm& other_value);

SymmetricAlgorithm& operator=(int other_value);
SymmetricAlgorithm& operator=(enum_type other_value);
SymmetricAlgorithm& operator=(const SymmetricAlgorithm& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SymmetricAlgorithm& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SymmetricAlgorithm& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SymmetricAlgorithm& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SymmetricAlgorithm& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SymmetricAlgorithm& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SymmetricAlgorithm& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SymmetricAlgorithm& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SymmetricAlgorithm_template : public Base_Template {
union {
SymmetricAlgorithm::enum_type single_value;
struct {
unsigned int n_values;
SymmetricAlgorithm_template *list_value;
} value_list;
};

void copy_template(const SymmetricAlgorithm_template& other_value);

public:
SymmetricAlgorithm_template();
SymmetricAlgorithm_template(template_sel other_value);
SymmetricAlgorithm_template(int other_value);
SymmetricAlgorithm_template(SymmetricAlgorithm::enum_type other_value);
SymmetricAlgorithm_template(const SymmetricAlgorithm& other_value);
SymmetricAlgorithm_template(const OPTIONAL<SymmetricAlgorithm>& other_value);
SymmetricAlgorithm_template(const SymmetricAlgorithm_template& other_value);
~SymmetricAlgorithm_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SymmetricAlgorithm_template& operator=(template_sel other_value);
SymmetricAlgorithm_template& operator=(int other_value);
SymmetricAlgorithm_template& operator=(SymmetricAlgorithm::enum_type other_value);
SymmetricAlgorithm_template& operator=(const SymmetricAlgorithm& other_value);
SymmetricAlgorithm_template& operator=(const OPTIONAL<SymmetricAlgorithm>& other_value);
SymmetricAlgorithm_template& operator=(const SymmetricAlgorithm_template& other_value);

boolean match(SymmetricAlgorithm::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SymmetricAlgorithm& other_value, boolean legacy = FALSE) const;
SymmetricAlgorithm::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SymmetricAlgorithm_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SymmetricAlgorithm& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class PublicKeyContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_eccPoint = 1, ALT_aesCcm = 2, ALT_other__key = 3 };
private:
union_selection_type union_selection;
union {
EccPoint *field_eccPoint;
AesCcm *field_aesCcm;
OCTETSTRING *field_other__key;
};
void copy_value(const PublicKeyContainer& other_value);

public:
PublicKeyContainer();
PublicKeyContainer(const PublicKeyContainer& other_value);
~PublicKeyContainer();
PublicKeyContainer& operator=(const PublicKeyContainer& other_value);
boolean operator==(const PublicKeyContainer& other_value) const;
inline boolean operator!=(const PublicKeyContainer& other_value) const { return !(*this == other_value); }
EccPoint& eccPoint();
const EccPoint& eccPoint() const;
AesCcm& aesCcm();
const AesCcm& aesCcm() const;
OCTETSTRING& other__key();
const OCTETSTRING& other__key() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PublicKeyContainer_template : public Base_Template {
union {
struct {
PublicKeyContainer::union_selection_type union_selection;
union {
EccPoint_template *field_eccPoint;
AesCcm_template *field_aesCcm;
OCTETSTRING_template *field_other__key;
};
} single_value;
struct {
unsigned int n_values;
PublicKeyContainer_template *list_value;
} value_list;
};
void copy_value(const PublicKeyContainer& other_value);

void copy_template(const PublicKeyContainer_template& other_value);

public:
PublicKeyContainer_template();
PublicKeyContainer_template(template_sel other_value);
PublicKeyContainer_template(const PublicKeyContainer& other_value);
PublicKeyContainer_template(const OPTIONAL<PublicKeyContainer>& other_value);
PublicKeyContainer_template(const PublicKeyContainer_template& other_value);
~PublicKeyContainer_template();
void clean_up();
PublicKeyContainer_template& operator=(template_sel other_value);
PublicKeyContainer_template& operator=(const PublicKeyContainer& other_value);
PublicKeyContainer_template& operator=(const OPTIONAL<PublicKeyContainer>& other_value);
PublicKeyContainer_template& operator=(const PublicKeyContainer_template& other_value);
boolean match(const PublicKeyContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;PublicKeyContainer valueof() const;
PublicKeyContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
EccPoint_template& eccPoint();
const EccPoint_template& eccPoint() const;
AesCcm_template& aesCcm();
const AesCcm_template& aesCcm() const;
OCTETSTRING_template& other__key();
const OCTETSTRING_template& other__key() const;
boolean ischosen(PublicKeyContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const PublicKeyContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class EccPointType : public Base_Type { // enum
friend class EccPointType_template;
public:
enum enum_type { e__x__coordinate__only = 0, e__compressed__lsb__y__0 = 2, e__compressed__lsb__y__1 = 3, e__uncompressed = 4, UNKNOWN_VALUE = 1, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
EccPointType();
EccPointType(int other_value);
EccPointType(enum_type other_value);
EccPointType(const EccPointType& other_value);

EccPointType& operator=(int other_value);
EccPointType& operator=(enum_type other_value);
EccPointType& operator=(const EccPointType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const EccPointType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const EccPointType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const EccPointType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const EccPointType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const EccPointType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const EccPointType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const EccPointType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EccPointType_template : public Base_Template {
union {
EccPointType::enum_type single_value;
struct {
unsigned int n_values;
EccPointType_template *list_value;
} value_list;
};

void copy_template(const EccPointType_template& other_value);

public:
EccPointType_template();
EccPointType_template(template_sel other_value);
EccPointType_template(int other_value);
EccPointType_template(EccPointType::enum_type other_value);
EccPointType_template(const EccPointType& other_value);
EccPointType_template(const OPTIONAL<EccPointType>& other_value);
EccPointType_template(const EccPointType_template& other_value);
~EccPointType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
EccPointType_template& operator=(template_sel other_value);
EccPointType_template& operator=(int other_value);
EccPointType_template& operator=(EccPointType::enum_type other_value);
EccPointType_template& operator=(const EccPointType& other_value);
EccPointType_template& operator=(const OPTIONAL<EccPointType>& other_value);
EccPointType_template& operator=(const EccPointType_template& other_value);

boolean match(EccPointType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const EccPointType& other_value, boolean legacy = FALSE) const;
EccPointType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EccPointType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const EccPointType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class EccPoint : public Base_Type {
  EccPointType field_type__;
  OCTETSTRING field_x;
  OPTIONAL<EccPointContainer> field_y;
  boolean bound_flag;
public:
  EccPoint();
  EccPoint(const EccPointType& par_type__,
    const OCTETSTRING& par_x,
    const OPTIONAL<EccPointContainer>& par_y);
  EccPoint(const EccPoint& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EccPoint& operator=(const EccPoint& other_value);
  boolean operator==(const EccPoint& other_value) const;
  inline boolean operator!=(const EccPoint& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline EccPointType& type__()
    {return field_type__;}
  inline const EccPointType& type__() const
    {return field_type__;}
  inline OCTETSTRING& x()
    {return field_x;}
  inline const OCTETSTRING& x() const
    {return field_x;}
  inline OPTIONAL<EccPointContainer>& y()
    {return field_y;}
  inline const OPTIONAL<EccPointContainer>& y() const
    {return field_y;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EccPoint_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EccPoint_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EccPoint& other_value);
void copy_template(const EccPoint_template& other_value);

public:
EccPoint_template();
EccPoint_template(template_sel other_value);
EccPoint_template(const EccPoint& other_value);
EccPoint_template(const OPTIONAL<EccPoint>& other_value);
EccPoint_template(const EccPoint_template& other_value);
~EccPoint_template();
EccPoint_template& operator=(template_sel other_value);
EccPoint_template& operator=(const EccPoint& other_value);
EccPoint_template& operator=(const OPTIONAL<EccPoint>& other_value);
EccPoint_template& operator=(const EccPoint_template& other_value);
boolean match(const EccPoint& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EccPoint valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EccPoint_template& list_item(unsigned int list_index) const;
EccPointType_template& type__();
const EccPointType_template& type__() const;
OCTETSTRING_template& x();
const OCTETSTRING_template& x() const;
EccPointContainer_template& y();
const EccPointContainer_template& y() const;
int size_of() const;
void log() const;
void log_match(const EccPoint& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EccPointContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_y = 1, ALT_data = 2 };
private:
union_selection_type union_selection;
union {
OCTETSTRING *field_y;
OCTETSTRING *field_data;
};
void copy_value(const EccPointContainer& other_value);

public:
EccPointContainer();
EccPointContainer(const EccPointContainer& other_value);
~EccPointContainer();
EccPointContainer& operator=(const EccPointContainer& other_value);
boolean operator==(const EccPointContainer& other_value) const;
inline boolean operator!=(const EccPointContainer& other_value) const { return !(*this == other_value); }
OCTETSTRING& y();
const OCTETSTRING& y() const;
OCTETSTRING& data();
const OCTETSTRING& data() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EccPointContainer_template : public Base_Template {
union {
struct {
EccPointContainer::union_selection_type union_selection;
union {
OCTETSTRING_template *field_y;
OCTETSTRING_template *field_data;
};
} single_value;
struct {
unsigned int n_values;
EccPointContainer_template *list_value;
} value_list;
};
void copy_value(const EccPointContainer& other_value);

void copy_template(const EccPointContainer_template& other_value);

public:
EccPointContainer_template();
EccPointContainer_template(template_sel other_value);
EccPointContainer_template(const EccPointContainer& other_value);
EccPointContainer_template(const OPTIONAL<EccPointContainer>& other_value);
EccPointContainer_template(const EccPointContainer_template& other_value);
~EccPointContainer_template();
void clean_up();
EccPointContainer_template& operator=(template_sel other_value);
EccPointContainer_template& operator=(const EccPointContainer& other_value);
EccPointContainer_template& operator=(const OPTIONAL<EccPointContainer>& other_value);
EccPointContainer_template& operator=(const EccPointContainer_template& other_value);
boolean match(const EccPointContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;EccPointContainer valueof() const;
EccPointContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
OCTETSTRING_template& y();
const OCTETSTRING_template& y() const;
OCTETSTRING_template& data();
const OCTETSTRING_template& data() const;
boolean ischosen(EccPointContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const EccPointContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AesCcm : public Base_Type {
  SymmetricAlgorithm field_supported__symm__alg;
  EccPoint field_eccPoint;
  boolean bound_flag;
public:
  AesCcm();
  AesCcm(const SymmetricAlgorithm& par_supported__symm__alg,
    const EccPoint& par_eccPoint);
  AesCcm(const AesCcm& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AesCcm& operator=(const AesCcm& other_value);
  boolean operator==(const AesCcm& other_value) const;
  inline boolean operator!=(const AesCcm& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline SymmetricAlgorithm& supported__symm__alg()
    {return field_supported__symm__alg;}
  inline const SymmetricAlgorithm& supported__symm__alg() const
    {return field_supported__symm__alg;}
  inline EccPoint& eccPoint()
    {return field_eccPoint;}
  inline const EccPoint& eccPoint() const
    {return field_eccPoint;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AesCcm_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AesCcm_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AesCcm& other_value);
void copy_template(const AesCcm_template& other_value);

public:
AesCcm_template();
AesCcm_template(template_sel other_value);
AesCcm_template(const AesCcm& other_value);
AesCcm_template(const OPTIONAL<AesCcm>& other_value);
AesCcm_template(const AesCcm_template& other_value);
~AesCcm_template();
AesCcm_template& operator=(template_sel other_value);
AesCcm_template& operator=(const AesCcm& other_value);
AesCcm_template& operator=(const OPTIONAL<AesCcm>& other_value);
AesCcm_template& operator=(const AesCcm_template& other_value);
boolean match(const AesCcm& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AesCcm valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AesCcm_template& list_item(unsigned int list_index) const;
SymmetricAlgorithm_template& supported__symm__alg();
const SymmetricAlgorithm_template& supported__symm__alg() const;
EccPoint_template& eccPoint();
const EccPoint_template& eccPoint() const;
int size_of() const;
void log() const;
void log_match(const AesCcm& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PublicKey : public Base_Type {
  PublicKeyAlgorithm field_algorithm;
  PublicKeyContainer field_public__key;
  boolean bound_flag;
public:
  PublicKey();
  PublicKey(const PublicKeyAlgorithm& par_algorithm,
    const PublicKeyContainer& par_public__key);
  PublicKey(const PublicKey& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PublicKey& operator=(const PublicKey& other_value);
  boolean operator==(const PublicKey& other_value) const;
  inline boolean operator!=(const PublicKey& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline PublicKeyAlgorithm& algorithm()
    {return field_algorithm;}
  inline const PublicKeyAlgorithm& algorithm() const
    {return field_algorithm;}
  inline PublicKeyContainer& public__key()
    {return field_public__key;}
  inline const PublicKeyContainer& public__key() const
    {return field_public__key;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PublicKey_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PublicKey_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PublicKey& other_value);
void copy_template(const PublicKey_template& other_value);

public:
PublicKey_template();
PublicKey_template(template_sel other_value);
PublicKey_template(const PublicKey& other_value);
PublicKey_template(const OPTIONAL<PublicKey>& other_value);
PublicKey_template(const PublicKey_template& other_value);
~PublicKey_template();
PublicKey_template& operator=(template_sel other_value);
PublicKey_template& operator=(const PublicKey& other_value);
PublicKey_template& operator=(const OPTIONAL<PublicKey>& other_value);
PublicKey_template& operator=(const PublicKey_template& other_value);
boolean match(const PublicKey& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PublicKey valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PublicKey_template& list_item(unsigned int list_index) const;
PublicKeyAlgorithm_template& algorithm();
const PublicKeyAlgorithm_template& algorithm() const;
PublicKeyContainer_template& public__key();
const PublicKeyContainer_template& public__key() const;
int size_of() const;
void log() const;
void log_match(const PublicKey& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EncryptionParametersContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nonce = 1, ALT_params = 2 };
private:
union_selection_type union_selection;
union {
OCTETSTRING *field_nonce;
OCTETSTRING *field_params;
};
void copy_value(const EncryptionParametersContainer& other_value);

public:
EncryptionParametersContainer();
EncryptionParametersContainer(const EncryptionParametersContainer& other_value);
~EncryptionParametersContainer();
EncryptionParametersContainer& operator=(const EncryptionParametersContainer& other_value);
boolean operator==(const EncryptionParametersContainer& other_value) const;
inline boolean operator!=(const EncryptionParametersContainer& other_value) const { return !(*this == other_value); }
OCTETSTRING& nonce();
const OCTETSTRING& nonce() const;
OCTETSTRING& params();
const OCTETSTRING& params() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EncryptionParametersContainer_template : public Base_Template {
union {
struct {
EncryptionParametersContainer::union_selection_type union_selection;
union {
OCTETSTRING_template *field_nonce;
OCTETSTRING_template *field_params;
};
} single_value;
struct {
unsigned int n_values;
EncryptionParametersContainer_template *list_value;
} value_list;
};
void copy_value(const EncryptionParametersContainer& other_value);

void copy_template(const EncryptionParametersContainer_template& other_value);

public:
EncryptionParametersContainer_template();
EncryptionParametersContainer_template(template_sel other_value);
EncryptionParametersContainer_template(const EncryptionParametersContainer& other_value);
EncryptionParametersContainer_template(const OPTIONAL<EncryptionParametersContainer>& other_value);
EncryptionParametersContainer_template(const EncryptionParametersContainer_template& other_value);
~EncryptionParametersContainer_template();
void clean_up();
EncryptionParametersContainer_template& operator=(template_sel other_value);
EncryptionParametersContainer_template& operator=(const EncryptionParametersContainer& other_value);
EncryptionParametersContainer_template& operator=(const OPTIONAL<EncryptionParametersContainer>& other_value);
EncryptionParametersContainer_template& operator=(const EncryptionParametersContainer_template& other_value);
boolean match(const EncryptionParametersContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;EncryptionParametersContainer valueof() const;
EncryptionParametersContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
OCTETSTRING_template& nonce();
const OCTETSTRING_template& nonce() const;
OCTETSTRING_template& params();
const OCTETSTRING_template& params() const;
boolean ischosen(EncryptionParametersContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const EncryptionParametersContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class EncryptionParameters : public Base_Type {
  SymmetricAlgorithm field_symm__algorithm;
  EncryptionParametersContainer field_public__key;
  boolean bound_flag;
public:
  EncryptionParameters();
  EncryptionParameters(const SymmetricAlgorithm& par_symm__algorithm,
    const EncryptionParametersContainer& par_public__key);
  EncryptionParameters(const EncryptionParameters& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EncryptionParameters& operator=(const EncryptionParameters& other_value);
  boolean operator==(const EncryptionParameters& other_value) const;
  inline boolean operator!=(const EncryptionParameters& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline SymmetricAlgorithm& symm__algorithm()
    {return field_symm__algorithm;}
  inline const SymmetricAlgorithm& symm__algorithm() const
    {return field_symm__algorithm;}
  inline EncryptionParametersContainer& public__key()
    {return field_public__key;}
  inline const EncryptionParametersContainer& public__key() const
    {return field_public__key;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EncryptionParameters_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EncryptionParameters_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EncryptionParameters& other_value);
void copy_template(const EncryptionParameters_template& other_value);

public:
EncryptionParameters_template();
EncryptionParameters_template(template_sel other_value);
EncryptionParameters_template(const EncryptionParameters& other_value);
EncryptionParameters_template(const OPTIONAL<EncryptionParameters>& other_value);
EncryptionParameters_template(const EncryptionParameters_template& other_value);
~EncryptionParameters_template();
EncryptionParameters_template& operator=(template_sel other_value);
EncryptionParameters_template& operator=(const EncryptionParameters& other_value);
EncryptionParameters_template& operator=(const OPTIONAL<EncryptionParameters>& other_value);
EncryptionParameters_template& operator=(const EncryptionParameters_template& other_value);
boolean match(const EncryptionParameters& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EncryptionParameters valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EncryptionParameters_template& list_item(unsigned int list_index) const;
SymmetricAlgorithm_template& symm__algorithm();
const SymmetricAlgorithm_template& symm__algorithm() const;
EncryptionParametersContainer_template& public__key();
const EncryptionParametersContainer_template& public__key() const;
int size_of() const;
void log() const;
void log_match(const EncryptionParameters& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SignatureContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_ecdsa__signature = 1, ALT_signature__ = 2 };
private:
union_selection_type union_selection;
union {
EcdsaSignature *field_ecdsa__signature;
OCTETSTRING *field_signature__;
};
void copy_value(const SignatureContainer& other_value);

public:
SignatureContainer();
SignatureContainer(const SignatureContainer& other_value);
~SignatureContainer();
SignatureContainer& operator=(const SignatureContainer& other_value);
boolean operator==(const SignatureContainer& other_value) const;
inline boolean operator!=(const SignatureContainer& other_value) const { return !(*this == other_value); }
EcdsaSignature& ecdsa__signature();
const EcdsaSignature& ecdsa__signature() const;
OCTETSTRING& signature__();
const OCTETSTRING& signature__() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SignatureContainer_template : public Base_Template {
union {
struct {
SignatureContainer::union_selection_type union_selection;
union {
EcdsaSignature_template *field_ecdsa__signature;
OCTETSTRING_template *field_signature__;
};
} single_value;
struct {
unsigned int n_values;
SignatureContainer_template *list_value;
} value_list;
};
void copy_value(const SignatureContainer& other_value);

void copy_template(const SignatureContainer_template& other_value);

public:
SignatureContainer_template();
SignatureContainer_template(template_sel other_value);
SignatureContainer_template(const SignatureContainer& other_value);
SignatureContainer_template(const OPTIONAL<SignatureContainer>& other_value);
SignatureContainer_template(const SignatureContainer_template& other_value);
~SignatureContainer_template();
void clean_up();
SignatureContainer_template& operator=(template_sel other_value);
SignatureContainer_template& operator=(const SignatureContainer& other_value);
SignatureContainer_template& operator=(const OPTIONAL<SignatureContainer>& other_value);
SignatureContainer_template& operator=(const SignatureContainer_template& other_value);
boolean match(const SignatureContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;SignatureContainer valueof() const;
SignatureContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
EcdsaSignature_template& ecdsa__signature();
const EcdsaSignature_template& ecdsa__signature() const;
OCTETSTRING_template& signature__();
const OCTETSTRING_template& signature__() const;
boolean ischosen(SignatureContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const SignatureContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class EcdsaSignature : public Base_Type {
  EccPoint field_r;
  OCTETSTRING field_s;
  boolean bound_flag;
public:
  EcdsaSignature();
  EcdsaSignature(const EccPoint& par_r,
    const OCTETSTRING& par_s);
  EcdsaSignature(const EcdsaSignature& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EcdsaSignature& operator=(const EcdsaSignature& other_value);
  boolean operator==(const EcdsaSignature& other_value) const;
  inline boolean operator!=(const EcdsaSignature& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline EccPoint& r()
    {return field_r;}
  inline const EccPoint& r() const
    {return field_r;}
  inline OCTETSTRING& s()
    {return field_s;}
  inline const OCTETSTRING& s() const
    {return field_s;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EcdsaSignature_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EcdsaSignature_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EcdsaSignature& other_value);
void copy_template(const EcdsaSignature_template& other_value);

public:
EcdsaSignature_template();
EcdsaSignature_template(template_sel other_value);
EcdsaSignature_template(const EcdsaSignature& other_value);
EcdsaSignature_template(const OPTIONAL<EcdsaSignature>& other_value);
EcdsaSignature_template(const EcdsaSignature_template& other_value);
~EcdsaSignature_template();
EcdsaSignature_template& operator=(template_sel other_value);
EcdsaSignature_template& operator=(const EcdsaSignature& other_value);
EcdsaSignature_template& operator=(const OPTIONAL<EcdsaSignature>& other_value);
EcdsaSignature_template& operator=(const EcdsaSignature_template& other_value);
boolean match(const EcdsaSignature& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EcdsaSignature valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EcdsaSignature_template& list_item(unsigned int list_index) const;
EccPoint_template& r();
const EccPoint_template& r() const;
OCTETSTRING_template& s();
const OCTETSTRING_template& s() const;
int size_of() const;
void log() const;
void log_match(const EcdsaSignature& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Signature : public Base_Type {
  PublicKeyAlgorithm field_algorithm;
  SignatureContainer field_signature__;
  boolean bound_flag;
public:
  Signature();
  Signature(const PublicKeyAlgorithm& par_algorithm,
    const SignatureContainer& par_signature__);
  Signature(const Signature& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Signature& operator=(const Signature& other_value);
  boolean operator==(const Signature& other_value) const;
  inline boolean operator!=(const Signature& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline PublicKeyAlgorithm& algorithm()
    {return field_algorithm;}
  inline const PublicKeyAlgorithm& algorithm() const
    {return field_algorithm;}
  inline SignatureContainer& signature__()
    {return field_signature__;}
  inline const SignatureContainer& signature__() const
    {return field_signature__;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Signature_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Signature_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Signature& other_value);
void copy_template(const Signature_template& other_value);

public:
Signature_template();
Signature_template(template_sel other_value);
Signature_template(const Signature& other_value);
Signature_template(const OPTIONAL<Signature>& other_value);
Signature_template(const Signature_template& other_value);
~Signature_template();
Signature_template& operator=(template_sel other_value);
Signature_template& operator=(const Signature& other_value);
Signature_template& operator=(const OPTIONAL<Signature>& other_value);
Signature_template& operator=(const Signature_template& other_value);
boolean match(const Signature& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Signature valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Signature_template& list_item(unsigned int list_index) const;
PublicKeyAlgorithm_template& algorithm();
const PublicKeyAlgorithm_template& algorithm() const;
SignatureContainer_template& signature__();
const SignatureContainer_template& signature__() const;
int size_of() const;
void log() const;
void log_match(const Signature& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SignerInfoType : public Base_Type { // enum
friend class SignerInfoType_template;
public:
enum enum_type { e__self = 0, e__certificate__digest__with__sha256 = 1, e__certificate = 2, e__certificate__chain = 3, e__certificate__digest__with__other__algorithm = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
SignerInfoType();
SignerInfoType(int other_value);
SignerInfoType(enum_type other_value);
SignerInfoType(const SignerInfoType& other_value);

SignerInfoType& operator=(int other_value);
SignerInfoType& operator=(enum_type other_value);
SignerInfoType& operator=(const SignerInfoType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SignerInfoType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SignerInfoType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SignerInfoType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SignerInfoType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SignerInfoType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SignerInfoType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SignerInfoType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SignerInfoType_template : public Base_Template {
union {
SignerInfoType::enum_type single_value;
struct {
unsigned int n_values;
SignerInfoType_template *list_value;
} value_list;
};

void copy_template(const SignerInfoType_template& other_value);

public:
SignerInfoType_template();
SignerInfoType_template(template_sel other_value);
SignerInfoType_template(int other_value);
SignerInfoType_template(SignerInfoType::enum_type other_value);
SignerInfoType_template(const SignerInfoType& other_value);
SignerInfoType_template(const OPTIONAL<SignerInfoType>& other_value);
SignerInfoType_template(const SignerInfoType_template& other_value);
~SignerInfoType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SignerInfoType_template& operator=(template_sel other_value);
SignerInfoType_template& operator=(int other_value);
SignerInfoType_template& operator=(SignerInfoType::enum_type other_value);
SignerInfoType_template& operator=(const SignerInfoType& other_value);
SignerInfoType_template& operator=(const OPTIONAL<SignerInfoType>& other_value);
SignerInfoType_template& operator=(const SignerInfoType_template& other_value);

boolean match(SignerInfoType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SignerInfoType& other_value, boolean legacy = FALSE) const;
SignerInfoType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SignerInfoType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SignerInfoType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SignerInfo : public Base_Type {
  SignerInfoType field_type__;
  OPTIONAL<SignerInfoContainer> field_signerInfo;
  boolean bound_flag;
public:
  SignerInfo();
  SignerInfo(const SignerInfoType& par_type__,
    const OPTIONAL<SignerInfoContainer>& par_signerInfo);
  SignerInfo(const SignerInfo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SignerInfo& operator=(const SignerInfo& other_value);
  boolean operator==(const SignerInfo& other_value) const;
  inline boolean operator!=(const SignerInfo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline SignerInfoType& type__()
    {return field_type__;}
  inline const SignerInfoType& type__() const
    {return field_type__;}
  inline OPTIONAL<SignerInfoContainer>& signerInfo()
    {return field_signerInfo;}
  inline const OPTIONAL<SignerInfoContainer>& signerInfo() const
    {return field_signerInfo;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SignerInfo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SignerInfo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SignerInfo& other_value);
void copy_template(const SignerInfo_template& other_value);

public:
SignerInfo_template();
SignerInfo_template(template_sel other_value);
SignerInfo_template(const SignerInfo& other_value);
SignerInfo_template(const OPTIONAL<SignerInfo>& other_value);
SignerInfo_template(const SignerInfo_template& other_value);
~SignerInfo_template();
SignerInfo_template& operator=(template_sel other_value);
SignerInfo_template& operator=(const SignerInfo& other_value);
SignerInfo_template& operator=(const OPTIONAL<SignerInfo>& other_value);
SignerInfo_template& operator=(const SignerInfo_template& other_value);
boolean match(const SignerInfo& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SignerInfo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SignerInfo_template& list_item(unsigned int list_index) const;
SignerInfoType_template& type__();
const SignerInfoType_template& type__() const;
SignerInfoContainer_template& signerInfo();
const SignerInfoContainer_template& signerInfo() const;
int size_of() const;
void log() const;
void log_match(const SignerInfo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SignerInfoContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_digest = 1, ALT_certificate = 2, ALT_certificates = 3, ALT_certificateWithAlgo = 4, ALT_info = 5 };
private:
union_selection_type union_selection;
union {
OCTETSTRING *field_digest;
Certificate *field_certificate;
CertificateChain *field_certificates;
CertificateWithAlgo *field_certificateWithAlgo;
OCTETSTRING *field_info;
};
void copy_value(const SignerInfoContainer& other_value);

public:
SignerInfoContainer();
SignerInfoContainer(const SignerInfoContainer& other_value);
~SignerInfoContainer();
SignerInfoContainer& operator=(const SignerInfoContainer& other_value);
boolean operator==(const SignerInfoContainer& other_value) const;
inline boolean operator!=(const SignerInfoContainer& other_value) const { return !(*this == other_value); }
OCTETSTRING& digest();
const OCTETSTRING& digest() const;
Certificate& certificate();
const Certificate& certificate() const;
CertificateChain& certificates();
const CertificateChain& certificates() const;
CertificateWithAlgo& certificateWithAlgo();
const CertificateWithAlgo& certificateWithAlgo() const;
OCTETSTRING& info();
const OCTETSTRING& info() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SignerInfoContainer_template : public Base_Template {
union {
struct {
SignerInfoContainer::union_selection_type union_selection;
union {
OCTETSTRING_template *field_digest;
Certificate_template *field_certificate;
CertificateChain_template *field_certificates;
CertificateWithAlgo_template *field_certificateWithAlgo;
OCTETSTRING_template *field_info;
};
} single_value;
struct {
unsigned int n_values;
SignerInfoContainer_template *list_value;
} value_list;
};
void copy_value(const SignerInfoContainer& other_value);

void copy_template(const SignerInfoContainer_template& other_value);

public:
SignerInfoContainer_template();
SignerInfoContainer_template(template_sel other_value);
SignerInfoContainer_template(const SignerInfoContainer& other_value);
SignerInfoContainer_template(const OPTIONAL<SignerInfoContainer>& other_value);
SignerInfoContainer_template(const SignerInfoContainer_template& other_value);
~SignerInfoContainer_template();
void clean_up();
SignerInfoContainer_template& operator=(template_sel other_value);
SignerInfoContainer_template& operator=(const SignerInfoContainer& other_value);
SignerInfoContainer_template& operator=(const OPTIONAL<SignerInfoContainer>& other_value);
SignerInfoContainer_template& operator=(const SignerInfoContainer_template& other_value);
boolean match(const SignerInfoContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;SignerInfoContainer valueof() const;
SignerInfoContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
OCTETSTRING_template& digest();
const OCTETSTRING_template& digest() const;
Certificate_template& certificate();
const Certificate_template& certificate() const;
CertificateChain_template& certificates();
const CertificateChain_template& certificates() const;
CertificateWithAlgo_template& certificateWithAlgo();
const CertificateWithAlgo_template& certificateWithAlgo() const;
OCTETSTRING_template& info();
const OCTETSTRING_template& info() const;
boolean ischosen(SignerInfoContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const SignerInfoContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SubjectType : public Base_Type { // enum
friend class SubjectType_template;
public:
enum enum_type { e__enrollment__credential = 0, e__authorization__ticket = 1, e__authorization__authority = 2, e__enrollment__authority = 3, e__root__ca = 4, e__crl__signer = 5, UNKNOWN_VALUE = 6, UNBOUND_VALUE = 7 };
private:
enum_type enum_value;

public:
SubjectType();
SubjectType(int other_value);
SubjectType(enum_type other_value);
SubjectType(const SubjectType& other_value);

SubjectType& operator=(int other_value);
SubjectType& operator=(enum_type other_value);
SubjectType& operator=(const SubjectType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SubjectType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SubjectType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SubjectType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SubjectType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SubjectType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SubjectType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SubjectType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SubjectType_template : public Base_Template {
union {
SubjectType::enum_type single_value;
struct {
unsigned int n_values;
SubjectType_template *list_value;
} value_list;
};

void copy_template(const SubjectType_template& other_value);

public:
SubjectType_template();
SubjectType_template(template_sel other_value);
SubjectType_template(int other_value);
SubjectType_template(SubjectType::enum_type other_value);
SubjectType_template(const SubjectType& other_value);
SubjectType_template(const OPTIONAL<SubjectType>& other_value);
SubjectType_template(const SubjectType_template& other_value);
~SubjectType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SubjectType_template& operator=(template_sel other_value);
SubjectType_template& operator=(int other_value);
SubjectType_template& operator=(SubjectType::enum_type other_value);
SubjectType_template& operator=(const SubjectType& other_value);
SubjectType_template& operator=(const OPTIONAL<SubjectType>& other_value);
SubjectType_template& operator=(const SubjectType_template& other_value);

boolean match(SubjectType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SubjectType& other_value, boolean legacy = FALSE) const;
SubjectType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SubjectType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SubjectType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SubjectInfo : public Base_Type {
  SubjectType field_subject__type;
  OCTETSTRING field_subject__name;
  boolean bound_flag;
public:
  SubjectInfo();
  SubjectInfo(const SubjectType& par_subject__type,
    const OCTETSTRING& par_subject__name);
  SubjectInfo(const SubjectInfo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SubjectInfo& operator=(const SubjectInfo& other_value);
  boolean operator==(const SubjectInfo& other_value) const;
  inline boolean operator!=(const SubjectInfo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline SubjectType& subject__type()
    {return field_subject__type;}
  inline const SubjectType& subject__type() const
    {return field_subject__type;}
  inline OCTETSTRING& subject__name()
    {return field_subject__name;}
  inline const OCTETSTRING& subject__name() const
    {return field_subject__name;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SubjectInfo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SubjectInfo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SubjectInfo& other_value);
void copy_template(const SubjectInfo_template& other_value);

public:
SubjectInfo_template();
SubjectInfo_template(template_sel other_value);
SubjectInfo_template(const SubjectInfo& other_value);
SubjectInfo_template(const OPTIONAL<SubjectInfo>& other_value);
SubjectInfo_template(const SubjectInfo_template& other_value);
~SubjectInfo_template();
SubjectInfo_template& operator=(template_sel other_value);
SubjectInfo_template& operator=(const SubjectInfo& other_value);
SubjectInfo_template& operator=(const OPTIONAL<SubjectInfo>& other_value);
SubjectInfo_template& operator=(const SubjectInfo_template& other_value);
boolean match(const SubjectInfo& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SubjectInfo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SubjectInfo_template& list_item(unsigned int list_index) const;
SubjectType_template& subject__type();
const SubjectType_template& subject__type() const;
OCTETSTRING_template& subject__name();
const OCTETSTRING_template& subject__name() const;
int size_of() const;
void log() const;
void log_match(const SubjectInfo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SubjectAttributes : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
SubjectAttribute **value_elements;
} *val_ptr;

static const SubjectAttribute UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SubjectAttributes& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef SubjectAttribute of_type;
SubjectAttributes();
SubjectAttributes(null_type other_value);
SubjectAttributes(const SubjectAttributes& other_value);
~SubjectAttributes();

void clean_up();
SubjectAttributes& operator=(null_type other_value);
SubjectAttributes& operator=(const SubjectAttributes& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SubjectAttributes& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SubjectAttributes& other_value) const { return !(*this == other_value); }

SubjectAttribute& operator[](int index_value);
SubjectAttribute& operator[](const INTEGER& index_value);
const SubjectAttribute& operator[](int index_value) const;
const SubjectAttribute& operator[](const INTEGER& index_value) const;

SubjectAttributes operator<<=(int rotate_count) const;
SubjectAttributes operator<<=(const INTEGER& rotate_count) const;
SubjectAttributes operator>>=(int rotate_count) const;
SubjectAttributes operator>>=(const INTEGER& rotate_count) const;

SubjectAttributes operator+(const SubjectAttributes& other_value) const;

SubjectAttributes substr(int index, int returncount) const;

SubjectAttributes replace(int index, int len, const SubjectAttributes& repl) const;

SubjectAttributes replace(int index, int len, const SubjectAttributes_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SubjectAttributes_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
SubjectAttribute_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SubjectAttributes_template *list_value;
} value_list;
struct {
unsigned int n_items;
SubjectAttribute_template *set_items;
} value_set;
};
void copy_value(const SubjectAttributes& other_value);
void copy_template(const SubjectAttributes_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
SubjectAttributes_template();
SubjectAttributes_template(template_sel other_value);
SubjectAttributes_template(null_type other_value);
SubjectAttributes_template(const SubjectAttributes& other_value);
SubjectAttributes_template(const OPTIONAL<SubjectAttributes>& other_value);
SubjectAttributes_template(const SubjectAttributes_template& other_value);
~SubjectAttributes_template();

void clean_up();
SubjectAttributes_template& operator=(template_sel other_value);
SubjectAttributes_template& operator=(null_type other_value);
SubjectAttributes_template& operator=(const SubjectAttributes& other_value);
SubjectAttributes_template& operator=(const OPTIONAL<SubjectAttributes>& other_value);
SubjectAttributes_template& operator=(const SubjectAttributes_template& other_value);

SubjectAttribute_template& operator[](int index_value);
SubjectAttribute_template& operator[](const INTEGER& index_value);
const SubjectAttribute_template& operator[](int index_value) const;
const SubjectAttribute_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SubjectAttributes& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SubjectAttributes valueof() const;
SubjectAttributes substr(int index, int returncount) const;

SubjectAttributes replace(int index, int len, const SubjectAttributes_template& repl) const;

SubjectAttributes replace(int index, int len, const SubjectAttributes& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SubjectAttributes_template& list_item(unsigned int list_index);
SubjectAttribute_template& set_item(unsigned int set_index);
void log() const;
void log_match(const SubjectAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SubjectAttributeType : public Base_Type { // enum
friend class SubjectAttributeType_template;
public:
enum enum_type { e__verification__key = 0, e__encryption__key = 1, e__assurance__level = 2, e__reconstruction__value = 3, e__its__aid__list = 32, e__its__aid__ssp__list = 33, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
SubjectAttributeType();
SubjectAttributeType(int other_value);
SubjectAttributeType(enum_type other_value);
SubjectAttributeType(const SubjectAttributeType& other_value);

SubjectAttributeType& operator=(int other_value);
SubjectAttributeType& operator=(enum_type other_value);
SubjectAttributeType& operator=(const SubjectAttributeType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SubjectAttributeType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SubjectAttributeType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SubjectAttributeType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SubjectAttributeType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SubjectAttributeType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SubjectAttributeType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SubjectAttributeType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SubjectAttributeType_template : public Base_Template {
union {
SubjectAttributeType::enum_type single_value;
struct {
unsigned int n_values;
SubjectAttributeType_template *list_value;
} value_list;
};

void copy_template(const SubjectAttributeType_template& other_value);

public:
SubjectAttributeType_template();
SubjectAttributeType_template(template_sel other_value);
SubjectAttributeType_template(int other_value);
SubjectAttributeType_template(SubjectAttributeType::enum_type other_value);
SubjectAttributeType_template(const SubjectAttributeType& other_value);
SubjectAttributeType_template(const OPTIONAL<SubjectAttributeType>& other_value);
SubjectAttributeType_template(const SubjectAttributeType_template& other_value);
~SubjectAttributeType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SubjectAttributeType_template& operator=(template_sel other_value);
SubjectAttributeType_template& operator=(int other_value);
SubjectAttributeType_template& operator=(SubjectAttributeType::enum_type other_value);
SubjectAttributeType_template& operator=(const SubjectAttributeType& other_value);
SubjectAttributeType_template& operator=(const OPTIONAL<SubjectAttributeType>& other_value);
SubjectAttributeType_template& operator=(const SubjectAttributeType_template& other_value);

boolean match(SubjectAttributeType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SubjectAttributeType& other_value, boolean legacy = FALSE) const;
SubjectAttributeType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SubjectAttributeType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SubjectAttributeType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SubjectAttributeContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_key = 1, ALT_rv = 2, ALT_assurance__level = 3, ALT_its__aid__list = 4, ALT_its__aid__ssp__list = 5, ALT_other__attribute = 6 };
private:
union_selection_type union_selection;
union {
PublicKey *field_key;
EccPoint *field_rv;
SubjectAssurance *field_assurance__level;
IntXs *field_its__aid__list;
ItsAidSsps *field_its__aid__ssp__list;
OCTETSTRING *field_other__attribute;
};
void copy_value(const SubjectAttributeContainer& other_value);

public:
SubjectAttributeContainer();
SubjectAttributeContainer(const SubjectAttributeContainer& other_value);
~SubjectAttributeContainer();
SubjectAttributeContainer& operator=(const SubjectAttributeContainer& other_value);
boolean operator==(const SubjectAttributeContainer& other_value) const;
inline boolean operator!=(const SubjectAttributeContainer& other_value) const { return !(*this == other_value); }
PublicKey& key();
const PublicKey& key() const;
EccPoint& rv();
const EccPoint& rv() const;
SubjectAssurance& assurance__level();
const SubjectAssurance& assurance__level() const;
IntXs& its__aid__list();
const IntXs& its__aid__list() const;
ItsAidSsps& its__aid__ssp__list();
const ItsAidSsps& its__aid__ssp__list() const;
OCTETSTRING& other__attribute();
const OCTETSTRING& other__attribute() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SubjectAttributeContainer_template : public Base_Template {
union {
struct {
SubjectAttributeContainer::union_selection_type union_selection;
union {
PublicKey_template *field_key;
EccPoint_template *field_rv;
SubjectAssurance_template *field_assurance__level;
IntXs_template *field_its__aid__list;
ItsAidSsps_template *field_its__aid__ssp__list;
OCTETSTRING_template *field_other__attribute;
};
} single_value;
struct {
unsigned int n_values;
SubjectAttributeContainer_template *list_value;
} value_list;
};
void copy_value(const SubjectAttributeContainer& other_value);

void copy_template(const SubjectAttributeContainer_template& other_value);

public:
SubjectAttributeContainer_template();
SubjectAttributeContainer_template(template_sel other_value);
SubjectAttributeContainer_template(const SubjectAttributeContainer& other_value);
SubjectAttributeContainer_template(const OPTIONAL<SubjectAttributeContainer>& other_value);
SubjectAttributeContainer_template(const SubjectAttributeContainer_template& other_value);
~SubjectAttributeContainer_template();
void clean_up();
SubjectAttributeContainer_template& operator=(template_sel other_value);
SubjectAttributeContainer_template& operator=(const SubjectAttributeContainer& other_value);
SubjectAttributeContainer_template& operator=(const OPTIONAL<SubjectAttributeContainer>& other_value);
SubjectAttributeContainer_template& operator=(const SubjectAttributeContainer_template& other_value);
boolean match(const SubjectAttributeContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;SubjectAttributeContainer valueof() const;
SubjectAttributeContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
PublicKey_template& key();
const PublicKey_template& key() const;
EccPoint_template& rv();
const EccPoint_template& rv() const;
SubjectAssurance_template& assurance__level();
const SubjectAssurance_template& assurance__level() const;
IntXs_template& its__aid__list();
const IntXs_template& its__aid__list() const;
ItsAidSsps_template& its__aid__ssp__list();
const ItsAidSsps_template& its__aid__ssp__list() const;
OCTETSTRING_template& other__attribute();
const OCTETSTRING_template& other__attribute() const;
boolean ischosen(SubjectAttributeContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const SubjectAttributeContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SubjectAssurance : public Base_Type {
  BITSTRING field_levels;
  BITSTRING field_reserved;
  BITSTRING field_confidence;
  boolean bound_flag;
public:
  SubjectAssurance();
  SubjectAssurance(const BITSTRING& par_levels,
    const BITSTRING& par_reserved,
    const BITSTRING& par_confidence);
  SubjectAssurance(const SubjectAssurance& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SubjectAssurance& operator=(const SubjectAssurance& other_value);
  boolean operator==(const SubjectAssurance& other_value) const;
  inline boolean operator!=(const SubjectAssurance& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& levels()
    {return field_levels;}
  inline const BITSTRING& levels() const
    {return field_levels;}
  inline BITSTRING& reserved()
    {return field_reserved;}
  inline const BITSTRING& reserved() const
    {return field_reserved;}
  inline BITSTRING& confidence()
    {return field_confidence;}
  inline const BITSTRING& confidence() const
    {return field_confidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SubjectAssurance_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SubjectAssurance_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SubjectAssurance& other_value);
void copy_template(const SubjectAssurance_template& other_value);

public:
SubjectAssurance_template();
SubjectAssurance_template(template_sel other_value);
SubjectAssurance_template(const SubjectAssurance& other_value);
SubjectAssurance_template(const OPTIONAL<SubjectAssurance>& other_value);
SubjectAssurance_template(const SubjectAssurance_template& other_value);
~SubjectAssurance_template();
SubjectAssurance_template& operator=(template_sel other_value);
SubjectAssurance_template& operator=(const SubjectAssurance& other_value);
SubjectAssurance_template& operator=(const OPTIONAL<SubjectAssurance>& other_value);
SubjectAssurance_template& operator=(const SubjectAssurance_template& other_value);
boolean match(const SubjectAssurance& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SubjectAssurance valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SubjectAssurance_template& list_item(unsigned int list_index) const;
BITSTRING_template& levels();
const BITSTRING_template& levels() const;
BITSTRING_template& reserved();
const BITSTRING_template& reserved() const;
BITSTRING_template& confidence();
const BITSTRING_template& confidence() const;
int size_of() const;
void log() const;
void log_match(const SubjectAssurance& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ItsAidSsps : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ItsAidSsp **value_elements;
} *val_ptr;

static const ItsAidSsp UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ItsAidSsps& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef ItsAidSsp of_type;
ItsAidSsps();
ItsAidSsps(null_type other_value);
ItsAidSsps(const ItsAidSsps& other_value);
~ItsAidSsps();

void clean_up();
ItsAidSsps& operator=(null_type other_value);
ItsAidSsps& operator=(const ItsAidSsps& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ItsAidSsps& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ItsAidSsps& other_value) const { return !(*this == other_value); }

ItsAidSsp& operator[](int index_value);
ItsAidSsp& operator[](const INTEGER& index_value);
const ItsAidSsp& operator[](int index_value) const;
const ItsAidSsp& operator[](const INTEGER& index_value) const;

ItsAidSsps operator<<=(int rotate_count) const;
ItsAidSsps operator<<=(const INTEGER& rotate_count) const;
ItsAidSsps operator>>=(int rotate_count) const;
ItsAidSsps operator>>=(const INTEGER& rotate_count) const;

ItsAidSsps operator+(const ItsAidSsps& other_value) const;

ItsAidSsps substr(int index, int returncount) const;

ItsAidSsps replace(int index, int len, const ItsAidSsps& repl) const;

ItsAidSsps replace(int index, int len, const ItsAidSsps_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ItsAidSsps_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
ItsAidSsp_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ItsAidSsps_template *list_value;
} value_list;
struct {
unsigned int n_items;
ItsAidSsp_template *set_items;
} value_set;
};
void copy_value(const ItsAidSsps& other_value);
void copy_template(const ItsAidSsps_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
ItsAidSsps_template();
ItsAidSsps_template(template_sel other_value);
ItsAidSsps_template(null_type other_value);
ItsAidSsps_template(const ItsAidSsps& other_value);
ItsAidSsps_template(const OPTIONAL<ItsAidSsps>& other_value);
ItsAidSsps_template(const ItsAidSsps_template& other_value);
~ItsAidSsps_template();

void clean_up();
ItsAidSsps_template& operator=(template_sel other_value);
ItsAidSsps_template& operator=(null_type other_value);
ItsAidSsps_template& operator=(const ItsAidSsps& other_value);
ItsAidSsps_template& operator=(const OPTIONAL<ItsAidSsps>& other_value);
ItsAidSsps_template& operator=(const ItsAidSsps_template& other_value);

ItsAidSsp_template& operator[](int index_value);
ItsAidSsp_template& operator[](const INTEGER& index_value);
const ItsAidSsp_template& operator[](int index_value) const;
const ItsAidSsp_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ItsAidSsps& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ItsAidSsps valueof() const;
ItsAidSsps substr(int index, int returncount) const;

ItsAidSsps replace(int index, int len, const ItsAidSsps_template& repl) const;

ItsAidSsps replace(int index, int len, const ItsAidSsps& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ItsAidSsps_template& list_item(unsigned int list_index);
ItsAidSsp_template& set_item(unsigned int set_index);
void log() const;
void log_match(const ItsAidSsps& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ServiceSpecificPermissions : public Base_Type {
  OCTETSTRING field_version;
  OPTIONAL<ServiceSpecificPermissionsContainer> field_sspContainer;
  boolean bound_flag;
public:
  ServiceSpecificPermissions();
  ServiceSpecificPermissions(const OCTETSTRING& par_version,
    const OPTIONAL<ServiceSpecificPermissionsContainer>& par_sspContainer);
  ServiceSpecificPermissions(const ServiceSpecificPermissions& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ServiceSpecificPermissions& operator=(const ServiceSpecificPermissions& other_value);
  boolean operator==(const ServiceSpecificPermissions& other_value) const;
  inline boolean operator!=(const ServiceSpecificPermissions& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& version()
    {return field_version;}
  inline const OCTETSTRING& version() const
    {return field_version;}
  inline OPTIONAL<ServiceSpecificPermissionsContainer>& sspContainer()
    {return field_sspContainer;}
  inline const OPTIONAL<ServiceSpecificPermissionsContainer>& sspContainer() const
    {return field_sspContainer;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ServiceSpecificPermissions_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ServiceSpecificPermissions_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ServiceSpecificPermissions& other_value);
void copy_template(const ServiceSpecificPermissions_template& other_value);

public:
ServiceSpecificPermissions_template();
ServiceSpecificPermissions_template(template_sel other_value);
ServiceSpecificPermissions_template(const ServiceSpecificPermissions& other_value);
ServiceSpecificPermissions_template(const OPTIONAL<ServiceSpecificPermissions>& other_value);
ServiceSpecificPermissions_template(const ServiceSpecificPermissions_template& other_value);
~ServiceSpecificPermissions_template();
ServiceSpecificPermissions_template& operator=(template_sel other_value);
ServiceSpecificPermissions_template& operator=(const ServiceSpecificPermissions& other_value);
ServiceSpecificPermissions_template& operator=(const OPTIONAL<ServiceSpecificPermissions>& other_value);
ServiceSpecificPermissions_template& operator=(const ServiceSpecificPermissions_template& other_value);
boolean match(const ServiceSpecificPermissions& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ServiceSpecificPermissions valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ServiceSpecificPermissions_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& version();
const OCTETSTRING_template& version() const;
ServiceSpecificPermissionsContainer_template& sspContainer();
const ServiceSpecificPermissionsContainer_template& sspContainer() const;
int size_of() const;
void log() const;
void log_match(const ServiceSpecificPermissions& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ServiceSpecificPermissionsContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_sspCAM = 1, ALT_sspDENM = 2, ALT_opaque = 3 };
private:
union_selection_type union_selection;
union {
SspCAM *field_sspCAM;
SspDENM *field_sspDENM;
OCTETSTRING *field_opaque;
};
void copy_value(const ServiceSpecificPermissionsContainer& other_value);

public:
ServiceSpecificPermissionsContainer();
ServiceSpecificPermissionsContainer(const ServiceSpecificPermissionsContainer& other_value);
~ServiceSpecificPermissionsContainer();
ServiceSpecificPermissionsContainer& operator=(const ServiceSpecificPermissionsContainer& other_value);
boolean operator==(const ServiceSpecificPermissionsContainer& other_value) const;
inline boolean operator!=(const ServiceSpecificPermissionsContainer& other_value) const { return !(*this == other_value); }
SspCAM& sspCAM();
const SspCAM& sspCAM() const;
SspDENM& sspDENM();
const SspDENM& sspDENM() const;
OCTETSTRING& opaque();
const OCTETSTRING& opaque() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ServiceSpecificPermissionsContainer_template : public Base_Template {
union {
struct {
ServiceSpecificPermissionsContainer::union_selection_type union_selection;
union {
SspCAM_template *field_sspCAM;
SspDENM_template *field_sspDENM;
OCTETSTRING_template *field_opaque;
};
} single_value;
struct {
unsigned int n_values;
ServiceSpecificPermissionsContainer_template *list_value;
} value_list;
};
void copy_value(const ServiceSpecificPermissionsContainer& other_value);

void copy_template(const ServiceSpecificPermissionsContainer_template& other_value);

public:
ServiceSpecificPermissionsContainer_template();
ServiceSpecificPermissionsContainer_template(template_sel other_value);
ServiceSpecificPermissionsContainer_template(const ServiceSpecificPermissionsContainer& other_value);
ServiceSpecificPermissionsContainer_template(const OPTIONAL<ServiceSpecificPermissionsContainer>& other_value);
ServiceSpecificPermissionsContainer_template(const ServiceSpecificPermissionsContainer_template& other_value);
~ServiceSpecificPermissionsContainer_template();
void clean_up();
ServiceSpecificPermissionsContainer_template& operator=(template_sel other_value);
ServiceSpecificPermissionsContainer_template& operator=(const ServiceSpecificPermissionsContainer& other_value);
ServiceSpecificPermissionsContainer_template& operator=(const OPTIONAL<ServiceSpecificPermissionsContainer>& other_value);
ServiceSpecificPermissionsContainer_template& operator=(const ServiceSpecificPermissionsContainer_template& other_value);
boolean match(const ServiceSpecificPermissionsContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ServiceSpecificPermissionsContainer valueof() const;
ServiceSpecificPermissionsContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
SspCAM_template& sspCAM();
const SspCAM_template& sspCAM() const;
SspDENM_template& sspDENM();
const SspDENM_template& sspDENM() const;
OCTETSTRING_template& opaque();
const OCTETSTRING_template& opaque() const;
boolean ischosen(ServiceSpecificPermissionsContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const ServiceSpecificPermissionsContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SspCAM : public Base_Type {
  BITSTRING field_cenDsrcTollingZone;
  BITSTRING field_publicTransport;
  BITSTRING field_specialTransport;
  BITSTRING field_dangerousGoods;
  BITSTRING field_roadwork;
  BITSTRING field_rescue;
  BITSTRING field_emergency;
  BITSTRING field_safetyCar;
  BITSTRING field_closedLanes;
  BITSTRING field_requestForRightOfWay;
  BITSTRING field_requestForFreeCrossingAtATrafficLight;
  BITSTRING field_noPassing;
  BITSTRING field_noPassingForTrucks;
  BITSTRING field_speedLimit;
  BITSTRING field_reserved1;
  BITSTRING field_reserved2;
  boolean bound_flag;
public:
  SspCAM();
  SspCAM(const BITSTRING& par_cenDsrcTollingZone,
    const BITSTRING& par_publicTransport,
    const BITSTRING& par_specialTransport,
    const BITSTRING& par_dangerousGoods,
    const BITSTRING& par_roadwork,
    const BITSTRING& par_rescue,
    const BITSTRING& par_emergency,
    const BITSTRING& par_safetyCar,
    const BITSTRING& par_closedLanes,
    const BITSTRING& par_requestForRightOfWay,
    const BITSTRING& par_requestForFreeCrossingAtATrafficLight,
    const BITSTRING& par_noPassing,
    const BITSTRING& par_noPassingForTrucks,
    const BITSTRING& par_speedLimit,
    const BITSTRING& par_reserved1,
    const BITSTRING& par_reserved2);
  SspCAM(const SspCAM& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SspCAM& operator=(const SspCAM& other_value);
  boolean operator==(const SspCAM& other_value) const;
  inline boolean operator!=(const SspCAM& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& cenDsrcTollingZone()
    {return field_cenDsrcTollingZone;}
  inline const BITSTRING& cenDsrcTollingZone() const
    {return field_cenDsrcTollingZone;}
  inline BITSTRING& publicTransport()
    {return field_publicTransport;}
  inline const BITSTRING& publicTransport() const
    {return field_publicTransport;}
  inline BITSTRING& specialTransport()
    {return field_specialTransport;}
  inline const BITSTRING& specialTransport() const
    {return field_specialTransport;}
  inline BITSTRING& dangerousGoods()
    {return field_dangerousGoods;}
  inline const BITSTRING& dangerousGoods() const
    {return field_dangerousGoods;}
  inline BITSTRING& roadwork()
    {return field_roadwork;}
  inline const BITSTRING& roadwork() const
    {return field_roadwork;}
  inline BITSTRING& rescue()
    {return field_rescue;}
  inline const BITSTRING& rescue() const
    {return field_rescue;}
  inline BITSTRING& emergency()
    {return field_emergency;}
  inline const BITSTRING& emergency() const
    {return field_emergency;}
  inline BITSTRING& safetyCar()
    {return field_safetyCar;}
  inline const BITSTRING& safetyCar() const
    {return field_safetyCar;}
  inline BITSTRING& closedLanes()
    {return field_closedLanes;}
  inline const BITSTRING& closedLanes() const
    {return field_closedLanes;}
  inline BITSTRING& requestForRightOfWay()
    {return field_requestForRightOfWay;}
  inline const BITSTRING& requestForRightOfWay() const
    {return field_requestForRightOfWay;}
  inline BITSTRING& requestForFreeCrossingAtATrafficLight()
    {return field_requestForFreeCrossingAtATrafficLight;}
  inline const BITSTRING& requestForFreeCrossingAtATrafficLight() const
    {return field_requestForFreeCrossingAtATrafficLight;}
  inline BITSTRING& noPassing()
    {return field_noPassing;}
  inline const BITSTRING& noPassing() const
    {return field_noPassing;}
  inline BITSTRING& noPassingForTrucks()
    {return field_noPassingForTrucks;}
  inline const BITSTRING& noPassingForTrucks() const
    {return field_noPassingForTrucks;}
  inline BITSTRING& speedLimit()
    {return field_speedLimit;}
  inline const BITSTRING& speedLimit() const
    {return field_speedLimit;}
  inline BITSTRING& reserved1()
    {return field_reserved1;}
  inline const BITSTRING& reserved1() const
    {return field_reserved1;}
  inline BITSTRING& reserved2()
    {return field_reserved2;}
  inline const BITSTRING& reserved2() const
    {return field_reserved2;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SspCAM_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SspCAM_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SspCAM& other_value);
void copy_template(const SspCAM_template& other_value);

public:
SspCAM_template();
SspCAM_template(template_sel other_value);
SspCAM_template(const SspCAM& other_value);
SspCAM_template(const OPTIONAL<SspCAM>& other_value);
SspCAM_template(const SspCAM_template& other_value);
~SspCAM_template();
SspCAM_template& operator=(template_sel other_value);
SspCAM_template& operator=(const SspCAM& other_value);
SspCAM_template& operator=(const OPTIONAL<SspCAM>& other_value);
SspCAM_template& operator=(const SspCAM_template& other_value);
boolean match(const SspCAM& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SspCAM valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SspCAM_template& list_item(unsigned int list_index) const;
BITSTRING_template& cenDsrcTollingZone();
const BITSTRING_template& cenDsrcTollingZone() const;
BITSTRING_template& publicTransport();
const BITSTRING_template& publicTransport() const;
BITSTRING_template& specialTransport();
const BITSTRING_template& specialTransport() const;
BITSTRING_template& dangerousGoods();
const BITSTRING_template& dangerousGoods() const;
BITSTRING_template& roadwork();
const BITSTRING_template& roadwork() const;
BITSTRING_template& rescue();
const BITSTRING_template& rescue() const;
BITSTRING_template& emergency();
const BITSTRING_template& emergency() const;
BITSTRING_template& safetyCar();
const BITSTRING_template& safetyCar() const;
BITSTRING_template& closedLanes();
const BITSTRING_template& closedLanes() const;
BITSTRING_template& requestForRightOfWay();
const BITSTRING_template& requestForRightOfWay() const;
BITSTRING_template& requestForFreeCrossingAtATrafficLight();
const BITSTRING_template& requestForFreeCrossingAtATrafficLight() const;
BITSTRING_template& noPassing();
const BITSTRING_template& noPassing() const;
BITSTRING_template& noPassingForTrucks();
const BITSTRING_template& noPassingForTrucks() const;
BITSTRING_template& speedLimit();
const BITSTRING_template& speedLimit() const;
BITSTRING_template& reserved1();
const BITSTRING_template& reserved1() const;
BITSTRING_template& reserved2();
const BITSTRING_template& reserved2() const;
int size_of() const;
void log() const;
void log_match(const SspCAM& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SspDENM : public Base_Type {
  BITSTRING field_trafficCondition;
  BITSTRING field_accident;
  BITSTRING field_roadworks;
  BITSTRING field_adverseWeatherCondition__Adhesion;
  BITSTRING field_hazardousLocation__SurfaceCondition;
  BITSTRING field_hazardousLocation__ObstacleOnTheRoad;
  BITSTRING field_hazardousLocation__AnimalOnTheRoad;
  BITSTRING field_humanPresenceOnTheRoad;
  BITSTRING field_wrongWayDriving;
  BITSTRING field_rescueAndRecoveryWorkInProgress;
  BITSTRING field_adverseWeatherCondition__ExtremeWeatherCondition;
  BITSTRING field_adverseWeatherCondition__Visibility;
  BITSTRING field_adverseWeatherCondition__Precipitation;
  BITSTRING field_slowVehicle;
  BITSTRING field_dangerousEndOfQueue;
  BITSTRING field_vehicleBreakdown;
  BITSTRING field_postCrash;
  BITSTRING field_humanProblem;
  BITSTRING field_stationaryVehicle;
  BITSTRING field_emergencyVehicleApproaching;
  BITSTRING field_hazardousLocation__DangerousCurve;
  BITSTRING field_collisionRisk;
  BITSTRING field_signalViolation;
  BITSTRING field_dangerousSituation;
  boolean bound_flag;
public:
  SspDENM();
  SspDENM(const BITSTRING& par_trafficCondition,
    const BITSTRING& par_accident,
    const BITSTRING& par_roadworks,
    const BITSTRING& par_adverseWeatherCondition__Adhesion,
    const BITSTRING& par_hazardousLocation__SurfaceCondition,
    const BITSTRING& par_hazardousLocation__ObstacleOnTheRoad,
    const BITSTRING& par_hazardousLocation__AnimalOnTheRoad,
    const BITSTRING& par_humanPresenceOnTheRoad,
    const BITSTRING& par_wrongWayDriving,
    const BITSTRING& par_rescueAndRecoveryWorkInProgress,
    const BITSTRING& par_adverseWeatherCondition__ExtremeWeatherCondition,
    const BITSTRING& par_adverseWeatherCondition__Visibility,
    const BITSTRING& par_adverseWeatherCondition__Precipitation,
    const BITSTRING& par_slowVehicle,
    const BITSTRING& par_dangerousEndOfQueue,
    const BITSTRING& par_vehicleBreakdown,
    const BITSTRING& par_postCrash,
    const BITSTRING& par_humanProblem,
    const BITSTRING& par_stationaryVehicle,
    const BITSTRING& par_emergencyVehicleApproaching,
    const BITSTRING& par_hazardousLocation__DangerousCurve,
    const BITSTRING& par_collisionRisk,
    const BITSTRING& par_signalViolation,
    const BITSTRING& par_dangerousSituation);
  SspDENM(const SspDENM& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SspDENM& operator=(const SspDENM& other_value);
  boolean operator==(const SspDENM& other_value) const;
  inline boolean operator!=(const SspDENM& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& trafficCondition()
    {return field_trafficCondition;}
  inline const BITSTRING& trafficCondition() const
    {return field_trafficCondition;}
  inline BITSTRING& accident()
    {return field_accident;}
  inline const BITSTRING& accident() const
    {return field_accident;}
  inline BITSTRING& roadworks()
    {return field_roadworks;}
  inline const BITSTRING& roadworks() const
    {return field_roadworks;}
  inline BITSTRING& adverseWeatherCondition__Adhesion()
    {return field_adverseWeatherCondition__Adhesion;}
  inline const BITSTRING& adverseWeatherCondition__Adhesion() const
    {return field_adverseWeatherCondition__Adhesion;}
  inline BITSTRING& hazardousLocation__SurfaceCondition()
    {return field_hazardousLocation__SurfaceCondition;}
  inline const BITSTRING& hazardousLocation__SurfaceCondition() const
    {return field_hazardousLocation__SurfaceCondition;}
  inline BITSTRING& hazardousLocation__ObstacleOnTheRoad()
    {return field_hazardousLocation__ObstacleOnTheRoad;}
  inline const BITSTRING& hazardousLocation__ObstacleOnTheRoad() const
    {return field_hazardousLocation__ObstacleOnTheRoad;}
  inline BITSTRING& hazardousLocation__AnimalOnTheRoad()
    {return field_hazardousLocation__AnimalOnTheRoad;}
  inline const BITSTRING& hazardousLocation__AnimalOnTheRoad() const
    {return field_hazardousLocation__AnimalOnTheRoad;}
  inline BITSTRING& humanPresenceOnTheRoad()
    {return field_humanPresenceOnTheRoad;}
  inline const BITSTRING& humanPresenceOnTheRoad() const
    {return field_humanPresenceOnTheRoad;}
  inline BITSTRING& wrongWayDriving()
    {return field_wrongWayDriving;}
  inline const BITSTRING& wrongWayDriving() const
    {return field_wrongWayDriving;}
  inline BITSTRING& rescueAndRecoveryWorkInProgress()
    {return field_rescueAndRecoveryWorkInProgress;}
  inline const BITSTRING& rescueAndRecoveryWorkInProgress() const
    {return field_rescueAndRecoveryWorkInProgress;}
  inline BITSTRING& adverseWeatherCondition__ExtremeWeatherCondition()
    {return field_adverseWeatherCondition__ExtremeWeatherCondition;}
  inline const BITSTRING& adverseWeatherCondition__ExtremeWeatherCondition() const
    {return field_adverseWeatherCondition__ExtremeWeatherCondition;}
  inline BITSTRING& adverseWeatherCondition__Visibility()
    {return field_adverseWeatherCondition__Visibility;}
  inline const BITSTRING& adverseWeatherCondition__Visibility() const
    {return field_adverseWeatherCondition__Visibility;}
  inline BITSTRING& adverseWeatherCondition__Precipitation()
    {return field_adverseWeatherCondition__Precipitation;}
  inline const BITSTRING& adverseWeatherCondition__Precipitation() const
    {return field_adverseWeatherCondition__Precipitation;}
  inline BITSTRING& slowVehicle()
    {return field_slowVehicle;}
  inline const BITSTRING& slowVehicle() const
    {return field_slowVehicle;}
  inline BITSTRING& dangerousEndOfQueue()
    {return field_dangerousEndOfQueue;}
  inline const BITSTRING& dangerousEndOfQueue() const
    {return field_dangerousEndOfQueue;}
  inline BITSTRING& vehicleBreakdown()
    {return field_vehicleBreakdown;}
  inline const BITSTRING& vehicleBreakdown() const
    {return field_vehicleBreakdown;}
  inline BITSTRING& postCrash()
    {return field_postCrash;}
  inline const BITSTRING& postCrash() const
    {return field_postCrash;}
  inline BITSTRING& humanProblem()
    {return field_humanProblem;}
  inline const BITSTRING& humanProblem() const
    {return field_humanProblem;}
  inline BITSTRING& stationaryVehicle()
    {return field_stationaryVehicle;}
  inline const BITSTRING& stationaryVehicle() const
    {return field_stationaryVehicle;}
  inline BITSTRING& emergencyVehicleApproaching()
    {return field_emergencyVehicleApproaching;}
  inline const BITSTRING& emergencyVehicleApproaching() const
    {return field_emergencyVehicleApproaching;}
  inline BITSTRING& hazardousLocation__DangerousCurve()
    {return field_hazardousLocation__DangerousCurve;}
  inline const BITSTRING& hazardousLocation__DangerousCurve() const
    {return field_hazardousLocation__DangerousCurve;}
  inline BITSTRING& collisionRisk()
    {return field_collisionRisk;}
  inline const BITSTRING& collisionRisk() const
    {return field_collisionRisk;}
  inline BITSTRING& signalViolation()
    {return field_signalViolation;}
  inline const BITSTRING& signalViolation() const
    {return field_signalViolation;}
  inline BITSTRING& dangerousSituation()
    {return field_dangerousSituation;}
  inline const BITSTRING& dangerousSituation() const
    {return field_dangerousSituation;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SspDENM_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SspDENM_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SspDENM& other_value);
void copy_template(const SspDENM_template& other_value);

public:
SspDENM_template();
SspDENM_template(template_sel other_value);
SspDENM_template(const SspDENM& other_value);
SspDENM_template(const OPTIONAL<SspDENM>& other_value);
SspDENM_template(const SspDENM_template& other_value);
~SspDENM_template();
SspDENM_template& operator=(template_sel other_value);
SspDENM_template& operator=(const SspDENM& other_value);
SspDENM_template& operator=(const OPTIONAL<SspDENM>& other_value);
SspDENM_template& operator=(const SspDENM_template& other_value);
boolean match(const SspDENM& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SspDENM valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SspDENM_template& list_item(unsigned int list_index) const;
BITSTRING_template& trafficCondition();
const BITSTRING_template& trafficCondition() const;
BITSTRING_template& accident();
const BITSTRING_template& accident() const;
BITSTRING_template& roadworks();
const BITSTRING_template& roadworks() const;
BITSTRING_template& adverseWeatherCondition__Adhesion();
const BITSTRING_template& adverseWeatherCondition__Adhesion() const;
BITSTRING_template& hazardousLocation__SurfaceCondition();
const BITSTRING_template& hazardousLocation__SurfaceCondition() const;
BITSTRING_template& hazardousLocation__ObstacleOnTheRoad();
const BITSTRING_template& hazardousLocation__ObstacleOnTheRoad() const;
BITSTRING_template& hazardousLocation__AnimalOnTheRoad();
const BITSTRING_template& hazardousLocation__AnimalOnTheRoad() const;
BITSTRING_template& humanPresenceOnTheRoad();
const BITSTRING_template& humanPresenceOnTheRoad() const;
BITSTRING_template& wrongWayDriving();
const BITSTRING_template& wrongWayDriving() const;
BITSTRING_template& rescueAndRecoveryWorkInProgress();
const BITSTRING_template& rescueAndRecoveryWorkInProgress() const;
BITSTRING_template& adverseWeatherCondition__ExtremeWeatherCondition();
const BITSTRING_template& adverseWeatherCondition__ExtremeWeatherCondition() const;
BITSTRING_template& adverseWeatherCondition__Visibility();
const BITSTRING_template& adverseWeatherCondition__Visibility() const;
BITSTRING_template& adverseWeatherCondition__Precipitation();
const BITSTRING_template& adverseWeatherCondition__Precipitation() const;
BITSTRING_template& slowVehicle();
const BITSTRING_template& slowVehicle() const;
BITSTRING_template& dangerousEndOfQueue();
const BITSTRING_template& dangerousEndOfQueue() const;
BITSTRING_template& vehicleBreakdown();
const BITSTRING_template& vehicleBreakdown() const;
BITSTRING_template& postCrash();
const BITSTRING_template& postCrash() const;
BITSTRING_template& humanProblem();
const BITSTRING_template& humanProblem() const;
BITSTRING_template& stationaryVehicle();
const BITSTRING_template& stationaryVehicle() const;
BITSTRING_template& emergencyVehicleApproaching();
const BITSTRING_template& emergencyVehicleApproaching() const;
BITSTRING_template& hazardousLocation__DangerousCurve();
const BITSTRING_template& hazardousLocation__DangerousCurve() const;
BITSTRING_template& collisionRisk();
const BITSTRING_template& collisionRisk() const;
BITSTRING_template& signalViolation();
const BITSTRING_template& signalViolation() const;
BITSTRING_template& dangerousSituation();
const BITSTRING_template& dangerousSituation() const;
int size_of() const;
void log() const;
void log_match(const SspDENM& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ItsAidSsp : public Base_Type {
  INTEGER field_its__aid;
  ServiceSpecificPermissions field_service__specific__permissions;
  boolean bound_flag;
public:
  ItsAidSsp();
  ItsAidSsp(const INTEGER& par_its__aid,
    const ServiceSpecificPermissions& par_service__specific__permissions);
  ItsAidSsp(const ItsAidSsp& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ItsAidSsp& operator=(const ItsAidSsp& other_value);
  boolean operator==(const ItsAidSsp& other_value) const;
  inline boolean operator!=(const ItsAidSsp& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& its__aid()
    {return field_its__aid;}
  inline const INTEGER& its__aid() const
    {return field_its__aid;}
  inline ServiceSpecificPermissions& service__specific__permissions()
    {return field_service__specific__permissions;}
  inline const ServiceSpecificPermissions& service__specific__permissions() const
    {return field_service__specific__permissions;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ItsAidSsp_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ItsAidSsp_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ItsAidSsp& other_value);
void copy_template(const ItsAidSsp_template& other_value);

public:
ItsAidSsp_template();
ItsAidSsp_template(template_sel other_value);
ItsAidSsp_template(const ItsAidSsp& other_value);
ItsAidSsp_template(const OPTIONAL<ItsAidSsp>& other_value);
ItsAidSsp_template(const ItsAidSsp_template& other_value);
~ItsAidSsp_template();
ItsAidSsp_template& operator=(template_sel other_value);
ItsAidSsp_template& operator=(const ItsAidSsp& other_value);
ItsAidSsp_template& operator=(const OPTIONAL<ItsAidSsp>& other_value);
ItsAidSsp_template& operator=(const ItsAidSsp_template& other_value);
boolean match(const ItsAidSsp& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ItsAidSsp valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ItsAidSsp_template& list_item(unsigned int list_index) const;
INTEGER_template& its__aid();
const INTEGER_template& its__aid() const;
ServiceSpecificPermissions_template& service__specific__permissions();
const ServiceSpecificPermissions_template& service__specific__permissions() const;
int size_of() const;
void log() const;
void log_match(const ItsAidSsp& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SubjectAttribute : public Base_Type {
  SubjectAttributeType field_type__;
  SubjectAttributeContainer field_attribute;
  boolean bound_flag;
public:
  SubjectAttribute();
  SubjectAttribute(const SubjectAttributeType& par_type__,
    const SubjectAttributeContainer& par_attribute);
  SubjectAttribute(const SubjectAttribute& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SubjectAttribute& operator=(const SubjectAttribute& other_value);
  boolean operator==(const SubjectAttribute& other_value) const;
  inline boolean operator!=(const SubjectAttribute& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline SubjectAttributeType& type__()
    {return field_type__;}
  inline const SubjectAttributeType& type__() const
    {return field_type__;}
  inline SubjectAttributeContainer& attribute()
    {return field_attribute;}
  inline const SubjectAttributeContainer& attribute() const
    {return field_attribute;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SubjectAttribute_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SubjectAttribute_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SubjectAttribute& other_value);
void copy_template(const SubjectAttribute_template& other_value);

public:
SubjectAttribute_template();
SubjectAttribute_template(template_sel other_value);
SubjectAttribute_template(const SubjectAttribute& other_value);
SubjectAttribute_template(const OPTIONAL<SubjectAttribute>& other_value);
SubjectAttribute_template(const SubjectAttribute_template& other_value);
~SubjectAttribute_template();
SubjectAttribute_template& operator=(template_sel other_value);
SubjectAttribute_template& operator=(const SubjectAttribute& other_value);
SubjectAttribute_template& operator=(const OPTIONAL<SubjectAttribute>& other_value);
SubjectAttribute_template& operator=(const SubjectAttribute_template& other_value);
boolean match(const SubjectAttribute& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SubjectAttribute valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SubjectAttribute_template& list_item(unsigned int list_index) const;
SubjectAttributeType_template& type__();
const SubjectAttributeType_template& type__() const;
SubjectAttributeContainer_template& attribute();
const SubjectAttributeContainer_template& attribute() const;
int size_of() const;
void log() const;
void log_match(const SubjectAttribute& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ValidityRestrictions : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ValidityRestriction **value_elements;
} *val_ptr;

static const ValidityRestriction UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ValidityRestrictions& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef ValidityRestriction of_type;
ValidityRestrictions();
ValidityRestrictions(null_type other_value);
ValidityRestrictions(const ValidityRestrictions& other_value);
~ValidityRestrictions();

void clean_up();
ValidityRestrictions& operator=(null_type other_value);
ValidityRestrictions& operator=(const ValidityRestrictions& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ValidityRestrictions& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ValidityRestrictions& other_value) const { return !(*this == other_value); }

ValidityRestriction& operator[](int index_value);
ValidityRestriction& operator[](const INTEGER& index_value);
const ValidityRestriction& operator[](int index_value) const;
const ValidityRestriction& operator[](const INTEGER& index_value) const;

ValidityRestrictions operator<<=(int rotate_count) const;
ValidityRestrictions operator<<=(const INTEGER& rotate_count) const;
ValidityRestrictions operator>>=(int rotate_count) const;
ValidityRestrictions operator>>=(const INTEGER& rotate_count) const;

ValidityRestrictions operator+(const ValidityRestrictions& other_value) const;

ValidityRestrictions substr(int index, int returncount) const;

ValidityRestrictions replace(int index, int len, const ValidityRestrictions& repl) const;

ValidityRestrictions replace(int index, int len, const ValidityRestrictions_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ValidityRestrictions_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
ValidityRestriction_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ValidityRestrictions_template *list_value;
} value_list;
struct {
unsigned int n_items;
ValidityRestriction_template *set_items;
} value_set;
};
void copy_value(const ValidityRestrictions& other_value);
void copy_template(const ValidityRestrictions_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
ValidityRestrictions_template();
ValidityRestrictions_template(template_sel other_value);
ValidityRestrictions_template(null_type other_value);
ValidityRestrictions_template(const ValidityRestrictions& other_value);
ValidityRestrictions_template(const OPTIONAL<ValidityRestrictions>& other_value);
ValidityRestrictions_template(const ValidityRestrictions_template& other_value);
~ValidityRestrictions_template();

void clean_up();
ValidityRestrictions_template& operator=(template_sel other_value);
ValidityRestrictions_template& operator=(null_type other_value);
ValidityRestrictions_template& operator=(const ValidityRestrictions& other_value);
ValidityRestrictions_template& operator=(const OPTIONAL<ValidityRestrictions>& other_value);
ValidityRestrictions_template& operator=(const ValidityRestrictions_template& other_value);

ValidityRestriction_template& operator[](int index_value);
ValidityRestriction_template& operator[](const INTEGER& index_value);
const ValidityRestriction_template& operator[](int index_value) const;
const ValidityRestriction_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ValidityRestrictions& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ValidityRestrictions valueof() const;
ValidityRestrictions substr(int index, int returncount) const;

ValidityRestrictions replace(int index, int len, const ValidityRestrictions_template& repl) const;

ValidityRestrictions replace(int index, int len, const ValidityRestrictions& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ValidityRestrictions_template& list_item(unsigned int list_index);
ValidityRestriction_template& set_item(unsigned int set_index);
void log() const;
void log_match(const ValidityRestrictions& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ValidityRestrictionType : public Base_Type { // enum
friend class ValidityRestrictionType_template;
public:
enum enum_type { e__time__end = 0, e__time__start__and__end = 1, e__time__start__and__duration = 2, e__region = 3, e__unknown = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
ValidityRestrictionType();
ValidityRestrictionType(int other_value);
ValidityRestrictionType(enum_type other_value);
ValidityRestrictionType(const ValidityRestrictionType& other_value);

ValidityRestrictionType& operator=(int other_value);
ValidityRestrictionType& operator=(enum_type other_value);
ValidityRestrictionType& operator=(const ValidityRestrictionType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ValidityRestrictionType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ValidityRestrictionType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ValidityRestrictionType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ValidityRestrictionType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ValidityRestrictionType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ValidityRestrictionType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ValidityRestrictionType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ValidityRestrictionType_template : public Base_Template {
union {
ValidityRestrictionType::enum_type single_value;
struct {
unsigned int n_values;
ValidityRestrictionType_template *list_value;
} value_list;
};

void copy_template(const ValidityRestrictionType_template& other_value);

public:
ValidityRestrictionType_template();
ValidityRestrictionType_template(template_sel other_value);
ValidityRestrictionType_template(int other_value);
ValidityRestrictionType_template(ValidityRestrictionType::enum_type other_value);
ValidityRestrictionType_template(const ValidityRestrictionType& other_value);
ValidityRestrictionType_template(const OPTIONAL<ValidityRestrictionType>& other_value);
ValidityRestrictionType_template(const ValidityRestrictionType_template& other_value);
~ValidityRestrictionType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ValidityRestrictionType_template& operator=(template_sel other_value);
ValidityRestrictionType_template& operator=(int other_value);
ValidityRestrictionType_template& operator=(ValidityRestrictionType::enum_type other_value);
ValidityRestrictionType_template& operator=(const ValidityRestrictionType& other_value);
ValidityRestrictionType_template& operator=(const OPTIONAL<ValidityRestrictionType>& other_value);
ValidityRestrictionType_template& operator=(const ValidityRestrictionType_template& other_value);

boolean match(ValidityRestrictionType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const ValidityRestrictionType& other_value, boolean legacy = FALSE) const;
ValidityRestrictionType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ValidityRestrictionType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ValidityRestrictionType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ValidityRestrictionContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_end__validity = 1, ALT_time__start__and__end = 2, ALT_time__start__and__duration = 3, ALT_region = 4, ALT_data = 5 };
private:
union_selection_type union_selection;
union {
INTEGER *field_end__validity;
TimeStartEnd *field_time__start__and__end;
TimeDuration *field_time__start__and__duration;
GeographicRegion *field_region;
OCTETSTRING *field_data;
};
void copy_value(const ValidityRestrictionContainer& other_value);

public:
ValidityRestrictionContainer();
ValidityRestrictionContainer(const ValidityRestrictionContainer& other_value);
~ValidityRestrictionContainer();
ValidityRestrictionContainer& operator=(const ValidityRestrictionContainer& other_value);
boolean operator==(const ValidityRestrictionContainer& other_value) const;
inline boolean operator!=(const ValidityRestrictionContainer& other_value) const { return !(*this == other_value); }
INTEGER& end__validity();
const INTEGER& end__validity() const;
TimeStartEnd& time__start__and__end();
const TimeStartEnd& time__start__and__end() const;
TimeDuration& time__start__and__duration();
const TimeDuration& time__start__and__duration() const;
GeographicRegion& region();
const GeographicRegion& region() const;
OCTETSTRING& data();
const OCTETSTRING& data() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ValidityRestrictionContainer_template : public Base_Template {
union {
struct {
ValidityRestrictionContainer::union_selection_type union_selection;
union {
INTEGER_template *field_end__validity;
TimeStartEnd_template *field_time__start__and__end;
TimeDuration_template *field_time__start__and__duration;
GeographicRegion_template *field_region;
OCTETSTRING_template *field_data;
};
} single_value;
struct {
unsigned int n_values;
ValidityRestrictionContainer_template *list_value;
} value_list;
};
void copy_value(const ValidityRestrictionContainer& other_value);

void copy_template(const ValidityRestrictionContainer_template& other_value);

public:
ValidityRestrictionContainer_template();
ValidityRestrictionContainer_template(template_sel other_value);
ValidityRestrictionContainer_template(const ValidityRestrictionContainer& other_value);
ValidityRestrictionContainer_template(const OPTIONAL<ValidityRestrictionContainer>& other_value);
ValidityRestrictionContainer_template(const ValidityRestrictionContainer_template& other_value);
~ValidityRestrictionContainer_template();
void clean_up();
ValidityRestrictionContainer_template& operator=(template_sel other_value);
ValidityRestrictionContainer_template& operator=(const ValidityRestrictionContainer& other_value);
ValidityRestrictionContainer_template& operator=(const OPTIONAL<ValidityRestrictionContainer>& other_value);
ValidityRestrictionContainer_template& operator=(const ValidityRestrictionContainer_template& other_value);
boolean match(const ValidityRestrictionContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ValidityRestrictionContainer valueof() const;
ValidityRestrictionContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& end__validity();
const INTEGER_template& end__validity() const;
TimeStartEnd_template& time__start__and__end();
const TimeStartEnd_template& time__start__and__end() const;
TimeDuration_template& time__start__and__duration();
const TimeDuration_template& time__start__and__duration() const;
GeographicRegion_template& region();
const GeographicRegion_template& region() const;
OCTETSTRING_template& data();
const OCTETSTRING_template& data() const;
boolean ischosen(ValidityRestrictionContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const ValidityRestrictionContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TimeStartEnd : public Base_Type {
  INTEGER field_start__validity;
  INTEGER field_end__validity;
  boolean bound_flag;
public:
  TimeStartEnd();
  TimeStartEnd(const INTEGER& par_start__validity,
    const INTEGER& par_end__validity);
  TimeStartEnd(const TimeStartEnd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TimeStartEnd& operator=(const TimeStartEnd& other_value);
  boolean operator==(const TimeStartEnd& other_value) const;
  inline boolean operator!=(const TimeStartEnd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& start__validity()
    {return field_start__validity;}
  inline const INTEGER& start__validity() const
    {return field_start__validity;}
  inline INTEGER& end__validity()
    {return field_end__validity;}
  inline const INTEGER& end__validity() const
    {return field_end__validity;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TimeStartEnd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TimeStartEnd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TimeStartEnd& other_value);
void copy_template(const TimeStartEnd_template& other_value);

public:
TimeStartEnd_template();
TimeStartEnd_template(template_sel other_value);
TimeStartEnd_template(const TimeStartEnd& other_value);
TimeStartEnd_template(const OPTIONAL<TimeStartEnd>& other_value);
TimeStartEnd_template(const TimeStartEnd_template& other_value);
~TimeStartEnd_template();
TimeStartEnd_template& operator=(template_sel other_value);
TimeStartEnd_template& operator=(const TimeStartEnd& other_value);
TimeStartEnd_template& operator=(const OPTIONAL<TimeStartEnd>& other_value);
TimeStartEnd_template& operator=(const TimeStartEnd_template& other_value);
boolean match(const TimeStartEnd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TimeStartEnd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TimeStartEnd_template& list_item(unsigned int list_index) const;
INTEGER_template& start__validity();
const INTEGER_template& start__validity() const;
INTEGER_template& end__validity();
const INTEGER_template& end__validity() const;
int size_of() const;
void log() const;
void log_match(const TimeStartEnd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DurationUnitType : public Base_Type { // enum
friend class DurationUnitType_template;
public:
enum enum_type { e__seconds = 0, e__minutes = 1, e__hours = 2, e__hoursBlock = 3, e__year = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
DurationUnitType();
DurationUnitType(int other_value);
DurationUnitType(enum_type other_value);
DurationUnitType(const DurationUnitType& other_value);

DurationUnitType& operator=(int other_value);
DurationUnitType& operator=(enum_type other_value);
DurationUnitType& operator=(const DurationUnitType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const DurationUnitType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DurationUnitType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const DurationUnitType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const DurationUnitType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const DurationUnitType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const DurationUnitType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const DurationUnitType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DurationUnitType_template : public Base_Template {
union {
DurationUnitType::enum_type single_value;
struct {
unsigned int n_values;
DurationUnitType_template *list_value;
} value_list;
};

void copy_template(const DurationUnitType_template& other_value);

public:
DurationUnitType_template();
DurationUnitType_template(template_sel other_value);
DurationUnitType_template(int other_value);
DurationUnitType_template(DurationUnitType::enum_type other_value);
DurationUnitType_template(const DurationUnitType& other_value);
DurationUnitType_template(const OPTIONAL<DurationUnitType>& other_value);
DurationUnitType_template(const DurationUnitType_template& other_value);
~DurationUnitType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
DurationUnitType_template& operator=(template_sel other_value);
DurationUnitType_template& operator=(int other_value);
DurationUnitType_template& operator=(DurationUnitType::enum_type other_value);
DurationUnitType_template& operator=(const DurationUnitType& other_value);
DurationUnitType_template& operator=(const OPTIONAL<DurationUnitType>& other_value);
DurationUnitType_template& operator=(const DurationUnitType_template& other_value);

boolean match(DurationUnitType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const DurationUnitType& other_value, boolean legacy = FALSE) const;
DurationUnitType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DurationUnitType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const DurationUnitType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Duration : public Base_Type {
  DurationUnitType field_unit;
  INTEGER field_duration;
  boolean bound_flag;
public:
  Duration();
  Duration(const DurationUnitType& par_unit,
    const INTEGER& par_duration);
  Duration(const Duration& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Duration& operator=(const Duration& other_value);
  boolean operator==(const Duration& other_value) const;
  inline boolean operator!=(const Duration& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline DurationUnitType& unit()
    {return field_unit;}
  inline const DurationUnitType& unit() const
    {return field_unit;}
  inline INTEGER& duration()
    {return field_duration;}
  inline const INTEGER& duration() const
    {return field_duration;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Duration_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Duration_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Duration& other_value);
void copy_template(const Duration_template& other_value);

public:
Duration_template();
Duration_template(template_sel other_value);
Duration_template(const Duration& other_value);
Duration_template(const OPTIONAL<Duration>& other_value);
Duration_template(const Duration_template& other_value);
~Duration_template();
Duration_template& operator=(template_sel other_value);
Duration_template& operator=(const Duration& other_value);
Duration_template& operator=(const OPTIONAL<Duration>& other_value);
Duration_template& operator=(const Duration_template& other_value);
boolean match(const Duration& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Duration valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Duration_template& list_item(unsigned int list_index) const;
DurationUnitType_template& unit();
const DurationUnitType_template& unit() const;
INTEGER_template& duration();
const INTEGER_template& duration() const;
int size_of() const;
void log() const;
void log_match(const Duration& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TimeDuration : public Base_Type {
  INTEGER field_start__validity;
  Duration field_duration;
  boolean bound_flag;
public:
  TimeDuration();
  TimeDuration(const INTEGER& par_start__validity,
    const Duration& par_duration);
  TimeDuration(const TimeDuration& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TimeDuration& operator=(const TimeDuration& other_value);
  boolean operator==(const TimeDuration& other_value) const;
  inline boolean operator!=(const TimeDuration& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& start__validity()
    {return field_start__validity;}
  inline const INTEGER& start__validity() const
    {return field_start__validity;}
  inline Duration& duration()
    {return field_duration;}
  inline const Duration& duration() const
    {return field_duration;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TimeDuration_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TimeDuration_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TimeDuration& other_value);
void copy_template(const TimeDuration_template& other_value);

public:
TimeDuration_template();
TimeDuration_template(template_sel other_value);
TimeDuration_template(const TimeDuration& other_value);
TimeDuration_template(const OPTIONAL<TimeDuration>& other_value);
TimeDuration_template(const TimeDuration_template& other_value);
~TimeDuration_template();
TimeDuration_template& operator=(template_sel other_value);
TimeDuration_template& operator=(const TimeDuration& other_value);
TimeDuration_template& operator=(const OPTIONAL<TimeDuration>& other_value);
TimeDuration_template& operator=(const TimeDuration_template& other_value);
boolean match(const TimeDuration& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TimeDuration valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TimeDuration_template& list_item(unsigned int list_index) const;
INTEGER_template& start__validity();
const INTEGER_template& start__validity() const;
Duration_template& duration();
const Duration_template& duration() const;
int size_of() const;
void log() const;
void log_match(const TimeDuration& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RegionType : public Base_Type { // enum
friend class RegionType_template;
public:
enum enum_type { e__none = 0, e__circle = 1, e__rectangle = 2, e__polygon = 3, e__id = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
RegionType();
RegionType(int other_value);
RegionType(enum_type other_value);
RegionType(const RegionType& other_value);

RegionType& operator=(int other_value);
RegionType& operator=(enum_type other_value);
RegionType& operator=(const RegionType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const RegionType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RegionType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const RegionType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const RegionType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const RegionType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const RegionType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const RegionType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RegionType_template : public Base_Template {
union {
RegionType::enum_type single_value;
struct {
unsigned int n_values;
RegionType_template *list_value;
} value_list;
};

void copy_template(const RegionType_template& other_value);

public:
RegionType_template();
RegionType_template(template_sel other_value);
RegionType_template(int other_value);
RegionType_template(RegionType::enum_type other_value);
RegionType_template(const RegionType& other_value);
RegionType_template(const OPTIONAL<RegionType>& other_value);
RegionType_template(const RegionType_template& other_value);
~RegionType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegionType_template& operator=(template_sel other_value);
RegionType_template& operator=(int other_value);
RegionType_template& operator=(RegionType::enum_type other_value);
RegionType_template& operator=(const RegionType& other_value);
RegionType_template& operator=(const OPTIONAL<RegionType>& other_value);
RegionType_template& operator=(const RegionType_template& other_value);

boolean match(RegionType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const RegionType& other_value, boolean legacy = FALSE) const;
RegionType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegionType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RegionType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GeographicRegion : public Base_Type {
  RegionType field_region__type;
  OPTIONAL<GeographicRegionContainer> field_region;
  boolean bound_flag;
public:
  GeographicRegion();
  GeographicRegion(const RegionType& par_region__type,
    const OPTIONAL<GeographicRegionContainer>& par_region);
  GeographicRegion(const GeographicRegion& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeographicRegion& operator=(const GeographicRegion& other_value);
  boolean operator==(const GeographicRegion& other_value) const;
  inline boolean operator!=(const GeographicRegion& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RegionType& region__type()
    {return field_region__type;}
  inline const RegionType& region__type() const
    {return field_region__type;}
  inline OPTIONAL<GeographicRegionContainer>& region()
    {return field_region;}
  inline const OPTIONAL<GeographicRegionContainer>& region() const
    {return field_region;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeographicRegion_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeographicRegion_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeographicRegion& other_value);
void copy_template(const GeographicRegion_template& other_value);

public:
GeographicRegion_template();
GeographicRegion_template(template_sel other_value);
GeographicRegion_template(const GeographicRegion& other_value);
GeographicRegion_template(const OPTIONAL<GeographicRegion>& other_value);
GeographicRegion_template(const GeographicRegion_template& other_value);
~GeographicRegion_template();
GeographicRegion_template& operator=(template_sel other_value);
GeographicRegion_template& operator=(const GeographicRegion& other_value);
GeographicRegion_template& operator=(const OPTIONAL<GeographicRegion>& other_value);
GeographicRegion_template& operator=(const GeographicRegion_template& other_value);
boolean match(const GeographicRegion& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeographicRegion valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeographicRegion_template& list_item(unsigned int list_index) const;
RegionType_template& region__type();
const RegionType_template& region__type() const;
GeographicRegionContainer_template& region();
const GeographicRegionContainer_template& region() const;
int size_of() const;
void log() const;
void log_match(const GeographicRegion& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeographicRegionContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_circular__region = 1, ALT_rectangular__region = 2, ALT_polygonal__region = 3, ALT_id__region = 4, ALT_other__region = 5 };
private:
union_selection_type union_selection;
union {
CircularRegion *field_circular__region;
RectangularRegions *field_rectangular__region;
PolygonalRegion *field_polygonal__region;
IdentifiedRegion *field_id__region;
OCTETSTRING *field_other__region;
};
void copy_value(const GeographicRegionContainer& other_value);

public:
GeographicRegionContainer();
GeographicRegionContainer(const GeographicRegionContainer& other_value);
~GeographicRegionContainer();
GeographicRegionContainer& operator=(const GeographicRegionContainer& other_value);
boolean operator==(const GeographicRegionContainer& other_value) const;
inline boolean operator!=(const GeographicRegionContainer& other_value) const { return !(*this == other_value); }
CircularRegion& circular__region();
const CircularRegion& circular__region() const;
RectangularRegions& rectangular__region();
const RectangularRegions& rectangular__region() const;
PolygonalRegion& polygonal__region();
const PolygonalRegion& polygonal__region() const;
IdentifiedRegion& id__region();
const IdentifiedRegion& id__region() const;
OCTETSTRING& other__region();
const OCTETSTRING& other__region() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeographicRegionContainer_template : public Base_Template {
union {
struct {
GeographicRegionContainer::union_selection_type union_selection;
union {
CircularRegion_template *field_circular__region;
RectangularRegions_template *field_rectangular__region;
PolygonalRegion_template *field_polygonal__region;
IdentifiedRegion_template *field_id__region;
OCTETSTRING_template *field_other__region;
};
} single_value;
struct {
unsigned int n_values;
GeographicRegionContainer_template *list_value;
} value_list;
};
void copy_value(const GeographicRegionContainer& other_value);

void copy_template(const GeographicRegionContainer_template& other_value);

public:
GeographicRegionContainer_template();
GeographicRegionContainer_template(template_sel other_value);
GeographicRegionContainer_template(const GeographicRegionContainer& other_value);
GeographicRegionContainer_template(const OPTIONAL<GeographicRegionContainer>& other_value);
GeographicRegionContainer_template(const GeographicRegionContainer_template& other_value);
~GeographicRegionContainer_template();
void clean_up();
GeographicRegionContainer_template& operator=(template_sel other_value);
GeographicRegionContainer_template& operator=(const GeographicRegionContainer& other_value);
GeographicRegionContainer_template& operator=(const OPTIONAL<GeographicRegionContainer>& other_value);
GeographicRegionContainer_template& operator=(const GeographicRegionContainer_template& other_value);
boolean match(const GeographicRegionContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;GeographicRegionContainer valueof() const;
GeographicRegionContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
CircularRegion_template& circular__region();
const CircularRegion_template& circular__region() const;
RectangularRegions_template& rectangular__region();
const RectangularRegions_template& rectangular__region() const;
PolygonalRegion_template& polygonal__region();
const PolygonalRegion_template& polygonal__region() const;
IdentifiedRegion_template& id__region();
const IdentifiedRegion_template& id__region() const;
OCTETSTRING_template& other__region();
const OCTETSTRING_template& other__region() const;
boolean ischosen(GeographicRegionContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const GeographicRegionContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TwoDLocation : public Base_Type {
  INTEGER field_latitude;
  INTEGER field_longitude;
  boolean bound_flag;
public:
  TwoDLocation();
  TwoDLocation(const INTEGER& par_latitude,
    const INTEGER& par_longitude);
  TwoDLocation(const TwoDLocation& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TwoDLocation& operator=(const TwoDLocation& other_value);
  boolean operator==(const TwoDLocation& other_value) const;
  inline boolean operator!=(const TwoDLocation& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& latitude()
    {return field_latitude;}
  inline const INTEGER& latitude() const
    {return field_latitude;}
  inline INTEGER& longitude()
    {return field_longitude;}
  inline const INTEGER& longitude() const
    {return field_longitude;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TwoDLocation_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TwoDLocation_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TwoDLocation& other_value);
void copy_template(const TwoDLocation_template& other_value);

public:
TwoDLocation_template();
TwoDLocation_template(template_sel other_value);
TwoDLocation_template(const TwoDLocation& other_value);
TwoDLocation_template(const OPTIONAL<TwoDLocation>& other_value);
TwoDLocation_template(const TwoDLocation_template& other_value);
~TwoDLocation_template();
TwoDLocation_template& operator=(template_sel other_value);
TwoDLocation_template& operator=(const TwoDLocation& other_value);
TwoDLocation_template& operator=(const OPTIONAL<TwoDLocation>& other_value);
TwoDLocation_template& operator=(const TwoDLocation_template& other_value);
boolean match(const TwoDLocation& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TwoDLocation valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TwoDLocation_template& list_item(unsigned int list_index) const;
INTEGER_template& latitude();
const INTEGER_template& latitude() const;
INTEGER_template& longitude();
const INTEGER_template& longitude() const;
int size_of() const;
void log() const;
void log_match(const TwoDLocation& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CircularRegion : public Base_Type {
  TwoDLocation field_center;
  INTEGER field_radius;
  boolean bound_flag;
public:
  CircularRegion();
  CircularRegion(const TwoDLocation& par_center,
    const INTEGER& par_radius);
  CircularRegion(const CircularRegion& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CircularRegion& operator=(const CircularRegion& other_value);
  boolean operator==(const CircularRegion& other_value) const;
  inline boolean operator!=(const CircularRegion& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline TwoDLocation& center()
    {return field_center;}
  inline const TwoDLocation& center() const
    {return field_center;}
  inline INTEGER& radius()
    {return field_radius;}
  inline const INTEGER& radius() const
    {return field_radius;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CircularRegion_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CircularRegion_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CircularRegion& other_value);
void copy_template(const CircularRegion_template& other_value);

public:
CircularRegion_template();
CircularRegion_template(template_sel other_value);
CircularRegion_template(const CircularRegion& other_value);
CircularRegion_template(const OPTIONAL<CircularRegion>& other_value);
CircularRegion_template(const CircularRegion_template& other_value);
~CircularRegion_template();
CircularRegion_template& operator=(template_sel other_value);
CircularRegion_template& operator=(const CircularRegion& other_value);
CircularRegion_template& operator=(const OPTIONAL<CircularRegion>& other_value);
CircularRegion_template& operator=(const CircularRegion_template& other_value);
boolean match(const CircularRegion& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CircularRegion valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CircularRegion_template& list_item(unsigned int list_index) const;
TwoDLocation_template& center();
const TwoDLocation_template& center() const;
INTEGER_template& radius();
const INTEGER_template& radius() const;
int size_of() const;
void log() const;
void log_match(const CircularRegion& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RectangularRegions : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
RectangularRegion **value_elements;
} *val_ptr;

static const RectangularRegion UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RectangularRegions& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef RectangularRegion of_type;
RectangularRegions();
RectangularRegions(null_type other_value);
RectangularRegions(const RectangularRegions& other_value);
~RectangularRegions();

void clean_up();
RectangularRegions& operator=(null_type other_value);
RectangularRegions& operator=(const RectangularRegions& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RectangularRegions& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RectangularRegions& other_value) const { return !(*this == other_value); }

RectangularRegion& operator[](int index_value);
RectangularRegion& operator[](const INTEGER& index_value);
const RectangularRegion& operator[](int index_value) const;
const RectangularRegion& operator[](const INTEGER& index_value) const;

RectangularRegions operator<<=(int rotate_count) const;
RectangularRegions operator<<=(const INTEGER& rotate_count) const;
RectangularRegions operator>>=(int rotate_count) const;
RectangularRegions operator>>=(const INTEGER& rotate_count) const;

RectangularRegions operator+(const RectangularRegions& other_value) const;

RectangularRegions substr(int index, int returncount) const;

RectangularRegions replace(int index, int len, const RectangularRegions& repl) const;

RectangularRegions replace(int index, int len, const RectangularRegions_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RectangularRegions_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
RectangularRegion_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RectangularRegions_template *list_value;
} value_list;
struct {
unsigned int n_items;
RectangularRegion_template *set_items;
} value_set;
};
void copy_value(const RectangularRegions& other_value);
void copy_template(const RectangularRegions_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
RectangularRegions_template();
RectangularRegions_template(template_sel other_value);
RectangularRegions_template(null_type other_value);
RectangularRegions_template(const RectangularRegions& other_value);
RectangularRegions_template(const OPTIONAL<RectangularRegions>& other_value);
RectangularRegions_template(const RectangularRegions_template& other_value);
~RectangularRegions_template();

void clean_up();
RectangularRegions_template& operator=(template_sel other_value);
RectangularRegions_template& operator=(null_type other_value);
RectangularRegions_template& operator=(const RectangularRegions& other_value);
RectangularRegions_template& operator=(const OPTIONAL<RectangularRegions>& other_value);
RectangularRegions_template& operator=(const RectangularRegions_template& other_value);

RectangularRegion_template& operator[](int index_value);
RectangularRegion_template& operator[](const INTEGER& index_value);
const RectangularRegion_template& operator[](int index_value) const;
const RectangularRegion_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RectangularRegions& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RectangularRegions valueof() const;
RectangularRegions substr(int index, int returncount) const;

RectangularRegions replace(int index, int len, const RectangularRegions_template& repl) const;

RectangularRegions replace(int index, int len, const RectangularRegions& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RectangularRegions_template& list_item(unsigned int list_index);
RectangularRegion_template& set_item(unsigned int set_index);
void log() const;
void log_match(const RectangularRegions& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RectangularRegion : public Base_Type {
  TwoDLocation field_northwest;
  TwoDLocation field_southeast;
  boolean bound_flag;
public:
  RectangularRegion();
  RectangularRegion(const TwoDLocation& par_northwest,
    const TwoDLocation& par_southeast);
  RectangularRegion(const RectangularRegion& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RectangularRegion& operator=(const RectangularRegion& other_value);
  boolean operator==(const RectangularRegion& other_value) const;
  inline boolean operator!=(const RectangularRegion& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline TwoDLocation& northwest()
    {return field_northwest;}
  inline const TwoDLocation& northwest() const
    {return field_northwest;}
  inline TwoDLocation& southeast()
    {return field_southeast;}
  inline const TwoDLocation& southeast() const
    {return field_southeast;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RectangularRegion_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RectangularRegion_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RectangularRegion& other_value);
void copy_template(const RectangularRegion_template& other_value);

public:
RectangularRegion_template();
RectangularRegion_template(template_sel other_value);
RectangularRegion_template(const RectangularRegion& other_value);
RectangularRegion_template(const OPTIONAL<RectangularRegion>& other_value);
RectangularRegion_template(const RectangularRegion_template& other_value);
~RectangularRegion_template();
RectangularRegion_template& operator=(template_sel other_value);
RectangularRegion_template& operator=(const RectangularRegion& other_value);
RectangularRegion_template& operator=(const OPTIONAL<RectangularRegion>& other_value);
RectangularRegion_template& operator=(const RectangularRegion_template& other_value);
boolean match(const RectangularRegion& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RectangularRegion valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RectangularRegion_template& list_item(unsigned int list_index) const;
TwoDLocation_template& northwest();
const TwoDLocation_template& northwest() const;
TwoDLocation_template& southeast();
const TwoDLocation_template& southeast() const;
int size_of() const;
void log() const;
void log_match(const RectangularRegion& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PolygonalRegion : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
TwoDLocation **value_elements;
} *val_ptr;

static const TwoDLocation UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PolygonalRegion& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef TwoDLocation of_type;
PolygonalRegion();
PolygonalRegion(null_type other_value);
PolygonalRegion(const PolygonalRegion& other_value);
~PolygonalRegion();

void clean_up();
PolygonalRegion& operator=(null_type other_value);
PolygonalRegion& operator=(const PolygonalRegion& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PolygonalRegion& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PolygonalRegion& other_value) const { return !(*this == other_value); }

TwoDLocation& operator[](int index_value);
TwoDLocation& operator[](const INTEGER& index_value);
const TwoDLocation& operator[](int index_value) const;
const TwoDLocation& operator[](const INTEGER& index_value) const;

PolygonalRegion operator<<=(int rotate_count) const;
PolygonalRegion operator<<=(const INTEGER& rotate_count) const;
PolygonalRegion operator>>=(int rotate_count) const;
PolygonalRegion operator>>=(const INTEGER& rotate_count) const;

PolygonalRegion operator+(const PolygonalRegion& other_value) const;

PolygonalRegion substr(int index, int returncount) const;

PolygonalRegion replace(int index, int len, const PolygonalRegion& repl) const;

PolygonalRegion replace(int index, int len, const PolygonalRegion_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PolygonalRegion_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
TwoDLocation_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PolygonalRegion_template *list_value;
} value_list;
struct {
unsigned int n_items;
TwoDLocation_template *set_items;
} value_set;
};
void copy_value(const PolygonalRegion& other_value);
void copy_template(const PolygonalRegion_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
PolygonalRegion_template();
PolygonalRegion_template(template_sel other_value);
PolygonalRegion_template(null_type other_value);
PolygonalRegion_template(const PolygonalRegion& other_value);
PolygonalRegion_template(const OPTIONAL<PolygonalRegion>& other_value);
PolygonalRegion_template(const PolygonalRegion_template& other_value);
~PolygonalRegion_template();

void clean_up();
PolygonalRegion_template& operator=(template_sel other_value);
PolygonalRegion_template& operator=(null_type other_value);
PolygonalRegion_template& operator=(const PolygonalRegion& other_value);
PolygonalRegion_template& operator=(const OPTIONAL<PolygonalRegion>& other_value);
PolygonalRegion_template& operator=(const PolygonalRegion_template& other_value);

TwoDLocation_template& operator[](int index_value);
TwoDLocation_template& operator[](const INTEGER& index_value);
const TwoDLocation_template& operator[](int index_value) const;
const TwoDLocation_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PolygonalRegion& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PolygonalRegion valueof() const;
PolygonalRegion substr(int index, int returncount) const;

PolygonalRegion replace(int index, int len, const PolygonalRegion_template& repl) const;

PolygonalRegion replace(int index, int len, const PolygonalRegion& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PolygonalRegion_template& list_item(unsigned int list_index);
TwoDLocation_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PolygonalRegion& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RegionDictionary : public Base_Type { // enum
friend class RegionDictionary_template;
public:
enum enum_type { e__iso__3166__1 = 0, e__un__stats = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
RegionDictionary();
RegionDictionary(int other_value);
RegionDictionary(enum_type other_value);
RegionDictionary(const RegionDictionary& other_value);

RegionDictionary& operator=(int other_value);
RegionDictionary& operator=(enum_type other_value);
RegionDictionary& operator=(const RegionDictionary& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const RegionDictionary& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RegionDictionary& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const RegionDictionary& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const RegionDictionary& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const RegionDictionary& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const RegionDictionary& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const RegionDictionary& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RegionDictionary_template : public Base_Template {
union {
RegionDictionary::enum_type single_value;
struct {
unsigned int n_values;
RegionDictionary_template *list_value;
} value_list;
};

void copy_template(const RegionDictionary_template& other_value);

public:
RegionDictionary_template();
RegionDictionary_template(template_sel other_value);
RegionDictionary_template(int other_value);
RegionDictionary_template(RegionDictionary::enum_type other_value);
RegionDictionary_template(const RegionDictionary& other_value);
RegionDictionary_template(const OPTIONAL<RegionDictionary>& other_value);
RegionDictionary_template(const RegionDictionary_template& other_value);
~RegionDictionary_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegionDictionary_template& operator=(template_sel other_value);
RegionDictionary_template& operator=(int other_value);
RegionDictionary_template& operator=(RegionDictionary::enum_type other_value);
RegionDictionary_template& operator=(const RegionDictionary& other_value);
RegionDictionary_template& operator=(const OPTIONAL<RegionDictionary>& other_value);
RegionDictionary_template& operator=(const RegionDictionary_template& other_value);

boolean match(RegionDictionary::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const RegionDictionary& other_value, boolean legacy = FALSE) const;
RegionDictionary::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegionDictionary_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RegionDictionary& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class IdentifiedRegion : public Base_Type {
  RegionDictionary field_region__dictionary;
  INTEGER field_region__identifier;
  INTEGER field_local__region;
  boolean bound_flag;
public:
  IdentifiedRegion();
  IdentifiedRegion(const RegionDictionary& par_region__dictionary,
    const INTEGER& par_region__identifier,
    const INTEGER& par_local__region);
  IdentifiedRegion(const IdentifiedRegion& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IdentifiedRegion& operator=(const IdentifiedRegion& other_value);
  boolean operator==(const IdentifiedRegion& other_value) const;
  inline boolean operator!=(const IdentifiedRegion& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RegionDictionary& region__dictionary()
    {return field_region__dictionary;}
  inline const RegionDictionary& region__dictionary() const
    {return field_region__dictionary;}
  inline INTEGER& region__identifier()
    {return field_region__identifier;}
  inline const INTEGER& region__identifier() const
    {return field_region__identifier;}
  inline INTEGER& local__region()
    {return field_local__region;}
  inline const INTEGER& local__region() const
    {return field_local__region;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IdentifiedRegion_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IdentifiedRegion_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IdentifiedRegion& other_value);
void copy_template(const IdentifiedRegion_template& other_value);

public:
IdentifiedRegion_template();
IdentifiedRegion_template(template_sel other_value);
IdentifiedRegion_template(const IdentifiedRegion& other_value);
IdentifiedRegion_template(const OPTIONAL<IdentifiedRegion>& other_value);
IdentifiedRegion_template(const IdentifiedRegion_template& other_value);
~IdentifiedRegion_template();
IdentifiedRegion_template& operator=(template_sel other_value);
IdentifiedRegion_template& operator=(const IdentifiedRegion& other_value);
IdentifiedRegion_template& operator=(const OPTIONAL<IdentifiedRegion>& other_value);
IdentifiedRegion_template& operator=(const IdentifiedRegion_template& other_value);
boolean match(const IdentifiedRegion& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IdentifiedRegion valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IdentifiedRegion_template& list_item(unsigned int list_index) const;
RegionDictionary_template& region__dictionary();
const RegionDictionary_template& region__dictionary() const;
INTEGER_template& region__identifier();
const INTEGER_template& region__identifier() const;
INTEGER_template& local__region();
const INTEGER_template& local__region() const;
int size_of() const;
void log() const;
void log_match(const IdentifiedRegion& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ValidityRestriction : public Base_Type {
  ValidityRestrictionType field_type__;
  ValidityRestrictionContainer field_validity;
  boolean bound_flag;
public:
  ValidityRestriction();
  ValidityRestriction(const ValidityRestrictionType& par_type__,
    const ValidityRestrictionContainer& par_validity);
  ValidityRestriction(const ValidityRestriction& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ValidityRestriction& operator=(const ValidityRestriction& other_value);
  boolean operator==(const ValidityRestriction& other_value) const;
  inline boolean operator!=(const ValidityRestriction& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ValidityRestrictionType& type__()
    {return field_type__;}
  inline const ValidityRestrictionType& type__() const
    {return field_type__;}
  inline ValidityRestrictionContainer& validity()
    {return field_validity;}
  inline const ValidityRestrictionContainer& validity() const
    {return field_validity;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ValidityRestriction_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ValidityRestriction_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ValidityRestriction& other_value);
void copy_template(const ValidityRestriction_template& other_value);

public:
ValidityRestriction_template();
ValidityRestriction_template(template_sel other_value);
ValidityRestriction_template(const ValidityRestriction& other_value);
ValidityRestriction_template(const OPTIONAL<ValidityRestriction>& other_value);
ValidityRestriction_template(const ValidityRestriction_template& other_value);
~ValidityRestriction_template();
ValidityRestriction_template& operator=(template_sel other_value);
ValidityRestriction_template& operator=(const ValidityRestriction& other_value);
ValidityRestriction_template& operator=(const OPTIONAL<ValidityRestriction>& other_value);
ValidityRestriction_template& operator=(const ValidityRestriction_template& other_value);
boolean match(const ValidityRestriction& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ValidityRestriction valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ValidityRestriction_template& list_item(unsigned int list_index) const;
ValidityRestrictionType_template& type__();
const ValidityRestrictionType_template& type__() const;
ValidityRestrictionContainer_template& validity();
const ValidityRestrictionContainer_template& validity() const;
int size_of() const;
void log() const;
void log_match(const ValidityRestriction& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Certificate : public Base_Type {
  INTEGER field_version;
  SignerInfo field_signer__info;
  SubjectInfo field_subject__info;
  SubjectAttributes field_subject__attributes;
  ValidityRestrictions field_validity__restrictions;
  Signature field_signature__;
  boolean bound_flag;
public:
  Certificate();
  Certificate(const INTEGER& par_version,
    const SignerInfo& par_signer__info,
    const SubjectInfo& par_subject__info,
    const SubjectAttributes& par_subject__attributes,
    const ValidityRestrictions& par_validity__restrictions,
    const Signature& par_signature__);
  Certificate(const Certificate& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Certificate& operator=(const Certificate& other_value);
  boolean operator==(const Certificate& other_value) const;
  inline boolean operator!=(const Certificate& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& version()
    {return field_version;}
  inline const INTEGER& version() const
    {return field_version;}
  inline SignerInfo& signer__info()
    {return field_signer__info;}
  inline const SignerInfo& signer__info() const
    {return field_signer__info;}
  inline SubjectInfo& subject__info()
    {return field_subject__info;}
  inline const SubjectInfo& subject__info() const
    {return field_subject__info;}
  inline SubjectAttributes& subject__attributes()
    {return field_subject__attributes;}
  inline const SubjectAttributes& subject__attributes() const
    {return field_subject__attributes;}
  inline ValidityRestrictions& validity__restrictions()
    {return field_validity__restrictions;}
  inline const ValidityRestrictions& validity__restrictions() const
    {return field_validity__restrictions;}
  inline Signature& signature__()
    {return field_signature__;}
  inline const Signature& signature__() const
    {return field_signature__;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Certificate_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Certificate_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Certificate& other_value);
void copy_template(const Certificate_template& other_value);

public:
Certificate_template();
Certificate_template(template_sel other_value);
Certificate_template(const Certificate& other_value);
Certificate_template(const OPTIONAL<Certificate>& other_value);
Certificate_template(const Certificate_template& other_value);
~Certificate_template();
Certificate_template& operator=(template_sel other_value);
Certificate_template& operator=(const Certificate& other_value);
Certificate_template& operator=(const OPTIONAL<Certificate>& other_value);
Certificate_template& operator=(const Certificate_template& other_value);
boolean match(const Certificate& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Certificate valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Certificate_template& list_item(unsigned int list_index) const;
INTEGER_template& version();
const INTEGER_template& version() const;
SignerInfo_template& signer__info();
const SignerInfo_template& signer__info() const;
SubjectInfo_template& subject__info();
const SubjectInfo_template& subject__info() const;
SubjectAttributes_template& subject__attributes();
const SubjectAttributes_template& subject__attributes() const;
ValidityRestrictions_template& validity__restrictions();
const ValidityRestrictions_template& validity__restrictions() const;
Signature_template& signature__();
const Signature_template& signature__() const;
int size_of() const;
void log() const;
void log_match(const Certificate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CertificateChain : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Certificate **value_elements;
} *val_ptr;

static const Certificate UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const CertificateChain& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef Certificate of_type;
CertificateChain();
CertificateChain(null_type other_value);
CertificateChain(const CertificateChain& other_value);
~CertificateChain();

void clean_up();
CertificateChain& operator=(null_type other_value);
CertificateChain& operator=(const CertificateChain& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const CertificateChain& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const CertificateChain& other_value) const { return !(*this == other_value); }

Certificate& operator[](int index_value);
Certificate& operator[](const INTEGER& index_value);
const Certificate& operator[](int index_value) const;
const Certificate& operator[](const INTEGER& index_value) const;

CertificateChain operator<<=(int rotate_count) const;
CertificateChain operator<<=(const INTEGER& rotate_count) const;
CertificateChain operator>>=(int rotate_count) const;
CertificateChain operator>>=(const INTEGER& rotate_count) const;

CertificateChain operator+(const CertificateChain& other_value) const;

CertificateChain substr(int index, int returncount) const;

CertificateChain replace(int index, int len, const CertificateChain& repl) const;

CertificateChain replace(int index, int len, const CertificateChain_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CertificateChain_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
Certificate_template **value_elements;
} single_value;
struct {
unsigned int n_values;
CertificateChain_template *list_value;
} value_list;
struct {
unsigned int n_items;
Certificate_template *set_items;
} value_set;
};
void copy_value(const CertificateChain& other_value);
void copy_template(const CertificateChain_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
CertificateChain_template();
CertificateChain_template(template_sel other_value);
CertificateChain_template(null_type other_value);
CertificateChain_template(const CertificateChain& other_value);
CertificateChain_template(const OPTIONAL<CertificateChain>& other_value);
CertificateChain_template(const CertificateChain_template& other_value);
~CertificateChain_template();

void clean_up();
CertificateChain_template& operator=(template_sel other_value);
CertificateChain_template& operator=(null_type other_value);
CertificateChain_template& operator=(const CertificateChain& other_value);
CertificateChain_template& operator=(const OPTIONAL<CertificateChain>& other_value);
CertificateChain_template& operator=(const CertificateChain_template& other_value);

Certificate_template& operator[](int index_value);
Certificate_template& operator[](const INTEGER& index_value);
const Certificate_template& operator[](int index_value) const;
const Certificate_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const CertificateChain& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
CertificateChain valueof() const;
CertificateChain substr(int index, int returncount) const;

CertificateChain replace(int index, int len, const CertificateChain_template& repl) const;

CertificateChain replace(int index, int len, const CertificateChain& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
CertificateChain_template& list_item(unsigned int list_index);
Certificate_template& set_item(unsigned int set_index);
void log() const;
void log_match(const CertificateChain& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class CertificateWithAlgo : public Base_Type {
  PublicKeyAlgorithm field_algorithm;
  OCTETSTRING field_digest;
  boolean bound_flag;
public:
  CertificateWithAlgo();
  CertificateWithAlgo(const PublicKeyAlgorithm& par_algorithm,
    const OCTETSTRING& par_digest);
  CertificateWithAlgo(const CertificateWithAlgo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CertificateWithAlgo& operator=(const CertificateWithAlgo& other_value);
  boolean operator==(const CertificateWithAlgo& other_value) const;
  inline boolean operator!=(const CertificateWithAlgo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline PublicKeyAlgorithm& algorithm()
    {return field_algorithm;}
  inline const PublicKeyAlgorithm& algorithm() const
    {return field_algorithm;}
  inline OCTETSTRING& digest()
    {return field_digest;}
  inline const OCTETSTRING& digest() const
    {return field_digest;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CertificateWithAlgo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CertificateWithAlgo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CertificateWithAlgo& other_value);
void copy_template(const CertificateWithAlgo_template& other_value);

public:
CertificateWithAlgo_template();
CertificateWithAlgo_template(template_sel other_value);
CertificateWithAlgo_template(const CertificateWithAlgo& other_value);
CertificateWithAlgo_template(const OPTIONAL<CertificateWithAlgo>& other_value);
CertificateWithAlgo_template(const CertificateWithAlgo_template& other_value);
~CertificateWithAlgo_template();
CertificateWithAlgo_template& operator=(template_sel other_value);
CertificateWithAlgo_template& operator=(const CertificateWithAlgo& other_value);
CertificateWithAlgo_template& operator=(const OPTIONAL<CertificateWithAlgo>& other_value);
CertificateWithAlgo_template& operator=(const CertificateWithAlgo_template& other_value);
boolean match(const CertificateWithAlgo& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CertificateWithAlgo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CertificateWithAlgo_template& list_item(unsigned int list_index) const;
PublicKeyAlgorithm_template& algorithm();
const PublicKeyAlgorithm_template& algorithm() const;
OCTETSTRING_template& digest();
const OCTETSTRING_template& digest() const;
int size_of() const;
void log() const;
void log_match(const CertificateWithAlgo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Time64WithStandardDeviation : public Base_Type {
  INTEGER field_time;
  INTEGER field_log__std__dev;
  boolean bound_flag;
public:
  Time64WithStandardDeviation();
  Time64WithStandardDeviation(const INTEGER& par_time,
    const INTEGER& par_log__std__dev);
  Time64WithStandardDeviation(const Time64WithStandardDeviation& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Time64WithStandardDeviation& operator=(const Time64WithStandardDeviation& other_value);
  boolean operator==(const Time64WithStandardDeviation& other_value) const;
  inline boolean operator!=(const Time64WithStandardDeviation& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& time()
    {return field_time;}
  inline const INTEGER& time() const
    {return field_time;}
  inline INTEGER& log__std__dev()
    {return field_log__std__dev;}
  inline const INTEGER& log__std__dev() const
    {return field_log__std__dev;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Time64WithStandardDeviation_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Time64WithStandardDeviation_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Time64WithStandardDeviation& other_value);
void copy_template(const Time64WithStandardDeviation_template& other_value);

public:
Time64WithStandardDeviation_template();
Time64WithStandardDeviation_template(template_sel other_value);
Time64WithStandardDeviation_template(const Time64WithStandardDeviation& other_value);
Time64WithStandardDeviation_template(const OPTIONAL<Time64WithStandardDeviation>& other_value);
Time64WithStandardDeviation_template(const Time64WithStandardDeviation_template& other_value);
~Time64WithStandardDeviation_template();
Time64WithStandardDeviation_template& operator=(template_sel other_value);
Time64WithStandardDeviation_template& operator=(const Time64WithStandardDeviation& other_value);
Time64WithStandardDeviation_template& operator=(const OPTIONAL<Time64WithStandardDeviation>& other_value);
Time64WithStandardDeviation_template& operator=(const Time64WithStandardDeviation_template& other_value);
boolean match(const Time64WithStandardDeviation& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Time64WithStandardDeviation valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Time64WithStandardDeviation_template& list_item(unsigned int list_index) const;
INTEGER_template& time();
const INTEGER_template& time() const;
INTEGER_template& log__std__dev();
const INTEGER_template& log__std__dev() const;
int size_of() const;
void log() const;
void log_match(const Time64WithStandardDeviation& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ThreeDLocation : public Base_Type {
  INTEGER field_latitude;
  INTEGER field_longitude;
  OCTETSTRING field_elevation;
  boolean bound_flag;
public:
  ThreeDLocation();
  ThreeDLocation(const INTEGER& par_latitude,
    const INTEGER& par_longitude,
    const OCTETSTRING& par_elevation);
  ThreeDLocation(const ThreeDLocation& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ThreeDLocation& operator=(const ThreeDLocation& other_value);
  boolean operator==(const ThreeDLocation& other_value) const;
  inline boolean operator!=(const ThreeDLocation& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& latitude()
    {return field_latitude;}
  inline const INTEGER& latitude() const
    {return field_latitude;}
  inline INTEGER& longitude()
    {return field_longitude;}
  inline const INTEGER& longitude() const
    {return field_longitude;}
  inline OCTETSTRING& elevation()
    {return field_elevation;}
  inline const OCTETSTRING& elevation() const
    {return field_elevation;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ThreeDLocation_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ThreeDLocation_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ThreeDLocation& other_value);
void copy_template(const ThreeDLocation_template& other_value);

public:
ThreeDLocation_template();
ThreeDLocation_template(template_sel other_value);
ThreeDLocation_template(const ThreeDLocation& other_value);
ThreeDLocation_template(const OPTIONAL<ThreeDLocation>& other_value);
ThreeDLocation_template(const ThreeDLocation_template& other_value);
~ThreeDLocation_template();
ThreeDLocation_template& operator=(template_sel other_value);
ThreeDLocation_template& operator=(const ThreeDLocation& other_value);
ThreeDLocation_template& operator=(const OPTIONAL<ThreeDLocation>& other_value);
ThreeDLocation_template& operator=(const ThreeDLocation_template& other_value);
boolean match(const ThreeDLocation& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ThreeDLocation valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ThreeDLocation_template& list_item(unsigned int list_index) const;
INTEGER_template& latitude();
const INTEGER_template& latitude() const;
INTEGER_template& longitude();
const INTEGER_template& longitude() const;
OCTETSTRING_template& elevation();
const OCTETSTRING_template& elevation() const;
int size_of() const;
void log() const;
void log_match(const ThreeDLocation& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ThreeDLocations : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ThreeDLocation **value_elements;
} *val_ptr;

static const ThreeDLocation UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ThreeDLocations& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef ThreeDLocation of_type;
ThreeDLocations();
ThreeDLocations(null_type other_value);
ThreeDLocations(const ThreeDLocations& other_value);
~ThreeDLocations();

void clean_up();
ThreeDLocations& operator=(null_type other_value);
ThreeDLocations& operator=(const ThreeDLocations& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ThreeDLocations& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ThreeDLocations& other_value) const { return !(*this == other_value); }

ThreeDLocation& operator[](int index_value);
ThreeDLocation& operator[](const INTEGER& index_value);
const ThreeDLocation& operator[](int index_value) const;
const ThreeDLocation& operator[](const INTEGER& index_value) const;

ThreeDLocations operator<<=(int rotate_count) const;
ThreeDLocations operator<<=(const INTEGER& rotate_count) const;
ThreeDLocations operator>>=(int rotate_count) const;
ThreeDLocations operator>>=(const INTEGER& rotate_count) const;

ThreeDLocations operator+(const ThreeDLocations& other_value) const;

ThreeDLocations substr(int index, int returncount) const;

ThreeDLocations replace(int index, int len, const ThreeDLocations& repl) const;

ThreeDLocations replace(int index, int len, const ThreeDLocations_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ThreeDLocations_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
ThreeDLocation_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ThreeDLocations_template *list_value;
} value_list;
struct {
unsigned int n_items;
ThreeDLocation_template *set_items;
} value_set;
};
void copy_value(const ThreeDLocations& other_value);
void copy_template(const ThreeDLocations_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
ThreeDLocations_template();
ThreeDLocations_template(template_sel other_value);
ThreeDLocations_template(null_type other_value);
ThreeDLocations_template(const ThreeDLocations& other_value);
ThreeDLocations_template(const OPTIONAL<ThreeDLocations>& other_value);
ThreeDLocations_template(const ThreeDLocations_template& other_value);
~ThreeDLocations_template();

void clean_up();
ThreeDLocations_template& operator=(template_sel other_value);
ThreeDLocations_template& operator=(null_type other_value);
ThreeDLocations_template& operator=(const ThreeDLocations& other_value);
ThreeDLocations_template& operator=(const OPTIONAL<ThreeDLocations>& other_value);
ThreeDLocations_template& operator=(const ThreeDLocations_template& other_value);

ThreeDLocation_template& operator[](int index_value);
ThreeDLocation_template& operator[](const INTEGER& index_value);
const ThreeDLocation_template& operator[](int index_value) const;
const ThreeDLocation_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ThreeDLocations& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ThreeDLocations valueof() const;
ThreeDLocations substr(int index, int returncount) const;

ThreeDLocations replace(int index, int len, const ThreeDLocations_template& repl) const;

ThreeDLocations replace(int index, int len, const ThreeDLocations& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ThreeDLocations_template& list_item(unsigned int list_index);
ThreeDLocation_template& set_item(unsigned int set_index);
void log() const;
void log_match(const ThreeDLocations& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class HeaderFields : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
HeaderField **value_elements;
} *val_ptr;

static const HeaderField UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const HeaderFields& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef HeaderField of_type;
HeaderFields();
HeaderFields(null_type other_value);
HeaderFields(const HeaderFields& other_value);
~HeaderFields();

void clean_up();
HeaderFields& operator=(null_type other_value);
HeaderFields& operator=(const HeaderFields& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const HeaderFields& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HeaderFields& other_value) const { return !(*this == other_value); }

HeaderField& operator[](int index_value);
HeaderField& operator[](const INTEGER& index_value);
const HeaderField& operator[](int index_value) const;
const HeaderField& operator[](const INTEGER& index_value) const;

HeaderFields operator<<=(int rotate_count) const;
HeaderFields operator<<=(const INTEGER& rotate_count) const;
HeaderFields operator>>=(int rotate_count) const;
HeaderFields operator>>=(const INTEGER& rotate_count) const;

HeaderFields operator+(const HeaderFields& other_value) const;

HeaderFields substr(int index, int returncount) const;

HeaderFields replace(int index, int len, const HeaderFields& repl) const;

HeaderFields replace(int index, int len, const HeaderFields_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderFields_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
HeaderField_template **value_elements;
} single_value;
struct {
unsigned int n_values;
HeaderFields_template *list_value;
} value_list;
struct {
unsigned int n_items;
HeaderField_template *set_items;
} value_set;
};
void copy_value(const HeaderFields& other_value);
void copy_template(const HeaderFields_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
HeaderFields_template();
HeaderFields_template(template_sel other_value);
HeaderFields_template(null_type other_value);
HeaderFields_template(const HeaderFields& other_value);
HeaderFields_template(const OPTIONAL<HeaderFields>& other_value);
HeaderFields_template(const HeaderFields_template& other_value);
~HeaderFields_template();

void clean_up();
HeaderFields_template& operator=(template_sel other_value);
HeaderFields_template& operator=(null_type other_value);
HeaderFields_template& operator=(const HeaderFields& other_value);
HeaderFields_template& operator=(const OPTIONAL<HeaderFields>& other_value);
HeaderFields_template& operator=(const HeaderFields_template& other_value);

HeaderField_template& operator[](int index_value);
HeaderField_template& operator[](const INTEGER& index_value);
const HeaderField_template& operator[](int index_value) const;
const HeaderField_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const HeaderFields& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
HeaderFields valueof() const;
HeaderFields substr(int index, int returncount) const;

HeaderFields replace(int index, int len, const HeaderFields_template& repl) const;

HeaderFields replace(int index, int len, const HeaderFields& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
HeaderFields_template& list_item(unsigned int list_index);
HeaderField_template& set_item(unsigned int set_index);
void log() const;
void log_match(const HeaderFields& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class HeaderFieldType : public Base_Type { // enum
friend class HeaderFieldType_template;
public:
enum enum_type { e__generation__time = 0, e__generation__time__standard__deviation = 1, e__expiration = 2, e__generation__location = 3, e__request__unrecognized__certificate = 4, e__its__aid = 5, e__signer__info = 128, e__encryption__parameters = 129, e__recipient__info = 130, UNKNOWN_VALUE = 6, UNBOUND_VALUE = 7 };
private:
enum_type enum_value;

public:
HeaderFieldType();
HeaderFieldType(int other_value);
HeaderFieldType(enum_type other_value);
HeaderFieldType(const HeaderFieldType& other_value);

HeaderFieldType& operator=(int other_value);
HeaderFieldType& operator=(enum_type other_value);
HeaderFieldType& operator=(const HeaderFieldType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const HeaderFieldType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HeaderFieldType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const HeaderFieldType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const HeaderFieldType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const HeaderFieldType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const HeaderFieldType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const HeaderFieldType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderFieldType_template : public Base_Template {
union {
HeaderFieldType::enum_type single_value;
struct {
unsigned int n_values;
HeaderFieldType_template *list_value;
} value_list;
};

void copy_template(const HeaderFieldType_template& other_value);

public:
HeaderFieldType_template();
HeaderFieldType_template(template_sel other_value);
HeaderFieldType_template(int other_value);
HeaderFieldType_template(HeaderFieldType::enum_type other_value);
HeaderFieldType_template(const HeaderFieldType& other_value);
HeaderFieldType_template(const OPTIONAL<HeaderFieldType>& other_value);
HeaderFieldType_template(const HeaderFieldType_template& other_value);
~HeaderFieldType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
HeaderFieldType_template& operator=(template_sel other_value);
HeaderFieldType_template& operator=(int other_value);
HeaderFieldType_template& operator=(HeaderFieldType::enum_type other_value);
HeaderFieldType_template& operator=(const HeaderFieldType& other_value);
HeaderFieldType_template& operator=(const OPTIONAL<HeaderFieldType>& other_value);
HeaderFieldType_template& operator=(const HeaderFieldType_template& other_value);

boolean match(HeaderFieldType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const HeaderFieldType& other_value, boolean legacy = FALSE) const;
HeaderFieldType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HeaderFieldType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HeaderFieldType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class HeaderFieldContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_generation__time = 1, ALT_generation__time__with__standard__deviation = 2, ALT_expiry__time = 3, ALT_generation__location = 4, ALT_digests = 5, ALT_its__aid = 6, ALT_signer = 7, ALT_enc__params = 8, ALT_recipients = 9, ALT_other__header = 10 };
private:
union_selection_type union_selection;
union {
INTEGER *field_generation__time;
Time64WithStandardDeviation *field_generation__time__with__standard__deviation;
INTEGER *field_expiry__time;
ThreeDLocation *field_generation__location;
HashedId3s *field_digests;
INTEGER *field_its__aid;
SignerInfo *field_signer;
EncryptionParameters *field_enc__params;
RecipientInfos *field_recipients;
OCTETSTRING *field_other__header;
};
void copy_value(const HeaderFieldContainer& other_value);

public:
HeaderFieldContainer();
HeaderFieldContainer(const HeaderFieldContainer& other_value);
~HeaderFieldContainer();
HeaderFieldContainer& operator=(const HeaderFieldContainer& other_value);
boolean operator==(const HeaderFieldContainer& other_value) const;
inline boolean operator!=(const HeaderFieldContainer& other_value) const { return !(*this == other_value); }
INTEGER& generation__time();
const INTEGER& generation__time() const;
Time64WithStandardDeviation& generation__time__with__standard__deviation();
const Time64WithStandardDeviation& generation__time__with__standard__deviation() const;
INTEGER& expiry__time();
const INTEGER& expiry__time() const;
ThreeDLocation& generation__location();
const ThreeDLocation& generation__location() const;
HashedId3s& digests();
const HashedId3s& digests() const;
INTEGER& its__aid();
const INTEGER& its__aid() const;
SignerInfo& signer();
const SignerInfo& signer() const;
EncryptionParameters& enc__params();
const EncryptionParameters& enc__params() const;
RecipientInfos& recipients();
const RecipientInfos& recipients() const;
OCTETSTRING& other__header();
const OCTETSTRING& other__header() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderFieldContainer_template : public Base_Template {
union {
struct {
HeaderFieldContainer::union_selection_type union_selection;
union {
INTEGER_template *field_generation__time;
Time64WithStandardDeviation_template *field_generation__time__with__standard__deviation;
INTEGER_template *field_expiry__time;
ThreeDLocation_template *field_generation__location;
HashedId3s_template *field_digests;
INTEGER_template *field_its__aid;
SignerInfo_template *field_signer;
EncryptionParameters_template *field_enc__params;
RecipientInfos_template *field_recipients;
OCTETSTRING_template *field_other__header;
};
} single_value;
struct {
unsigned int n_values;
HeaderFieldContainer_template *list_value;
} value_list;
};
void copy_value(const HeaderFieldContainer& other_value);

void copy_template(const HeaderFieldContainer_template& other_value);

public:
HeaderFieldContainer_template();
HeaderFieldContainer_template(template_sel other_value);
HeaderFieldContainer_template(const HeaderFieldContainer& other_value);
HeaderFieldContainer_template(const OPTIONAL<HeaderFieldContainer>& other_value);
HeaderFieldContainer_template(const HeaderFieldContainer_template& other_value);
~HeaderFieldContainer_template();
void clean_up();
HeaderFieldContainer_template& operator=(template_sel other_value);
HeaderFieldContainer_template& operator=(const HeaderFieldContainer& other_value);
HeaderFieldContainer_template& operator=(const OPTIONAL<HeaderFieldContainer>& other_value);
HeaderFieldContainer_template& operator=(const HeaderFieldContainer_template& other_value);
boolean match(const HeaderFieldContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;HeaderFieldContainer valueof() const;
HeaderFieldContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& generation__time();
const INTEGER_template& generation__time() const;
Time64WithStandardDeviation_template& generation__time__with__standard__deviation();
const Time64WithStandardDeviation_template& generation__time__with__standard__deviation() const;
INTEGER_template& expiry__time();
const INTEGER_template& expiry__time() const;
ThreeDLocation_template& generation__location();
const ThreeDLocation_template& generation__location() const;
HashedId3s_template& digests();
const HashedId3s_template& digests() const;
INTEGER_template& its__aid();
const INTEGER_template& its__aid() const;
SignerInfo_template& signer();
const SignerInfo_template& signer() const;
EncryptionParameters_template& enc__params();
const EncryptionParameters_template& enc__params() const;
RecipientInfos_template& recipients();
const RecipientInfos_template& recipients() const;
OCTETSTRING_template& other__header();
const OCTETSTRING_template& other__header() const;
boolean ischosen(HeaderFieldContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const HeaderFieldContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RecipientInfos : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
RecipientInfo **value_elements;
} *val_ptr;

static const RecipientInfo UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RecipientInfos& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef RecipientInfo of_type;
RecipientInfos();
RecipientInfos(null_type other_value);
RecipientInfos(const RecipientInfos& other_value);
~RecipientInfos();

void clean_up();
RecipientInfos& operator=(null_type other_value);
RecipientInfos& operator=(const RecipientInfos& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RecipientInfos& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RecipientInfos& other_value) const { return !(*this == other_value); }

RecipientInfo& operator[](int index_value);
RecipientInfo& operator[](const INTEGER& index_value);
const RecipientInfo& operator[](int index_value) const;
const RecipientInfo& operator[](const INTEGER& index_value) const;

RecipientInfos operator<<=(int rotate_count) const;
RecipientInfos operator<<=(const INTEGER& rotate_count) const;
RecipientInfos operator>>=(int rotate_count) const;
RecipientInfos operator>>=(const INTEGER& rotate_count) const;

RecipientInfos operator+(const RecipientInfos& other_value) const;

RecipientInfos substr(int index, int returncount) const;

RecipientInfos replace(int index, int len, const RecipientInfos& repl) const;

RecipientInfos replace(int index, int len, const RecipientInfos_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RecipientInfos_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
RecipientInfo_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RecipientInfos_template *list_value;
} value_list;
struct {
unsigned int n_items;
RecipientInfo_template *set_items;
} value_set;
};
void copy_value(const RecipientInfos& other_value);
void copy_template(const RecipientInfos_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
RecipientInfos_template();
RecipientInfos_template(template_sel other_value);
RecipientInfos_template(null_type other_value);
RecipientInfos_template(const RecipientInfos& other_value);
RecipientInfos_template(const OPTIONAL<RecipientInfos>& other_value);
RecipientInfos_template(const RecipientInfos_template& other_value);
~RecipientInfos_template();

void clean_up();
RecipientInfos_template& operator=(template_sel other_value);
RecipientInfos_template& operator=(null_type other_value);
RecipientInfos_template& operator=(const RecipientInfos& other_value);
RecipientInfos_template& operator=(const OPTIONAL<RecipientInfos>& other_value);
RecipientInfos_template& operator=(const RecipientInfos_template& other_value);

RecipientInfo_template& operator[](int index_value);
RecipientInfo_template& operator[](const INTEGER& index_value);
const RecipientInfo_template& operator[](int index_value) const;
const RecipientInfo_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RecipientInfos& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RecipientInfos valueof() const;
RecipientInfos substr(int index, int returncount) const;

RecipientInfos replace(int index, int len, const RecipientInfos_template& repl) const;

RecipientInfos replace(int index, int len, const RecipientInfos& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RecipientInfos_template& list_item(unsigned int list_index);
RecipientInfo_template& set_item(unsigned int set_index);
void log() const;
void log_match(const RecipientInfos& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RecipientInfoContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_enc__key = 1, ALT_enc__key__other = 2 };
private:
union_selection_type union_selection;
union {
EciesEncryptedKey *field_enc__key;
OCTETSTRING *field_enc__key__other;
};
void copy_value(const RecipientInfoContainer& other_value);

public:
RecipientInfoContainer();
RecipientInfoContainer(const RecipientInfoContainer& other_value);
~RecipientInfoContainer();
RecipientInfoContainer& operator=(const RecipientInfoContainer& other_value);
boolean operator==(const RecipientInfoContainer& other_value) const;
inline boolean operator!=(const RecipientInfoContainer& other_value) const { return !(*this == other_value); }
EciesEncryptedKey& enc__key();
const EciesEncryptedKey& enc__key() const;
OCTETSTRING& enc__key__other();
const OCTETSTRING& enc__key__other() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RecipientInfoContainer_template : public Base_Template {
union {
struct {
RecipientInfoContainer::union_selection_type union_selection;
union {
EciesEncryptedKey_template *field_enc__key;
OCTETSTRING_template *field_enc__key__other;
};
} single_value;
struct {
unsigned int n_values;
RecipientInfoContainer_template *list_value;
} value_list;
};
void copy_value(const RecipientInfoContainer& other_value);

void copy_template(const RecipientInfoContainer_template& other_value);

public:
RecipientInfoContainer_template();
RecipientInfoContainer_template(template_sel other_value);
RecipientInfoContainer_template(const RecipientInfoContainer& other_value);
RecipientInfoContainer_template(const OPTIONAL<RecipientInfoContainer>& other_value);
RecipientInfoContainer_template(const RecipientInfoContainer_template& other_value);
~RecipientInfoContainer_template();
void clean_up();
RecipientInfoContainer_template& operator=(template_sel other_value);
RecipientInfoContainer_template& operator=(const RecipientInfoContainer& other_value);
RecipientInfoContainer_template& operator=(const OPTIONAL<RecipientInfoContainer>& other_value);
RecipientInfoContainer_template& operator=(const RecipientInfoContainer_template& other_value);
boolean match(const RecipientInfoContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;RecipientInfoContainer valueof() const;
RecipientInfoContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
EciesEncryptedKey_template& enc__key();
const EciesEncryptedKey_template& enc__key() const;
OCTETSTRING_template& enc__key__other();
const OCTETSTRING_template& enc__key__other() const;
boolean ischosen(RecipientInfoContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const RecipientInfoContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class EciesEncryptedKey : public Base_Type {
  EccPoint field_v;
  OCTETSTRING field_c;
  OCTETSTRING field_t;
  boolean bound_flag;
public:
  EciesEncryptedKey();
  EciesEncryptedKey(const EccPoint& par_v,
    const OCTETSTRING& par_c,
    const OCTETSTRING& par_t);
  EciesEncryptedKey(const EciesEncryptedKey& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EciesEncryptedKey& operator=(const EciesEncryptedKey& other_value);
  boolean operator==(const EciesEncryptedKey& other_value) const;
  inline boolean operator!=(const EciesEncryptedKey& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline EccPoint& v()
    {return field_v;}
  inline const EccPoint& v() const
    {return field_v;}
  inline OCTETSTRING& c()
    {return field_c;}
  inline const OCTETSTRING& c() const
    {return field_c;}
  inline OCTETSTRING& t()
    {return field_t;}
  inline const OCTETSTRING& t() const
    {return field_t;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EciesEncryptedKey_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EciesEncryptedKey_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EciesEncryptedKey& other_value);
void copy_template(const EciesEncryptedKey_template& other_value);

public:
EciesEncryptedKey_template();
EciesEncryptedKey_template(template_sel other_value);
EciesEncryptedKey_template(const EciesEncryptedKey& other_value);
EciesEncryptedKey_template(const OPTIONAL<EciesEncryptedKey>& other_value);
EciesEncryptedKey_template(const EciesEncryptedKey_template& other_value);
~EciesEncryptedKey_template();
EciesEncryptedKey_template& operator=(template_sel other_value);
EciesEncryptedKey_template& operator=(const EciesEncryptedKey& other_value);
EciesEncryptedKey_template& operator=(const OPTIONAL<EciesEncryptedKey>& other_value);
EciesEncryptedKey_template& operator=(const EciesEncryptedKey_template& other_value);
boolean match(const EciesEncryptedKey& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EciesEncryptedKey valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EciesEncryptedKey_template& list_item(unsigned int list_index) const;
EccPoint_template& v();
const EccPoint_template& v() const;
OCTETSTRING_template& c();
const OCTETSTRING_template& c() const;
OCTETSTRING_template& t();
const OCTETSTRING_template& t() const;
int size_of() const;
void log() const;
void log_match(const EciesEncryptedKey& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RecipientInfo : public Base_Type {
  OCTETSTRING field_cert__id;
  PublicKeyAlgorithm field_pk__encryption;
  RecipientInfoContainer field_enc__key;
  boolean bound_flag;
public:
  RecipientInfo();
  RecipientInfo(const OCTETSTRING& par_cert__id,
    const PublicKeyAlgorithm& par_pk__encryption,
    const RecipientInfoContainer& par_enc__key);
  RecipientInfo(const RecipientInfo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RecipientInfo& operator=(const RecipientInfo& other_value);
  boolean operator==(const RecipientInfo& other_value) const;
  inline boolean operator!=(const RecipientInfo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& cert__id()
    {return field_cert__id;}
  inline const OCTETSTRING& cert__id() const
    {return field_cert__id;}
  inline PublicKeyAlgorithm& pk__encryption()
    {return field_pk__encryption;}
  inline const PublicKeyAlgorithm& pk__encryption() const
    {return field_pk__encryption;}
  inline RecipientInfoContainer& enc__key()
    {return field_enc__key;}
  inline const RecipientInfoContainer& enc__key() const
    {return field_enc__key;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RecipientInfo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RecipientInfo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RecipientInfo& other_value);
void copy_template(const RecipientInfo_template& other_value);

public:
RecipientInfo_template();
RecipientInfo_template(template_sel other_value);
RecipientInfo_template(const RecipientInfo& other_value);
RecipientInfo_template(const OPTIONAL<RecipientInfo>& other_value);
RecipientInfo_template(const RecipientInfo_template& other_value);
~RecipientInfo_template();
RecipientInfo_template& operator=(template_sel other_value);
RecipientInfo_template& operator=(const RecipientInfo& other_value);
RecipientInfo_template& operator=(const OPTIONAL<RecipientInfo>& other_value);
RecipientInfo_template& operator=(const RecipientInfo_template& other_value);
boolean match(const RecipientInfo& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RecipientInfo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RecipientInfo_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& cert__id();
const OCTETSTRING_template& cert__id() const;
PublicKeyAlgorithm_template& pk__encryption();
const PublicKeyAlgorithm_template& pk__encryption() const;
RecipientInfoContainer_template& enc__key();
const RecipientInfoContainer_template& enc__key() const;
int size_of() const;
void log() const;
void log_match(const RecipientInfo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HeaderField : public Base_Type {
  HeaderFieldType field_type__;
  HeaderFieldContainer field_headerField;
  boolean bound_flag;
public:
  HeaderField();
  HeaderField(const HeaderFieldType& par_type__,
    const HeaderFieldContainer& par_headerField);
  HeaderField(const HeaderField& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HeaderField& operator=(const HeaderField& other_value);
  boolean operator==(const HeaderField& other_value) const;
  inline boolean operator!=(const HeaderField& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderFieldType& type__()
    {return field_type__;}
  inline const HeaderFieldType& type__() const
    {return field_type__;}
  inline HeaderFieldContainer& headerField()
    {return field_headerField;}
  inline const HeaderFieldContainer& headerField() const
    {return field_headerField;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderField_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HeaderField_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HeaderField& other_value);
void copy_template(const HeaderField_template& other_value);

public:
HeaderField_template();
HeaderField_template(template_sel other_value);
HeaderField_template(const HeaderField& other_value);
HeaderField_template(const OPTIONAL<HeaderField>& other_value);
HeaderField_template(const HeaderField_template& other_value);
~HeaderField_template();
HeaderField_template& operator=(template_sel other_value);
HeaderField_template& operator=(const HeaderField& other_value);
HeaderField_template& operator=(const OPTIONAL<HeaderField>& other_value);
HeaderField_template& operator=(const HeaderField_template& other_value);
boolean match(const HeaderField& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HeaderField valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HeaderField_template& list_item(unsigned int list_index) const;
HeaderFieldType_template& type__();
const HeaderFieldType_template& type__() const;
HeaderFieldContainer_template& headerField();
const HeaderFieldContainer_template& headerField() const;
int size_of() const;
void log() const;
void log_match(const HeaderField& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SecPayloadType : public Base_Type { // enum
friend class SecPayloadType_template;
public:
enum enum_type { e__unsecured = 0, e__signed = 1, e__encrypted = 2, e__signed__external = 3, e__signed__and__encrypted = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
SecPayloadType();
SecPayloadType(int other_value);
SecPayloadType(enum_type other_value);
SecPayloadType(const SecPayloadType& other_value);

SecPayloadType& operator=(int other_value);
SecPayloadType& operator=(enum_type other_value);
SecPayloadType& operator=(const SecPayloadType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SecPayloadType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SecPayloadType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SecPayloadType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SecPayloadType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SecPayloadType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SecPayloadType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SecPayloadType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SecPayloadType_template : public Base_Template {
union {
SecPayloadType::enum_type single_value;
struct {
unsigned int n_values;
SecPayloadType_template *list_value;
} value_list;
};

void copy_template(const SecPayloadType_template& other_value);

public:
SecPayloadType_template();
SecPayloadType_template(template_sel other_value);
SecPayloadType_template(int other_value);
SecPayloadType_template(SecPayloadType::enum_type other_value);
SecPayloadType_template(const SecPayloadType& other_value);
SecPayloadType_template(const OPTIONAL<SecPayloadType>& other_value);
SecPayloadType_template(const SecPayloadType_template& other_value);
~SecPayloadType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SecPayloadType_template& operator=(template_sel other_value);
SecPayloadType_template& operator=(int other_value);
SecPayloadType_template& operator=(SecPayloadType::enum_type other_value);
SecPayloadType_template& operator=(const SecPayloadType& other_value);
SecPayloadType_template& operator=(const OPTIONAL<SecPayloadType>& other_value);
SecPayloadType_template& operator=(const SecPayloadType_template& other_value);

boolean match(SecPayloadType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SecPayloadType& other_value, boolean legacy = FALSE) const;
SecPayloadType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SecPayloadType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SecPayloadType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SecPayload : public Base_Type {
  SecPayloadType field_type__;
  OPTIONAL<OCTETSTRING> field_data;
  boolean bound_flag;
public:
  SecPayload();
  SecPayload(const SecPayloadType& par_type__,
    const OPTIONAL<OCTETSTRING>& par_data);
  SecPayload(const SecPayload& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SecPayload& operator=(const SecPayload& other_value);
  boolean operator==(const SecPayload& other_value) const;
  inline boolean operator!=(const SecPayload& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline SecPayloadType& type__()
    {return field_type__;}
  inline const SecPayloadType& type__() const
    {return field_type__;}
  inline OPTIONAL<OCTETSTRING>& data()
    {return field_data;}
  inline const OPTIONAL<OCTETSTRING>& data() const
    {return field_data;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SecPayload_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SecPayload_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SecPayload& other_value);
void copy_template(const SecPayload_template& other_value);

public:
SecPayload_template();
SecPayload_template(template_sel other_value);
SecPayload_template(const SecPayload& other_value);
SecPayload_template(const OPTIONAL<SecPayload>& other_value);
SecPayload_template(const SecPayload_template& other_value);
~SecPayload_template();
SecPayload_template& operator=(template_sel other_value);
SecPayload_template& operator=(const SecPayload& other_value);
SecPayload_template& operator=(const OPTIONAL<SecPayload>& other_value);
SecPayload_template& operator=(const SecPayload_template& other_value);
boolean match(const SecPayload& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SecPayload valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SecPayload_template& list_item(unsigned int list_index) const;
SecPayloadType_template& type__();
const SecPayloadType_template& type__() const;
OCTETSTRING_template& data();
const OCTETSTRING_template& data() const;
int size_of() const;
void log() const;
void log_match(const SecPayload& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TrailerFieldType : public Base_Type { // enum
friend class TrailerFieldType_template;
public:
enum enum_type { e__signature = 1, UNKNOWN_VALUE = 0, UNBOUND_VALUE = 2 };
private:
enum_type enum_value;

public:
TrailerFieldType();
TrailerFieldType(int other_value);
TrailerFieldType(enum_type other_value);
TrailerFieldType(const TrailerFieldType& other_value);

TrailerFieldType& operator=(int other_value);
TrailerFieldType& operator=(enum_type other_value);
TrailerFieldType& operator=(const TrailerFieldType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const TrailerFieldType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TrailerFieldType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const TrailerFieldType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const TrailerFieldType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const TrailerFieldType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const TrailerFieldType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const TrailerFieldType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TrailerFieldType_template : public Base_Template {
union {
TrailerFieldType::enum_type single_value;
struct {
unsigned int n_values;
TrailerFieldType_template *list_value;
} value_list;
};

void copy_template(const TrailerFieldType_template& other_value);

public:
TrailerFieldType_template();
TrailerFieldType_template(template_sel other_value);
TrailerFieldType_template(int other_value);
TrailerFieldType_template(TrailerFieldType::enum_type other_value);
TrailerFieldType_template(const TrailerFieldType& other_value);
TrailerFieldType_template(const OPTIONAL<TrailerFieldType>& other_value);
TrailerFieldType_template(const TrailerFieldType_template& other_value);
~TrailerFieldType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
TrailerFieldType_template& operator=(template_sel other_value);
TrailerFieldType_template& operator=(int other_value);
TrailerFieldType_template& operator=(TrailerFieldType::enum_type other_value);
TrailerFieldType_template& operator=(const TrailerFieldType& other_value);
TrailerFieldType_template& operator=(const OPTIONAL<TrailerFieldType>& other_value);
TrailerFieldType_template& operator=(const TrailerFieldType_template& other_value);

boolean match(TrailerFieldType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const TrailerFieldType& other_value, boolean legacy = FALSE) const;
TrailerFieldType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TrailerFieldType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const TrailerFieldType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ToBeSignedSecuredMessage : public Base_Type {
  INTEGER field_protocol__version;
  HeaderFields field_header__fields;
  SecPayload field_payload__field;
  INTEGER field_trailer__fieldsLength;
  TrailerFieldType field_trailerFieldType;
  boolean bound_flag;
public:
  ToBeSignedSecuredMessage();
  ToBeSignedSecuredMessage(const INTEGER& par_protocol__version,
    const HeaderFields& par_header__fields,
    const SecPayload& par_payload__field,
    const INTEGER& par_trailer__fieldsLength,
    const TrailerFieldType& par_trailerFieldType);
  ToBeSignedSecuredMessage(const ToBeSignedSecuredMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ToBeSignedSecuredMessage& operator=(const ToBeSignedSecuredMessage& other_value);
  boolean operator==(const ToBeSignedSecuredMessage& other_value) const;
  inline boolean operator!=(const ToBeSignedSecuredMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& protocol__version()
    {return field_protocol__version;}
  inline const INTEGER& protocol__version() const
    {return field_protocol__version;}
  inline HeaderFields& header__fields()
    {return field_header__fields;}
  inline const HeaderFields& header__fields() const
    {return field_header__fields;}
  inline SecPayload& payload__field()
    {return field_payload__field;}
  inline const SecPayload& payload__field() const
    {return field_payload__field;}
  inline INTEGER& trailer__fieldsLength()
    {return field_trailer__fieldsLength;}
  inline const INTEGER& trailer__fieldsLength() const
    {return field_trailer__fieldsLength;}
  inline TrailerFieldType& trailerFieldType()
    {return field_trailerFieldType;}
  inline const TrailerFieldType& trailerFieldType() const
    {return field_trailerFieldType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ToBeSignedSecuredMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ToBeSignedSecuredMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ToBeSignedSecuredMessage& other_value);
void copy_template(const ToBeSignedSecuredMessage_template& other_value);

public:
ToBeSignedSecuredMessage_template();
ToBeSignedSecuredMessage_template(template_sel other_value);
ToBeSignedSecuredMessage_template(const ToBeSignedSecuredMessage& other_value);
ToBeSignedSecuredMessage_template(const OPTIONAL<ToBeSignedSecuredMessage>& other_value);
ToBeSignedSecuredMessage_template(const ToBeSignedSecuredMessage_template& other_value);
~ToBeSignedSecuredMessage_template();
ToBeSignedSecuredMessage_template& operator=(template_sel other_value);
ToBeSignedSecuredMessage_template& operator=(const ToBeSignedSecuredMessage& other_value);
ToBeSignedSecuredMessage_template& operator=(const OPTIONAL<ToBeSignedSecuredMessage>& other_value);
ToBeSignedSecuredMessage_template& operator=(const ToBeSignedSecuredMessage_template& other_value);
boolean match(const ToBeSignedSecuredMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ToBeSignedSecuredMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ToBeSignedSecuredMessage_template& list_item(unsigned int list_index) const;
INTEGER_template& protocol__version();
const INTEGER_template& protocol__version() const;
HeaderFields_template& header__fields();
const HeaderFields_template& header__fields() const;
SecPayload_template& payload__field();
const SecPayload_template& payload__field() const;
INTEGER_template& trailer__fieldsLength();
const INTEGER_template& trailer__fieldsLength() const;
TrailerFieldType_template& trailerFieldType();
const TrailerFieldType_template& trailerFieldType() const;
int size_of() const;
void log() const;
void log_match(const ToBeSignedSecuredMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TrailerFields : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
TrailerField **value_elements;
} *val_ptr;

static const TrailerField UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const TrailerFields& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef TrailerField of_type;
TrailerFields();
TrailerFields(null_type other_value);
TrailerFields(const TrailerFields& other_value);
~TrailerFields();

void clean_up();
TrailerFields& operator=(null_type other_value);
TrailerFields& operator=(const TrailerFields& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const TrailerFields& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TrailerFields& other_value) const { return !(*this == other_value); }

TrailerField& operator[](int index_value);
TrailerField& operator[](const INTEGER& index_value);
const TrailerField& operator[](int index_value) const;
const TrailerField& operator[](const INTEGER& index_value) const;

TrailerFields operator<<=(int rotate_count) const;
TrailerFields operator<<=(const INTEGER& rotate_count) const;
TrailerFields operator>>=(int rotate_count) const;
TrailerFields operator>>=(const INTEGER& rotate_count) const;

TrailerFields operator+(const TrailerFields& other_value) const;

TrailerFields substr(int index, int returncount) const;

TrailerFields replace(int index, int len, const TrailerFields& repl) const;

TrailerFields replace(int index, int len, const TrailerFields_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TrailerFields_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
TrailerField_template **value_elements;
} single_value;
struct {
unsigned int n_values;
TrailerFields_template *list_value;
} value_list;
struct {
unsigned int n_items;
TrailerField_template *set_items;
} value_set;
};
void copy_value(const TrailerFields& other_value);
void copy_template(const TrailerFields_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
TrailerFields_template();
TrailerFields_template(template_sel other_value);
TrailerFields_template(null_type other_value);
TrailerFields_template(const TrailerFields& other_value);
TrailerFields_template(const OPTIONAL<TrailerFields>& other_value);
TrailerFields_template(const TrailerFields_template& other_value);
~TrailerFields_template();

void clean_up();
TrailerFields_template& operator=(template_sel other_value);
TrailerFields_template& operator=(null_type other_value);
TrailerFields_template& operator=(const TrailerFields& other_value);
TrailerFields_template& operator=(const OPTIONAL<TrailerFields>& other_value);
TrailerFields_template& operator=(const TrailerFields_template& other_value);

TrailerField_template& operator[](int index_value);
TrailerField_template& operator[](const INTEGER& index_value);
const TrailerField_template& operator[](int index_value) const;
const TrailerField_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const TrailerFields& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
TrailerFields valueof() const;
TrailerFields substr(int index, int returncount) const;

TrailerFields replace(int index, int len, const TrailerFields_template& repl) const;

TrailerFields replace(int index, int len, const TrailerFields& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
TrailerFields_template& list_item(unsigned int list_index);
TrailerField_template& set_item(unsigned int set_index);
void log() const;
void log_match(const TrailerFields& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TrailerFieldContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_signature__ = 1, ALT_security__field = 2 };
private:
union_selection_type union_selection;
union {
Signature *field_signature__;
OCTETSTRING *field_security__field;
};
void copy_value(const TrailerFieldContainer& other_value);

public:
TrailerFieldContainer();
TrailerFieldContainer(const TrailerFieldContainer& other_value);
~TrailerFieldContainer();
TrailerFieldContainer& operator=(const TrailerFieldContainer& other_value);
boolean operator==(const TrailerFieldContainer& other_value) const;
inline boolean operator!=(const TrailerFieldContainer& other_value) const { return !(*this == other_value); }
Signature& signature__();
const Signature& signature__() const;
OCTETSTRING& security__field();
const OCTETSTRING& security__field() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TrailerFieldContainer_template : public Base_Template {
union {
struct {
TrailerFieldContainer::union_selection_type union_selection;
union {
Signature_template *field_signature__;
OCTETSTRING_template *field_security__field;
};
} single_value;
struct {
unsigned int n_values;
TrailerFieldContainer_template *list_value;
} value_list;
};
void copy_value(const TrailerFieldContainer& other_value);

void copy_template(const TrailerFieldContainer_template& other_value);

public:
TrailerFieldContainer_template();
TrailerFieldContainer_template(template_sel other_value);
TrailerFieldContainer_template(const TrailerFieldContainer& other_value);
TrailerFieldContainer_template(const OPTIONAL<TrailerFieldContainer>& other_value);
TrailerFieldContainer_template(const TrailerFieldContainer_template& other_value);
~TrailerFieldContainer_template();
void clean_up();
TrailerFieldContainer_template& operator=(template_sel other_value);
TrailerFieldContainer_template& operator=(const TrailerFieldContainer& other_value);
TrailerFieldContainer_template& operator=(const OPTIONAL<TrailerFieldContainer>& other_value);
TrailerFieldContainer_template& operator=(const TrailerFieldContainer_template& other_value);
boolean match(const TrailerFieldContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;TrailerFieldContainer valueof() const;
TrailerFieldContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
Signature_template& signature__();
const Signature_template& signature__() const;
OCTETSTRING_template& security__field();
const OCTETSTRING_template& security__field() const;
boolean ischosen(TrailerFieldContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const TrailerFieldContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TrailerField : public Base_Type {
  TrailerFieldType field_type__;
  TrailerFieldContainer field_trailerField;
  boolean bound_flag;
public:
  TrailerField();
  TrailerField(const TrailerFieldType& par_type__,
    const TrailerFieldContainer& par_trailerField);
  TrailerField(const TrailerField& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TrailerField& operator=(const TrailerField& other_value);
  boolean operator==(const TrailerField& other_value) const;
  inline boolean operator!=(const TrailerField& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline TrailerFieldType& type__()
    {return field_type__;}
  inline const TrailerFieldType& type__() const
    {return field_type__;}
  inline TrailerFieldContainer& trailerField()
    {return field_trailerField;}
  inline const TrailerFieldContainer& trailerField() const
    {return field_trailerField;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TrailerField_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TrailerField_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TrailerField& other_value);
void copy_template(const TrailerField_template& other_value);

public:
TrailerField_template();
TrailerField_template(template_sel other_value);
TrailerField_template(const TrailerField& other_value);
TrailerField_template(const OPTIONAL<TrailerField>& other_value);
TrailerField_template(const TrailerField_template& other_value);
~TrailerField_template();
TrailerField_template& operator=(template_sel other_value);
TrailerField_template& operator=(const TrailerField& other_value);
TrailerField_template& operator=(const OPTIONAL<TrailerField>& other_value);
TrailerField_template& operator=(const TrailerField_template& other_value);
boolean match(const TrailerField& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TrailerField valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TrailerField_template& list_item(unsigned int list_index) const;
TrailerFieldType_template& type__();
const TrailerFieldType_template& type__() const;
TrailerFieldContainer_template& trailerField();
const TrailerFieldContainer_template& trailerField() const;
int size_of() const;
void log() const;
void log_match(const TrailerField& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SecuredMessage : public Base_Type {
  INTEGER field_protocol__version;
  HeaderFields field_header__fields;
  SecPayload field_payload__field;
  TrailerFields field_trailer__fields;
  boolean bound_flag;
public:
  SecuredMessage();
  SecuredMessage(const INTEGER& par_protocol__version,
    const HeaderFields& par_header__fields,
    const SecPayload& par_payload__field,
    const TrailerFields& par_trailer__fields);
  SecuredMessage(const SecuredMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SecuredMessage& operator=(const SecuredMessage& other_value);
  boolean operator==(const SecuredMessage& other_value) const;
  inline boolean operator!=(const SecuredMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& protocol__version()
    {return field_protocol__version;}
  inline const INTEGER& protocol__version() const
    {return field_protocol__version;}
  inline HeaderFields& header__fields()
    {return field_header__fields;}
  inline const HeaderFields& header__fields() const
    {return field_header__fields;}
  inline SecPayload& payload__field()
    {return field_payload__field;}
  inline const SecPayload& payload__field() const
    {return field_payload__field;}
  inline TrailerFields& trailer__fields()
    {return field_trailer__fields;}
  inline const TrailerFields& trailer__fields() const
    {return field_trailer__fields;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SecuredMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SecuredMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SecuredMessage& other_value);
void copy_template(const SecuredMessage_template& other_value);

public:
SecuredMessage_template();
SecuredMessage_template(template_sel other_value);
SecuredMessage_template(const SecuredMessage& other_value);
SecuredMessage_template(const OPTIONAL<SecuredMessage>& other_value);
SecuredMessage_template(const SecuredMessage_template& other_value);
~SecuredMessage_template();
SecuredMessage_template& operator=(template_sel other_value);
SecuredMessage_template& operator=(const SecuredMessage& other_value);
SecuredMessage_template& operator=(const OPTIONAL<SecuredMessage>& other_value);
SecuredMessage_template& operator=(const SecuredMessage_template& other_value);
boolean match(const SecuredMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SecuredMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SecuredMessage_template& list_item(unsigned int list_index) const;
INTEGER_template& protocol__version();
const INTEGER_template& protocol__version() const;
HeaderFields_template& header__fields();
const HeaderFields_template& header__fields() const;
SecPayload_template& payload__field();
const SecPayload_template& payload__field() const;
TrailerFields_template& trailer__fields();
const TrailerFields_template& trailer__fields() const;
int size_of() const;
void log() const;
void log_match(const SecuredMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ToBeSignedCertificate : public Base_Type {
  INTEGER field_version;
  SignerInfo field_signer__info;
  SubjectInfo field_subject__info;
  SubjectAttributes field_subject__attributes;
  ValidityRestrictions field_validity__restrictions;
  boolean bound_flag;
public:
  ToBeSignedCertificate();
  ToBeSignedCertificate(const INTEGER& par_version,
    const SignerInfo& par_signer__info,
    const SubjectInfo& par_subject__info,
    const SubjectAttributes& par_subject__attributes,
    const ValidityRestrictions& par_validity__restrictions);
  ToBeSignedCertificate(const ToBeSignedCertificate& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ToBeSignedCertificate& operator=(const ToBeSignedCertificate& other_value);
  boolean operator==(const ToBeSignedCertificate& other_value) const;
  inline boolean operator!=(const ToBeSignedCertificate& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& version()
    {return field_version;}
  inline const INTEGER& version() const
    {return field_version;}
  inline SignerInfo& signer__info()
    {return field_signer__info;}
  inline const SignerInfo& signer__info() const
    {return field_signer__info;}
  inline SubjectInfo& subject__info()
    {return field_subject__info;}
  inline const SubjectInfo& subject__info() const
    {return field_subject__info;}
  inline SubjectAttributes& subject__attributes()
    {return field_subject__attributes;}
  inline const SubjectAttributes& subject__attributes() const
    {return field_subject__attributes;}
  inline ValidityRestrictions& validity__restrictions()
    {return field_validity__restrictions;}
  inline const ValidityRestrictions& validity__restrictions() const
    {return field_validity__restrictions;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ToBeSignedCertificate_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ToBeSignedCertificate_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ToBeSignedCertificate& other_value);
void copy_template(const ToBeSignedCertificate_template& other_value);

public:
ToBeSignedCertificate_template();
ToBeSignedCertificate_template(template_sel other_value);
ToBeSignedCertificate_template(const ToBeSignedCertificate& other_value);
ToBeSignedCertificate_template(const OPTIONAL<ToBeSignedCertificate>& other_value);
ToBeSignedCertificate_template(const ToBeSignedCertificate_template& other_value);
~ToBeSignedCertificate_template();
ToBeSignedCertificate_template& operator=(template_sel other_value);
ToBeSignedCertificate_template& operator=(const ToBeSignedCertificate& other_value);
ToBeSignedCertificate_template& operator=(const OPTIONAL<ToBeSignedCertificate>& other_value);
ToBeSignedCertificate_template& operator=(const ToBeSignedCertificate_template& other_value);
boolean match(const ToBeSignedCertificate& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ToBeSignedCertificate valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ToBeSignedCertificate_template& list_item(unsigned int list_index) const;
INTEGER_template& version();
const INTEGER_template& version() const;
SignerInfo_template& signer__info();
const SignerInfo_template& signer__info() const;
SubjectInfo_template& subject__info();
const SubjectInfo_template& subject__info() const;
SubjectAttributes_template& subject__attributes();
const SubjectAttributes_template& subject__attributes() const;
ValidityRestrictions_template& validity__restrictions();
const ValidityRestrictions_template& validity__restrictions() const;
int size_of() const;
void log() const;
void log_match(const ToBeSignedCertificate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TaConfig : public Base_Type {
  OCTETSTRING field_signingPrivateKey;
  OCTETSTRING field_encryptPrivateKey;
  Certificate field_caCertificate;
  Certificate field_aaCertificate;
  Certificate field_atCertificate;
  ThreeDLocation field_location;
  boolean bound_flag;
public:
  TaConfig();
  TaConfig(const OCTETSTRING& par_signingPrivateKey,
    const OCTETSTRING& par_encryptPrivateKey,
    const Certificate& par_caCertificate,
    const Certificate& par_aaCertificate,
    const Certificate& par_atCertificate,
    const ThreeDLocation& par_location);
  TaConfig(const TaConfig& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TaConfig& operator=(const TaConfig& other_value);
  boolean operator==(const TaConfig& other_value) const;
  inline boolean operator!=(const TaConfig& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& signingPrivateKey()
    {return field_signingPrivateKey;}
  inline const OCTETSTRING& signingPrivateKey() const
    {return field_signingPrivateKey;}
  inline OCTETSTRING& encryptPrivateKey()
    {return field_encryptPrivateKey;}
  inline const OCTETSTRING& encryptPrivateKey() const
    {return field_encryptPrivateKey;}
  inline Certificate& caCertificate()
    {return field_caCertificate;}
  inline const Certificate& caCertificate() const
    {return field_caCertificate;}
  inline Certificate& aaCertificate()
    {return field_aaCertificate;}
  inline const Certificate& aaCertificate() const
    {return field_aaCertificate;}
  inline Certificate& atCertificate()
    {return field_atCertificate;}
  inline const Certificate& atCertificate() const
    {return field_atCertificate;}
  inline ThreeDLocation& location()
    {return field_location;}
  inline const ThreeDLocation& location() const
    {return field_location;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TaConfig_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TaConfig_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TaConfig& other_value);
void copy_template(const TaConfig_template& other_value);

public:
TaConfig_template();
TaConfig_template(template_sel other_value);
TaConfig_template(const TaConfig& other_value);
TaConfig_template(const OPTIONAL<TaConfig>& other_value);
TaConfig_template(const TaConfig_template& other_value);
~TaConfig_template();
TaConfig_template& operator=(template_sel other_value);
TaConfig_template& operator=(const TaConfig& other_value);
TaConfig_template& operator=(const OPTIONAL<TaConfig>& other_value);
TaConfig_template& operator=(const TaConfig_template& other_value);
boolean match(const TaConfig& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TaConfig valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TaConfig_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& signingPrivateKey();
const OCTETSTRING_template& signingPrivateKey() const;
OCTETSTRING_template& encryptPrivateKey();
const OCTETSTRING_template& encryptPrivateKey() const;
Certificate_template& caCertificate();
const Certificate_template& caCertificate() const;
Certificate_template& aaCertificate();
const Certificate_template& aaCertificate() const;
Certificate_template& atCertificate();
const Certificate_template& atCertificate() const;
ThreeDLocation_template& location();
const ThreeDLocation_template& location() const;
int size_of() const;
void log() const;
void log_match(const TaConfig& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TaConfigs : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
TaConfig **value_elements;
} *val_ptr;

static const TaConfig UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const TaConfigs& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef TaConfig of_type;
TaConfigs();
TaConfigs(null_type other_value);
TaConfigs(const TaConfigs& other_value);
~TaConfigs();

void clean_up();
TaConfigs& operator=(null_type other_value);
TaConfigs& operator=(const TaConfigs& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const TaConfigs& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TaConfigs& other_value) const { return !(*this == other_value); }

TaConfig& operator[](int index_value);
TaConfig& operator[](const INTEGER& index_value);
const TaConfig& operator[](int index_value) const;
const TaConfig& operator[](const INTEGER& index_value) const;

TaConfigs operator<<=(int rotate_count) const;
TaConfigs operator<<=(const INTEGER& rotate_count) const;
TaConfigs operator>>=(int rotate_count) const;
TaConfigs operator>>=(const INTEGER& rotate_count) const;

TaConfigs operator+(const TaConfigs& other_value) const;

TaConfigs substr(int index, int returncount) const;

TaConfigs replace(int index, int len, const TaConfigs& repl) const;

TaConfigs replace(int index, int len, const TaConfigs_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TaConfigs_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
TaConfig_template **value_elements;
} single_value;
struct {
unsigned int n_values;
TaConfigs_template *list_value;
} value_list;
struct {
unsigned int n_items;
TaConfig_template *set_items;
} value_set;
};
void copy_value(const TaConfigs& other_value);
void copy_template(const TaConfigs_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
TaConfigs_template();
TaConfigs_template(template_sel other_value);
TaConfigs_template(null_type other_value);
TaConfigs_template(const TaConfigs& other_value);
TaConfigs_template(const OPTIONAL<TaConfigs>& other_value);
TaConfigs_template(const TaConfigs_template& other_value);
~TaConfigs_template();

void clean_up();
TaConfigs_template& operator=(template_sel other_value);
TaConfigs_template& operator=(null_type other_value);
TaConfigs_template& operator=(const TaConfigs& other_value);
TaConfigs_template& operator=(const OPTIONAL<TaConfigs>& other_value);
TaConfigs_template& operator=(const TaConfigs_template& other_value);

TaConfig_template& operator[](int index_value);
TaConfig_template& operator[](const INTEGER& index_value);
const TaConfig_template& operator[](int index_value) const;
const TaConfig_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const TaConfigs& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
TaConfigs valueof() const;
TaConfigs substr(int index, int returncount) const;

TaConfigs replace(int index, int len, const TaConfigs_template& repl) const;

TaConfigs replace(int index, int len, const TaConfigs& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
TaConfigs_template& list_item(unsigned int list_index);
TaConfig_template& set_item(unsigned int set_index);
void log() const;
void log_match(const TaConfigs& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AcEnableSecurity : public Base_Type {
  CHARSTRING field_certificateId;
  boolean bound_flag;
public:
  AcEnableSecurity();
  AcEnableSecurity(const CHARSTRING& par_certificateId);
  AcEnableSecurity(const AcEnableSecurity& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AcEnableSecurity& operator=(const AcEnableSecurity& other_value);
  boolean operator==(const AcEnableSecurity& other_value) const;
  inline boolean operator!=(const AcEnableSecurity& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& certificateId()
    {return field_certificateId;}
  inline const CHARSTRING& certificateId() const
    {return field_certificateId;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcEnableSecurity_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AcEnableSecurity_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AcEnableSecurity& other_value);
void copy_template(const AcEnableSecurity_template& other_value);

public:
AcEnableSecurity_template();
AcEnableSecurity_template(template_sel other_value);
AcEnableSecurity_template(const AcEnableSecurity& other_value);
AcEnableSecurity_template(const OPTIONAL<AcEnableSecurity>& other_value);
AcEnableSecurity_template(const AcEnableSecurity_template& other_value);
~AcEnableSecurity_template();
AcEnableSecurity_template& operator=(template_sel other_value);
AcEnableSecurity_template& operator=(const AcEnableSecurity& other_value);
AcEnableSecurity_template& operator=(const OPTIONAL<AcEnableSecurity>& other_value);
AcEnableSecurity_template& operator=(const AcEnableSecurity_template& other_value);
boolean match(const AcEnableSecurity& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AcEnableSecurity valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcEnableSecurity_template& list_item(unsigned int list_index) const;
CHARSTRING_template& certificateId();
const CHARSTRING_template& certificateId() const;
int size_of() const;
void log() const;
void log_match(const AcEnableSecurity& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AcDisableSecurity : public Base_Type {
  BOOLEAN field_disable;
  boolean bound_flag;
public:
  AcDisableSecurity();
  AcDisableSecurity(const BOOLEAN& par_disable);
  AcDisableSecurity(const AcDisableSecurity& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AcDisableSecurity& operator=(const AcDisableSecurity& other_value);
  boolean operator==(const AcDisableSecurity& other_value) const;
  inline boolean operator!=(const AcDisableSecurity& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& disable()
    {return field_disable;}
  inline const BOOLEAN& disable() const
    {return field_disable;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcDisableSecurity_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AcDisableSecurity_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AcDisableSecurity& other_value);
void copy_template(const AcDisableSecurity_template& other_value);

public:
AcDisableSecurity_template();
AcDisableSecurity_template(template_sel other_value);
AcDisableSecurity_template(const AcDisableSecurity& other_value);
AcDisableSecurity_template(const OPTIONAL<AcDisableSecurity>& other_value);
AcDisableSecurity_template(const AcDisableSecurity_template& other_value);
~AcDisableSecurity_template();
AcDisableSecurity_template& operator=(template_sel other_value);
AcDisableSecurity_template& operator=(const AcDisableSecurity& other_value);
AcDisableSecurity_template& operator=(const OPTIONAL<AcDisableSecurity>& other_value);
AcDisableSecurity_template& operator=(const AcDisableSecurity_template& other_value);
boolean match(const AcDisableSecurity& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AcDisableSecurity valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcDisableSecurity_template& list_item(unsigned int list_index) const;
BOOLEAN_template& disable();
const BOOLEAN_template& disable() const;
int size_of() const;
void log() const;
void log_match(const AcDisableSecurity& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const SubjectAttributes& other_value);
inline boolean operator!=(null_type null_value, const SubjectAttributes& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ItsAidSsps& other_value);
inline boolean operator!=(null_type null_value, const ItsAidSsps& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ValidityRestrictions& other_value);
inline boolean operator!=(null_type null_value, const ValidityRestrictions& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const RectangularRegions& other_value);
inline boolean operator!=(null_type null_value, const RectangularRegions& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PolygonalRegion& other_value);
inline boolean operator!=(null_type null_value, const PolygonalRegion& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const CertificateChain& other_value);
inline boolean operator!=(null_type null_value, const CertificateChain& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ThreeDLocations& other_value);
inline boolean operator!=(null_type null_value, const ThreeDLocations& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const HeaderFields& other_value);
inline boolean operator!=(null_type null_value, const HeaderFields& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const RecipientInfos& other_value);
inline boolean operator!=(null_type null_value, const RecipientInfos& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const TrailerFields& other_value);
inline boolean operator!=(null_type null_value, const TrailerFields& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const TaConfigs& other_value);
inline boolean operator!=(null_type null_value, const TaConfigs& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_RAWdescriptor_t IntX_raw_;
extern const XERdescriptor_t IntX_xer_;
extern const TTCN_Typedescriptor_t IntX_descr_;
extern const TTCN_RAWdescriptor_t PublicKeyAlgorithm_raw_;
extern const TTCN_JSONdescriptor_t PublicKeyAlgorithm_json_;
extern const TTCN_Typedescriptor_t PublicKeyAlgorithm_descr_;
extern const TTCN_RAWdescriptor_t SymmetricAlgorithm_raw_;
extern const TTCN_JSONdescriptor_t SymmetricAlgorithm_json_;
extern const TTCN_Typedescriptor_t SymmetricAlgorithm_descr_;
extern const TTCN_RAWdescriptor_t PublicKeyContainer_raw_;
extern const TTCN_JSONdescriptor_t PublicKeyContainer_json_;
extern const TTCN_Typedescriptor_t PublicKeyContainer_descr_;
extern const TTCN_RAWdescriptor_t EccPointType_raw_;
extern const TTCN_JSONdescriptor_t EccPointType_json_;
extern const TTCN_Typedescriptor_t EccPointType_descr_;
extern const XERdescriptor_t EccPoint_x_xer_;
extern const TTCN_Typedescriptor_t EccPoint_x_descr_;
extern const TTCN_RAWdescriptor_t EccPoint_raw_;
extern const TTCN_JSONdescriptor_t EccPoint_json_;
extern const TTCN_Typedescriptor_t EccPoint_descr_;
extern const TTCN_RAWdescriptor_t EccPointContainer_raw_;
extern const TTCN_JSONdescriptor_t EccPointContainer_json_;
extern const TTCN_Typedescriptor_t EccPointContainer_descr_;
extern const XERdescriptor_t EccPointContainer_y_xer_;
extern const TTCN_Typedescriptor_t EccPointContainer_y_descr_;
extern const XERdescriptor_t EccPointContainer_data_xer_;
extern const TTCN_Typedescriptor_t EccPointContainer_data_descr_;
extern const TTCN_RAWdescriptor_t AesCcm_raw_;
extern const TTCN_JSONdescriptor_t AesCcm_json_;
extern const TTCN_Typedescriptor_t AesCcm_descr_;
extern const XERdescriptor_t PublicKeyContainer_other__key_xer_;
extern const TTCN_Typedescriptor_t PublicKeyContainer_other__key_descr_;
extern const TTCN_RAWdescriptor_t PublicKey_raw_;
extern const TTCN_JSONdescriptor_t PublicKey_json_;
extern const TTCN_Typedescriptor_t PublicKey_descr_;
extern const TTCN_RAWdescriptor_t EncryptionParametersContainer_raw_;
extern const TTCN_JSONdescriptor_t EncryptionParametersContainer_json_;
extern const TTCN_Typedescriptor_t EncryptionParametersContainer_descr_;
extern const XERdescriptor_t EncryptionParametersContainer_nonce_xer_;
extern const TTCN_Typedescriptor_t EncryptionParametersContainer_nonce_descr_;
extern const XERdescriptor_t EncryptionParametersContainer_params_xer_;
extern const TTCN_Typedescriptor_t EncryptionParametersContainer_params_descr_;
extern const TTCN_RAWdescriptor_t EncryptionParameters_raw_;
extern const TTCN_JSONdescriptor_t EncryptionParameters_json_;
extern const TTCN_Typedescriptor_t EncryptionParameters_descr_;
extern const TTCN_RAWdescriptor_t SignatureContainer_raw_;
extern const TTCN_JSONdescriptor_t SignatureContainer_json_;
extern const TTCN_Typedescriptor_t SignatureContainer_descr_;
extern const XERdescriptor_t EcdsaSignature_s_xer_;
extern const TTCN_Typedescriptor_t EcdsaSignature_s_descr_;
extern const TTCN_RAWdescriptor_t EcdsaSignature_raw_;
extern const TTCN_JSONdescriptor_t EcdsaSignature_json_;
extern const TTCN_Typedescriptor_t EcdsaSignature_descr_;
extern const XERdescriptor_t SignatureContainer_signature___xer_;
extern const TTCN_Typedescriptor_t SignatureContainer_signature___descr_;
extern const TTCN_RAWdescriptor_t Signature_raw_;
extern const TTCN_JSONdescriptor_t Signature_json_;
extern const TTCN_Typedescriptor_t Signature_descr_;
extern const TTCN_RAWdescriptor_t SignerInfoType_raw_;
extern const TTCN_JSONdescriptor_t SignerInfoType_json_;
extern const TTCN_Typedescriptor_t SignerInfoType_descr_;
extern const TTCN_RAWdescriptor_t SignerInfo_raw_;
extern const TTCN_JSONdescriptor_t SignerInfo_json_;
extern const TTCN_Typedescriptor_t SignerInfo_descr_;
extern const TTCN_RAWdescriptor_t SignerInfoContainer_raw_;
extern const TTCN_JSONdescriptor_t SignerInfoContainer_json_;
extern const TTCN_Typedescriptor_t SignerInfoContainer_descr_;
extern const TTCN_RAWdescriptor_t HashedId8_raw_;
extern const XERdescriptor_t HashedId8_xer_;
extern const TTCN_Typedescriptor_t HashedId8_descr_;
extern const XERdescriptor_t SignerInfoContainer_digest_xer_;
extern const TTCN_Typedescriptor_t SignerInfoContainer_digest_descr_;
extern const XERdescriptor_t Certificate_version_xer_;
extern const TTCN_Typedescriptor_t Certificate_version_descr_;
extern const TTCN_RAWdescriptor_t SubjectType_raw_;
extern const TTCN_JSONdescriptor_t SubjectType_json_;
extern const TTCN_Typedescriptor_t SubjectType_descr_;
extern const XERdescriptor_t SubjectInfo_subject__name_xer_;
extern const TTCN_Typedescriptor_t SubjectInfo_subject__name_descr_;
extern const TTCN_RAWdescriptor_t SubjectInfo_raw_;
extern const TTCN_JSONdescriptor_t SubjectInfo_json_;
extern const TTCN_Typedescriptor_t SubjectInfo_descr_;
extern const TTCN_RAWdescriptor_t SubjectAttributes_raw_;
extern const TTCN_JSONdescriptor_t SubjectAttributes_json_;
extern const TTCN_Typedescriptor_t SubjectAttributes_descr_;
extern const TTCN_RAWdescriptor_t SubjectAttributeType_raw_;
extern const TTCN_JSONdescriptor_t SubjectAttributeType_json_;
extern const TTCN_Typedescriptor_t SubjectAttributeType_descr_;
extern const TTCN_RAWdescriptor_t SubjectAttributeContainer_raw_;
extern const TTCN_JSONdescriptor_t SubjectAttributeContainer_json_;
extern const TTCN_Typedescriptor_t SubjectAttributeContainer_descr_;
extern const XERdescriptor_t SubjectAssurance_levels_xer_;
extern const TTCN_Typedescriptor_t SubjectAssurance_levels_descr_;
extern const XERdescriptor_t SubjectAssurance_reserved_xer_;
extern const TTCN_Typedescriptor_t SubjectAssurance_reserved_descr_;
extern const XERdescriptor_t SubjectAssurance_confidence_xer_;
extern const TTCN_Typedescriptor_t SubjectAssurance_confidence_descr_;
extern const TTCN_RAWdescriptor_t SubjectAssurance_raw_;
extern const TTCN_JSONdescriptor_t SubjectAssurance_json_;
extern const TTCN_Typedescriptor_t SubjectAssurance_descr_;
extern const TTCN_RAWdescriptor_t IntXs_raw_;
extern const TTCN_JSONdescriptor_t IntXs_json_;
extern const TTCN_Typedescriptor_t IntXs_descr_;
extern const XERdescriptor_t IntXs_0_xer_;
extern const TTCN_Typedescriptor_t IntXs_0_descr_;
extern const TTCN_RAWdescriptor_t ItsAidSsps_raw_;
extern const TTCN_JSONdescriptor_t ItsAidSsps_json_;
extern const TTCN_Typedescriptor_t ItsAidSsps_descr_;
extern const XERdescriptor_t ItsAidSsp_its__aid_xer_;
extern const TTCN_Typedescriptor_t ItsAidSsp_its__aid_descr_;
extern const XERdescriptor_t ServiceSpecificPermissions_version_xer_;
extern const TTCN_Typedescriptor_t ServiceSpecificPermissions_version_descr_;
extern const TTCN_RAWdescriptor_t ServiceSpecificPermissions_raw_;
extern const TTCN_JSONdescriptor_t ServiceSpecificPermissions_json_;
extern const TTCN_Typedescriptor_t ServiceSpecificPermissions_descr_;
extern const TTCN_RAWdescriptor_t ServiceSpecificPermissionsContainer_raw_;
extern const TTCN_JSONdescriptor_t ServiceSpecificPermissionsContainer_json_;
extern const TTCN_Typedescriptor_t ServiceSpecificPermissionsContainer_descr_;
extern const XERdescriptor_t SspCAM_cenDsrcTollingZone_xer_;
extern const TTCN_Typedescriptor_t SspCAM_cenDsrcTollingZone_descr_;
extern const XERdescriptor_t SspCAM_publicTransport_xer_;
extern const TTCN_Typedescriptor_t SspCAM_publicTransport_descr_;
extern const XERdescriptor_t SspCAM_specialTransport_xer_;
extern const TTCN_Typedescriptor_t SspCAM_specialTransport_descr_;
extern const XERdescriptor_t SspCAM_dangerousGoods_xer_;
extern const TTCN_Typedescriptor_t SspCAM_dangerousGoods_descr_;
extern const XERdescriptor_t SspCAM_roadwork_xer_;
extern const TTCN_Typedescriptor_t SspCAM_roadwork_descr_;
extern const XERdescriptor_t SspCAM_rescue_xer_;
extern const TTCN_Typedescriptor_t SspCAM_rescue_descr_;
extern const XERdescriptor_t SspCAM_emergency_xer_;
extern const TTCN_Typedescriptor_t SspCAM_emergency_descr_;
extern const XERdescriptor_t SspCAM_safetyCar_xer_;
extern const TTCN_Typedescriptor_t SspCAM_safetyCar_descr_;
extern const XERdescriptor_t SspCAM_closedLanes_xer_;
extern const TTCN_Typedescriptor_t SspCAM_closedLanes_descr_;
extern const XERdescriptor_t SspCAM_requestForRightOfWay_xer_;
extern const TTCN_Typedescriptor_t SspCAM_requestForRightOfWay_descr_;
extern const XERdescriptor_t SspCAM_requestForFreeCrossingAtATrafficLight_xer_;
extern const TTCN_Typedescriptor_t SspCAM_requestForFreeCrossingAtATrafficLight_descr_;
extern const XERdescriptor_t SspCAM_noPassing_xer_;
extern const TTCN_Typedescriptor_t SspCAM_noPassing_descr_;
extern const XERdescriptor_t SspCAM_noPassingForTrucks_xer_;
extern const TTCN_Typedescriptor_t SspCAM_noPassingForTrucks_descr_;
extern const XERdescriptor_t SspCAM_speedLimit_xer_;
extern const TTCN_Typedescriptor_t SspCAM_speedLimit_descr_;
extern const XERdescriptor_t SspCAM_reserved1_xer_;
extern const TTCN_Typedescriptor_t SspCAM_reserved1_descr_;
extern const XERdescriptor_t SspCAM_reserved2_xer_;
extern const TTCN_Typedescriptor_t SspCAM_reserved2_descr_;
extern const TTCN_RAWdescriptor_t SspCAM_raw_;
extern const TTCN_JSONdescriptor_t SspCAM_json_;
extern const TTCN_Typedescriptor_t SspCAM_descr_;
extern const XERdescriptor_t SspDENM_trafficCondition_xer_;
extern const TTCN_Typedescriptor_t SspDENM_trafficCondition_descr_;
extern const XERdescriptor_t SspDENM_accident_xer_;
extern const TTCN_Typedescriptor_t SspDENM_accident_descr_;
extern const XERdescriptor_t SspDENM_roadworks_xer_;
extern const TTCN_Typedescriptor_t SspDENM_roadworks_descr_;
extern const XERdescriptor_t SspDENM_adverseWeatherCondition__Adhesion_xer_;
extern const TTCN_Typedescriptor_t SspDENM_adverseWeatherCondition__Adhesion_descr_;
extern const XERdescriptor_t SspDENM_hazardousLocation__SurfaceCondition_xer_;
extern const TTCN_Typedescriptor_t SspDENM_hazardousLocation__SurfaceCondition_descr_;
extern const XERdescriptor_t SspDENM_hazardousLocation__ObstacleOnTheRoad_xer_;
extern const TTCN_Typedescriptor_t SspDENM_hazardousLocation__ObstacleOnTheRoad_descr_;
extern const XERdescriptor_t SspDENM_hazardousLocation__AnimalOnTheRoad_xer_;
extern const TTCN_Typedescriptor_t SspDENM_hazardousLocation__AnimalOnTheRoad_descr_;
extern const XERdescriptor_t SspDENM_humanPresenceOnTheRoad_xer_;
extern const TTCN_Typedescriptor_t SspDENM_humanPresenceOnTheRoad_descr_;
extern const XERdescriptor_t SspDENM_wrongWayDriving_xer_;
extern const TTCN_Typedescriptor_t SspDENM_wrongWayDriving_descr_;
extern const XERdescriptor_t SspDENM_rescueAndRecoveryWorkInProgress_xer_;
extern const TTCN_Typedescriptor_t SspDENM_rescueAndRecoveryWorkInProgress_descr_;
extern const XERdescriptor_t SspDENM_adverseWeatherCondition__ExtremeWeatherCondition_xer_;
extern const TTCN_Typedescriptor_t SspDENM_adverseWeatherCondition__ExtremeWeatherCondition_descr_;
extern const XERdescriptor_t SspDENM_adverseWeatherCondition__Visibility_xer_;
extern const TTCN_Typedescriptor_t SspDENM_adverseWeatherCondition__Visibility_descr_;
extern const XERdescriptor_t SspDENM_adverseWeatherCondition__Precipitation_xer_;
extern const TTCN_Typedescriptor_t SspDENM_adverseWeatherCondition__Precipitation_descr_;
extern const XERdescriptor_t SspDENM_slowVehicle_xer_;
extern const TTCN_Typedescriptor_t SspDENM_slowVehicle_descr_;
extern const XERdescriptor_t SspDENM_dangerousEndOfQueue_xer_;
extern const TTCN_Typedescriptor_t SspDENM_dangerousEndOfQueue_descr_;
extern const XERdescriptor_t SspDENM_vehicleBreakdown_xer_;
extern const TTCN_Typedescriptor_t SspDENM_vehicleBreakdown_descr_;
extern const XERdescriptor_t SspDENM_postCrash_xer_;
extern const TTCN_Typedescriptor_t SspDENM_postCrash_descr_;
extern const XERdescriptor_t SspDENM_humanProblem_xer_;
extern const TTCN_Typedescriptor_t SspDENM_humanProblem_descr_;
extern const XERdescriptor_t SspDENM_stationaryVehicle_xer_;
extern const TTCN_Typedescriptor_t SspDENM_stationaryVehicle_descr_;
extern const XERdescriptor_t SspDENM_emergencyVehicleApproaching_xer_;
extern const TTCN_Typedescriptor_t SspDENM_emergencyVehicleApproaching_descr_;
extern const XERdescriptor_t SspDENM_hazardousLocation__DangerousCurve_xer_;
extern const TTCN_Typedescriptor_t SspDENM_hazardousLocation__DangerousCurve_descr_;
extern const XERdescriptor_t SspDENM_collisionRisk_xer_;
extern const TTCN_Typedescriptor_t SspDENM_collisionRisk_descr_;
extern const XERdescriptor_t SspDENM_signalViolation_xer_;
extern const TTCN_Typedescriptor_t SspDENM_signalViolation_descr_;
extern const XERdescriptor_t SspDENM_dangerousSituation_xer_;
extern const TTCN_Typedescriptor_t SspDENM_dangerousSituation_descr_;
extern const TTCN_RAWdescriptor_t SspDENM_raw_;
extern const TTCN_JSONdescriptor_t SspDENM_json_;
extern const TTCN_Typedescriptor_t SspDENM_descr_;
extern const XERdescriptor_t ServiceSpecificPermissionsContainer_opaque_xer_;
extern const TTCN_Typedescriptor_t ServiceSpecificPermissionsContainer_opaque_descr_;
extern const TTCN_RAWdescriptor_t ItsAidSsp_raw_;
extern const TTCN_JSONdescriptor_t ItsAidSsp_json_;
extern const TTCN_Typedescriptor_t ItsAidSsp_descr_;
extern const XERdescriptor_t SubjectAttributeContainer_other__attribute_xer_;
extern const TTCN_Typedescriptor_t SubjectAttributeContainer_other__attribute_descr_;
extern const TTCN_RAWdescriptor_t SubjectAttribute_raw_;
extern const TTCN_JSONdescriptor_t SubjectAttribute_json_;
extern const TTCN_Typedescriptor_t SubjectAttribute_descr_;
extern const TTCN_RAWdescriptor_t ValidityRestrictions_raw_;
extern const TTCN_JSONdescriptor_t ValidityRestrictions_json_;
extern const TTCN_Typedescriptor_t ValidityRestrictions_descr_;
extern const TTCN_RAWdescriptor_t ValidityRestrictionType_raw_;
extern const TTCN_JSONdescriptor_t ValidityRestrictionType_json_;
extern const TTCN_Typedescriptor_t ValidityRestrictionType_descr_;
extern const TTCN_RAWdescriptor_t ValidityRestrictionContainer_raw_;
extern const TTCN_JSONdescriptor_t ValidityRestrictionContainer_json_;
extern const TTCN_Typedescriptor_t ValidityRestrictionContainer_descr_;
extern const TTCN_RAWdescriptor_t Time32_raw_;
extern const XERdescriptor_t Time32_xer_;
extern const TTCN_Typedescriptor_t Time32_descr_;
extern const XERdescriptor_t ValidityRestrictionContainer_end__validity_xer_;
extern const TTCN_Typedescriptor_t ValidityRestrictionContainer_end__validity_descr_;
extern const XERdescriptor_t TimeStartEnd_start__validity_xer_;
extern const TTCN_Typedescriptor_t TimeStartEnd_start__validity_descr_;
extern const XERdescriptor_t TimeStartEnd_end__validity_xer_;
extern const TTCN_Typedescriptor_t TimeStartEnd_end__validity_descr_;
extern const TTCN_RAWdescriptor_t TimeStartEnd_raw_;
extern const TTCN_JSONdescriptor_t TimeStartEnd_json_;
extern const TTCN_Typedescriptor_t TimeStartEnd_descr_;
extern const XERdescriptor_t TimeDuration_start__validity_xer_;
extern const TTCN_Typedescriptor_t TimeDuration_start__validity_descr_;
extern const TTCN_RAWdescriptor_t DurationUnitType_raw_;
extern const TTCN_JSONdescriptor_t DurationUnitType_json_;
extern const TTCN_Typedescriptor_t DurationUnitType_descr_;
extern const XERdescriptor_t Duration_duration_xer_;
extern const TTCN_Typedescriptor_t Duration_duration_descr_;
extern const TTCN_RAWdescriptor_t Duration_raw_;
extern const TTCN_JSONdescriptor_t Duration_json_;
extern const TTCN_Typedescriptor_t Duration_descr_;
extern const TTCN_RAWdescriptor_t TimeDuration_raw_;
extern const TTCN_JSONdescriptor_t TimeDuration_json_;
extern const TTCN_Typedescriptor_t TimeDuration_descr_;
extern const TTCN_RAWdescriptor_t RegionType_raw_;
extern const TTCN_JSONdescriptor_t RegionType_json_;
extern const TTCN_Typedescriptor_t RegionType_descr_;
extern const TTCN_RAWdescriptor_t GeographicRegion_raw_;
extern const TTCN_JSONdescriptor_t GeographicRegion_json_;
extern const TTCN_Typedescriptor_t GeographicRegion_descr_;
extern const TTCN_RAWdescriptor_t GeographicRegionContainer_raw_;
extern const TTCN_JSONdescriptor_t GeographicRegionContainer_json_;
extern const TTCN_Typedescriptor_t GeographicRegionContainer_descr_;
extern const TTCN_RAWdescriptor_t WGSLatitude_raw_;
extern const XERdescriptor_t WGSLatitude_xer_;
extern const TTCN_Typedescriptor_t WGSLatitude_descr_;
extern const XERdescriptor_t TwoDLocation_latitude_xer_;
extern const TTCN_Typedescriptor_t TwoDLocation_latitude_descr_;
extern const TTCN_RAWdescriptor_t WGSLongitude_raw_;
extern const XERdescriptor_t WGSLongitude_xer_;
extern const TTCN_Typedescriptor_t WGSLongitude_descr_;
extern const XERdescriptor_t TwoDLocation_longitude_xer_;
extern const TTCN_Typedescriptor_t TwoDLocation_longitude_descr_;
extern const TTCN_RAWdescriptor_t TwoDLocation_raw_;
extern const TTCN_JSONdescriptor_t TwoDLocation_json_;
extern const TTCN_Typedescriptor_t TwoDLocation_descr_;
extern const XERdescriptor_t CircularRegion_radius_xer_;
extern const TTCN_Typedescriptor_t CircularRegion_radius_descr_;
extern const TTCN_RAWdescriptor_t CircularRegion_raw_;
extern const TTCN_JSONdescriptor_t CircularRegion_json_;
extern const TTCN_Typedescriptor_t CircularRegion_descr_;
extern const TTCN_RAWdescriptor_t RectangularRegions_raw_;
extern const TTCN_JSONdescriptor_t RectangularRegions_json_;
extern const TTCN_Typedescriptor_t RectangularRegions_descr_;
extern const TTCN_RAWdescriptor_t RectangularRegion_raw_;
extern const TTCN_JSONdescriptor_t RectangularRegion_json_;
extern const TTCN_Typedescriptor_t RectangularRegion_descr_;
extern const TTCN_RAWdescriptor_t PolygonalRegion_raw_;
extern const TTCN_JSONdescriptor_t PolygonalRegion_json_;
extern const TTCN_Typedescriptor_t PolygonalRegion_descr_;
extern const TTCN_RAWdescriptor_t RegionDictionary_raw_;
extern const TTCN_JSONdescriptor_t RegionDictionary_json_;
extern const TTCN_Typedescriptor_t RegionDictionary_descr_;
extern const XERdescriptor_t IdentifiedRegion_region__identifier_xer_;
extern const TTCN_Typedescriptor_t IdentifiedRegion_region__identifier_descr_;
extern const XERdescriptor_t IdentifiedRegion_local__region_xer_;
extern const TTCN_Typedescriptor_t IdentifiedRegion_local__region_descr_;
extern const TTCN_RAWdescriptor_t IdentifiedRegion_raw_;
extern const TTCN_JSONdescriptor_t IdentifiedRegion_json_;
extern const TTCN_Typedescriptor_t IdentifiedRegion_descr_;
extern const XERdescriptor_t GeographicRegionContainer_other__region_xer_;
extern const TTCN_Typedescriptor_t GeographicRegionContainer_other__region_descr_;
extern const XERdescriptor_t ValidityRestrictionContainer_data_xer_;
extern const TTCN_Typedescriptor_t ValidityRestrictionContainer_data_descr_;
extern const TTCN_RAWdescriptor_t ValidityRestriction_raw_;
extern const TTCN_JSONdescriptor_t ValidityRestriction_json_;
extern const TTCN_Typedescriptor_t ValidityRestriction_descr_;
extern const TTCN_RAWdescriptor_t Certificate_raw_;
extern const TTCN_JSONdescriptor_t Certificate_json_;
extern const TTCN_Typedescriptor_t Certificate_descr_;
extern const TTCN_RAWdescriptor_t CertificateChain_raw_;
extern const TTCN_JSONdescriptor_t CertificateChain_json_;
extern const TTCN_Typedescriptor_t CertificateChain_descr_;
extern const XERdescriptor_t CertificateWithAlgo_digest_xer_;
extern const TTCN_Typedescriptor_t CertificateWithAlgo_digest_descr_;
extern const TTCN_RAWdescriptor_t CertificateWithAlgo_raw_;
extern const TTCN_JSONdescriptor_t CertificateWithAlgo_json_;
extern const TTCN_Typedescriptor_t CertificateWithAlgo_descr_;
extern const XERdescriptor_t SignerInfoContainer_info_xer_;
extern const TTCN_Typedescriptor_t SignerInfoContainer_info_descr_;
extern const TTCN_RAWdescriptor_t HashedId3_raw_;
extern const XERdescriptor_t HashedId3_xer_;
extern const TTCN_Typedescriptor_t HashedId3_descr_;
extern const TTCN_RAWdescriptor_t Time64_raw_;
extern const XERdescriptor_t Time64_xer_;
extern const TTCN_Typedescriptor_t Time64_descr_;
extern const XERdescriptor_t Time64WithStandardDeviation_time_xer_;
extern const TTCN_Typedescriptor_t Time64WithStandardDeviation_time_descr_;
extern const XERdescriptor_t Time64WithStandardDeviation_log__std__dev_xer_;
extern const TTCN_Typedescriptor_t Time64WithStandardDeviation_log__std__dev_descr_;
extern const TTCN_RAWdescriptor_t Time64WithStandardDeviation_raw_;
extern const TTCN_JSONdescriptor_t Time64WithStandardDeviation_json_;
extern const TTCN_Typedescriptor_t Time64WithStandardDeviation_descr_;
extern const XERdescriptor_t ThreeDLocation_latitude_xer_;
extern const TTCN_Typedescriptor_t ThreeDLocation_latitude_descr_;
extern const XERdescriptor_t ThreeDLocation_longitude_xer_;
extern const TTCN_Typedescriptor_t ThreeDLocation_longitude_descr_;
extern const XERdescriptor_t ThreeDLocation_elevation_xer_;
extern const TTCN_Typedescriptor_t ThreeDLocation_elevation_descr_;
extern const TTCN_RAWdescriptor_t ThreeDLocation_raw_;
extern const TTCN_JSONdescriptor_t ThreeDLocation_json_;
extern const TTCN_Typedescriptor_t ThreeDLocation_descr_;
extern const TTCN_RAWdescriptor_t ThreeDLocations_raw_;
extern const TTCN_Typedescriptor_t ThreeDLocations_descr_;
extern const TTCN_RAWdescriptor_t RegionIdentifiers_raw_;
extern const TTCN_Typedescriptor_t RegionIdentifiers_descr_;
extern const XERdescriptor_t RegionIdentifiers_0_xer_;
extern const TTCN_Typedescriptor_t RegionIdentifiers_0_descr_;
extern const XERdescriptor_t ToBeSignedSecuredMessage_protocol__version_xer_;
extern const TTCN_Typedescriptor_t ToBeSignedSecuredMessage_protocol__version_descr_;
extern const TTCN_RAWdescriptor_t HeaderFields_raw_;
extern const TTCN_JSONdescriptor_t HeaderFields_json_;
extern const TTCN_Typedescriptor_t HeaderFields_descr_;
extern const TTCN_RAWdescriptor_t HeaderFieldType_raw_;
extern const TTCN_JSONdescriptor_t HeaderFieldType_json_;
extern const TTCN_Typedescriptor_t HeaderFieldType_descr_;
extern const TTCN_RAWdescriptor_t HeaderFieldContainer_raw_;
extern const TTCN_JSONdescriptor_t HeaderFieldContainer_json_;
extern const TTCN_Typedescriptor_t HeaderFieldContainer_descr_;
extern const XERdescriptor_t HeaderFieldContainer_generation__time_xer_;
extern const TTCN_Typedescriptor_t HeaderFieldContainer_generation__time_descr_;
extern const XERdescriptor_t HeaderFieldContainer_expiry__time_xer_;
extern const TTCN_Typedescriptor_t HeaderFieldContainer_expiry__time_descr_;
extern const TTCN_RAWdescriptor_t HashedId3s_raw_;
extern const TTCN_JSONdescriptor_t HashedId3s_json_;
extern const TTCN_Typedescriptor_t HashedId3s_descr_;
extern const XERdescriptor_t HashedId3s_0_xer_;
extern const TTCN_Typedescriptor_t HashedId3s_0_descr_;
extern const XERdescriptor_t HeaderFieldContainer_its__aid_xer_;
extern const TTCN_Typedescriptor_t HeaderFieldContainer_its__aid_descr_;
extern const TTCN_RAWdescriptor_t RecipientInfos_raw_;
extern const TTCN_JSONdescriptor_t RecipientInfos_json_;
extern const TTCN_Typedescriptor_t RecipientInfos_descr_;
extern const XERdescriptor_t RecipientInfo_cert__id_xer_;
extern const TTCN_Typedescriptor_t RecipientInfo_cert__id_descr_;
extern const TTCN_RAWdescriptor_t RecipientInfoContainer_raw_;
extern const TTCN_JSONdescriptor_t RecipientInfoContainer_json_;
extern const TTCN_Typedescriptor_t RecipientInfoContainer_descr_;
extern const XERdescriptor_t EciesEncryptedKey_c_xer_;
extern const TTCN_Typedescriptor_t EciesEncryptedKey_c_descr_;
extern const XERdescriptor_t EciesEncryptedKey_t_xer_;
extern const TTCN_Typedescriptor_t EciesEncryptedKey_t_descr_;
extern const TTCN_RAWdescriptor_t EciesEncryptedKey_raw_;
extern const TTCN_JSONdescriptor_t EciesEncryptedKey_json_;
extern const TTCN_Typedescriptor_t EciesEncryptedKey_descr_;
extern const XERdescriptor_t RecipientInfoContainer_enc__key__other_xer_;
extern const TTCN_Typedescriptor_t RecipientInfoContainer_enc__key__other_descr_;
extern const TTCN_RAWdescriptor_t RecipientInfo_raw_;
extern const TTCN_JSONdescriptor_t RecipientInfo_json_;
extern const TTCN_Typedescriptor_t RecipientInfo_descr_;
extern const XERdescriptor_t HeaderFieldContainer_other__header_xer_;
extern const TTCN_Typedescriptor_t HeaderFieldContainer_other__header_descr_;
extern const TTCN_RAWdescriptor_t HeaderField_raw_;
extern const TTCN_JSONdescriptor_t HeaderField_json_;
extern const TTCN_Typedescriptor_t HeaderField_descr_;
extern const TTCN_RAWdescriptor_t SecPayloadType_raw_;
extern const TTCN_JSONdescriptor_t SecPayloadType_json_;
extern const TTCN_Typedescriptor_t SecPayloadType_descr_;
extern const TTCN_RAWdescriptor_t SecPayload_raw_;
extern const TTCN_JSONdescriptor_t SecPayload_json_;
extern const TTCN_Typedescriptor_t SecPayload_descr_;
extern const XERdescriptor_t SecPayload_data_xer_;
extern const TTCN_Typedescriptor_t SecPayload_data_descr_;
extern const XERdescriptor_t ToBeSignedSecuredMessage_trailer__fieldsLength_xer_;
extern const TTCN_Typedescriptor_t ToBeSignedSecuredMessage_trailer__fieldsLength_descr_;
extern const TTCN_RAWdescriptor_t TrailerFieldType_raw_;
extern const TTCN_JSONdescriptor_t TrailerFieldType_json_;
extern const TTCN_Typedescriptor_t TrailerFieldType_descr_;
extern const TTCN_RAWdescriptor_t ToBeSignedSecuredMessage_raw_;
extern const TTCN_JSONdescriptor_t ToBeSignedSecuredMessage_json_;
extern const TTCN_Typedescriptor_t ToBeSignedSecuredMessage_descr_;
extern const XERdescriptor_t SecuredMessage_protocol__version_xer_;
extern const TTCN_Typedescriptor_t SecuredMessage_protocol__version_descr_;
extern const TTCN_RAWdescriptor_t TrailerFields_raw_;
extern const TTCN_JSONdescriptor_t TrailerFields_json_;
extern const TTCN_Typedescriptor_t TrailerFields_descr_;
extern const TTCN_RAWdescriptor_t TrailerFieldContainer_raw_;
extern const TTCN_JSONdescriptor_t TrailerFieldContainer_json_;
extern const TTCN_Typedescriptor_t TrailerFieldContainer_descr_;
extern const XERdescriptor_t TrailerFieldContainer_security__field_xer_;
extern const TTCN_Typedescriptor_t TrailerFieldContainer_security__field_descr_;
extern const TTCN_RAWdescriptor_t TrailerField_raw_;
extern const TTCN_JSONdescriptor_t TrailerField_json_;
extern const TTCN_Typedescriptor_t TrailerField_descr_;
extern const TTCN_RAWdescriptor_t SecuredMessage_raw_;
extern const TTCN_JSONdescriptor_t SecuredMessage_json_;
extern const TTCN_Typedescriptor_t SecuredMessage_descr_;
extern const XERdescriptor_t ToBeSignedCertificate_version_xer_;
extern const TTCN_Typedescriptor_t ToBeSignedCertificate_version_descr_;
extern const TTCN_RAWdescriptor_t ToBeSignedCertificate_raw_;
extern const TTCN_JSONdescriptor_t ToBeSignedCertificate_json_;
extern const TTCN_Typedescriptor_t ToBeSignedCertificate_descr_;
extern const XERdescriptor_t TaConfig_signingPrivateKey_xer_;
extern const TTCN_Typedescriptor_t TaConfig_signingPrivateKey_descr_;
extern const XERdescriptor_t TaConfig_encryptPrivateKey_xer_;
extern const TTCN_Typedescriptor_t TaConfig_encryptPrivateKey_descr_;
extern const TTCN_RAWdescriptor_t TaConfig_raw_;
extern const TTCN_JSONdescriptor_t TaConfig_json_;
extern const TTCN_Typedescriptor_t TaConfig_descr_;
extern const TTCN_RAWdescriptor_t TaConfigs_raw_;
extern const TTCN_Typedescriptor_t TaConfigs_descr_;
extern const XERdescriptor_t AcEnableSecurity_certificateId_xer_;
extern const TTCN_Typedescriptor_t AcEnableSecurity_certificateId_descr_;
extern const TTCN_RAWdescriptor_t AcEnableSecurity_raw_;
extern const TTCN_JSONdescriptor_t AcEnableSecurity_json_;
extern const TTCN_Typedescriptor_t AcEnableSecurity_descr_;
extern const XERdescriptor_t AcDisableSecurity_disable_xer_;
extern const TTCN_Typedescriptor_t AcDisableSecurity_disable_descr_;
extern const TTCN_RAWdescriptor_t AcDisableSecurity_raw_;
extern const TTCN_JSONdescriptor_t AcDisableSecurity_json_;
extern const TTCN_Typedescriptor_t AcDisableSecurity_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
