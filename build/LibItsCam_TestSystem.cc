// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "LibItsCam_TestSystem.hh"

namespace LibItsCam__TestSystem {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean init_comp_type(const char *component_type, boolean init_base_comps);

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x4f, 0xa6, 0x37, 0xf4, 0x6c, 0x2f, 0xad, 0x5b, 0x26, 0xcb, 0x27, 0xdf, 0x14, 0x52, 0x55, 0xe5 };

/* Global variable definitions */

const TTCN_Typedescriptor_t& ItsCamSystem_descr_ = COMPONENT_descr_;
UpperTesterCAMPort ItsCamSystem_component_utPort("utPort");
CamPort ItsCamSystem_component_camPort("camPort");
const TTCN_Typedescriptor_t& ItsCam_descr_ = COMPONENT_descr_;
UpperTesterCAMPort ItsCam_component_utPort("utPort");
CamPort ItsCam_component_camPort("camPort");
const XERdescriptor_t       CamInd_gnNextHeader_xer_ = { {"gnNextHeader>\n", "gnNextHeader>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CamInd_gnNextHeader_descr_ = { "@LibItsCam_TestSystem.CamInd.gnNextHeader", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &CamInd_gnNextHeader_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CamInd_gnHeaderType_xer_ = { {"gnHeaderType>\n", "gnHeaderType>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CamInd_gnHeaderType_descr_ = { "@LibItsCam_TestSystem.CamInd.gnHeaderType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &CamInd_gnHeaderType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CamInd_gnHeaderSubtype_xer_ = { {"gnHeaderSubtype>\n", "gnHeaderSubtype>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CamInd_gnHeaderSubtype_descr_ = { "@LibItsCam_TestSystem.CamInd.gnHeaderSubtype", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &CamInd_gnHeaderSubtype_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CamInd_gnLifetime_xer_ = { {"gnLifetime>\n", "gnLifetime>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CamInd_gnLifetime_descr_ = { "@LibItsCam_TestSystem.CamInd.gnLifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &CamInd_gnLifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CamInd_gnTrafficClass_xer_ = { {"gnTrafficClass>\n", "gnTrafficClass>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CamInd_gnTrafficClass_descr_ = { "@LibItsCam_TestSystem.CamInd.gnTrafficClass", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &CamInd_gnTrafficClass_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CamInd_btpDestinationPort_xer_ = { {"btpDestinationPort>\n", "btpDestinationPort>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CamInd_btpDestinationPort_descr_ = { "@LibItsCam_TestSystem.CamInd.btpDestinationPort", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &CamInd_btpDestinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CamInd_btpInfo_xer_ = { {"btpInfo>\n", "btpInfo>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CamInd_btpInfo_descr_ = { "@LibItsCam_TestSystem.CamInd.btpInfo", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &CamInd_btpInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CamInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for CamInd
const TTCN_JSONdescriptor_t CamInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CamInd_descr_ = { "@LibItsCam_TestSystem.CamInd", NULL, &CamInd_raw_, NULL, NULL, &CamInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
CamInd ItsCam_component_vc__camMsg;
DEFAULT ItsCam_component_vc__default;
BOOLEAN ItsCam_component_vc__camReceived;
LibItsCam__TypesAndValues::UtCamEventIndList ItsCam_component_vc__utEvents;
const TTCN_RAWdescriptor_t CamReq_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for CamReq
const TTCN_JSONdescriptor_t CamReq_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CamReq_descr_ = { "@LibItsCam_TestSystem.CamReq", NULL, &CamReq_raw_, NULL, NULL, &CamReq_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 0;
TTCN_Module module_object("LibItsCam_TestSystem", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, init_comp_type, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

void UpperTesterCAMPort_BASE::remove_msg_queue_head()
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
switch (my_head->item_selection) {
case MESSAGE_0:
delete (my_head)->message_0;
break;
case MESSAGE_1:
delete (my_head)->message_1;
break;
case MESSAGE_2:
delete (my_head)->message_2;
break;
case MESSAGE_3:
delete (my_head)->message_3;
break;
default:
TTCN_error("Internal error: Invalid message selector in the queue of port %s.", port_name);
}
msg_queue_item_base *next_item = msg_queue_head->next_item;
delete (msg_queue_item*)msg_queue_head;
msg_queue_head = next_item;
if (next_item == NULL) msg_queue_tail = NULL;
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::extract__msg, port_name, 0, ++msg_head_count, CHARSTRING(0,NULL), CHARSTRING(0,NULL));}

void UpperTesterCAMPort_BASE::clear_queue()
{
while (msg_queue_head != NULL) remove_msg_queue_head();
}

UpperTesterCAMPort_BASE::UpperTesterCAMPort_BASE(const char *par_port_name)
 : PORT(par_port_name)
{
msg_queue_head = NULL;
msg_queue_tail = NULL;
}

UpperTesterCAMPort_BASE::~UpperTesterCAMPort_BASE()
{
clear_queue();
}

void UpperTesterCAMPort_BASE::send(const LibItsCommon__TypesAndValues::UtInitialize& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @LibItsCommon_TypesAndValues.UtInitialize : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) outgoing_send(send_par);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@LibItsCommon_TypesAndValues.UtInitialize");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void UpperTesterCAMPort_BASE::send(const LibItsCommon__TypesAndValues::UtInitialize& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void UpperTesterCAMPort_BASE::send(const LibItsCommon__TypesAndValues::UtInitialize_template& send_par, const COMPONENT& destination_component)
{
const LibItsCommon__TypesAndValues::UtInitialize& send_par_value = LibItsCommon__TypesAndValues::UtInitialize(send_par.valueof());
send(send_par_value, destination_component);
}

void UpperTesterCAMPort_BASE::send(const LibItsCommon__TypesAndValues::UtInitialize_template& send_par)
{
const LibItsCommon__TypesAndValues::UtInitialize& send_par_value = LibItsCommon__TypesAndValues::UtInitialize(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

void UpperTesterCAMPort_BASE::send(const LibItsCam__TypesAndValues::UtCamTrigger& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @LibItsCam_TypesAndValues.UtCamTrigger : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) outgoing_send(send_par);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@LibItsCam_TypesAndValues.UtCamTrigger");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void UpperTesterCAMPort_BASE::send(const LibItsCam__TypesAndValues::UtCamTrigger& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void UpperTesterCAMPort_BASE::send(const LibItsCam__TypesAndValues::UtCamTrigger_template& send_par, const COMPONENT& destination_component)
{
const LibItsCam__TypesAndValues::UtCamTrigger& send_par_value = LibItsCam__TypesAndValues::UtCamTrigger(send_par.valueof());
send(send_par_value, destination_component);
}

void UpperTesterCAMPort_BASE::send(const LibItsCam__TypesAndValues::UtCamTrigger_template& send_par)
{
const LibItsCam__TypesAndValues::UtCamTrigger& send_par_value = LibItsCam__TypesAndValues::UtCamTrigger(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

void UpperTesterCAMPort_BASE::send(const LibItsCommon__TypesAndValues::UtChangePosition& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @LibItsCommon_TypesAndValues.UtChangePosition : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) outgoing_send(send_par);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@LibItsCommon_TypesAndValues.UtChangePosition");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void UpperTesterCAMPort_BASE::send(const LibItsCommon__TypesAndValues::UtChangePosition& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void UpperTesterCAMPort_BASE::send(const LibItsCommon__TypesAndValues::UtChangePosition_template& send_par, const COMPONENT& destination_component)
{
const LibItsCommon__TypesAndValues::UtChangePosition& send_par_value = LibItsCommon__TypesAndValues::UtChangePosition(send_par.valueof());
send(send_par_value, destination_component);
}

void UpperTesterCAMPort_BASE::send(const LibItsCommon__TypesAndValues::UtChangePosition_template& send_par)
{
const LibItsCommon__TypesAndValues::UtChangePosition& send_par_value = LibItsCommon__TypesAndValues::UtChangePosition(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

alt_status UpperTesterCAMPort_BASE::receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_1:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamTriggerResult: "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_2:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtChangePositionResult: "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_3:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamEventInd: "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_1:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamTriggerResult: "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_2:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtChangePositionResult: "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_3:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamEventInd: "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_1:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamTriggerResult: "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_2:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtChangePositionResult: "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_3:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamEventInd: "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::receive(const LibItsCommon__TypesAndValues::UtInitializeResult_template& value_template, LibItsCommon__TypesAndValues::UtInitializeResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCommon_TypesAndValues.UtInitializeResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::check_receive(const LibItsCommon__TypesAndValues::UtInitializeResult_template& value_template, LibItsCommon__TypesAndValues::UtInitializeResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCommon_TypesAndValues.UtInitializeResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::trigger(const LibItsCommon__TypesAndValues::UtInitializeResult_template& value_template, LibItsCommon__TypesAndValues::UtInitializeResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsCommon_TypesAndValues.UtInitializeResult.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::receive(const LibItsCam__TypesAndValues::UtCamTriggerResult_template& value_template, LibItsCam__TypesAndValues::UtCamTriggerResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_1) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCam_TypesAndValues.UtCamTriggerResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_1, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_1;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamTriggerResult : "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::check_receive(const LibItsCam__TypesAndValues::UtCamTriggerResult_template& value_template, LibItsCam__TypesAndValues::UtCamTriggerResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_1) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCam_TypesAndValues.UtCamTriggerResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_1, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_1;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamTriggerResult : "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::trigger(const LibItsCam__TypesAndValues::UtCamTriggerResult_template& value_template, LibItsCam__TypesAndValues::UtCamTriggerResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_1) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsCam_TypesAndValues.UtCamTriggerResult.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_1, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_1;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamTriggerResult : "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::receive(const LibItsCommon__TypesAndValues::UtChangePositionResult_template& value_template, LibItsCommon__TypesAndValues::UtChangePositionResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_2) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCommon_TypesAndValues.UtChangePositionResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_2, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_2;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtChangePositionResult : "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::check_receive(const LibItsCommon__TypesAndValues::UtChangePositionResult_template& value_template, LibItsCommon__TypesAndValues::UtChangePositionResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_2) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCommon_TypesAndValues.UtChangePositionResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_2, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_2;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtChangePositionResult : "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::trigger(const LibItsCommon__TypesAndValues::UtChangePositionResult_template& value_template, LibItsCommon__TypesAndValues::UtChangePositionResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_2) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsCommon_TypesAndValues.UtChangePositionResult.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_2, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_2;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtChangePositionResult : "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::receive(const LibItsCam__TypesAndValues::UtCamEventInd_template& value_template, LibItsCam__TypesAndValues::UtCamEventInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_3) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCam_TypesAndValues.UtCamEventInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_3, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_3;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamEventInd : "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::check_receive(const LibItsCam__TypesAndValues::UtCamEventInd_template& value_template, LibItsCam__TypesAndValues::UtCamEventInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_3) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCam_TypesAndValues.UtCamEventInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_3, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_3;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamEventInd : "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status UpperTesterCAMPort_BASE::trigger(const LibItsCam__TypesAndValues::UtCamEventInd_template& value_template, LibItsCam__TypesAndValues::UtCamEventInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_3) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsCam_TypesAndValues.UtCamEventInd.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_3, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_3;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TypesAndValues.UtCamEventInd : "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

void UpperTesterCAMPort_BASE::incoming_message(const LibItsCommon__TypesAndValues::UtInitializeResult& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsCommon_TypesAndValues.UtInitializeResult : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_0;
new_item->message_0 = new LibItsCommon__TypesAndValues::UtInitializeResult(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

void UpperTesterCAMPort_BASE::incoming_message(const LibItsCam__TypesAndValues::UtCamTriggerResult& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsCam_TypesAndValues.UtCamTriggerResult : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_1;
new_item->message_1 = new LibItsCam__TypesAndValues::UtCamTriggerResult(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

void UpperTesterCAMPort_BASE::incoming_message(const LibItsCommon__TypesAndValues::UtChangePositionResult& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsCommon_TypesAndValues.UtChangePositionResult : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_2;
new_item->message_2 = new LibItsCommon__TypesAndValues::UtChangePositionResult(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

void UpperTesterCAMPort_BASE::incoming_message(const LibItsCam__TypesAndValues::UtCamEventInd& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsCam_TypesAndValues.UtCamEventInd : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_3;
new_item->message_3 = new LibItsCam__TypesAndValues::UtCamEventInd(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

boolean UpperTesterCAMPort_BASE::process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING&)
{
if (!strcmp(message_type, "@LibItsCommon_TypesAndValues.UtInitializeResult")) {
LibItsCommon__TypesAndValues::UtInitializeResult incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else if (!strcmp(message_type, "@LibItsCam_TypesAndValues.UtCamTriggerResult")) {
LibItsCam__TypesAndValues::UtCamTriggerResult incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else if (!strcmp(message_type, "@LibItsCommon_TypesAndValues.UtChangePositionResult")) {
LibItsCommon__TypesAndValues::UtChangePositionResult incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else if (!strcmp(message_type, "@LibItsCam_TypesAndValues.UtCamEventInd")) {
LibItsCam__TypesAndValues::UtCamEventInd incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else return FALSE;
}

void CamPort_BASE::remove_msg_queue_head()
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
switch (my_head->item_selection) {
case MESSAGE_0:
delete (my_head)->message_0;
break;
default:
TTCN_error("Internal error: Invalid message selector in the queue of port %s.", port_name);
}
msg_queue_item_base *next_item = msg_queue_head->next_item;
delete (msg_queue_item*)msg_queue_head;
msg_queue_head = next_item;
if (next_item == NULL) msg_queue_tail = NULL;
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::extract__msg, port_name, 0, ++msg_head_count, CHARSTRING(0,NULL), CHARSTRING(0,NULL));}

void CamPort_BASE::clear_queue()
{
while (msg_queue_head != NULL) remove_msg_queue_head();
}

CamPort_BASE::CamPort_BASE(const char *par_port_name)
 : PORT(par_port_name)
{
msg_queue_head = NULL;
msg_queue_tail = NULL;
}

CamPort_BASE::~CamPort_BASE()
{
clear_queue();
}

void CamPort_BASE::send(const CamReq& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @LibItsCam_TestSystem.CamReq : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) outgoing_send(send_par);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@LibItsCam_TestSystem.CamReq");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void CamPort_BASE::send(const CamReq& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void CamPort_BASE::send(const CamReq_template& send_par, const COMPONENT& destination_component)
{
const CamReq& send_par_value = CamReq(send_par.valueof());
send(send_par_value, destination_component);
}

void CamPort_BASE::send(const CamReq_template& send_par)
{
const CamReq& send_par_value = CamReq(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

alt_status CamPort_BASE::receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TestSystem.CamInd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status CamPort_BASE::check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TestSystem.CamInd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
return ALT_YES;
}
}

alt_status CamPort_BASE::trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TestSystem.CamInd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status CamPort_BASE::receive(const CamInd_template& value_template, CamInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCam_TestSystem.CamInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TestSystem.CamInd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status CamPort_BASE::check_receive(const CamInd_template& value_template, CamInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCam_TestSystem.CamInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TestSystem.CamInd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status CamPort_BASE::trigger(const CamInd_template& value_template, CamInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsCam_TestSystem.CamInd.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCam_TestSystem.CamInd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

void CamPort_BASE::incoming_message(const CamInd& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsCam_TestSystem.CamInd : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_0;
new_item->message_0 = new CamInd(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

boolean CamPort_BASE::process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING&)
{
if (!strcmp(message_type, "@LibItsCam_TestSystem.CamInd")) {
CamInd incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else return FALSE;
}

CamInd::CamInd()
{
  bound_flag = FALSE;
}

CamInd::CamInd(const CAM__PDU__Descriptions::CAM& par_msgIn,
    const INTEGER& par_gnNextHeader,
    const INTEGER& par_gnHeaderType,
    const INTEGER& par_gnHeaderSubtype,
    const INTEGER& par_gnLifetime,
    const INTEGER& par_gnTrafficClass,
    const INTEGER& par_btpDestinationPort,
    const INTEGER& par_btpInfo)
  :   field_msgIn(par_msgIn),
  field_gnNextHeader(par_gnNextHeader),
  field_gnHeaderType(par_gnHeaderType),
  field_gnHeaderSubtype(par_gnHeaderSubtype),
  field_gnLifetime(par_gnLifetime),
  field_gnTrafficClass(par_gnTrafficClass),
  field_btpDestinationPort(par_btpDestinationPort),
  field_btpInfo(par_btpInfo)
{
  bound_flag = TRUE;
}

CamInd::CamInd(const CamInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsCam_TestSystem.CamInd.");
bound_flag = TRUE;
if (other_value.msgIn().is_bound()) field_msgIn = other_value.msgIn();
else field_msgIn.clean_up();
if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
else field_gnNextHeader.clean_up();
if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
else field_gnHeaderType.clean_up();
if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
else field_gnHeaderSubtype.clean_up();
if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
else field_gnLifetime.clean_up();
if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
else field_gnTrafficClass.clean_up();
if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
else field_btpDestinationPort.clean_up();
if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
else field_btpInfo.clean_up();
}

void CamInd::clean_up()
{
field_msgIn.clean_up();
field_gnNextHeader.clean_up();
field_gnHeaderType.clean_up();
field_gnHeaderSubtype.clean_up();
field_gnLifetime.clean_up();
field_gnTrafficClass.clean_up();
field_btpDestinationPort.clean_up();
field_btpInfo.clean_up();
bound_flag = FALSE;
}

CamInd& CamInd::operator=(const CamInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsCam_TestSystem.CamInd.");
  bound_flag = TRUE;
  if (other_value.msgIn().is_bound()) field_msgIn = other_value.msgIn();
  else field_msgIn.clean_up();
  if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
  else field_gnNextHeader.clean_up();
  if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
  else field_gnHeaderType.clean_up();
  if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
  else field_gnHeaderSubtype.clean_up();
  if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
  else field_gnLifetime.clean_up();
  if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
  else field_gnTrafficClass.clean_up();
  if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
  else field_btpDestinationPort.clean_up();
  if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
  else field_btpInfo.clean_up();
}
return *this;
}

boolean CamInd::operator==(const CamInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgIn==other_value.field_msgIn
  && field_gnNextHeader==other_value.field_gnNextHeader
  && field_gnHeaderType==other_value.field_gnHeaderType
  && field_gnHeaderSubtype==other_value.field_gnHeaderSubtype
  && field_gnLifetime==other_value.field_gnLifetime
  && field_gnTrafficClass==other_value.field_gnTrafficClass
  && field_btpDestinationPort==other_value.field_btpDestinationPort
  && field_btpInfo==other_value.field_btpInfo;
}

boolean CamInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgIn.is_bound()) return TRUE;
if(field_gnNextHeader.is_bound()) return TRUE;
if(field_gnHeaderType.is_bound()) return TRUE;
if(field_gnHeaderSubtype.is_bound()) return TRUE;
if(field_gnLifetime.is_bound()) return TRUE;
if(field_gnTrafficClass.is_bound()) return TRUE;
if(field_btpDestinationPort.is_bound()) return TRUE;
if(field_btpInfo.is_bound()) return TRUE;
return FALSE;
}
boolean CamInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgIn.is_value()) return FALSE;
if(!field_gnNextHeader.is_value()) return FALSE;
if(!field_gnHeaderType.is_value()) return FALSE;
if(!field_gnHeaderSubtype.is_value()) return FALSE;
if(!field_gnLifetime.is_value()) return FALSE;
if(!field_gnTrafficClass.is_value()) return FALSE;
if(!field_btpDestinationPort.is_value()) return FALSE;
if(!field_btpInfo.is_value()) return FALSE;
return TRUE;
}
int CamInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsCam_TestSystem.CamInd");
  return 8;
}

void CamInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgIn := ");
field_msgIn.log();
TTCN_Logger::log_event_str(", gnNextHeader := ");
field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
}

void CamInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsCam_TestSystem.CamInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      msgIn().set_param(param);
      return;
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsCam_TestSystem.CamInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record value of type @LibItsCam_TestSystem.CamInd has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgIn().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsCam_TestSystem.CamInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsCam_TestSystem.CamInd");
  }
}

Module_Param* CamInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsCam_TestSystem.CamInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      return msgIn().get_param(param_name);
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsCam_TestSystem.CamInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgIn = field_msgIn.get_param(param_name);
  mp_field_msgIn->set_id(new Module_Param_FieldName(mcopystr("msgIn")));
  mp->add_elem(mp_field_msgIn);
  Module_Param* mp_field_gnNextHeader = field_gnNextHeader.get_param(param_name);
  mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
  mp->add_elem(mp_field_gnNextHeader);
  Module_Param* mp_field_gnHeaderType = field_gnHeaderType.get_param(param_name);
  mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
  mp->add_elem(mp_field_gnHeaderType);
  Module_Param* mp_field_gnHeaderSubtype = field_gnHeaderSubtype.get_param(param_name);
  mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
  mp->add_elem(mp_field_gnHeaderSubtype);
  Module_Param* mp_field_gnLifetime = field_gnLifetime.get_param(param_name);
  mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
  mp->add_elem(mp_field_gnLifetime);
  Module_Param* mp_field_gnTrafficClass = field_gnTrafficClass.get_param(param_name);
  mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
  mp->add_elem(mp_field_gnTrafficClass);
  Module_Param* mp_field_btpDestinationPort = field_btpDestinationPort.get_param(param_name);
  mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
  mp->add_elem(mp_field_btpDestinationPort);
  Module_Param* mp_field_btpInfo = field_btpInfo.get_param(param_name);
  mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
  mp->add_elem(mp_field_btpInfo);
  return mp;
  }

void CamInd::set_implicit_omit()
{
if (msgIn().is_bound()) msgIn().set_implicit_omit();
if (gnNextHeader().is_bound()) gnNextHeader().set_implicit_omit();
if (gnHeaderType().is_bound()) gnHeaderType().set_implicit_omit();
if (gnHeaderSubtype().is_bound()) gnHeaderSubtype().set_implicit_omit();
if (gnLifetime().is_bound()) gnLifetime().set_implicit_omit();
if (gnTrafficClass().is_bound()) gnTrafficClass().set_implicit_omit();
if (btpDestinationPort().is_bound()) btpDestinationPort().set_implicit_omit();
if (btpInfo().is_bound()) btpInfo().set_implicit_omit();
}

void CamInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsCam_TestSystem.CamInd.");
field_msgIn.encode_text(text_buf);
field_gnNextHeader.encode_text(text_buf);
field_gnHeaderType.encode_text(text_buf);
field_gnHeaderSubtype.encode_text(text_buf);
field_gnLifetime.encode_text(text_buf);
field_gnTrafficClass.encode_text(text_buf);
field_btpDestinationPort.encode_text(text_buf);
field_btpInfo.encode_text(text_buf);
}

void CamInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgIn.decode_text(text_buf);
field_gnNextHeader.decode_text(text_buf);
field_gnHeaderType.decode_text(text_buf);
field_gnHeaderSubtype.decode_text(text_buf);
field_gnLifetime.decode_text(text_buf);
field_gnTrafficClass.decode_text(text_buf);
field_btpDestinationPort.decode_text(text_buf);
field_btpInfo.decode_text(text_buf);
}

void CamInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CamInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int CamInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_msgIn.RAW_decode(CAM__PDU__Descriptions::CAM_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnNextHeader.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnHeaderType.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnHeaderSubtype.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnLifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnTrafficClass.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_btpDestinationPort.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_btpInfo.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int CamInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 8;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(8);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CAM__PDU__Descriptions::CAM_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_msgIn.RAW_encode(CAM__PDU__Descriptions::CAM_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_gnNextHeader.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_gnHeaderType.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_gnHeaderSubtype.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_gnLifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_gnTrafficClass.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_btpDestinationPort.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_btpInfo.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[7]);
  return myleaf.length = encoded_length;
}

int CamInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsCam_TestSystem.CamInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "msgIn");
    enc_len += field_msgIn.JSON_encode(CAM__PDU__Descriptions::CAM_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnNextHeader");
    enc_len += field_gnNextHeader.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnHeaderType");
    enc_len += field_gnHeaderType.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnHeaderSubtype");
    enc_len += field_gnHeaderSubtype.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnLifetime");
    enc_len += field_gnLifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnTrafficClass");
    enc_len += field_gnTrafficClass.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpDestinationPort");
    enc_len += field_btpDestinationPort.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpInfo");
    enc_len += field_btpInfo.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CamInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "msgIn", name_len)) {
         int ret_val = field_msgIn.JSON_decode(CAM__PDU__Descriptions::CAM_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "msgIn");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "gnNextHeader", name_len)) {
         int ret_val = field_gnNextHeader.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnNextHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "gnHeaderType", name_len)) {
         int ret_val = field_gnHeaderType.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnHeaderType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "gnHeaderSubtype", name_len)) {
         int ret_val = field_gnHeaderSubtype.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnHeaderSubtype");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "gnLifetime", name_len)) {
         int ret_val = field_gnLifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnLifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "gnTrafficClass", name_len)) {
         int ret_val = field_gnTrafficClass.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnTrafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "btpDestinationPort", name_len)) {
         int ret_val = field_btpDestinationPort.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpDestinationPort");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "btpInfo", name_len)) {
         int ret_val = field_btpInfo.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpInfo");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_msgIn.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "msgIn");
    return JSON_ERROR_FATAL;
  }
if (!field_gnNextHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnNextHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_gnHeaderType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnHeaderType");
    return JSON_ERROR_FATAL;
  }
if (!field_gnHeaderSubtype.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnHeaderSubtype");
    return JSON_ERROR_FATAL;
  }
if (!field_gnLifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnLifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_gnTrafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnTrafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_btpDestinationPort.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpDestinationPort");
    return JSON_ERROR_FATAL;
  }
if (!field_btpInfo.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpInfo");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct CamInd_template::single_value_struct {
CAM__PDU__Descriptions::CAM_template field_msgIn;
INTEGER_template field_gnNextHeader;
INTEGER_template field_gnHeaderType;
INTEGER_template field_gnHeaderSubtype;
INTEGER_template field_gnLifetime;
INTEGER_template field_gnTrafficClass;
INTEGER_template field_btpDestinationPort;
INTEGER_template field_btpInfo;
};

void CamInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgIn = ANY_VALUE;
single_value->field_gnNextHeader = ANY_VALUE;
single_value->field_gnHeaderType = ANY_VALUE;
single_value->field_gnHeaderSubtype = ANY_VALUE;
single_value->field_gnLifetime = ANY_VALUE;
single_value->field_gnTrafficClass = ANY_VALUE;
single_value->field_btpDestinationPort = ANY_VALUE;
single_value->field_btpInfo = ANY_VALUE;
}
}
}

void CamInd_template::copy_value(const CamInd& other_value)
{
single_value = new single_value_struct;
if (other_value.msgIn().is_bound()) {
  single_value->field_msgIn = other_value.msgIn();
} else {
  single_value->field_msgIn.clean_up();
}
if (other_value.gnNextHeader().is_bound()) {
  single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
  single_value->field_gnNextHeader.clean_up();
}
if (other_value.gnHeaderType().is_bound()) {
  single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
  single_value->field_gnHeaderType.clean_up();
}
if (other_value.gnHeaderSubtype().is_bound()) {
  single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
  single_value->field_gnHeaderSubtype.clean_up();
}
if (other_value.gnLifetime().is_bound()) {
  single_value->field_gnLifetime = other_value.gnLifetime();
} else {
  single_value->field_gnLifetime.clean_up();
}
if (other_value.gnTrafficClass().is_bound()) {
  single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
  single_value->field_gnTrafficClass.clean_up();
}
if (other_value.btpDestinationPort().is_bound()) {
  single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
  single_value->field_btpDestinationPort.clean_up();
}
if (other_value.btpInfo().is_bound()) {
  single_value->field_btpInfo = other_value.btpInfo();
} else {
  single_value->field_btpInfo.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CamInd_template::copy_template(const CamInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgIn().get_selection()) {
single_value->field_msgIn = other_value.msgIn();
} else {
single_value->field_msgIn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnNextHeader().get_selection()) {
single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
single_value->field_gnNextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderType().get_selection()) {
single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
single_value->field_gnHeaderType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderSubtype().get_selection()) {
single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
single_value->field_gnHeaderSubtype.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnLifetime().get_selection()) {
single_value->field_gnLifetime = other_value.gnLifetime();
} else {
single_value->field_gnLifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnTrafficClass().get_selection()) {
single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
single_value->field_gnTrafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpDestinationPort().get_selection()) {
single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
single_value->field_btpDestinationPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpInfo().get_selection()) {
single_value->field_btpInfo = other_value.btpInfo();
} else {
single_value->field_btpInfo.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CamInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsCam_TestSystem.CamInd.");
break;
}
set_selection(other_value);
}

CamInd_template::CamInd_template()
{
}

CamInd_template::CamInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CamInd_template::CamInd_template(const CamInd& other_value)
{
copy_value(other_value);
}

CamInd_template::CamInd_template(const OPTIONAL<CamInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CamInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsCam_TestSystem.CamInd from an unbound optional field.");
}
}

CamInd_template::CamInd_template(const CamInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CamInd_template::~CamInd_template()
{
clean_up();
}

CamInd_template& CamInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CamInd_template& CamInd_template::operator=(const CamInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CamInd_template& CamInd_template::operator=(const OPTIONAL<CamInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CamInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsCam_TestSystem.CamInd.");
}
return *this;
}

CamInd_template& CamInd_template::operator=(const CamInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CamInd_template::match(const CamInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgIn().is_bound()) return FALSE;
if(!single_value->field_msgIn.match(other_value.msgIn(), legacy))return FALSE;
if(!other_value.gnNextHeader().is_bound()) return FALSE;
if(!single_value->field_gnNextHeader.match(other_value.gnNextHeader(), legacy))return FALSE;
if(!other_value.gnHeaderType().is_bound()) return FALSE;
if(!single_value->field_gnHeaderType.match(other_value.gnHeaderType(), legacy))return FALSE;
if(!other_value.gnHeaderSubtype().is_bound()) return FALSE;
if(!single_value->field_gnHeaderSubtype.match(other_value.gnHeaderSubtype(), legacy))return FALSE;
if(!other_value.gnLifetime().is_bound()) return FALSE;
if(!single_value->field_gnLifetime.match(other_value.gnLifetime(), legacy))return FALSE;
if(!other_value.gnTrafficClass().is_bound()) return FALSE;
if(!single_value->field_gnTrafficClass.match(other_value.gnTrafficClass(), legacy))return FALSE;
if(!other_value.btpDestinationPort().is_bound()) return FALSE;
if(!single_value->field_btpDestinationPort.match(other_value.btpDestinationPort(), legacy))return FALSE;
if(!other_value.btpInfo().is_bound()) return FALSE;
if(!single_value->field_btpInfo.match(other_value.btpInfo(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsCam_TestSystem.CamInd.");
}
return FALSE;
}

boolean CamInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgIn.is_bound()) return TRUE;
if (single_value->field_gnNextHeader.is_bound()) return TRUE;
if (single_value->field_gnHeaderType.is_bound()) return TRUE;
if (single_value->field_gnHeaderSubtype.is_bound()) return TRUE;
if (single_value->field_gnLifetime.is_bound()) return TRUE;
if (single_value->field_gnTrafficClass.is_bound()) return TRUE;
if (single_value->field_btpDestinationPort.is_bound()) return TRUE;
if (single_value->field_btpInfo.is_bound()) return TRUE;
return FALSE;
}

boolean CamInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgIn.is_value()) return FALSE;
if (!single_value->field_gnNextHeader.is_value()) return FALSE;
if (!single_value->field_gnHeaderType.is_value()) return FALSE;
if (!single_value->field_gnHeaderSubtype.is_value()) return FALSE;
if (!single_value->field_gnLifetime.is_value()) return FALSE;
if (!single_value->field_gnTrafficClass.is_value()) return FALSE;
if (!single_value->field_btpDestinationPort.is_value()) return FALSE;
if (!single_value->field_btpInfo.is_value()) return FALSE;
return TRUE;
}

void CamInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CamInd CamInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsCam_TestSystem.CamInd.");
CamInd ret_val;
if (single_value->field_msgIn.is_bound()) {
ret_val.msgIn() = single_value->field_msgIn.valueof();
}
if (single_value->field_gnNextHeader.is_bound()) {
ret_val.gnNextHeader() = single_value->field_gnNextHeader.valueof();
}
if (single_value->field_gnHeaderType.is_bound()) {
ret_val.gnHeaderType() = single_value->field_gnHeaderType.valueof();
}
if (single_value->field_gnHeaderSubtype.is_bound()) {
ret_val.gnHeaderSubtype() = single_value->field_gnHeaderSubtype.valueof();
}
if (single_value->field_gnLifetime.is_bound()) {
ret_val.gnLifetime() = single_value->field_gnLifetime.valueof();
}
if (single_value->field_gnTrafficClass.is_bound()) {
ret_val.gnTrafficClass() = single_value->field_gnTrafficClass.valueof();
}
if (single_value->field_btpDestinationPort.is_bound()) {
ret_val.btpDestinationPort() = single_value->field_btpDestinationPort.valueof();
}
if (single_value->field_btpInfo.is_bound()) {
ret_val.btpInfo() = single_value->field_btpInfo.valueof();
}
return ret_val;
}

void CamInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsCam_TestSystem.CamInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CamInd_template[list_length];
}

CamInd_template& CamInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsCam_TestSystem.CamInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsCam_TestSystem.CamInd.");
return value_list.list_value[list_index];
}

CAM__PDU__Descriptions::CAM_template& CamInd_template::msgIn()
{
set_specific();
return single_value->field_msgIn;
}

const CAM__PDU__Descriptions::CAM_template& CamInd_template::msgIn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgIn of a non-specific template of type @LibItsCam_TestSystem.CamInd.");
return single_value->field_msgIn;
}

INTEGER_template& CamInd_template::gnNextHeader()
{
set_specific();
return single_value->field_gnNextHeader;
}

const INTEGER_template& CamInd_template::gnNextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnNextHeader of a non-specific template of type @LibItsCam_TestSystem.CamInd.");
return single_value->field_gnNextHeader;
}

INTEGER_template& CamInd_template::gnHeaderType()
{
set_specific();
return single_value->field_gnHeaderType;
}

const INTEGER_template& CamInd_template::gnHeaderType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderType of a non-specific template of type @LibItsCam_TestSystem.CamInd.");
return single_value->field_gnHeaderType;
}

INTEGER_template& CamInd_template::gnHeaderSubtype()
{
set_specific();
return single_value->field_gnHeaderSubtype;
}

const INTEGER_template& CamInd_template::gnHeaderSubtype() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderSubtype of a non-specific template of type @LibItsCam_TestSystem.CamInd.");
return single_value->field_gnHeaderSubtype;
}

INTEGER_template& CamInd_template::gnLifetime()
{
set_specific();
return single_value->field_gnLifetime;
}

const INTEGER_template& CamInd_template::gnLifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnLifetime of a non-specific template of type @LibItsCam_TestSystem.CamInd.");
return single_value->field_gnLifetime;
}

INTEGER_template& CamInd_template::gnTrafficClass()
{
set_specific();
return single_value->field_gnTrafficClass;
}

const INTEGER_template& CamInd_template::gnTrafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnTrafficClass of a non-specific template of type @LibItsCam_TestSystem.CamInd.");
return single_value->field_gnTrafficClass;
}

INTEGER_template& CamInd_template::btpDestinationPort()
{
set_specific();
return single_value->field_btpDestinationPort;
}

const INTEGER_template& CamInd_template::btpDestinationPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpDestinationPort of a non-specific template of type @LibItsCam_TestSystem.CamInd.");
return single_value->field_btpDestinationPort;
}

INTEGER_template& CamInd_template::btpInfo()
{
set_specific();
return single_value->field_btpInfo;
}

const INTEGER_template& CamInd_template::btpInfo() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpInfo of a non-specific template of type @LibItsCam_TestSystem.CamInd.");
return single_value->field_btpInfo;
}

int CamInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 8;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsCam_TestSystem.CamInd.");
  }
  return 0;
}

void CamInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgIn := ");
single_value->field_msgIn.log();
TTCN_Logger::log_event_str(", gnNextHeader := ");
single_value->field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CamInd_template::log_match(const CamInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgIn.match(match_value.msgIn(), legacy)){
TTCN_Logger::log_logmatch_info(".msgIn");
single_value->field_msgIn.log_match(match_value.msgIn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnNextHeader.match(match_value.gnNextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".gnNextHeader");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnHeaderType.match(match_value.gnHeaderType(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderType");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnHeaderSubtype.match(match_value.gnHeaderSubtype(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderSubtype");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnLifetime.match(match_value.gnLifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".gnLifetime");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnTrafficClass.match(match_value.gnTrafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".gnTrafficClass");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_btpDestinationPort.match(match_value.btpDestinationPort(), legacy)){
TTCN_Logger::log_logmatch_info(".btpDestinationPort");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_btpInfo.match(match_value.btpInfo(), legacy)){
TTCN_Logger::log_logmatch_info(".btpInfo");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgIn := ");
single_value->field_msgIn.log_match(match_value.msgIn(), legacy);
TTCN_Logger::log_event_str(", gnNextHeader := ");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CamInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgIn.encode_text(text_buf);
single_value->field_gnNextHeader.encode_text(text_buf);
single_value->field_gnHeaderType.encode_text(text_buf);
single_value->field_gnHeaderSubtype.encode_text(text_buf);
single_value->field_gnLifetime.encode_text(text_buf);
single_value->field_gnTrafficClass.encode_text(text_buf);
single_value->field_btpDestinationPort.encode_text(text_buf);
single_value->field_btpInfo.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsCam_TestSystem.CamInd.");
}
}

void CamInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgIn.decode_text(text_buf);
single_value->field_gnNextHeader.decode_text(text_buf);
single_value->field_gnHeaderType.decode_text(text_buf);
single_value->field_gnHeaderSubtype.decode_text(text_buf);
single_value->field_gnLifetime.decode_text(text_buf);
single_value->field_gnTrafficClass.decode_text(text_buf);
single_value->field_btpDestinationPort.decode_text(text_buf);
single_value->field_btpInfo.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CamInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsCam_TestSystem.CamInd.");
}
}

void CamInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsCam_TestSystem.CamInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      msgIn().set_param(param);
      return;
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsCam_TestSystem.CamInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CamInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record template of type @LibItsCam_TestSystem.CamInd has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgIn().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsCam_TestSystem.CamInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsCam_TestSystem.CamInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CamInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsCam_TestSystem.CamInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      return msgIn().get_param(param_name);
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsCam_TestSystem.CamInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgIn = single_value->field_msgIn.get_param(param_name);
    mp_field_msgIn->set_id(new Module_Param_FieldName(mcopystr("msgIn")));
    mp->add_elem(mp_field_msgIn);
    Module_Param* mp_field_gnNextHeader = single_value->field_gnNextHeader.get_param(param_name);
    mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
    mp->add_elem(mp_field_gnNextHeader);
    Module_Param* mp_field_gnHeaderType = single_value->field_gnHeaderType.get_param(param_name);
    mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
    mp->add_elem(mp_field_gnHeaderType);
    Module_Param* mp_field_gnHeaderSubtype = single_value->field_gnHeaderSubtype.get_param(param_name);
    mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
    mp->add_elem(mp_field_gnHeaderSubtype);
    Module_Param* mp_field_gnLifetime = single_value->field_gnLifetime.get_param(param_name);
    mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
    mp->add_elem(mp_field_gnLifetime);
    Module_Param* mp_field_gnTrafficClass = single_value->field_gnTrafficClass.get_param(param_name);
    mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
    mp->add_elem(mp_field_gnTrafficClass);
    Module_Param* mp_field_btpDestinationPort = single_value->field_btpDestinationPort.get_param(param_name);
    mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
    mp->add_elem(mp_field_btpDestinationPort);
    Module_Param* mp_field_btpInfo = single_value->field_btpInfo.get_param(param_name);
    mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
    mp->add_elem(mp_field_btpInfo);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CamInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgIn.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TestSystem.CamInd");
single_value->field_gnNextHeader.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TestSystem.CamInd");
single_value->field_gnHeaderType.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TestSystem.CamInd");
single_value->field_gnHeaderSubtype.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TestSystem.CamInd");
single_value->field_gnLifetime.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TestSystem.CamInd");
single_value->field_gnTrafficClass.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TestSystem.CamInd");
single_value->field_btpDestinationPort.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TestSystem.CamInd");
single_value->field_btpInfo.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TestSystem.CamInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsCam_TestSystem.CamInd");
}

boolean CamInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CamInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

CamReq::CamReq()
{
  bound_flag = FALSE;
}

CamReq::CamReq(const CAM__PDU__Descriptions::CAM& par_msgOut)
  :   field_msgOut(par_msgOut)
{
  bound_flag = TRUE;
}

CamReq::CamReq(const CamReq& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsCam_TestSystem.CamReq.");
bound_flag = TRUE;
if (other_value.msgOut().is_bound()) field_msgOut = other_value.msgOut();
else field_msgOut.clean_up();
}

void CamReq::clean_up()
{
field_msgOut.clean_up();
bound_flag = FALSE;
}

CamReq& CamReq::operator=(const CamReq& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsCam_TestSystem.CamReq.");
  bound_flag = TRUE;
  if (other_value.msgOut().is_bound()) field_msgOut = other_value.msgOut();
  else field_msgOut.clean_up();
}
return *this;
}

boolean CamReq::operator==(const CamReq& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgOut==other_value.field_msgOut;
}

boolean CamReq::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgOut.is_bound()) return TRUE;
return FALSE;
}
boolean CamReq::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgOut.is_value()) return FALSE;
return TRUE;
}
int CamReq::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsCam_TestSystem.CamReq");
  return 1;
}

void CamReq::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgOut := ");
field_msgOut.log();
TTCN_Logger::log_event_str(" }");
}

void CamReq::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsCam_TestSystem.CamReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      msgOut().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsCam_TestSystem.CamReq'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsCam_TestSystem.CamReq has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgOut().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgOut")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgOut().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsCam_TestSystem.CamReq: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsCam_TestSystem.CamReq");
  }
}

Module_Param* CamReq::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsCam_TestSystem.CamReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      return msgOut().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsCam_TestSystem.CamReq'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgOut = field_msgOut.get_param(param_name);
  mp_field_msgOut->set_id(new Module_Param_FieldName(mcopystr("msgOut")));
  mp->add_elem(mp_field_msgOut);
  return mp;
  }

void CamReq::set_implicit_omit()
{
if (msgOut().is_bound()) msgOut().set_implicit_omit();
}

void CamReq::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsCam_TestSystem.CamReq.");
field_msgOut.encode_text(text_buf);
}

void CamReq::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgOut.decode_text(text_buf);
}

void CamReq::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CamReq::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int CamReq::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_msgOut.RAW_decode(CAM__PDU__Descriptions::CAM_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int CamReq::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CAM__PDU__Descriptions::CAM_descr_.raw);
  encoded_length += field_msgOut.RAW_encode(CAM__PDU__Descriptions::CAM_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int CamReq::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsCam_TestSystem.CamReq.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "msgOut");
    enc_len += field_msgOut.JSON_encode(CAM__PDU__Descriptions::CAM_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CamReq::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "msgOut", name_len)) {
         int ret_val = field_msgOut.JSON_decode(CAM__PDU__Descriptions::CAM_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "msgOut");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_msgOut.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "msgOut");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct CamReq_template::single_value_struct {
CAM__PDU__Descriptions::CAM_template field_msgOut;
};

void CamReq_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgOut = ANY_VALUE;
}
}
}

void CamReq_template::copy_value(const CamReq& other_value)
{
single_value = new single_value_struct;
if (other_value.msgOut().is_bound()) {
  single_value->field_msgOut = other_value.msgOut();
} else {
  single_value->field_msgOut.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CamReq_template::copy_template(const CamReq_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgOut().get_selection()) {
single_value->field_msgOut = other_value.msgOut();
} else {
single_value->field_msgOut.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CamReq_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsCam_TestSystem.CamReq.");
break;
}
set_selection(other_value);
}

CamReq_template::CamReq_template()
{
}

CamReq_template::CamReq_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CamReq_template::CamReq_template(const CamReq& other_value)
{
copy_value(other_value);
}

CamReq_template::CamReq_template(const OPTIONAL<CamReq>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CamReq&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsCam_TestSystem.CamReq from an unbound optional field.");
}
}

CamReq_template::CamReq_template(const CamReq_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CamReq_template::~CamReq_template()
{
clean_up();
}

CamReq_template& CamReq_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CamReq_template& CamReq_template::operator=(const CamReq& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CamReq_template& CamReq_template::operator=(const OPTIONAL<CamReq>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CamReq&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsCam_TestSystem.CamReq.");
}
return *this;
}

CamReq_template& CamReq_template::operator=(const CamReq_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CamReq_template::match(const CamReq& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgOut().is_bound()) return FALSE;
if(!single_value->field_msgOut.match(other_value.msgOut(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsCam_TestSystem.CamReq.");
}
return FALSE;
}

boolean CamReq_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgOut.is_bound()) return TRUE;
return FALSE;
}

boolean CamReq_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgOut.is_value()) return FALSE;
return TRUE;
}

void CamReq_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CamReq CamReq_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsCam_TestSystem.CamReq.");
CamReq ret_val;
if (single_value->field_msgOut.is_bound()) {
ret_val.msgOut() = single_value->field_msgOut.valueof();
}
return ret_val;
}

void CamReq_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsCam_TestSystem.CamReq.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CamReq_template[list_length];
}

CamReq_template& CamReq_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsCam_TestSystem.CamReq.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsCam_TestSystem.CamReq.");
return value_list.list_value[list_index];
}

CAM__PDU__Descriptions::CAM_template& CamReq_template::msgOut()
{
set_specific();
return single_value->field_msgOut;
}

const CAM__PDU__Descriptions::CAM_template& CamReq_template::msgOut() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgOut of a non-specific template of type @LibItsCam_TestSystem.CamReq.");
return single_value->field_msgOut;
}

int CamReq_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamReq which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamReq containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamReq containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamReq containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamReq containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TestSystem.CamReq containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsCam_TestSystem.CamReq.");
  }
  return 0;
}

void CamReq_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgOut := ");
single_value->field_msgOut.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CamReq_template::log_match(const CamReq& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgOut.match(match_value.msgOut(), legacy)){
TTCN_Logger::log_logmatch_info(".msgOut");
single_value->field_msgOut.log_match(match_value.msgOut(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgOut := ");
single_value->field_msgOut.log_match(match_value.msgOut(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CamReq_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgOut.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsCam_TestSystem.CamReq.");
}
}

void CamReq_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgOut.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CamReq_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsCam_TestSystem.CamReq.");
}
}

void CamReq_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsCam_TestSystem.CamReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      msgOut().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsCam_TestSystem.CamReq'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CamReq_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsCam_TestSystem.CamReq has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgOut().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgOut")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgOut().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsCam_TestSystem.CamReq: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsCam_TestSystem.CamReq");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CamReq_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsCam_TestSystem.CamReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      return msgOut().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsCam_TestSystem.CamReq'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgOut = single_value->field_msgOut.get_param(param_name);
    mp_field_msgOut->set_id(new Module_Param_FieldName(mcopystr("msgOut")));
    mp->add_elem(mp_field_msgOut);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CamReq_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgOut.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TestSystem.CamReq");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsCam_TestSystem.CamReq");
}

boolean CamReq_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CamReq_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("LibItsCam_TestSystem.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsCam_TestSystem");
LibItsCommon__TestSystem::module_object.pre_init_module();
LibItsCommon__TypesAndValues::module_object.pre_init_module();
LibItsCam__TypesAndValues::module_object.pre_init_module();
General__Types::module_object.pre_init_module();
TTCN__EncDec::module_object.pre_init_module();
}

static void post_init_module()
{
TTCN_Location current_location("LibItsCam_TestSystem.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsCam_TestSystem");
LibItsCommon__TestSystem::module_object.post_init_module();
LibItsCommon__TypesAndValues::module_object.post_init_module();
LibItsCam__TypesAndValues::module_object.post_init_module();
General__Types::module_object.post_init_module();
TTCN__EncDec::module_object.post_init_module();
}

static boolean init_comp_type(const char *component_type, boolean init_base_comps)
{
(void)init_base_comps;
if (!strcmp(component_type, "ItsCamSystem")) {
ItsCamSystem_component_utPort.activate_port();
ItsCamSystem_component_camPort.activate_port();
return TRUE;
} else if (!strcmp(component_type, "ItsCam")) {
if (init_base_comps) {
Module_List::initialize_component("LibCommon_Sync", "BaseSyncComp", FALSE);
Module_List::initialize_component("LibCommon_Sync", "ClientSyncComp", FALSE);
Module_List::initialize_component("LibCommon_Sync", "SelfSyncComp", FALSE);
Module_List::initialize_component("LibItsCommon_TestSystem", "ItsBaseComponent", FALSE);
}
ItsCam_component_utPort.activate_port();
ItsCam_component_camPort.activate_port();
ItsCam_component_vc__camMsg.clean_up();
ItsCam_component_vc__default = NULL_COMPREF;
ItsCam_component_vc__camReceived = FALSE;
ItsCam_component_vc__utEvents = NULL_VALUE;
return TRUE;
} else return FALSE;
}


} /* end of namespace */
