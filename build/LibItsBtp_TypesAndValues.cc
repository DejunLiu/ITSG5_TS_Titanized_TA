// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "LibItsBtp_TypesAndValues.hh"

namespace LibItsBtp__TypesAndValues {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x6c, 0x4a, 0x56, 0xbd, 0x4f, 0x6c, 0x49, 0xc7, 0x4b, 0x91, 0x58, 0x42, 0x4c, 0xcd, 0xa7, 0xa2 };

/* Global variable definitions */

const TTCN_RAWdescriptor_t BtpHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BtpHeader
const TTCN_JSONdescriptor_t BtpHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BtpHeader_descr_ = { "@LibItsBtp_TypesAndValues.BtpHeader", NULL, &BtpHeader_raw_, NULL, NULL, &BtpHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpPortId_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       BtpPortId_xer_ = { {"BtpPortId>\n", "BtpPortId>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BtpPortId_descr_ = { "@LibItsBtp_TypesAndValues.BtpPortId", &INTEGER_ber_, &BtpPortId_raw_, &INTEGER_text_, &BtpPortId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpAHeader_destinationPort_xer_ = { {"destinationPort>\n", "destinationPort>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BtpAHeader_destinationPort_descr_ = { "@LibItsBtp_TypesAndValues.BtpAHeader.destinationPort", &INTEGER_ber_, &BtpPortId_raw_, &INTEGER_text_, &BtpAHeader_destinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpAHeader_sourcePort_xer_ = { {"sourcePort>\n", "sourcePort>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BtpAHeader_sourcePort_descr_ = { "@LibItsBtp_TypesAndValues.BtpAHeader.sourcePort", &INTEGER_ber_, &BtpPortId_raw_, &INTEGER_text_, &BtpAHeader_sourcePort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpAHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BtpAHeader
const TTCN_JSONdescriptor_t BtpAHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BtpAHeader_descr_ = { "@LibItsBtp_TypesAndValues.BtpAHeader", NULL, &BtpAHeader_raw_, NULL, NULL, &BtpAHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpBHeader_destinationPort_xer_ = { {"destinationPort>\n", "destinationPort>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BtpBHeader_destinationPort_descr_ = { "@LibItsBtp_TypesAndValues.BtpBHeader.destinationPort", &INTEGER_ber_, &BtpPortId_raw_, &INTEGER_text_, &BtpBHeader_destinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpPortInfo_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       BtpPortInfo_xer_ = { {"BtpPortInfo>\n", "BtpPortInfo>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BtpPortInfo_descr_ = { "@LibItsBtp_TypesAndValues.BtpPortInfo", &INTEGER_ber_, &BtpPortInfo_raw_, &INTEGER_text_, &BtpPortInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpBHeader_destinationPortInfo_xer_ = { {"destinationPortInfo>\n", "destinationPortInfo>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BtpBHeader_destinationPortInfo_descr_ = { "@LibItsBtp_TypesAndValues.BtpBHeader.destinationPortInfo", &INTEGER_ber_, &BtpPortInfo_raw_, &INTEGER_text_, &BtpBHeader_destinationPortInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpBHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BtpBHeader
const TTCN_JSONdescriptor_t BtpBHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BtpBHeader_descr_ = { "@LibItsBtp_TypesAndValues.BtpBHeader", NULL, &BtpBHeader_raw_, NULL, NULL, &BtpBHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpPacket_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BtpPacket
const TTCN_JSONdescriptor_t BtpPacket_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BtpPacket_descr_ = { "@LibItsBtp_TypesAndValues.BtpPacket", NULL, &BtpPacket_raw_, NULL, NULL, &BtpPacket_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpRawPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       BtpRawPayload_xer_ = { {"BtpRawPayload>\n", "BtpRawPayload>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BtpRawPayload_descr_ = { "@LibItsBtp_TypesAndValues.BtpRawPayload", &OCTETSTRING_ber_, &BtpRawPayload_raw_, &OCTETSTRING_text_, &BtpRawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BtpPayload_rawPayload_xer_ = { {"rawPayload>\n", "rawPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BtpPayload_rawPayload_descr_ = { "@LibItsBtp_TypesAndValues.BtpPayload.rawPayload", &OCTETSTRING_ber_, &BtpRawPayload_raw_, &OCTETSTRING_text_, &BtpPayload_rawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BtpPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BtpPayload
const TTCN_JSONdescriptor_t BtpPayload_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BtpPayload_descr_ = { "@LibItsBtp_TypesAndValues.BtpPayload", NULL, &BtpPayload_raw_, NULL, NULL, &BtpPayload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t DecodedBtpPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for DecodedBtpPayload
const TTCN_JSONdescriptor_t DecodedBtpPayload_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DecodedBtpPayload_descr_ = { "@LibItsBtp_TypesAndValues.DecodedBtpPayload", NULL, &DecodedBtpPayload_raw_, NULL, NULL, &DecodedBtpPayload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtBtpTrigger_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtBtpTrigger
const TTCN_JSONdescriptor_t UtBtpTrigger_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t UtBtpTrigger_descr_ = { "@LibItsBtp_TypesAndValues.UtBtpTrigger", NULL, &UtBtpTrigger_raw_, NULL, NULL, &UtBtpTrigger_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GenerateBtpA_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GenerateBtpA
const TTCN_JSONdescriptor_t GenerateBtpA_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GenerateBtpA_descr_ = { "@LibItsBtp_TypesAndValues.GenerateBtpA", NULL, &GenerateBtpA_raw_, NULL, NULL, &GenerateBtpA_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GenerateBtpB_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GenerateBtpB
const TTCN_JSONdescriptor_t GenerateBtpB_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GenerateBtpB_descr_ = { "@LibItsBtp_TypesAndValues.GenerateBtpB", NULL, &GenerateBtpB_raw_, NULL, NULL, &GenerateBtpB_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtBtpTriggerResult_utBtpTriggerResult_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       UtBtpTriggerResult_utBtpTriggerResult_xer_ = { {"utBtpTriggerResult>\n", "utBtpTriggerResult>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t UtBtpTriggerResult_utBtpTriggerResult_descr_ = { "@LibItsBtp_TypesAndValues.UtBtpTriggerResult.utBtpTriggerResult", &BOOLEAN_ber_, &UtBtpTriggerResult_utBtpTriggerResult_raw_, &BOOLEAN_text_, &UtBtpTriggerResult_utBtpTriggerResult_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtBtpTriggerResult_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtBtpTriggerResult
const TTCN_JSONdescriptor_t UtBtpTriggerResult_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t UtBtpTriggerResult_descr_ = { "@LibItsBtp_TypesAndValues.UtBtpTriggerResult", NULL, &UtBtpTriggerResult_raw_, NULL, NULL, &UtBtpTriggerResult_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UtBtpEventInd_rawPayload_xer_ = { {"rawPayload>\n", "rawPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t UtBtpEventInd_rawPayload_descr_ = { "@LibItsBtp_TypesAndValues.UtBtpEventInd.rawPayload", &OCTETSTRING_ber_, &BtpRawPayload_raw_, &OCTETSTRING_text_, &UtBtpEventInd_rawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtBtpEventInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtBtpEventInd
const TTCN_JSONdescriptor_t UtBtpEventInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t UtBtpEventInd_descr_ = { "@LibItsBtp_TypesAndValues.UtBtpEventInd", NULL, &UtBtpEventInd_raw_, NULL, NULL, &UtBtpEventInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtBtpEventIndList_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtBtpEventIndList
const TTCN_Typedescriptor_t UtBtpEventIndList_descr_ = { "@LibItsBtp_TypesAndValues.UtBtpEventIndList", NULL, &UtBtpEventIndList_raw_, NULL, NULL, NULL, &UtBtpEventInd_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 0;
TTCN_Module module_object("LibItsBtp_TypesAndValues", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

void BtpHeader::copy_value(const BtpHeader& other_value)
{
switch (other_value.union_selection) {
case ALT_btpAHeader:
field_btpAHeader = new BtpAHeader(*other_value.field_btpAHeader);
break;
case ALT_btpBHeader:
field_btpBHeader = new BtpBHeader(*other_value.field_btpBHeader);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsBtp_TypesAndValues.BtpHeader.");
}
union_selection = other_value.union_selection;
}

BtpHeader::BtpHeader()
{
union_selection = UNBOUND_VALUE;
}

BtpHeader::BtpHeader(const BtpHeader& other_value)
: Base_Type(){
copy_value(other_value);
}

BtpHeader::~BtpHeader()
{
clean_up();
}

BtpHeader& BtpHeader::operator=(const BtpHeader& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean BtpHeader::operator==(const BtpHeader& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsBtp_TypesAndValues.BtpHeader.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsBtp_TypesAndValues.BtpHeader.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_btpAHeader:
return *field_btpAHeader == *other_value.field_btpAHeader;
case ALT_btpBHeader:
return *field_btpBHeader == *other_value.field_btpBHeader;
default:
return FALSE;
}
}

BtpAHeader& BtpHeader::btpAHeader()
{
if (union_selection != ALT_btpAHeader) {
clean_up();
field_btpAHeader = new BtpAHeader;
union_selection = ALT_btpAHeader;
}
return *field_btpAHeader;
}

const BtpAHeader& BtpHeader::btpAHeader() const
{
if (union_selection != ALT_btpAHeader) TTCN_error("Using non-selected field btpAHeader in a value of union type @LibItsBtp_TypesAndValues.BtpHeader.");
return *field_btpAHeader;
}

BtpBHeader& BtpHeader::btpBHeader()
{
if (union_selection != ALT_btpBHeader) {
clean_up();
field_btpBHeader = new BtpBHeader;
union_selection = ALT_btpBHeader;
}
return *field_btpBHeader;
}

const BtpBHeader& BtpHeader::btpBHeader() const
{
if (union_selection != ALT_btpBHeader) TTCN_error("Using non-selected field btpBHeader in a value of union type @LibItsBtp_TypesAndValues.BtpHeader.");
return *field_btpBHeader;
}

boolean BtpHeader::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsBtp_TypesAndValues.BtpHeader.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsBtp_TypesAndValues.BtpHeader.");
return union_selection == checked_selection;
}

boolean BtpHeader::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean BtpHeader::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_btpAHeader: return field_btpAHeader->is_value();
case ALT_btpBHeader: return field_btpBHeader->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void BtpHeader::clean_up()
{
switch (union_selection) {
case ALT_btpAHeader:
  delete field_btpAHeader;
  break;
case ALT_btpBHeader:
  delete field_btpBHeader;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void BtpHeader::log() const
{
switch (union_selection) {
case ALT_btpAHeader:
TTCN_Logger::log_event_str("{ btpAHeader := ");
field_btpAHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_btpBHeader:
TTCN_Logger::log_event_str("{ btpBHeader := ");
field_btpBHeader->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void BtpHeader::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsBtp_TypesAndValues.BtpHeader'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      btpAHeader().set_param(param);
      return;
    } else if (strcmp("btpBHeader", param_field) == 0) {
      btpBHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsBtp_TypesAndValues.BtpHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "btpAHeader")) {
    btpAHeader().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "btpBHeader")) {
    btpBHeader().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsBtp_TypesAndValues.BtpHeader.", mp_last->get_id()->get_name());
}

Module_Param* BtpHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsBtp_TypesAndValues.BtpHeader'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      return btpAHeader().get_param(param_name);
    } else if (strcmp("btpBHeader", param_field) == 0) {
      return btpBHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `BtpHeader'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_btpAHeader:
    mp_field = field_btpAHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("btpAHeader")));
    break;
  case ALT_btpBHeader:
    mp_field = field_btpBHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("btpBHeader")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void BtpHeader::set_implicit_omit()
{
switch (union_selection) {
case ALT_btpAHeader:
field_btpAHeader->set_implicit_omit(); break;
case ALT_btpBHeader:
field_btpBHeader->set_implicit_omit(); break;
default: break;
}
}

void BtpHeader::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_btpAHeader:
field_btpAHeader->encode_text(text_buf);
break;
case ALT_btpBHeader:
field_btpBHeader->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsBtp_TypesAndValues.BtpHeader.");
}
}

void BtpHeader::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_btpAHeader:
btpAHeader().decode_text(text_buf);
break;
case ALT_btpBHeader:
btpBHeader().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsBtp_TypesAndValues.BtpHeader.");
}
}

void BtpHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BtpHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BtpHeader::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = btpAHeader().RAW_decode(BtpAHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = btpBHeader().RAW_decode(BtpBHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = btpAHeader().RAW_decode(BtpAHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = btpBHeader().RAW_decode(BtpBHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int BtpHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_btpAHeader:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, BtpAHeader_descr_.raw);
    encoded_length = field_btpAHeader->RAW_encode(BtpAHeader_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &BtpAHeader_descr_;
    break;
  case ALT_btpBHeader:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, BtpBHeader_descr_.raw);
    encoded_length = field_btpBHeader->RAW_encode(BtpBHeader_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &BtpBHeader_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int BtpHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_btpAHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpAHeader");
    enc_len += field_btpAHeader->JSON_encode(BtpAHeader_descr_, p_tok);
    break;
  case ALT_btpBHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpBHeader");
    enc_len += field_btpBHeader->JSON_encode(BtpBHeader_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.BtpHeader.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BtpHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "btpAHeader", name_len)) {
      int ret_val = btpAHeader().JSON_decode(BtpAHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpAHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "btpBHeader", name_len)) {
      int ret_val = btpBHeader().JSON_decode(BtpBHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpBHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void BtpHeader_template::copy_value(const BtpHeader& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader = new BtpAHeader_template(other_value.btpAHeader());
break;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader = new BtpBHeader_template(other_value.btpBHeader());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsBtp_TypesAndValues.BtpHeader.");
}
set_selection(SPECIFIC_VALUE);
}

void BtpHeader_template::copy_template(const BtpHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader = new BtpAHeader_template(*other_value.single_value.field_btpAHeader);
break;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader = new BtpBHeader_template(*other_value.single_value.field_btpBHeader);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsBtp_TypesAndValues.BtpHeader.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BtpHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
}
set_selection(other_value);
}

BtpHeader_template::BtpHeader_template()
{
}

BtpHeader_template::BtpHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BtpHeader_template::BtpHeader_template(const BtpHeader& other_value)
{
copy_value(other_value);
}

BtpHeader_template::BtpHeader_template(const OPTIONAL<BtpHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsBtp_TypesAndValues.BtpHeader from an unbound optional field.");
}
}

BtpHeader_template::BtpHeader_template(const BtpHeader_template& other_value)
: Base_Template(){
copy_template(other_value);
}

BtpHeader_template::~BtpHeader_template()
{
clean_up();
}

void BtpHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
delete single_value.field_btpAHeader;
break;
case BtpHeader::ALT_btpBHeader:
delete single_value.field_btpBHeader;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BtpHeader_template& BtpHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpHeader_template& BtpHeader_template::operator=(const BtpHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BtpHeader_template& BtpHeader_template::operator=(const OPTIONAL<BtpHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
}
return *this;
}

BtpHeader_template& BtpHeader_template::operator=(const BtpHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BtpHeader_template::match(const BtpHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
BtpHeader::union_selection_type value_selection = other_value.get_selection();
if (value_selection == BtpHeader::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case BtpHeader::ALT_btpAHeader:
return single_value.field_btpAHeader->match(other_value.btpAHeader(), legacy);
case BtpHeader::ALT_btpBHeader:
return single_value.field_btpBHeader->match(other_value.btpBHeader(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
}
return FALSE;
}

boolean BtpHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
return single_value.field_btpAHeader->is_value();
case BtpHeader::ALT_btpBHeader:
return single_value.field_btpBHeader->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
}
}

BtpHeader BtpHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
BtpHeader ret_val;
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
ret_val.btpAHeader() = single_value.field_btpAHeader->valueof();
break;
case BtpHeader::ALT_btpBHeader:
ret_val.btpBHeader() = single_value.field_btpBHeader->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
}
return ret_val;
}

BtpHeader_template& BtpHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
return value_list.list_value[list_index];
}
void BtpHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BtpHeader_template[list_length];
}

BtpAHeader_template& BtpHeader_template::btpAHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != BtpHeader::ALT_btpAHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_btpAHeader = new BtpAHeader_template(ANY_VALUE);
else single_value.field_btpAHeader = new BtpAHeader_template;
single_value.union_selection = BtpHeader::ALT_btpAHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_btpAHeader;
}

const BtpAHeader_template& BtpHeader_template::btpAHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field btpAHeader in a non-specific template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
if (single_value.union_selection != BtpHeader::ALT_btpAHeader) TTCN_error("Accessing non-selected field btpAHeader in a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
return *single_value.field_btpAHeader;
}

BtpBHeader_template& BtpHeader_template::btpBHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != BtpHeader::ALT_btpBHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_btpBHeader = new BtpBHeader_template(ANY_VALUE);
else single_value.field_btpBHeader = new BtpBHeader_template;
single_value.union_selection = BtpHeader::ALT_btpBHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_btpBHeader;
}

const BtpBHeader_template& BtpHeader_template::btpBHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field btpBHeader in a non-specific template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
if (single_value.union_selection != BtpHeader::ALT_btpBHeader) TTCN_error("Accessing non-selected field btpBHeader in a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
return *single_value.field_btpBHeader;
}

boolean BtpHeader_template::ischosen(BtpHeader::union_selection_type checked_selection) const
{
if (checked_selection == BtpHeader::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsBtp_TypesAndValues.BtpHeader.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == BtpHeader::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsBtp_TypesAndValues.BtpHeader containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsBtp_TypesAndValues.BtpHeader, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsBtp_TypesAndValues.BtpHeader");
}
return FALSE;
}

void BtpHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
TTCN_Logger::log_event_str("{ btpAHeader := ");
single_value.field_btpAHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case BtpHeader::ALT_btpBHeader:
TTCN_Logger::log_event_str("{ btpBHeader := ");
single_value.field_btpBHeader->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BtpHeader_template::log_match(const BtpHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".btpAHeader");
single_value.field_btpAHeader->log_match(match_value.btpAHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ btpAHeader := ");
single_value.field_btpAHeader->log_match(match_value.btpAHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case BtpHeader::ALT_btpBHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".btpBHeader");
single_value.field_btpBHeader->log_match(match_value.btpBHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ btpBHeader := ");
single_value.field_btpBHeader->log_match(match_value.btpBHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BtpHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader->encode_text(text_buf);
break;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsBtp_TypesAndValues.BtpHeader.");
}
}

void BtpHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = BtpHeader::UNBOUND_VALUE;
BtpHeader::union_selection_type new_selection = (BtpHeader::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader = new BtpAHeader_template;
single_value.field_btpAHeader->decode_text(text_buf);
break;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader = new BtpBHeader_template;
single_value.field_btpBHeader->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsBtp_TypesAndValues.BtpHeader.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BtpHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsBtp_TypesAndValues.BtpHeader.");
}
}

boolean BtpHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BtpHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void BtpHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsBtp_TypesAndValues.BtpHeader'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      btpAHeader().set_param(param);
      return;
    } else if (strcmp("btpBHeader", param_field) == 0) {
      btpBHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsBtp_TypesAndValues.BtpHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BtpHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsBtp_TypesAndValues.BtpHeader");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "btpAHeader")) {
      btpAHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "btpBHeader")) {
      btpBHeader().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsBtp_TypesAndValues.BtpHeader.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsBtp_TypesAndValues.BtpHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BtpHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsBtp_TypesAndValues.BtpHeader'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      return btpAHeader().get_param(param_name);
    } else if (strcmp("btpBHeader", param_field) == 0) {
      return btpBHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `BtpHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case BtpHeader::ALT_btpAHeader:
      mp_field = single_value.field_btpAHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("btpAHeader")));
      break;
    case BtpHeader::ALT_btpBHeader:
      mp_field = single_value.field_btpBHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("btpBHeader")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BtpHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case BtpHeader::ALT_btpAHeader:
single_value.field_btpAHeader->check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpHeader");
return;
case BtpHeader::ALT_btpBHeader:
single_value.field_btpBHeader->check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpHeader");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsBtp_TypesAndValues.BtpHeader.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpHeader");
}

BtpAHeader::BtpAHeader()
{
  bound_flag = FALSE;
}

BtpAHeader::BtpAHeader(const INTEGER& par_destinationPort,
    const INTEGER& par_sourcePort)
  :   field_destinationPort(par_destinationPort),
  field_sourcePort(par_sourcePort)
{
  bound_flag = TRUE;
}

BtpAHeader::BtpAHeader(const BtpAHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsBtp_TypesAndValues.BtpAHeader.");
bound_flag = TRUE;
if (other_value.destinationPort().is_bound()) field_destinationPort = other_value.destinationPort();
else field_destinationPort.clean_up();
if (other_value.sourcePort().is_bound()) field_sourcePort = other_value.sourcePort();
else field_sourcePort.clean_up();
}

void BtpAHeader::clean_up()
{
field_destinationPort.clean_up();
field_sourcePort.clean_up();
bound_flag = FALSE;
}

BtpAHeader& BtpAHeader::operator=(const BtpAHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsBtp_TypesAndValues.BtpAHeader.");
  bound_flag = TRUE;
  if (other_value.destinationPort().is_bound()) field_destinationPort = other_value.destinationPort();
  else field_destinationPort.clean_up();
  if (other_value.sourcePort().is_bound()) field_sourcePort = other_value.sourcePort();
  else field_sourcePort.clean_up();
}
return *this;
}

boolean BtpAHeader::operator==(const BtpAHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_destinationPort==other_value.field_destinationPort
  && field_sourcePort==other_value.field_sourcePort;
}

boolean BtpAHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_destinationPort.is_bound()) return TRUE;
if(field_sourcePort.is_bound()) return TRUE;
return FALSE;
}
boolean BtpAHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_destinationPort.is_value()) return FALSE;
if(!field_sourcePort.is_value()) return FALSE;
return TRUE;
}
int BtpAHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsBtp_TypesAndValues.BtpAHeader");
  return 2;
}

void BtpAHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ destinationPort := ");
field_destinationPort.log();
TTCN_Logger::log_event_str(", sourcePort := ");
field_sourcePort.log();
TTCN_Logger::log_event_str(" }");
}

void BtpAHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsBtp_TypesAndValues.BtpAHeader'");
    }
    if (strcmp("destinationPort", param_field) == 0) {
      destinationPort().set_param(param);
      return;
    } else if (strcmp("sourcePort", param_field) == 0) {
      sourcePort().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpAHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsBtp_TypesAndValues.BtpAHeader has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) destinationPort().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sourcePort().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "destinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          destinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sourcePort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sourcePort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.BtpAHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsBtp_TypesAndValues.BtpAHeader");
  }
}

Module_Param* BtpAHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsBtp_TypesAndValues.BtpAHeader'");
    }
    if (strcmp("destinationPort", param_field) == 0) {
      return destinationPort().get_param(param_name);
    } else if (strcmp("sourcePort", param_field) == 0) {
      return sourcePort().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpAHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_destinationPort = field_destinationPort.get_param(param_name);
  mp_field_destinationPort->set_id(new Module_Param_FieldName(mcopystr("destinationPort")));
  mp->add_elem(mp_field_destinationPort);
  Module_Param* mp_field_sourcePort = field_sourcePort.get_param(param_name);
  mp_field_sourcePort->set_id(new Module_Param_FieldName(mcopystr("sourcePort")));
  mp->add_elem(mp_field_sourcePort);
  return mp;
  }

void BtpAHeader::set_implicit_omit()
{
if (destinationPort().is_bound()) destinationPort().set_implicit_omit();
if (sourcePort().is_bound()) sourcePort().set_implicit_omit();
}

void BtpAHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsBtp_TypesAndValues.BtpAHeader.");
field_destinationPort.encode_text(text_buf);
field_sourcePort.encode_text(text_buf);
}

void BtpAHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_destinationPort.decode_text(text_buf);
field_sourcePort.decode_text(text_buf);
}

void BtpAHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BtpAHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BtpAHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_destinationPort.RAW_decode(BtpPortId_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_sourcePort.RAW_decode(BtpPortId_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int BtpAHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BtpPortId_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, BtpPortId_descr_.raw);
  encoded_length += field_destinationPort.RAW_encode(BtpPortId_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_sourcePort.RAW_encode(BtpPortId_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int BtpAHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.BtpAHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "destinationPort");
    enc_len += field_destinationPort.JSON_encode(BtpPortId_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sourcePort");
    enc_len += field_sourcePort.JSON_encode(BtpPortId_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BtpAHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (15 == name_len && 0 == strncmp(fld_name, "destinationPort", name_len)) {
         int ret_val = field_destinationPort.JSON_decode(BtpPortId_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "destinationPort");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "sourcePort", name_len)) {
         int ret_val = field_sourcePort.JSON_decode(BtpPortId_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sourcePort");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_destinationPort.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "destinationPort");
    return JSON_ERROR_FATAL;
  }
if (!field_sourcePort.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "sourcePort");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct BtpAHeader_template::single_value_struct {
INTEGER_template field_destinationPort;
INTEGER_template field_sourcePort;
};

void BtpAHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_destinationPort = ANY_VALUE;
single_value->field_sourcePort = ANY_VALUE;
}
}
}

void BtpAHeader_template::copy_value(const BtpAHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.destinationPort().is_bound()) {
  single_value->field_destinationPort = other_value.destinationPort();
} else {
  single_value->field_destinationPort.clean_up();
}
if (other_value.sourcePort().is_bound()) {
  single_value->field_sourcePort = other_value.sourcePort();
} else {
  single_value->field_sourcePort.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BtpAHeader_template::copy_template(const BtpAHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.destinationPort().get_selection()) {
single_value->field_destinationPort = other_value.destinationPort();
} else {
single_value->field_destinationPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sourcePort().get_selection()) {
single_value->field_sourcePort = other_value.sourcePort();
} else {
single_value->field_sourcePort.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BtpAHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
break;
}
set_selection(other_value);
}

BtpAHeader_template::BtpAHeader_template()
{
}

BtpAHeader_template::BtpAHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BtpAHeader_template::BtpAHeader_template(const BtpAHeader& other_value)
{
copy_value(other_value);
}

BtpAHeader_template::BtpAHeader_template(const OPTIONAL<BtpAHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpAHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsBtp_TypesAndValues.BtpAHeader from an unbound optional field.");
}
}

BtpAHeader_template::BtpAHeader_template(const BtpAHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BtpAHeader_template::~BtpAHeader_template()
{
clean_up();
}

BtpAHeader_template& BtpAHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpAHeader_template& BtpAHeader_template::operator=(const BtpAHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BtpAHeader_template& BtpAHeader_template::operator=(const OPTIONAL<BtpAHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpAHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
}
return *this;
}

BtpAHeader_template& BtpAHeader_template::operator=(const BtpAHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BtpAHeader_template::match(const BtpAHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.destinationPort().is_bound()) return FALSE;
if(!single_value->field_destinationPort.match(other_value.destinationPort(), legacy))return FALSE;
if(!other_value.sourcePort().is_bound()) return FALSE;
if(!single_value->field_sourcePort.match(other_value.sourcePort(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
}
return FALSE;
}

boolean BtpAHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_destinationPort.is_bound()) return TRUE;
if (single_value->field_sourcePort.is_bound()) return TRUE;
return FALSE;
}

boolean BtpAHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_destinationPort.is_value()) return FALSE;
if (!single_value->field_sourcePort.is_value()) return FALSE;
return TRUE;
}

void BtpAHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BtpAHeader BtpAHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
BtpAHeader ret_val;
if (single_value->field_destinationPort.is_bound()) {
ret_val.destinationPort() = single_value->field_destinationPort.valueof();
}
if (single_value->field_sourcePort.is_bound()) {
ret_val.sourcePort() = single_value->field_sourcePort.valueof();
}
return ret_val;
}

void BtpAHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BtpAHeader_template[list_length];
}

BtpAHeader_template& BtpAHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& BtpAHeader_template::destinationPort()
{
set_specific();
return single_value->field_destinationPort;
}

const INTEGER_template& BtpAHeader_template::destinationPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field destinationPort of a non-specific template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
return single_value->field_destinationPort;
}

INTEGER_template& BtpAHeader_template::sourcePort()
{
set_specific();
return single_value->field_sourcePort;
}

const INTEGER_template& BtpAHeader_template::sourcePort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sourcePort of a non-specific template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
return single_value->field_sourcePort;
}

int BtpAHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpAHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpAHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpAHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpAHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpAHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpAHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
  }
  return 0;
}

void BtpAHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ destinationPort := ");
single_value->field_destinationPort.log();
TTCN_Logger::log_event_str(", sourcePort := ");
single_value->field_sourcePort.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BtpAHeader_template::log_match(const BtpAHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_destinationPort.match(match_value.destinationPort(), legacy)){
TTCN_Logger::log_logmatch_info(".destinationPort");
single_value->field_destinationPort.log_match(match_value.destinationPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sourcePort.match(match_value.sourcePort(), legacy)){
TTCN_Logger::log_logmatch_info(".sourcePort");
single_value->field_sourcePort.log_match(match_value.sourcePort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ destinationPort := ");
single_value->field_destinationPort.log_match(match_value.destinationPort(), legacy);
TTCN_Logger::log_event_str(", sourcePort := ");
single_value->field_sourcePort.log_match(match_value.sourcePort(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BtpAHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_destinationPort.encode_text(text_buf);
single_value->field_sourcePort.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
}
}

void BtpAHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_destinationPort.decode_text(text_buf);
single_value->field_sourcePort.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BtpAHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsBtp_TypesAndValues.BtpAHeader.");
}
}

void BtpAHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsBtp_TypesAndValues.BtpAHeader'");
    }
    if (strcmp("destinationPort", param_field) == 0) {
      destinationPort().set_param(param);
      return;
    } else if (strcmp("sourcePort", param_field) == 0) {
      sourcePort().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsBtp_TypesAndValues.BtpAHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BtpAHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsBtp_TypesAndValues.BtpAHeader has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) destinationPort().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sourcePort().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "destinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          destinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sourcePort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sourcePort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.BtpAHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsBtp_TypesAndValues.BtpAHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BtpAHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsBtp_TypesAndValues.BtpAHeader'");
    }
    if (strcmp("destinationPort", param_field) == 0) {
      return destinationPort().get_param(param_name);
    } else if (strcmp("sourcePort", param_field) == 0) {
      return sourcePort().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpAHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_destinationPort = single_value->field_destinationPort.get_param(param_name);
    mp_field_destinationPort->set_id(new Module_Param_FieldName(mcopystr("destinationPort")));
    mp->add_elem(mp_field_destinationPort);
    Module_Param* mp_field_sourcePort = single_value->field_sourcePort.get_param(param_name);
    mp_field_sourcePort->set_id(new Module_Param_FieldName(mcopystr("sourcePort")));
    mp->add_elem(mp_field_sourcePort);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BtpAHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_destinationPort.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpAHeader");
single_value->field_sourcePort.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpAHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpAHeader");
}

boolean BtpAHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BtpAHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

BtpBHeader::BtpBHeader()
{
  bound_flag = FALSE;
}

BtpBHeader::BtpBHeader(const INTEGER& par_destinationPort,
    const INTEGER& par_destinationPortInfo)
  :   field_destinationPort(par_destinationPort),
  field_destinationPortInfo(par_destinationPortInfo)
{
  bound_flag = TRUE;
}

BtpBHeader::BtpBHeader(const BtpBHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsBtp_TypesAndValues.BtpBHeader.");
bound_flag = TRUE;
if (other_value.destinationPort().is_bound()) field_destinationPort = other_value.destinationPort();
else field_destinationPort.clean_up();
if (other_value.destinationPortInfo().is_bound()) field_destinationPortInfo = other_value.destinationPortInfo();
else field_destinationPortInfo.clean_up();
}

void BtpBHeader::clean_up()
{
field_destinationPort.clean_up();
field_destinationPortInfo.clean_up();
bound_flag = FALSE;
}

BtpBHeader& BtpBHeader::operator=(const BtpBHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsBtp_TypesAndValues.BtpBHeader.");
  bound_flag = TRUE;
  if (other_value.destinationPort().is_bound()) field_destinationPort = other_value.destinationPort();
  else field_destinationPort.clean_up();
  if (other_value.destinationPortInfo().is_bound()) field_destinationPortInfo = other_value.destinationPortInfo();
  else field_destinationPortInfo.clean_up();
}
return *this;
}

boolean BtpBHeader::operator==(const BtpBHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_destinationPort==other_value.field_destinationPort
  && field_destinationPortInfo==other_value.field_destinationPortInfo;
}

boolean BtpBHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_destinationPort.is_bound()) return TRUE;
if(field_destinationPortInfo.is_bound()) return TRUE;
return FALSE;
}
boolean BtpBHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_destinationPort.is_value()) return FALSE;
if(!field_destinationPortInfo.is_value()) return FALSE;
return TRUE;
}
int BtpBHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsBtp_TypesAndValues.BtpBHeader");
  return 2;
}

void BtpBHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ destinationPort := ");
field_destinationPort.log();
TTCN_Logger::log_event_str(", destinationPortInfo := ");
field_destinationPortInfo.log();
TTCN_Logger::log_event_str(" }");
}

void BtpBHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsBtp_TypesAndValues.BtpBHeader'");
    }
    if (strcmp("destinationPort", param_field) == 0) {
      destinationPort().set_param(param);
      return;
    } else if (strcmp("destinationPortInfo", param_field) == 0) {
      destinationPortInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpBHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsBtp_TypesAndValues.BtpBHeader has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) destinationPort().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) destinationPortInfo().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "destinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          destinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "destinationPortInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          destinationPortInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.BtpBHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsBtp_TypesAndValues.BtpBHeader");
  }
}

Module_Param* BtpBHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsBtp_TypesAndValues.BtpBHeader'");
    }
    if (strcmp("destinationPort", param_field) == 0) {
      return destinationPort().get_param(param_name);
    } else if (strcmp("destinationPortInfo", param_field) == 0) {
      return destinationPortInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpBHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_destinationPort = field_destinationPort.get_param(param_name);
  mp_field_destinationPort->set_id(new Module_Param_FieldName(mcopystr("destinationPort")));
  mp->add_elem(mp_field_destinationPort);
  Module_Param* mp_field_destinationPortInfo = field_destinationPortInfo.get_param(param_name);
  mp_field_destinationPortInfo->set_id(new Module_Param_FieldName(mcopystr("destinationPortInfo")));
  mp->add_elem(mp_field_destinationPortInfo);
  return mp;
  }

void BtpBHeader::set_implicit_omit()
{
if (destinationPort().is_bound()) destinationPort().set_implicit_omit();
if (destinationPortInfo().is_bound()) destinationPortInfo().set_implicit_omit();
}

void BtpBHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsBtp_TypesAndValues.BtpBHeader.");
field_destinationPort.encode_text(text_buf);
field_destinationPortInfo.encode_text(text_buf);
}

void BtpBHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_destinationPort.decode_text(text_buf);
field_destinationPortInfo.decode_text(text_buf);
}

void BtpBHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BtpBHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BtpBHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_destinationPort.RAW_decode(BtpPortId_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_destinationPortInfo.RAW_decode(BtpPortInfo_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int BtpBHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BtpPortId_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, BtpPortInfo_descr_.raw);
  encoded_length += field_destinationPort.RAW_encode(BtpPortId_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_destinationPortInfo.RAW_encode(BtpPortInfo_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int BtpBHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.BtpBHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "destinationPort");
    enc_len += field_destinationPort.JSON_encode(BtpPortId_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "destinationPortInfo");
    enc_len += field_destinationPortInfo.JSON_encode(BtpPortInfo_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BtpBHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (15 == name_len && 0 == strncmp(fld_name, "destinationPort", name_len)) {
         int ret_val = field_destinationPort.JSON_decode(BtpPortId_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "destinationPort");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "destinationPortInfo", name_len)) {
         int ret_val = field_destinationPortInfo.JSON_decode(BtpPortInfo_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "destinationPortInfo");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_destinationPort.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "destinationPort");
    return JSON_ERROR_FATAL;
  }
if (!field_destinationPortInfo.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "destinationPortInfo");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct BtpBHeader_template::single_value_struct {
INTEGER_template field_destinationPort;
INTEGER_template field_destinationPortInfo;
};

void BtpBHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_destinationPort = ANY_VALUE;
single_value->field_destinationPortInfo = ANY_VALUE;
}
}
}

void BtpBHeader_template::copy_value(const BtpBHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.destinationPort().is_bound()) {
  single_value->field_destinationPort = other_value.destinationPort();
} else {
  single_value->field_destinationPort.clean_up();
}
if (other_value.destinationPortInfo().is_bound()) {
  single_value->field_destinationPortInfo = other_value.destinationPortInfo();
} else {
  single_value->field_destinationPortInfo.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BtpBHeader_template::copy_template(const BtpBHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.destinationPort().get_selection()) {
single_value->field_destinationPort = other_value.destinationPort();
} else {
single_value->field_destinationPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.destinationPortInfo().get_selection()) {
single_value->field_destinationPortInfo = other_value.destinationPortInfo();
} else {
single_value->field_destinationPortInfo.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BtpBHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
break;
}
set_selection(other_value);
}

BtpBHeader_template::BtpBHeader_template()
{
}

BtpBHeader_template::BtpBHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BtpBHeader_template::BtpBHeader_template(const BtpBHeader& other_value)
{
copy_value(other_value);
}

BtpBHeader_template::BtpBHeader_template(const OPTIONAL<BtpBHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpBHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsBtp_TypesAndValues.BtpBHeader from an unbound optional field.");
}
}

BtpBHeader_template::BtpBHeader_template(const BtpBHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BtpBHeader_template::~BtpBHeader_template()
{
clean_up();
}

BtpBHeader_template& BtpBHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpBHeader_template& BtpBHeader_template::operator=(const BtpBHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BtpBHeader_template& BtpBHeader_template::operator=(const OPTIONAL<BtpBHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpBHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
}
return *this;
}

BtpBHeader_template& BtpBHeader_template::operator=(const BtpBHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BtpBHeader_template::match(const BtpBHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.destinationPort().is_bound()) return FALSE;
if(!single_value->field_destinationPort.match(other_value.destinationPort(), legacy))return FALSE;
if(!other_value.destinationPortInfo().is_bound()) return FALSE;
if(!single_value->field_destinationPortInfo.match(other_value.destinationPortInfo(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
}
return FALSE;
}

boolean BtpBHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_destinationPort.is_bound()) return TRUE;
if (single_value->field_destinationPortInfo.is_bound()) return TRUE;
return FALSE;
}

boolean BtpBHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_destinationPort.is_value()) return FALSE;
if (!single_value->field_destinationPortInfo.is_value()) return FALSE;
return TRUE;
}

void BtpBHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BtpBHeader BtpBHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
BtpBHeader ret_val;
if (single_value->field_destinationPort.is_bound()) {
ret_val.destinationPort() = single_value->field_destinationPort.valueof();
}
if (single_value->field_destinationPortInfo.is_bound()) {
ret_val.destinationPortInfo() = single_value->field_destinationPortInfo.valueof();
}
return ret_val;
}

void BtpBHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BtpBHeader_template[list_length];
}

BtpBHeader_template& BtpBHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& BtpBHeader_template::destinationPort()
{
set_specific();
return single_value->field_destinationPort;
}

const INTEGER_template& BtpBHeader_template::destinationPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field destinationPort of a non-specific template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
return single_value->field_destinationPort;
}

INTEGER_template& BtpBHeader_template::destinationPortInfo()
{
set_specific();
return single_value->field_destinationPortInfo;
}

const INTEGER_template& BtpBHeader_template::destinationPortInfo() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field destinationPortInfo of a non-specific template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
return single_value->field_destinationPortInfo;
}

int BtpBHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpBHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpBHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpBHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpBHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpBHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpBHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
  }
  return 0;
}

void BtpBHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ destinationPort := ");
single_value->field_destinationPort.log();
TTCN_Logger::log_event_str(", destinationPortInfo := ");
single_value->field_destinationPortInfo.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BtpBHeader_template::log_match(const BtpBHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_destinationPort.match(match_value.destinationPort(), legacy)){
TTCN_Logger::log_logmatch_info(".destinationPort");
single_value->field_destinationPort.log_match(match_value.destinationPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_destinationPortInfo.match(match_value.destinationPortInfo(), legacy)){
TTCN_Logger::log_logmatch_info(".destinationPortInfo");
single_value->field_destinationPortInfo.log_match(match_value.destinationPortInfo(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ destinationPort := ");
single_value->field_destinationPort.log_match(match_value.destinationPort(), legacy);
TTCN_Logger::log_event_str(", destinationPortInfo := ");
single_value->field_destinationPortInfo.log_match(match_value.destinationPortInfo(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BtpBHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_destinationPort.encode_text(text_buf);
single_value->field_destinationPortInfo.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
}
}

void BtpBHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_destinationPort.decode_text(text_buf);
single_value->field_destinationPortInfo.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BtpBHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsBtp_TypesAndValues.BtpBHeader.");
}
}

void BtpBHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsBtp_TypesAndValues.BtpBHeader'");
    }
    if (strcmp("destinationPort", param_field) == 0) {
      destinationPort().set_param(param);
      return;
    } else if (strcmp("destinationPortInfo", param_field) == 0) {
      destinationPortInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsBtp_TypesAndValues.BtpBHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BtpBHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsBtp_TypesAndValues.BtpBHeader has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) destinationPort().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) destinationPortInfo().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "destinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          destinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "destinationPortInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          destinationPortInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.BtpBHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsBtp_TypesAndValues.BtpBHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BtpBHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsBtp_TypesAndValues.BtpBHeader'");
    }
    if (strcmp("destinationPort", param_field) == 0) {
      return destinationPort().get_param(param_name);
    } else if (strcmp("destinationPortInfo", param_field) == 0) {
      return destinationPortInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpBHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_destinationPort = single_value->field_destinationPort.get_param(param_name);
    mp_field_destinationPort->set_id(new Module_Param_FieldName(mcopystr("destinationPort")));
    mp->add_elem(mp_field_destinationPort);
    Module_Param* mp_field_destinationPortInfo = single_value->field_destinationPortInfo.get_param(param_name);
    mp_field_destinationPortInfo->set_id(new Module_Param_FieldName(mcopystr("destinationPortInfo")));
    mp->add_elem(mp_field_destinationPortInfo);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BtpBHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_destinationPort.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpBHeader");
single_value->field_destinationPortInfo.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpBHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpBHeader");
}

boolean BtpBHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BtpBHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

BtpPacket::BtpPacket()
{
  bound_flag = FALSE;
}

BtpPacket::BtpPacket(const BtpHeader& par_header,
    const OPTIONAL<BtpPayload>& par_payload)
  :   field_header(par_header),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

BtpPacket::BtpPacket(const BtpPacket& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsBtp_TypesAndValues.BtpPacket.");
bound_flag = TRUE;
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void BtpPacket::clean_up()
{
field_header.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

BtpPacket& BtpPacket::operator=(const BtpPacket& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsBtp_TypesAndValues.BtpPacket.");
  bound_flag = TRUE;
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean BtpPacket::operator==(const BtpPacket& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_header==other_value.field_header
  && field_payload==other_value.field_payload;
}

boolean BtpPacket::is_bound() const
{
if (bound_flag) return TRUE;
if(field_header.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_payload.get_selection() || field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean BtpPacket::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_header.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_payload.get_selection() && !field_payload.is_value()) return FALSE;
return TRUE;
}
int BtpPacket::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsBtp_TypesAndValues.BtpPacket");
  int ret_val = 1;
  if (field_payload.ispresent()) ret_val++;
  return ret_val;
}

void BtpPacket::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void BtpPacket::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsBtp_TypesAndValues.BtpPacket'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpPacket'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsBtp_TypesAndValues.BtpPacket has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.BtpPacket: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsBtp_TypesAndValues.BtpPacket");
  }
}

Module_Param* BtpPacket::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsBtp_TypesAndValues.BtpPacket'");
    }
    if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpPacket'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_header = field_header.get_param(param_name);
  mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
  mp->add_elem(mp_field_header);
  Module_Param* mp_field_payload = field_payload.get_param(param_name);
  mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
  mp->add_elem(mp_field_payload);
  return mp;
  }

void BtpPacket::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (!payload().is_bound()) payload() = OMIT_VALUE;
else payload().set_implicit_omit();
}

void BtpPacket::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsBtp_TypesAndValues.BtpPacket.");
field_header.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void BtpPacket::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_header.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void BtpPacket::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BtpPacket::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BtpPacket::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_header.RAW_decode(BtpHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_payload().RAW_decode(BtpPayload_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_payload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_payload=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int BtpPacket::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BtpHeader_descr_.raw);
  if (field_payload.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, BtpPayload_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  encoded_length += field_header.RAW_encode(BtpHeader_descr_, *myleaf.body.node.nodes[0]);
  if (field_payload.ispresent()) {
  encoded_length += field_payload().RAW_encode(BtpPayload_descr_, *myleaf.body.node.nodes[1]);
  }
  return myleaf.length = encoded_length;
}

int BtpPacket::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.BtpPacket.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header");
    enc_len += field_header.JSON_encode(BtpHeader_descr_, p_tok);
  }

  if (field_payload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(BtpPayload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BtpPacket::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "header", name_len)) {
         int ret_val = field_header.JSON_decode(BtpHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
         int ret_val = field_payload.JSON_decode(BtpPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_header.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header");
    return JSON_ERROR_FATAL;
  }
if (!field_payload.is_bound()) {
    field_payload = OMIT_VALUE;
  }

  return dec_len;
}

struct BtpPacket_template::single_value_struct {
BtpHeader_template field_header;
BtpPayload_template field_payload;
};

void BtpPacket_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_payload = ANY_OR_OMIT;
}
}
}

void BtpPacket_template::copy_value(const BtpPacket& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.payload().is_bound()) {
  if (other_value.payload().ispresent()) single_value->field_payload = other_value.payload()();
  else single_value->field_payload = OMIT_VALUE;
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BtpPacket_template::copy_template(const BtpPacket_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BtpPacket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpPacket.");
break;
}
set_selection(other_value);
}

BtpPacket_template::BtpPacket_template()
{
}

BtpPacket_template::BtpPacket_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BtpPacket_template::BtpPacket_template(const BtpPacket& other_value)
{
copy_value(other_value);
}

BtpPacket_template::BtpPacket_template(const OPTIONAL<BtpPacket>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpPacket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsBtp_TypesAndValues.BtpPacket from an unbound optional field.");
}
}

BtpPacket_template::BtpPacket_template(const BtpPacket_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BtpPacket_template::~BtpPacket_template()
{
clean_up();
}

BtpPacket_template& BtpPacket_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpPacket_template& BtpPacket_template::operator=(const BtpPacket& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BtpPacket_template& BtpPacket_template::operator=(const OPTIONAL<BtpPacket>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpPacket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsBtp_TypesAndValues.BtpPacket.");
}
return *this;
}

BtpPacket_template& BtpPacket_template::operator=(const BtpPacket_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BtpPacket_template::match(const BtpPacket& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if((other_value.payload().ispresent() ? !single_value->field_payload.match((const BtpPayload&)other_value.payload(), legacy) : !single_value->field_payload.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpPacket.");
}
return FALSE;
}

boolean BtpPacket_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_payload.is_omit() || single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean BtpPacket_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_payload.is_omit() && !single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void BtpPacket_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BtpPacket BtpPacket_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsBtp_TypesAndValues.BtpPacket.");
BtpPacket ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_payload.is_omit()) ret_val.payload() = OMIT_VALUE;
else if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void BtpPacket_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsBtp_TypesAndValues.BtpPacket.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BtpPacket_template[list_length];
}

BtpPacket_template& BtpPacket_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsBtp_TypesAndValues.BtpPacket.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsBtp_TypesAndValues.BtpPacket.");
return value_list.list_value[list_index];
}

BtpHeader_template& BtpPacket_template::header()
{
set_specific();
return single_value->field_header;
}

const BtpHeader_template& BtpPacket_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @LibItsBtp_TypesAndValues.BtpPacket.");
return single_value->field_header;
}

BtpPayload_template& BtpPacket_template::payload()
{
set_specific();
return single_value->field_payload;
}

const BtpPayload_template& BtpPacket_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @LibItsBtp_TypesAndValues.BtpPacket.");
return single_value->field_payload;
}

int BtpPacket_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPacket which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_payload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPacket containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPacket containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPacket containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPacket containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPacket containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpPacket.");
  }
  return 0;
}

void BtpPacket_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BtpPacket_template::log_match(const BtpPacket& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.payload().ispresent()){
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_payload.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".payload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_payload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", payload := ");
if (match_value.payload().ispresent()) single_value->field_payload.log_match(match_value.payload(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_payload.log();
if (single_value->field_payload.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BtpPacket_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpPacket.");
}
}

void BtpPacket_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BtpPacket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsBtp_TypesAndValues.BtpPacket.");
}
}

void BtpPacket_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsBtp_TypesAndValues.BtpPacket'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsBtp_TypesAndValues.BtpPacket'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BtpPacket_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsBtp_TypesAndValues.BtpPacket has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.BtpPacket: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsBtp_TypesAndValues.BtpPacket");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BtpPacket_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsBtp_TypesAndValues.BtpPacket'");
    }
    if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpPacket'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_header = single_value->field_header.get_param(param_name);
    mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
    mp->add_elem(mp_field_header);
    Module_Param* mp_field_payload = single_value->field_payload.get_param(param_name);
    mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
    mp->add_elem(mp_field_payload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BtpPacket_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpPacket");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpPacket");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpPacket");
}

boolean BtpPacket_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BtpPacket_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

BtpPayload::BtpPayload()
{
  bound_flag = FALSE;
}

BtpPayload::BtpPayload(const OPTIONAL<DecodedBtpPayload>& par_decodedPayload,
    const OCTETSTRING& par_rawPayload)
  :   field_decodedPayload(par_decodedPayload),
  field_rawPayload(par_rawPayload)
{
  bound_flag = TRUE;
}

BtpPayload::BtpPayload(const BtpPayload& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsBtp_TypesAndValues.BtpPayload.");
bound_flag = TRUE;
if (other_value.decodedPayload().is_bound()) field_decodedPayload = other_value.decodedPayload();
else field_decodedPayload.clean_up();
if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
else field_rawPayload.clean_up();
}

void BtpPayload::clean_up()
{
field_decodedPayload.clean_up();
field_rawPayload.clean_up();
bound_flag = FALSE;
}

BtpPayload& BtpPayload::operator=(const BtpPayload& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsBtp_TypesAndValues.BtpPayload.");
  bound_flag = TRUE;
  if (other_value.decodedPayload().is_bound()) field_decodedPayload = other_value.decodedPayload();
  else field_decodedPayload.clean_up();
  if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
  else field_rawPayload.clean_up();
}
return *this;
}

boolean BtpPayload::operator==(const BtpPayload& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_decodedPayload==other_value.field_decodedPayload
  && field_rawPayload==other_value.field_rawPayload;
}

boolean BtpPayload::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_decodedPayload.get_selection() || field_decodedPayload.is_bound()) return TRUE;
if(field_rawPayload.is_bound()) return TRUE;
return FALSE;
}
boolean BtpPayload::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_decodedPayload.get_selection() && !field_decodedPayload.is_value()) return FALSE;
if(!field_rawPayload.is_value()) return FALSE;
return TRUE;
}
int BtpPayload::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsBtp_TypesAndValues.BtpPayload");
  int ret_val = 1;
  if (field_decodedPayload.ispresent()) ret_val++;
  return ret_val;
}

void BtpPayload::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ decodedPayload := ");
field_decodedPayload.log();
TTCN_Logger::log_event_str(", rawPayload := ");
field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
}

void BtpPayload::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsBtp_TypesAndValues.BtpPayload'");
    }
    if (strcmp("decodedPayload", param_field) == 0) {
      decodedPayload().set_param(param);
      return;
    } else if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsBtp_TypesAndValues.BtpPayload has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) decodedPayload().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "decodedPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          decodedPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.BtpPayload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsBtp_TypesAndValues.BtpPayload");
  }
}

Module_Param* BtpPayload::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsBtp_TypesAndValues.BtpPayload'");
    }
    if (strcmp("decodedPayload", param_field) == 0) {
      return decodedPayload().get_param(param_name);
    } else if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpPayload'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_decodedPayload = field_decodedPayload.get_param(param_name);
  mp_field_decodedPayload->set_id(new Module_Param_FieldName(mcopystr("decodedPayload")));
  mp->add_elem(mp_field_decodedPayload);
  Module_Param* mp_field_rawPayload = field_rawPayload.get_param(param_name);
  mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
  mp->add_elem(mp_field_rawPayload);
  return mp;
  }

void BtpPayload::set_implicit_omit()
{
if (!decodedPayload().is_bound()) decodedPayload() = OMIT_VALUE;
else decodedPayload().set_implicit_omit();
if (rawPayload().is_bound()) rawPayload().set_implicit_omit();
}

void BtpPayload::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsBtp_TypesAndValues.BtpPayload.");
field_decodedPayload.encode_text(text_buf);
field_rawPayload.encode_text(text_buf);
}

void BtpPayload::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_decodedPayload.decode_text(text_buf);
field_rawPayload.decode_text(text_buf);
}

void BtpPayload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BtpPayload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BtpPayload::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_decodedPayload().RAW_decode(DecodedBtpPayload_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_decodedPayload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_decodedPayload=OMIT_VALUE;
  decoded_field_length = field_rawPayload.RAW_decode(BtpRawPayload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int BtpPayload::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  if (field_decodedPayload.ispresent()) {
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, DecodedBtpPayload_descr_.raw);
  }
  else myleaf.body.node.nodes[0] = NULL;
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, BtpRawPayload_descr_.raw);
  if (field_decodedPayload.ispresent()) {
  encoded_length += field_decodedPayload().RAW_encode(DecodedBtpPayload_descr_, *myleaf.body.node.nodes[0]);
  }
  encoded_length += field_rawPayload.RAW_encode(BtpRawPayload_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int BtpPayload::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.BtpPayload.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_decodedPayload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "decodedPayload");
    enc_len += field_decodedPayload.JSON_encode(DecodedBtpPayload_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rawPayload");
    enc_len += field_rawPayload.JSON_encode(BtpRawPayload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BtpPayload::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (14 == name_len && 0 == strncmp(fld_name, "decodedPayload", name_len)) {
         int ret_val = field_decodedPayload.JSON_decode(DecodedBtpPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "decodedPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "rawPayload", name_len)) {
         int ret_val = field_rawPayload.JSON_decode(BtpRawPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rawPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_decodedPayload.is_bound()) {
    field_decodedPayload = OMIT_VALUE;
  }
if (!field_rawPayload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rawPayload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct BtpPayload_template::single_value_struct {
DecodedBtpPayload_template field_decodedPayload;
OCTETSTRING_template field_rawPayload;
};

void BtpPayload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_decodedPayload = ANY_OR_OMIT;
single_value->field_rawPayload = ANY_VALUE;
}
}
}

void BtpPayload_template::copy_value(const BtpPayload& other_value)
{
single_value = new single_value_struct;
if (other_value.decodedPayload().is_bound()) {
  if (other_value.decodedPayload().ispresent()) single_value->field_decodedPayload = other_value.decodedPayload()();
  else single_value->field_decodedPayload = OMIT_VALUE;
} else {
  single_value->field_decodedPayload.clean_up();
}
if (other_value.rawPayload().is_bound()) {
  single_value->field_rawPayload = other_value.rawPayload();
} else {
  single_value->field_rawPayload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BtpPayload_template::copy_template(const BtpPayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.decodedPayload().get_selection()) {
single_value->field_decodedPayload = other_value.decodedPayload();
} else {
single_value->field_decodedPayload.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rawPayload().get_selection()) {
single_value->field_rawPayload = other_value.rawPayload();
} else {
single_value->field_rawPayload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BtpPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpPayload.");
break;
}
set_selection(other_value);
}

BtpPayload_template::BtpPayload_template()
{
}

BtpPayload_template::BtpPayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BtpPayload_template::BtpPayload_template(const BtpPayload& other_value)
{
copy_value(other_value);
}

BtpPayload_template::BtpPayload_template(const OPTIONAL<BtpPayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsBtp_TypesAndValues.BtpPayload from an unbound optional field.");
}
}

BtpPayload_template::BtpPayload_template(const BtpPayload_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BtpPayload_template::~BtpPayload_template()
{
clean_up();
}

BtpPayload_template& BtpPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BtpPayload_template& BtpPayload_template::operator=(const BtpPayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BtpPayload_template& BtpPayload_template::operator=(const OPTIONAL<BtpPayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BtpPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsBtp_TypesAndValues.BtpPayload.");
}
return *this;
}

BtpPayload_template& BtpPayload_template::operator=(const BtpPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BtpPayload_template::match(const BtpPayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.decodedPayload().is_bound()) return FALSE;
if((other_value.decodedPayload().ispresent() ? !single_value->field_decodedPayload.match((const DecodedBtpPayload&)other_value.decodedPayload(), legacy) : !single_value->field_decodedPayload.match_omit(legacy)))return FALSE;
if(!other_value.rawPayload().is_bound()) return FALSE;
if(!single_value->field_rawPayload.match(other_value.rawPayload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpPayload.");
}
return FALSE;
}

boolean BtpPayload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_decodedPayload.is_omit() || single_value->field_decodedPayload.is_bound()) return TRUE;
if (single_value->field_rawPayload.is_bound()) return TRUE;
return FALSE;
}

boolean BtpPayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_decodedPayload.is_omit() && !single_value->field_decodedPayload.is_value()) return FALSE;
if (!single_value->field_rawPayload.is_value()) return FALSE;
return TRUE;
}

void BtpPayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BtpPayload BtpPayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsBtp_TypesAndValues.BtpPayload.");
BtpPayload ret_val;
if (single_value->field_decodedPayload.is_omit()) ret_val.decodedPayload() = OMIT_VALUE;
else if (single_value->field_decodedPayload.is_bound()) {
ret_val.decodedPayload() = single_value->field_decodedPayload.valueof();
}
if (single_value->field_rawPayload.is_bound()) {
ret_val.rawPayload() = single_value->field_rawPayload.valueof();
}
return ret_val;
}

void BtpPayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsBtp_TypesAndValues.BtpPayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BtpPayload_template[list_length];
}

BtpPayload_template& BtpPayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsBtp_TypesAndValues.BtpPayload.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsBtp_TypesAndValues.BtpPayload.");
return value_list.list_value[list_index];
}

DecodedBtpPayload_template& BtpPayload_template::decodedPayload()
{
set_specific();
return single_value->field_decodedPayload;
}

const DecodedBtpPayload_template& BtpPayload_template::decodedPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field decodedPayload of a non-specific template of type @LibItsBtp_TypesAndValues.BtpPayload.");
return single_value->field_decodedPayload;
}

OCTETSTRING_template& BtpPayload_template::rawPayload()
{
set_specific();
return single_value->field_rawPayload;
}

const OCTETSTRING_template& BtpPayload_template::rawPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawPayload of a non-specific template of type @LibItsBtp_TypesAndValues.BtpPayload.");
return single_value->field_rawPayload;
}

int BtpPayload_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPayload which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_decodedPayload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPayload containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPayload containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPayload containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPayload containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.BtpPayload containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpPayload.");
  }
  return 0;
}

void BtpPayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ decodedPayload := ");
single_value->field_decodedPayload.log();
TTCN_Logger::log_event_str(", rawPayload := ");
single_value->field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BtpPayload_template::log_match(const BtpPayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.decodedPayload().ispresent()){
if(!single_value->field_decodedPayload.match(match_value.decodedPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".decodedPayload");
single_value->field_decodedPayload.log_match(match_value.decodedPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_decodedPayload.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".decodedPayload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_decodedPayload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_rawPayload.match(match_value.rawPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".rawPayload");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ decodedPayload := ");
if (match_value.decodedPayload().ispresent()) single_value->field_decodedPayload.log_match(match_value.decodedPayload(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_decodedPayload.log();
if (single_value->field_decodedPayload.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", rawPayload := ");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BtpPayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_decodedPayload.encode_text(text_buf);
single_value->field_rawPayload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.BtpPayload.");
}
}

void BtpPayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_decodedPayload.decode_text(text_buf);
single_value->field_rawPayload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BtpPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsBtp_TypesAndValues.BtpPayload.");
}
}

void BtpPayload_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsBtp_TypesAndValues.BtpPayload'");
    }
    if (strcmp("decodedPayload", param_field) == 0) {
      decodedPayload().set_param(param);
      return;
    } else if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsBtp_TypesAndValues.BtpPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BtpPayload_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsBtp_TypesAndValues.BtpPayload has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) decodedPayload().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "decodedPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          decodedPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.BtpPayload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsBtp_TypesAndValues.BtpPayload");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BtpPayload_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsBtp_TypesAndValues.BtpPayload'");
    }
    if (strcmp("decodedPayload", param_field) == 0) {
      return decodedPayload().get_param(param_name);
    } else if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.BtpPayload'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_decodedPayload = single_value->field_decodedPayload.get_param(param_name);
    mp_field_decodedPayload->set_id(new Module_Param_FieldName(mcopystr("decodedPayload")));
    mp->add_elem(mp_field_decodedPayload);
    Module_Param* mp_field_rawPayload = single_value->field_rawPayload.get_param(param_name);
    mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
    mp->add_elem(mp_field_rawPayload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BtpPayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_decodedPayload.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpPayload");
single_value->field_rawPayload.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpPayload");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.BtpPayload");
}

boolean BtpPayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BtpPayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DecodedBtpPayload::copy_value(const DecodedBtpPayload& other_value)
{
switch (other_value.union_selection) {
case ALT_camPacket:
field_camPacket = new CAM__PDU__Descriptions::CAM(*other_value.field_camPacket);
break;
case ALT_denmPacket:
field_denmPacket = new DENM__PDU__Descriptions::DENM(*other_value.field_denmPacket);
break;
case ALT_mapPacket:
field_mapPacket = new MAP__SPAT__ETSI::MAP__PDU(*other_value.field_mapPacket);
break;
case ALT_spatPacket:
field_spatPacket = new MAP__SPAT__ETSI::SPAT__PDU(*other_value.field_spatPacket);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
union_selection = other_value.union_selection;
}

DecodedBtpPayload::DecodedBtpPayload()
{
union_selection = UNBOUND_VALUE;
}

DecodedBtpPayload::DecodedBtpPayload(const DecodedBtpPayload& other_value)
: Base_Type(){
copy_value(other_value);
}

DecodedBtpPayload::~DecodedBtpPayload()
{
clean_up();
}

DecodedBtpPayload& DecodedBtpPayload::operator=(const DecodedBtpPayload& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean DecodedBtpPayload::operator==(const DecodedBtpPayload& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_camPacket:
return *field_camPacket == *other_value.field_camPacket;
case ALT_denmPacket:
return *field_denmPacket == *other_value.field_denmPacket;
case ALT_mapPacket:
return *field_mapPacket == *other_value.field_mapPacket;
case ALT_spatPacket:
return *field_spatPacket == *other_value.field_spatPacket;
default:
return FALSE;
}
}

CAM__PDU__Descriptions::CAM& DecodedBtpPayload::camPacket()
{
if (union_selection != ALT_camPacket) {
clean_up();
field_camPacket = new CAM__PDU__Descriptions::CAM;
union_selection = ALT_camPacket;
}
return *field_camPacket;
}

const CAM__PDU__Descriptions::CAM& DecodedBtpPayload::camPacket() const
{
if (union_selection != ALT_camPacket) TTCN_error("Using non-selected field camPacket in a value of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return *field_camPacket;
}

DENM__PDU__Descriptions::DENM& DecodedBtpPayload::denmPacket()
{
if (union_selection != ALT_denmPacket) {
clean_up();
field_denmPacket = new DENM__PDU__Descriptions::DENM;
union_selection = ALT_denmPacket;
}
return *field_denmPacket;
}

const DENM__PDU__Descriptions::DENM& DecodedBtpPayload::denmPacket() const
{
if (union_selection != ALT_denmPacket) TTCN_error("Using non-selected field denmPacket in a value of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return *field_denmPacket;
}

MAP__SPAT__ETSI::MAP__PDU& DecodedBtpPayload::mapPacket()
{
if (union_selection != ALT_mapPacket) {
clean_up();
field_mapPacket = new MAP__SPAT__ETSI::MAP__PDU;
union_selection = ALT_mapPacket;
}
return *field_mapPacket;
}

const MAP__SPAT__ETSI::MAP__PDU& DecodedBtpPayload::mapPacket() const
{
if (union_selection != ALT_mapPacket) TTCN_error("Using non-selected field mapPacket in a value of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return *field_mapPacket;
}

MAP__SPAT__ETSI::SPAT__PDU& DecodedBtpPayload::spatPacket()
{
if (union_selection != ALT_spatPacket) {
clean_up();
field_spatPacket = new MAP__SPAT__ETSI::SPAT__PDU;
union_selection = ALT_spatPacket;
}
return *field_spatPacket;
}

const MAP__SPAT__ETSI::SPAT__PDU& DecodedBtpPayload::spatPacket() const
{
if (union_selection != ALT_spatPacket) TTCN_error("Using non-selected field spatPacket in a value of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return *field_spatPacket;
}

boolean DecodedBtpPayload::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return union_selection == checked_selection;
}

boolean DecodedBtpPayload::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean DecodedBtpPayload::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_camPacket: return field_camPacket->is_value();
case ALT_denmPacket: return field_denmPacket->is_value();
case ALT_mapPacket: return field_mapPacket->is_value();
case ALT_spatPacket: return field_spatPacket->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void DecodedBtpPayload::clean_up()
{
switch (union_selection) {
case ALT_camPacket:
  delete field_camPacket;
  break;
case ALT_denmPacket:
  delete field_denmPacket;
  break;
case ALT_mapPacket:
  delete field_mapPacket;
  break;
case ALT_spatPacket:
  delete field_spatPacket;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void DecodedBtpPayload::log() const
{
switch (union_selection) {
case ALT_camPacket:
TTCN_Logger::log_event_str("{ camPacket := ");
field_camPacket->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_denmPacket:
TTCN_Logger::log_event_str("{ denmPacket := ");
field_denmPacket->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_mapPacket:
TTCN_Logger::log_event_str("{ mapPacket := ");
field_mapPacket->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_spatPacket:
TTCN_Logger::log_event_str("{ spatPacket := ");
field_spatPacket->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void DecodedBtpPayload::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsBtp_TypesAndValues.DecodedBtpPayload'");
    }
    if (strcmp("camPacket", param_field) == 0) {
      camPacket().set_param(param);
      return;
    } else if (strcmp("denmPacket", param_field) == 0) {
      denmPacket().set_param(param);
      return;
    } else if (strcmp("mapPacket", param_field) == 0) {
      mapPacket().set_param(param);
      return;
    } else if (strcmp("spatPacket", param_field) == 0) {
      spatPacket().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsBtp_TypesAndValues.DecodedBtpPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "camPacket")) {
    camPacket().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "denmPacket")) {
    denmPacket().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "mapPacket")) {
    mapPacket().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "spatPacket")) {
    spatPacket().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsBtp_TypesAndValues.DecodedBtpPayload.", mp_last->get_id()->get_name());
}

Module_Param* DecodedBtpPayload::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsBtp_TypesAndValues.DecodedBtpPayload'");
    }
    if (strcmp("camPacket", param_field) == 0) {
      return camPacket().get_param(param_name);
    } else if (strcmp("denmPacket", param_field) == 0) {
      return denmPacket().get_param(param_name);
    } else if (strcmp("mapPacket", param_field) == 0) {
      return mapPacket().get_param(param_name);
    } else if (strcmp("spatPacket", param_field) == 0) {
      return spatPacket().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `DecodedBtpPayload'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_camPacket:
    mp_field = field_camPacket->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("camPacket")));
    break;
  case ALT_denmPacket:
    mp_field = field_denmPacket->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("denmPacket")));
    break;
  case ALT_mapPacket:
    mp_field = field_mapPacket->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("mapPacket")));
    break;
  case ALT_spatPacket:
    mp_field = field_spatPacket->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("spatPacket")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void DecodedBtpPayload::set_implicit_omit()
{
switch (union_selection) {
case ALT_camPacket:
field_camPacket->set_implicit_omit(); break;
case ALT_denmPacket:
field_denmPacket->set_implicit_omit(); break;
case ALT_mapPacket:
field_mapPacket->set_implicit_omit(); break;
case ALT_spatPacket:
field_spatPacket->set_implicit_omit(); break;
default: break;
}
}

void DecodedBtpPayload::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_camPacket:
field_camPacket->encode_text(text_buf);
break;
case ALT_denmPacket:
field_denmPacket->encode_text(text_buf);
break;
case ALT_mapPacket:
field_mapPacket->encode_text(text_buf);
break;
case ALT_spatPacket:
field_spatPacket->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
}

void DecodedBtpPayload::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_camPacket:
camPacket().decode_text(text_buf);
break;
case ALT_denmPacket:
denmPacket().decode_text(text_buf);
break;
case ALT_mapPacket:
mapPacket().decode_text(text_buf);
break;
case ALT_spatPacket:
spatPacket().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
}

void DecodedBtpPayload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DecodedBtpPayload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int DecodedBtpPayload::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = camPacket().RAW_decode(CAM__PDU__Descriptions::CAM_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = denmPacket().RAW_decode(DENM__PDU__Descriptions::DENM_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = mapPacket().RAW_decode(MAP__SPAT__ETSI::MAP__PDU_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = spatPacket().RAW_decode(MAP__SPAT__ETSI::SPAT__PDU_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = camPacket().RAW_decode(CAM__PDU__Descriptions::CAM_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = denmPacket().RAW_decode(DENM__PDU__Descriptions::DENM_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = mapPacket().RAW_decode(MAP__SPAT__ETSI::MAP__PDU_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = spatPacket().RAW_decode(MAP__SPAT__ETSI::SPAT__PDU_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int DecodedBtpPayload::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 4;  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  memset(myleaf.body.node.nodes, 0, 4 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_camPacket:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, CAM__PDU__Descriptions::CAM_descr_.raw);
    encoded_length = field_camPacket->RAW_encode(CAM__PDU__Descriptions::CAM_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &CAM__PDU__Descriptions::CAM_descr_;
    break;
  case ALT_denmPacket:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, DENM__PDU__Descriptions::DENM_descr_.raw);
    encoded_length = field_denmPacket->RAW_encode(DENM__PDU__Descriptions::DENM_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &DENM__PDU__Descriptions::DENM_descr_;
    break;
  case ALT_mapPacket:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, MAP__SPAT__ETSI::MAP__PDU_descr_.raw);
    encoded_length = field_mapPacket->RAW_encode(MAP__SPAT__ETSI::MAP__PDU_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &MAP__SPAT__ETSI::MAP__PDU_descr_;
    break;
  case ALT_spatPacket:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, MAP__SPAT__ETSI::SPAT__PDU_descr_.raw);
    encoded_length = field_spatPacket->RAW_encode(MAP__SPAT__ETSI::SPAT__PDU_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &MAP__SPAT__ETSI::SPAT__PDU_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int DecodedBtpPayload::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_camPacket:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "camPacket");
    enc_len += field_camPacket->JSON_encode(CAM__PDU__Descriptions::CAM_descr_, p_tok);
    break;
  case ALT_denmPacket:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "denmPacket");
    enc_len += field_denmPacket->JSON_encode(DENM__PDU__Descriptions::DENM_descr_, p_tok);
    break;
  case ALT_mapPacket:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "mapPacket");
    enc_len += field_mapPacket->JSON_encode(MAP__SPAT__ETSI::MAP__PDU_descr_, p_tok);
    break;
  case ALT_spatPacket:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "spatPacket");
    enc_len += field_spatPacket->JSON_encode(MAP__SPAT__ETSI::SPAT__PDU_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DecodedBtpPayload::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "camPacket", name_len)) {
      int ret_val = camPacket().JSON_decode(CAM__PDU__Descriptions::CAM_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "camPacket");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "denmPacket", name_len)) {
      int ret_val = denmPacket().JSON_decode(DENM__PDU__Descriptions::DENM_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "denmPacket");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "mapPacket", name_len)) {
      int ret_val = mapPacket().JSON_decode(MAP__SPAT__ETSI::MAP__PDU_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "mapPacket");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "spatPacket", name_len)) {
      int ret_val = spatPacket().JSON_decode(MAP__SPAT__ETSI::SPAT__PDU_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "spatPacket");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void DecodedBtpPayload_template::copy_value(const DecodedBtpPayload& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_camPacket:
single_value.field_camPacket = new CAM__PDU__Descriptions::CAM_template(other_value.camPacket());
break;
case DecodedBtpPayload::ALT_denmPacket:
single_value.field_denmPacket = new DENM__PDU__Descriptions::DENM_template(other_value.denmPacket());
break;
case DecodedBtpPayload::ALT_mapPacket:
single_value.field_mapPacket = new MAP__SPAT__ETSI::MAP__PDU_template(other_value.mapPacket());
break;
case DecodedBtpPayload::ALT_spatPacket:
single_value.field_spatPacket = new MAP__SPAT__ETSI::SPAT__PDU_template(other_value.spatPacket());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
set_selection(SPECIFIC_VALUE);
}

void DecodedBtpPayload_template::copy_template(const DecodedBtpPayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_camPacket:
single_value.field_camPacket = new CAM__PDU__Descriptions::CAM_template(*other_value.single_value.field_camPacket);
break;
case DecodedBtpPayload::ALT_denmPacket:
single_value.field_denmPacket = new DENM__PDU__Descriptions::DENM_template(*other_value.single_value.field_denmPacket);
break;
case DecodedBtpPayload::ALT_mapPacket:
single_value.field_mapPacket = new MAP__SPAT__ETSI::MAP__PDU_template(*other_value.single_value.field_mapPacket);
break;
case DecodedBtpPayload::ALT_spatPacket:
single_value.field_spatPacket = new MAP__SPAT__ETSI::SPAT__PDU_template(*other_value.single_value.field_spatPacket);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DecodedBtpPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
set_selection(other_value);
}

DecodedBtpPayload_template::DecodedBtpPayload_template()
{
}

DecodedBtpPayload_template::DecodedBtpPayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DecodedBtpPayload_template::DecodedBtpPayload_template(const DecodedBtpPayload& other_value)
{
copy_value(other_value);
}

DecodedBtpPayload_template::DecodedBtpPayload_template(const OPTIONAL<DecodedBtpPayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DecodedBtpPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload from an unbound optional field.");
}
}

DecodedBtpPayload_template::DecodedBtpPayload_template(const DecodedBtpPayload_template& other_value)
: Base_Template(){
copy_template(other_value);
}

DecodedBtpPayload_template::~DecodedBtpPayload_template()
{
clean_up();
}

void DecodedBtpPayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_camPacket:
delete single_value.field_camPacket;
break;
case DecodedBtpPayload::ALT_denmPacket:
delete single_value.field_denmPacket;
break;
case DecodedBtpPayload::ALT_mapPacket:
delete single_value.field_mapPacket;
break;
case DecodedBtpPayload::ALT_spatPacket:
delete single_value.field_spatPacket;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::operator=(const DecodedBtpPayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::operator=(const OPTIONAL<DecodedBtpPayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DecodedBtpPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
return *this;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::operator=(const DecodedBtpPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DecodedBtpPayload_template::match(const DecodedBtpPayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
DecodedBtpPayload::union_selection_type value_selection = other_value.get_selection();
if (value_selection == DecodedBtpPayload::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case DecodedBtpPayload::ALT_camPacket:
return single_value.field_camPacket->match(other_value.camPacket(), legacy);
case DecodedBtpPayload::ALT_denmPacket:
return single_value.field_denmPacket->match(other_value.denmPacket(), legacy);
case DecodedBtpPayload::ALT_mapPacket:
return single_value.field_mapPacket->match(other_value.mapPacket(), legacy);
case DecodedBtpPayload::ALT_spatPacket:
return single_value.field_spatPacket->match(other_value.spatPacket(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
return FALSE;
}

boolean DecodedBtpPayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_camPacket:
return single_value.field_camPacket->is_value();
case DecodedBtpPayload::ALT_denmPacket:
return single_value.field_denmPacket->is_value();
case DecodedBtpPayload::ALT_mapPacket:
return single_value.field_mapPacket->is_value();
case DecodedBtpPayload::ALT_spatPacket:
return single_value.field_spatPacket->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
}

DecodedBtpPayload DecodedBtpPayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
DecodedBtpPayload ret_val;
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_camPacket:
ret_val.camPacket() = single_value.field_camPacket->valueof();
break;
case DecodedBtpPayload::ALT_denmPacket:
ret_val.denmPacket() = single_value.field_denmPacket->valueof();
break;
case DecodedBtpPayload::ALT_mapPacket:
ret_val.mapPacket() = single_value.field_mapPacket->valueof();
break;
case DecodedBtpPayload::ALT_spatPacket:
ret_val.spatPacket() = single_value.field_spatPacket->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
return ret_val;
}

DecodedBtpPayload_template& DecodedBtpPayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return value_list.list_value[list_index];
}
void DecodedBtpPayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DecodedBtpPayload_template[list_length];
}

CAM__PDU__Descriptions::CAM_template& DecodedBtpPayload_template::camPacket()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DecodedBtpPayload::ALT_camPacket) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_camPacket = new CAM__PDU__Descriptions::CAM_template(ANY_VALUE);
else single_value.field_camPacket = new CAM__PDU__Descriptions::CAM_template;
single_value.union_selection = DecodedBtpPayload::ALT_camPacket;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_camPacket;
}

const CAM__PDU__Descriptions::CAM_template& DecodedBtpPayload_template::camPacket() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field camPacket in a non-specific template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
if (single_value.union_selection != DecodedBtpPayload::ALT_camPacket) TTCN_error("Accessing non-selected field camPacket in a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return *single_value.field_camPacket;
}

DENM__PDU__Descriptions::DENM_template& DecodedBtpPayload_template::denmPacket()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DecodedBtpPayload::ALT_denmPacket) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_denmPacket = new DENM__PDU__Descriptions::DENM_template(ANY_VALUE);
else single_value.field_denmPacket = new DENM__PDU__Descriptions::DENM_template;
single_value.union_selection = DecodedBtpPayload::ALT_denmPacket;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_denmPacket;
}

const DENM__PDU__Descriptions::DENM_template& DecodedBtpPayload_template::denmPacket() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field denmPacket in a non-specific template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
if (single_value.union_selection != DecodedBtpPayload::ALT_denmPacket) TTCN_error("Accessing non-selected field denmPacket in a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return *single_value.field_denmPacket;
}

MAP__SPAT__ETSI::MAP__PDU_template& DecodedBtpPayload_template::mapPacket()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DecodedBtpPayload::ALT_mapPacket) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_mapPacket = new MAP__SPAT__ETSI::MAP__PDU_template(ANY_VALUE);
else single_value.field_mapPacket = new MAP__SPAT__ETSI::MAP__PDU_template;
single_value.union_selection = DecodedBtpPayload::ALT_mapPacket;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_mapPacket;
}

const MAP__SPAT__ETSI::MAP__PDU_template& DecodedBtpPayload_template::mapPacket() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field mapPacket in a non-specific template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
if (single_value.union_selection != DecodedBtpPayload::ALT_mapPacket) TTCN_error("Accessing non-selected field mapPacket in a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return *single_value.field_mapPacket;
}

MAP__SPAT__ETSI::SPAT__PDU_template& DecodedBtpPayload_template::spatPacket()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DecodedBtpPayload::ALT_spatPacket) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_spatPacket = new MAP__SPAT__ETSI::SPAT__PDU_template(ANY_VALUE);
else single_value.field_spatPacket = new MAP__SPAT__ETSI::SPAT__PDU_template;
single_value.union_selection = DecodedBtpPayload::ALT_spatPacket;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_spatPacket;
}

const MAP__SPAT__ETSI::SPAT__PDU_template& DecodedBtpPayload_template::spatPacket() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field spatPacket in a non-specific template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
if (single_value.union_selection != DecodedBtpPayload::ALT_spatPacket) TTCN_error("Accessing non-selected field spatPacket in a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return *single_value.field_spatPacket;
}

boolean DecodedBtpPayload_template::ischosen(DecodedBtpPayload::union_selection_type checked_selection) const
{
if (checked_selection == DecodedBtpPayload::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == DecodedBtpPayload::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload");
}
return FALSE;
}

void DecodedBtpPayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_camPacket:
TTCN_Logger::log_event_str("{ camPacket := ");
single_value.field_camPacket->log();
TTCN_Logger::log_event_str(" }");
break;
case DecodedBtpPayload::ALT_denmPacket:
TTCN_Logger::log_event_str("{ denmPacket := ");
single_value.field_denmPacket->log();
TTCN_Logger::log_event_str(" }");
break;
case DecodedBtpPayload::ALT_mapPacket:
TTCN_Logger::log_event_str("{ mapPacket := ");
single_value.field_mapPacket->log();
TTCN_Logger::log_event_str(" }");
break;
case DecodedBtpPayload::ALT_spatPacket:
TTCN_Logger::log_event_str("{ spatPacket := ");
single_value.field_spatPacket->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DecodedBtpPayload_template::log_match(const DecodedBtpPayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_camPacket:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".camPacket");
single_value.field_camPacket->log_match(match_value.camPacket(), legacy);
} else {
TTCN_Logger::log_event_str("{ camPacket := ");
single_value.field_camPacket->log_match(match_value.camPacket(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case DecodedBtpPayload::ALT_denmPacket:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".denmPacket");
single_value.field_denmPacket->log_match(match_value.denmPacket(), legacy);
} else {
TTCN_Logger::log_event_str("{ denmPacket := ");
single_value.field_denmPacket->log_match(match_value.denmPacket(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case DecodedBtpPayload::ALT_mapPacket:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".mapPacket");
single_value.field_mapPacket->log_match(match_value.mapPacket(), legacy);
} else {
TTCN_Logger::log_event_str("{ mapPacket := ");
single_value.field_mapPacket->log_match(match_value.mapPacket(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case DecodedBtpPayload::ALT_spatPacket:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".spatPacket");
single_value.field_spatPacket->log_match(match_value.spatPacket(), legacy);
} else {
TTCN_Logger::log_event_str("{ spatPacket := ");
single_value.field_spatPacket->log_match(match_value.spatPacket(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DecodedBtpPayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_camPacket:
single_value.field_camPacket->encode_text(text_buf);
break;
case DecodedBtpPayload::ALT_denmPacket:
single_value.field_denmPacket->encode_text(text_buf);
break;
case DecodedBtpPayload::ALT_mapPacket:
single_value.field_mapPacket->encode_text(text_buf);
break;
case DecodedBtpPayload::ALT_spatPacket:
single_value.field_spatPacket->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
}

void DecodedBtpPayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = DecodedBtpPayload::UNBOUND_VALUE;
DecodedBtpPayload::union_selection_type new_selection = (DecodedBtpPayload::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case DecodedBtpPayload::ALT_camPacket:
single_value.field_camPacket = new CAM__PDU__Descriptions::CAM_template;
single_value.field_camPacket->decode_text(text_buf);
break;
case DecodedBtpPayload::ALT_denmPacket:
single_value.field_denmPacket = new DENM__PDU__Descriptions::DENM_template;
single_value.field_denmPacket->decode_text(text_buf);
break;
case DecodedBtpPayload::ALT_mapPacket:
single_value.field_mapPacket = new MAP__SPAT__ETSI::MAP__PDU_template;
single_value.field_mapPacket->decode_text(text_buf);
break;
case DecodedBtpPayload::ALT_spatPacket:
single_value.field_spatPacket = new MAP__SPAT__ETSI::SPAT__PDU_template;
single_value.field_spatPacket->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DecodedBtpPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
}

boolean DecodedBtpPayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DecodedBtpPayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DecodedBtpPayload_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsBtp_TypesAndValues.DecodedBtpPayload'");
    }
    if (strcmp("camPacket", param_field) == 0) {
      camPacket().set_param(param);
      return;
    } else if (strcmp("denmPacket", param_field) == 0) {
      denmPacket().set_param(param);
      return;
    } else if (strcmp("mapPacket", param_field) == 0) {
      mapPacket().set_param(param);
      return;
    } else if (strcmp("spatPacket", param_field) == 0) {
      spatPacket().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsBtp_TypesAndValues.DecodedBtpPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DecodedBtpPayload_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsBtp_TypesAndValues.DecodedBtpPayload");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "camPacket")) {
      camPacket().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "denmPacket")) {
      denmPacket().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "mapPacket")) {
      mapPacket().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "spatPacket")) {
      spatPacket().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsBtp_TypesAndValues.DecodedBtpPayload.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsBtp_TypesAndValues.DecodedBtpPayload");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DecodedBtpPayload_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsBtp_TypesAndValues.DecodedBtpPayload'");
    }
    if (strcmp("camPacket", param_field) == 0) {
      return camPacket().get_param(param_name);
    } else if (strcmp("denmPacket", param_field) == 0) {
      return denmPacket().get_param(param_name);
    } else if (strcmp("mapPacket", param_field) == 0) {
      return mapPacket().get_param(param_name);
    } else if (strcmp("spatPacket", param_field) == 0) {
      return spatPacket().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `DecodedBtpPayload'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case DecodedBtpPayload::ALT_camPacket:
      mp_field = single_value.field_camPacket->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("camPacket")));
      break;
    case DecodedBtpPayload::ALT_denmPacket:
      mp_field = single_value.field_denmPacket->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("denmPacket")));
      break;
    case DecodedBtpPayload::ALT_mapPacket:
      mp_field = single_value.field_mapPacket->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("mapPacket")));
      break;
    case DecodedBtpPayload::ALT_spatPacket:
      mp_field = single_value.field_spatPacket->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("spatPacket")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DecodedBtpPayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case DecodedBtpPayload::ALT_camPacket:
single_value.field_camPacket->check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.DecodedBtpPayload");
return;
case DecodedBtpPayload::ALT_denmPacket:
single_value.field_denmPacket->check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.DecodedBtpPayload");
return;
case DecodedBtpPayload::ALT_mapPacket:
single_value.field_mapPacket->check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.DecodedBtpPayload");
return;
case DecodedBtpPayload::ALT_spatPacket:
single_value.field_spatPacket->check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.DecodedBtpPayload");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsBtp_TypesAndValues.DecodedBtpPayload.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.DecodedBtpPayload");
}

void UtBtpTrigger::copy_value(const UtBtpTrigger& other_value)
{
switch (other_value.union_selection) {
case ALT_btpA:
field_btpA = new GenerateBtpA(*other_value.field_btpA);
break;
case ALT_btpB:
field_btpB = new GenerateBtpB(*other_value.field_btpB);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
union_selection = other_value.union_selection;
}

UtBtpTrigger::UtBtpTrigger()
{
union_selection = UNBOUND_VALUE;
}

UtBtpTrigger::UtBtpTrigger(const UtBtpTrigger& other_value)
: Base_Type(){
copy_value(other_value);
}

UtBtpTrigger::~UtBtpTrigger()
{
clean_up();
}

UtBtpTrigger& UtBtpTrigger::operator=(const UtBtpTrigger& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean UtBtpTrigger::operator==(const UtBtpTrigger& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_btpA:
return *field_btpA == *other_value.field_btpA;
case ALT_btpB:
return *field_btpB == *other_value.field_btpB;
default:
return FALSE;
}
}

GenerateBtpA& UtBtpTrigger::btpA()
{
if (union_selection != ALT_btpA) {
clean_up();
field_btpA = new GenerateBtpA;
union_selection = ALT_btpA;
}
return *field_btpA;
}

const GenerateBtpA& UtBtpTrigger::btpA() const
{
if (union_selection != ALT_btpA) TTCN_error("Using non-selected field btpA in a value of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
return *field_btpA;
}

GenerateBtpB& UtBtpTrigger::btpB()
{
if (union_selection != ALT_btpB) {
clean_up();
field_btpB = new GenerateBtpB;
union_selection = ALT_btpB;
}
return *field_btpB;
}

const GenerateBtpB& UtBtpTrigger::btpB() const
{
if (union_selection != ALT_btpB) TTCN_error("Using non-selected field btpB in a value of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
return *field_btpB;
}

boolean UtBtpTrigger::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
return union_selection == checked_selection;
}

boolean UtBtpTrigger::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean UtBtpTrigger::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_btpA: return field_btpA->is_value();
case ALT_btpB: return field_btpB->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void UtBtpTrigger::clean_up()
{
switch (union_selection) {
case ALT_btpA:
  delete field_btpA;
  break;
case ALT_btpB:
  delete field_btpB;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void UtBtpTrigger::log() const
{
switch (union_selection) {
case ALT_btpA:
TTCN_Logger::log_event_str("{ btpA := ");
field_btpA->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_btpB:
TTCN_Logger::log_event_str("{ btpB := ");
field_btpB->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void UtBtpTrigger::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsBtp_TypesAndValues.UtBtpTrigger'");
    }
    if (strcmp("btpA", param_field) == 0) {
      btpA().set_param(param);
      return;
    } else if (strcmp("btpB", param_field) == 0) {
      btpB().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsBtp_TypesAndValues.UtBtpTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "btpA")) {
    btpA().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "btpB")) {
    btpB().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsBtp_TypesAndValues.UtBtpTrigger.", mp_last->get_id()->get_name());
}

Module_Param* UtBtpTrigger::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsBtp_TypesAndValues.UtBtpTrigger'");
    }
    if (strcmp("btpA", param_field) == 0) {
      return btpA().get_param(param_name);
    } else if (strcmp("btpB", param_field) == 0) {
      return btpB().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `UtBtpTrigger'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_btpA:
    mp_field = field_btpA->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("btpA")));
    break;
  case ALT_btpB:
    mp_field = field_btpB->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("btpB")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void UtBtpTrigger::set_implicit_omit()
{
switch (union_selection) {
case ALT_btpA:
field_btpA->set_implicit_omit(); break;
case ALT_btpB:
field_btpB->set_implicit_omit(); break;
default: break;
}
}

void UtBtpTrigger::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_btpA:
field_btpA->encode_text(text_buf);
break;
case ALT_btpB:
field_btpB->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
}

void UtBtpTrigger::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_btpA:
btpA().decode_text(text_buf);
break;
case ALT_btpB:
btpB().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
}

void UtBtpTrigger::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtBtpTrigger::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtBtpTrigger::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = btpA().RAW_decode(GenerateBtpA_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = btpB().RAW_decode(GenerateBtpB_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = btpA().RAW_decode(GenerateBtpA_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = btpB().RAW_decode(GenerateBtpB_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int UtBtpTrigger::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_btpA:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, GenerateBtpA_descr_.raw);
    encoded_length = field_btpA->RAW_encode(GenerateBtpA_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &GenerateBtpA_descr_;
    break;
  case ALT_btpB:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, GenerateBtpB_descr_.raw);
    encoded_length = field_btpB->RAW_encode(GenerateBtpB_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &GenerateBtpB_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int UtBtpTrigger::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_btpA:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpA");
    enc_len += field_btpA->JSON_encode(GenerateBtpA_descr_, p_tok);
    break;
  case ALT_btpB:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpB");
    enc_len += field_btpB->JSON_encode(GenerateBtpB_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int UtBtpTrigger::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "btpA", name_len)) {
      int ret_val = btpA().JSON_decode(GenerateBtpA_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpA");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "btpB", name_len)) {
      int ret_val = btpB().JSON_decode(GenerateBtpB_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpB");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void UtBtpTrigger_template::copy_value(const UtBtpTrigger& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case UtBtpTrigger::ALT_btpA:
single_value.field_btpA = new GenerateBtpA_template(other_value.btpA());
break;
case UtBtpTrigger::ALT_btpB:
single_value.field_btpB = new GenerateBtpB_template(other_value.btpB());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
set_selection(SPECIFIC_VALUE);
}

void UtBtpTrigger_template::copy_template(const UtBtpTrigger_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case UtBtpTrigger::ALT_btpA:
single_value.field_btpA = new GenerateBtpA_template(*other_value.single_value.field_btpA);
break;
case UtBtpTrigger::ALT_btpB:
single_value.field_btpB = new GenerateBtpB_template(*other_value.single_value.field_btpB);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtBtpTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
set_selection(other_value);
}

UtBtpTrigger_template::UtBtpTrigger_template()
{
}

UtBtpTrigger_template::UtBtpTrigger_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UtBtpTrigger_template::UtBtpTrigger_template(const UtBtpTrigger& other_value)
{
copy_value(other_value);
}

UtBtpTrigger_template::UtBtpTrigger_template(const OPTIONAL<UtBtpTrigger>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtBtpTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger from an unbound optional field.");
}
}

UtBtpTrigger_template::UtBtpTrigger_template(const UtBtpTrigger_template& other_value)
: Base_Template(){
copy_template(other_value);
}

UtBtpTrigger_template::~UtBtpTrigger_template()
{
clean_up();
}

void UtBtpTrigger_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case UtBtpTrigger::ALT_btpA:
delete single_value.field_btpA;
break;
case UtBtpTrigger::ALT_btpB:
delete single_value.field_btpB;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtBtpTrigger_template& UtBtpTrigger_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtBtpTrigger_template& UtBtpTrigger_template::operator=(const UtBtpTrigger& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtBtpTrigger_template& UtBtpTrigger_template::operator=(const OPTIONAL<UtBtpTrigger>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtBtpTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
return *this;
}

UtBtpTrigger_template& UtBtpTrigger_template::operator=(const UtBtpTrigger_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UtBtpTrigger_template::match(const UtBtpTrigger& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
UtBtpTrigger::union_selection_type value_selection = other_value.get_selection();
if (value_selection == UtBtpTrigger::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case UtBtpTrigger::ALT_btpA:
return single_value.field_btpA->match(other_value.btpA(), legacy);
case UtBtpTrigger::ALT_btpB:
return single_value.field_btpB->match(other_value.btpB(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
return FALSE;
}

boolean UtBtpTrigger_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case UtBtpTrigger::ALT_btpA:
return single_value.field_btpA->is_value();
case UtBtpTrigger::ALT_btpB:
return single_value.field_btpB->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
}

UtBtpTrigger UtBtpTrigger_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
UtBtpTrigger ret_val;
switch (single_value.union_selection) {
case UtBtpTrigger::ALT_btpA:
ret_val.btpA() = single_value.field_btpA->valueof();
break;
case UtBtpTrigger::ALT_btpB:
ret_val.btpB() = single_value.field_btpB->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
return ret_val;
}

UtBtpTrigger_template& UtBtpTrigger_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
return value_list.list_value[list_index];
}
void UtBtpTrigger_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UtBtpTrigger_template[list_length];
}

GenerateBtpA_template& UtBtpTrigger_template::btpA()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtBtpTrigger::ALT_btpA) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_btpA = new GenerateBtpA_template(ANY_VALUE);
else single_value.field_btpA = new GenerateBtpA_template;
single_value.union_selection = UtBtpTrigger::ALT_btpA;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_btpA;
}

const GenerateBtpA_template& UtBtpTrigger_template::btpA() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field btpA in a non-specific template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
if (single_value.union_selection != UtBtpTrigger::ALT_btpA) TTCN_error("Accessing non-selected field btpA in a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
return *single_value.field_btpA;
}

GenerateBtpB_template& UtBtpTrigger_template::btpB()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtBtpTrigger::ALT_btpB) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_btpB = new GenerateBtpB_template(ANY_VALUE);
else single_value.field_btpB = new GenerateBtpB_template;
single_value.union_selection = UtBtpTrigger::ALT_btpB;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_btpB;
}

const GenerateBtpB_template& UtBtpTrigger_template::btpB() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field btpB in a non-specific template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
if (single_value.union_selection != UtBtpTrigger::ALT_btpB) TTCN_error("Accessing non-selected field btpB in a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
return *single_value.field_btpB;
}

boolean UtBtpTrigger_template::ischosen(UtBtpTrigger::union_selection_type checked_selection) const
{
if (checked_selection == UtBtpTrigger::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == UtBtpTrigger::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger");
}
return FALSE;
}

void UtBtpTrigger_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case UtBtpTrigger::ALT_btpA:
TTCN_Logger::log_event_str("{ btpA := ");
single_value.field_btpA->log();
TTCN_Logger::log_event_str(" }");
break;
case UtBtpTrigger::ALT_btpB:
TTCN_Logger::log_event_str("{ btpB := ");
single_value.field_btpB->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UtBtpTrigger_template::log_match(const UtBtpTrigger& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case UtBtpTrigger::ALT_btpA:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".btpA");
single_value.field_btpA->log_match(match_value.btpA(), legacy);
} else {
TTCN_Logger::log_event_str("{ btpA := ");
single_value.field_btpA->log_match(match_value.btpA(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtBtpTrigger::ALT_btpB:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".btpB");
single_value.field_btpB->log_match(match_value.btpB(), legacy);
} else {
TTCN_Logger::log_event_str("{ btpB := ");
single_value.field_btpB->log_match(match_value.btpB(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtBtpTrigger_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case UtBtpTrigger::ALT_btpA:
single_value.field_btpA->encode_text(text_buf);
break;
case UtBtpTrigger::ALT_btpB:
single_value.field_btpB->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
}

void UtBtpTrigger_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = UtBtpTrigger::UNBOUND_VALUE;
UtBtpTrigger::union_selection_type new_selection = (UtBtpTrigger::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case UtBtpTrigger::ALT_btpA:
single_value.field_btpA = new GenerateBtpA_template;
single_value.field_btpA->decode_text(text_buf);
break;
case UtBtpTrigger::ALT_btpB:
single_value.field_btpB = new GenerateBtpB_template;
single_value.field_btpB->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtBtpTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
}

boolean UtBtpTrigger_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtBtpTrigger_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void UtBtpTrigger_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsBtp_TypesAndValues.UtBtpTrigger'");
    }
    if (strcmp("btpA", param_field) == 0) {
      btpA().set_param(param);
      return;
    } else if (strcmp("btpB", param_field) == 0) {
      btpB().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsBtp_TypesAndValues.UtBtpTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtBtpTrigger_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsBtp_TypesAndValues.UtBtpTrigger");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "btpA")) {
      btpA().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "btpB")) {
      btpB().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsBtp_TypesAndValues.UtBtpTrigger.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsBtp_TypesAndValues.UtBtpTrigger");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* UtBtpTrigger_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsBtp_TypesAndValues.UtBtpTrigger'");
    }
    if (strcmp("btpA", param_field) == 0) {
      return btpA().get_param(param_name);
    } else if (strcmp("btpB", param_field) == 0) {
      return btpB().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `UtBtpTrigger'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case UtBtpTrigger::ALT_btpA:
      mp_field = single_value.field_btpA->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("btpA")));
      break;
    case UtBtpTrigger::ALT_btpB:
      mp_field = single_value.field_btpB->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("btpB")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void UtBtpTrigger_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case UtBtpTrigger::ALT_btpA:
single_value.field_btpA->check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.UtBtpTrigger");
return;
case UtBtpTrigger::ALT_btpB:
single_value.field_btpB->check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.UtBtpTrigger");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsBtp_TypesAndValues.UtBtpTrigger.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.UtBtpTrigger");
}

GenerateBtpA::GenerateBtpA()
{
  bound_flag = FALSE;
}

GenerateBtpA::GenerateBtpA(const BtpAHeader& par_btpAHeader)
  :   field_btpAHeader(par_btpAHeader)
{
  bound_flag = TRUE;
}

GenerateBtpA::GenerateBtpA(const GenerateBtpA& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
bound_flag = TRUE;
if (other_value.btpAHeader().is_bound()) field_btpAHeader = other_value.btpAHeader();
else field_btpAHeader.clean_up();
}

void GenerateBtpA::clean_up()
{
field_btpAHeader.clean_up();
bound_flag = FALSE;
}

GenerateBtpA& GenerateBtpA::operator=(const GenerateBtpA& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
  bound_flag = TRUE;
  if (other_value.btpAHeader().is_bound()) field_btpAHeader = other_value.btpAHeader();
  else field_btpAHeader.clean_up();
}
return *this;
}

boolean GenerateBtpA::operator==(const GenerateBtpA& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_btpAHeader==other_value.field_btpAHeader;
}

boolean GenerateBtpA::is_bound() const
{
if (bound_flag) return TRUE;
if(field_btpAHeader.is_bound()) return TRUE;
return FALSE;
}
boolean GenerateBtpA::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_btpAHeader.is_value()) return FALSE;
return TRUE;
}
int GenerateBtpA::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsBtp_TypesAndValues.GenerateBtpA");
  return 1;
}

void GenerateBtpA::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ btpAHeader := ");
field_btpAHeader.log();
TTCN_Logger::log_event_str(" }");
}

void GenerateBtpA::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsBtp_TypesAndValues.GenerateBtpA'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      btpAHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.GenerateBtpA'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsBtp_TypesAndValues.GenerateBtpA has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) btpAHeader().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpAHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpAHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.GenerateBtpA: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsBtp_TypesAndValues.GenerateBtpA");
  }
}

Module_Param* GenerateBtpA::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsBtp_TypesAndValues.GenerateBtpA'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      return btpAHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.GenerateBtpA'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_btpAHeader = field_btpAHeader.get_param(param_name);
  mp_field_btpAHeader->set_id(new Module_Param_FieldName(mcopystr("btpAHeader")));
  mp->add_elem(mp_field_btpAHeader);
  return mp;
  }

void GenerateBtpA::set_implicit_omit()
{
if (btpAHeader().is_bound()) btpAHeader().set_implicit_omit();
}

void GenerateBtpA::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
field_btpAHeader.encode_text(text_buf);
}

void GenerateBtpA::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_btpAHeader.decode_text(text_buf);
}

void GenerateBtpA::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GenerateBtpA::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GenerateBtpA::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_btpAHeader.RAW_decode(BtpAHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GenerateBtpA::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BtpAHeader_descr_.raw);
  encoded_length += field_btpAHeader.RAW_encode(BtpAHeader_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int GenerateBtpA::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpAHeader");
    enc_len += field_btpAHeader.JSON_encode(BtpAHeader_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GenerateBtpA::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "btpAHeader", name_len)) {
         int ret_val = field_btpAHeader.JSON_decode(BtpAHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpAHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_btpAHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpAHeader");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GenerateBtpA_template::single_value_struct {
BtpAHeader_template field_btpAHeader;
};

void GenerateBtpA_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_btpAHeader = ANY_VALUE;
}
}
}

void GenerateBtpA_template::copy_value(const GenerateBtpA& other_value)
{
single_value = new single_value_struct;
if (other_value.btpAHeader().is_bound()) {
  single_value->field_btpAHeader = other_value.btpAHeader();
} else {
  single_value->field_btpAHeader.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GenerateBtpA_template::copy_template(const GenerateBtpA_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.btpAHeader().get_selection()) {
single_value->field_btpAHeader = other_value.btpAHeader();
} else {
single_value->field_btpAHeader.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GenerateBtpA_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
break;
}
set_selection(other_value);
}

GenerateBtpA_template::GenerateBtpA_template()
{
}

GenerateBtpA_template::GenerateBtpA_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GenerateBtpA_template::GenerateBtpA_template(const GenerateBtpA& other_value)
{
copy_value(other_value);
}

GenerateBtpA_template::GenerateBtpA_template(const OPTIONAL<GenerateBtpA>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateBtpA&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsBtp_TypesAndValues.GenerateBtpA from an unbound optional field.");
}
}

GenerateBtpA_template::GenerateBtpA_template(const GenerateBtpA_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GenerateBtpA_template::~GenerateBtpA_template()
{
clean_up();
}

GenerateBtpA_template& GenerateBtpA_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GenerateBtpA_template& GenerateBtpA_template::operator=(const GenerateBtpA& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GenerateBtpA_template& GenerateBtpA_template::operator=(const OPTIONAL<GenerateBtpA>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateBtpA&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
}
return *this;
}

GenerateBtpA_template& GenerateBtpA_template::operator=(const GenerateBtpA_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GenerateBtpA_template::match(const GenerateBtpA& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.btpAHeader().is_bound()) return FALSE;
if(!single_value->field_btpAHeader.match(other_value.btpAHeader(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
}
return FALSE;
}

boolean GenerateBtpA_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_btpAHeader.is_bound()) return TRUE;
return FALSE;
}

boolean GenerateBtpA_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_btpAHeader.is_value()) return FALSE;
return TRUE;
}

void GenerateBtpA_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GenerateBtpA GenerateBtpA_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
GenerateBtpA ret_val;
if (single_value->field_btpAHeader.is_bound()) {
ret_val.btpAHeader() = single_value->field_btpAHeader.valueof();
}
return ret_val;
}

void GenerateBtpA_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GenerateBtpA_template[list_length];
}

GenerateBtpA_template& GenerateBtpA_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
return value_list.list_value[list_index];
}

BtpAHeader_template& GenerateBtpA_template::btpAHeader()
{
set_specific();
return single_value->field_btpAHeader;
}

const BtpAHeader_template& GenerateBtpA_template::btpAHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpAHeader of a non-specific template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
return single_value->field_btpAHeader;
}

int GenerateBtpA_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpA which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpA containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpA containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpA containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpA containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpA containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
  }
  return 0;
}

void GenerateBtpA_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ btpAHeader := ");
single_value->field_btpAHeader.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GenerateBtpA_template::log_match(const GenerateBtpA& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_btpAHeader.match(match_value.btpAHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".btpAHeader");
single_value->field_btpAHeader.log_match(match_value.btpAHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ btpAHeader := ");
single_value->field_btpAHeader.log_match(match_value.btpAHeader(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GenerateBtpA_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_btpAHeader.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
}
}

void GenerateBtpA_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_btpAHeader.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GenerateBtpA_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsBtp_TypesAndValues.GenerateBtpA.");
}
}

void GenerateBtpA_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsBtp_TypesAndValues.GenerateBtpA'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      btpAHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsBtp_TypesAndValues.GenerateBtpA'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GenerateBtpA_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsBtp_TypesAndValues.GenerateBtpA has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) btpAHeader().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpAHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpAHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.GenerateBtpA: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsBtp_TypesAndValues.GenerateBtpA");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GenerateBtpA_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsBtp_TypesAndValues.GenerateBtpA'");
    }
    if (strcmp("btpAHeader", param_field) == 0) {
      return btpAHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.GenerateBtpA'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_btpAHeader = single_value->field_btpAHeader.get_param(param_name);
    mp_field_btpAHeader->set_id(new Module_Param_FieldName(mcopystr("btpAHeader")));
    mp->add_elem(mp_field_btpAHeader);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GenerateBtpA_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_btpAHeader.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.GenerateBtpA");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.GenerateBtpA");
}

boolean GenerateBtpA_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GenerateBtpA_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GenerateBtpB::GenerateBtpB()
{
  bound_flag = FALSE;
}

GenerateBtpB::GenerateBtpB(const BtpBHeader& par_btpBHeader)
  :   field_btpBHeader(par_btpBHeader)
{
  bound_flag = TRUE;
}

GenerateBtpB::GenerateBtpB(const GenerateBtpB& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
bound_flag = TRUE;
if (other_value.btpBHeader().is_bound()) field_btpBHeader = other_value.btpBHeader();
else field_btpBHeader.clean_up();
}

void GenerateBtpB::clean_up()
{
field_btpBHeader.clean_up();
bound_flag = FALSE;
}

GenerateBtpB& GenerateBtpB::operator=(const GenerateBtpB& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
  bound_flag = TRUE;
  if (other_value.btpBHeader().is_bound()) field_btpBHeader = other_value.btpBHeader();
  else field_btpBHeader.clean_up();
}
return *this;
}

boolean GenerateBtpB::operator==(const GenerateBtpB& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_btpBHeader==other_value.field_btpBHeader;
}

boolean GenerateBtpB::is_bound() const
{
if (bound_flag) return TRUE;
if(field_btpBHeader.is_bound()) return TRUE;
return FALSE;
}
boolean GenerateBtpB::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_btpBHeader.is_value()) return FALSE;
return TRUE;
}
int GenerateBtpB::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsBtp_TypesAndValues.GenerateBtpB");
  return 1;
}

void GenerateBtpB::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ btpBHeader := ");
field_btpBHeader.log();
TTCN_Logger::log_event_str(" }");
}

void GenerateBtpB::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsBtp_TypesAndValues.GenerateBtpB'");
    }
    if (strcmp("btpBHeader", param_field) == 0) {
      btpBHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.GenerateBtpB'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsBtp_TypesAndValues.GenerateBtpB has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) btpBHeader().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpBHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpBHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.GenerateBtpB: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsBtp_TypesAndValues.GenerateBtpB");
  }
}

Module_Param* GenerateBtpB::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsBtp_TypesAndValues.GenerateBtpB'");
    }
    if (strcmp("btpBHeader", param_field) == 0) {
      return btpBHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.GenerateBtpB'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_btpBHeader = field_btpBHeader.get_param(param_name);
  mp_field_btpBHeader->set_id(new Module_Param_FieldName(mcopystr("btpBHeader")));
  mp->add_elem(mp_field_btpBHeader);
  return mp;
  }

void GenerateBtpB::set_implicit_omit()
{
if (btpBHeader().is_bound()) btpBHeader().set_implicit_omit();
}

void GenerateBtpB::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
field_btpBHeader.encode_text(text_buf);
}

void GenerateBtpB::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_btpBHeader.decode_text(text_buf);
}

void GenerateBtpB::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GenerateBtpB::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GenerateBtpB::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_btpBHeader.RAW_decode(BtpBHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GenerateBtpB::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BtpBHeader_descr_.raw);
  encoded_length += field_btpBHeader.RAW_encode(BtpBHeader_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int GenerateBtpB::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpBHeader");
    enc_len += field_btpBHeader.JSON_encode(BtpBHeader_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GenerateBtpB::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "btpBHeader", name_len)) {
         int ret_val = field_btpBHeader.JSON_decode(BtpBHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpBHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_btpBHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpBHeader");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GenerateBtpB_template::single_value_struct {
BtpBHeader_template field_btpBHeader;
};

void GenerateBtpB_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_btpBHeader = ANY_VALUE;
}
}
}

void GenerateBtpB_template::copy_value(const GenerateBtpB& other_value)
{
single_value = new single_value_struct;
if (other_value.btpBHeader().is_bound()) {
  single_value->field_btpBHeader = other_value.btpBHeader();
} else {
  single_value->field_btpBHeader.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GenerateBtpB_template::copy_template(const GenerateBtpB_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.btpBHeader().get_selection()) {
single_value->field_btpBHeader = other_value.btpBHeader();
} else {
single_value->field_btpBHeader.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GenerateBtpB_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
break;
}
set_selection(other_value);
}

GenerateBtpB_template::GenerateBtpB_template()
{
}

GenerateBtpB_template::GenerateBtpB_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GenerateBtpB_template::GenerateBtpB_template(const GenerateBtpB& other_value)
{
copy_value(other_value);
}

GenerateBtpB_template::GenerateBtpB_template(const OPTIONAL<GenerateBtpB>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateBtpB&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsBtp_TypesAndValues.GenerateBtpB from an unbound optional field.");
}
}

GenerateBtpB_template::GenerateBtpB_template(const GenerateBtpB_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GenerateBtpB_template::~GenerateBtpB_template()
{
clean_up();
}

GenerateBtpB_template& GenerateBtpB_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GenerateBtpB_template& GenerateBtpB_template::operator=(const GenerateBtpB& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GenerateBtpB_template& GenerateBtpB_template::operator=(const OPTIONAL<GenerateBtpB>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateBtpB&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
}
return *this;
}

GenerateBtpB_template& GenerateBtpB_template::operator=(const GenerateBtpB_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GenerateBtpB_template::match(const GenerateBtpB& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.btpBHeader().is_bound()) return FALSE;
if(!single_value->field_btpBHeader.match(other_value.btpBHeader(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
}
return FALSE;
}

boolean GenerateBtpB_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_btpBHeader.is_bound()) return TRUE;
return FALSE;
}

boolean GenerateBtpB_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_btpBHeader.is_value()) return FALSE;
return TRUE;
}

void GenerateBtpB_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GenerateBtpB GenerateBtpB_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
GenerateBtpB ret_val;
if (single_value->field_btpBHeader.is_bound()) {
ret_val.btpBHeader() = single_value->field_btpBHeader.valueof();
}
return ret_val;
}

void GenerateBtpB_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GenerateBtpB_template[list_length];
}

GenerateBtpB_template& GenerateBtpB_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
return value_list.list_value[list_index];
}

BtpBHeader_template& GenerateBtpB_template::btpBHeader()
{
set_specific();
return single_value->field_btpBHeader;
}

const BtpBHeader_template& GenerateBtpB_template::btpBHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpBHeader of a non-specific template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
return single_value->field_btpBHeader;
}

int GenerateBtpB_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpB which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpB containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpB containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpB containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpB containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.GenerateBtpB containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
  }
  return 0;
}

void GenerateBtpB_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ btpBHeader := ");
single_value->field_btpBHeader.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GenerateBtpB_template::log_match(const GenerateBtpB& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_btpBHeader.match(match_value.btpBHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".btpBHeader");
single_value->field_btpBHeader.log_match(match_value.btpBHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ btpBHeader := ");
single_value->field_btpBHeader.log_match(match_value.btpBHeader(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GenerateBtpB_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_btpBHeader.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
}
}

void GenerateBtpB_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_btpBHeader.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GenerateBtpB_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsBtp_TypesAndValues.GenerateBtpB.");
}
}

void GenerateBtpB_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsBtp_TypesAndValues.GenerateBtpB'");
    }
    if (strcmp("btpBHeader", param_field) == 0) {
      btpBHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsBtp_TypesAndValues.GenerateBtpB'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GenerateBtpB_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsBtp_TypesAndValues.GenerateBtpB has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) btpBHeader().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpBHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpBHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.GenerateBtpB: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsBtp_TypesAndValues.GenerateBtpB");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GenerateBtpB_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsBtp_TypesAndValues.GenerateBtpB'");
    }
    if (strcmp("btpBHeader", param_field) == 0) {
      return btpBHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.GenerateBtpB'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_btpBHeader = single_value->field_btpBHeader.get_param(param_name);
    mp_field_btpBHeader->set_id(new Module_Param_FieldName(mcopystr("btpBHeader")));
    mp->add_elem(mp_field_btpBHeader);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GenerateBtpB_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_btpBHeader.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.GenerateBtpB");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.GenerateBtpB");
}

boolean GenerateBtpB_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GenerateBtpB_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

UtBtpTriggerResult::UtBtpTriggerResult()
{
  bound_flag = FALSE;
}

UtBtpTriggerResult::UtBtpTriggerResult(const BOOLEAN& par_utBtpTriggerResult)
  :   field_utBtpTriggerResult(par_utBtpTriggerResult)
{
  bound_flag = TRUE;
}

UtBtpTriggerResult::UtBtpTriggerResult(const UtBtpTriggerResult& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
bound_flag = TRUE;
if (other_value.utBtpTriggerResult().is_bound()) field_utBtpTriggerResult = other_value.utBtpTriggerResult();
else field_utBtpTriggerResult.clean_up();
}

void UtBtpTriggerResult::clean_up()
{
field_utBtpTriggerResult.clean_up();
bound_flag = FALSE;
}

UtBtpTriggerResult& UtBtpTriggerResult::operator=(const UtBtpTriggerResult& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
  bound_flag = TRUE;
  if (other_value.utBtpTriggerResult().is_bound()) field_utBtpTriggerResult = other_value.utBtpTriggerResult();
  else field_utBtpTriggerResult.clean_up();
}
return *this;
}

boolean UtBtpTriggerResult::operator==(const UtBtpTriggerResult& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_utBtpTriggerResult==other_value.field_utBtpTriggerResult;
}

boolean UtBtpTriggerResult::is_bound() const
{
if (bound_flag) return TRUE;
if(field_utBtpTriggerResult.is_bound()) return TRUE;
return FALSE;
}
boolean UtBtpTriggerResult::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_utBtpTriggerResult.is_value()) return FALSE;
return TRUE;
}
int UtBtpTriggerResult::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult");
  return 1;
}

void UtBtpTriggerResult::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ utBtpTriggerResult := ");
field_utBtpTriggerResult.log();
TTCN_Logger::log_event_str(" }");
}

void UtBtpTriggerResult::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsBtp_TypesAndValues.UtBtpTriggerResult'");
    }
    if (strcmp("utBtpTriggerResult", param_field) == 0) {
      utBtpTriggerResult().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.UtBtpTriggerResult'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) utBtpTriggerResult().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "utBtpTriggerResult")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          utBtpTriggerResult().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.UtBtpTriggerResult: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsBtp_TypesAndValues.UtBtpTriggerResult");
  }
}

Module_Param* UtBtpTriggerResult::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsBtp_TypesAndValues.UtBtpTriggerResult'");
    }
    if (strcmp("utBtpTriggerResult", param_field) == 0) {
      return utBtpTriggerResult().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.UtBtpTriggerResult'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_utBtpTriggerResult = field_utBtpTriggerResult.get_param(param_name);
  mp_field_utBtpTriggerResult->set_id(new Module_Param_FieldName(mcopystr("utBtpTriggerResult")));
  mp->add_elem(mp_field_utBtpTriggerResult);
  return mp;
  }

void UtBtpTriggerResult::set_implicit_omit()
{
if (utBtpTriggerResult().is_bound()) utBtpTriggerResult().set_implicit_omit();
}

void UtBtpTriggerResult::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
field_utBtpTriggerResult.encode_text(text_buf);
}

void UtBtpTriggerResult::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_utBtpTriggerResult.decode_text(text_buf);
}

void UtBtpTriggerResult::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtBtpTriggerResult::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtBtpTriggerResult::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_utBtpTriggerResult.RAW_decode(UtBtpTriggerResult_utBtpTriggerResult_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int UtBtpTriggerResult::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, UtBtpTriggerResult_utBtpTriggerResult_descr_.raw);
  encoded_length += field_utBtpTriggerResult.RAW_encode(UtBtpTriggerResult_utBtpTriggerResult_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int UtBtpTriggerResult::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "utBtpTriggerResult");
    enc_len += field_utBtpTriggerResult.JSON_encode(UtBtpTriggerResult_utBtpTriggerResult_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int UtBtpTriggerResult::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "utBtpTriggerResult", name_len)) {
         int ret_val = field_utBtpTriggerResult.JSON_decode(UtBtpTriggerResult_utBtpTriggerResult_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "utBtpTriggerResult");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_utBtpTriggerResult.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "utBtpTriggerResult");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct UtBtpTriggerResult_template::single_value_struct {
BOOLEAN_template field_utBtpTriggerResult;
};

void UtBtpTriggerResult_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_utBtpTriggerResult = ANY_VALUE;
}
}
}

void UtBtpTriggerResult_template::copy_value(const UtBtpTriggerResult& other_value)
{
single_value = new single_value_struct;
if (other_value.utBtpTriggerResult().is_bound()) {
  single_value->field_utBtpTriggerResult = other_value.utBtpTriggerResult();
} else {
  single_value->field_utBtpTriggerResult.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void UtBtpTriggerResult_template::copy_template(const UtBtpTriggerResult_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.utBtpTriggerResult().get_selection()) {
single_value->field_utBtpTriggerResult = other_value.utBtpTriggerResult();
} else {
single_value->field_utBtpTriggerResult.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtBtpTriggerResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
break;
}
set_selection(other_value);
}

UtBtpTriggerResult_template::UtBtpTriggerResult_template()
{
}

UtBtpTriggerResult_template::UtBtpTriggerResult_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UtBtpTriggerResult_template::UtBtpTriggerResult_template(const UtBtpTriggerResult& other_value)
{
copy_value(other_value);
}

UtBtpTriggerResult_template::UtBtpTriggerResult_template(const OPTIONAL<UtBtpTriggerResult>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtBtpTriggerResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult from an unbound optional field.");
}
}

UtBtpTriggerResult_template::UtBtpTriggerResult_template(const UtBtpTriggerResult_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

UtBtpTriggerResult_template::~UtBtpTriggerResult_template()
{
clean_up();
}

UtBtpTriggerResult_template& UtBtpTriggerResult_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtBtpTriggerResult_template& UtBtpTriggerResult_template::operator=(const UtBtpTriggerResult& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtBtpTriggerResult_template& UtBtpTriggerResult_template::operator=(const OPTIONAL<UtBtpTriggerResult>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtBtpTriggerResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
}
return *this;
}

UtBtpTriggerResult_template& UtBtpTriggerResult_template::operator=(const UtBtpTriggerResult_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UtBtpTriggerResult_template::match(const UtBtpTriggerResult& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.utBtpTriggerResult().is_bound()) return FALSE;
if(!single_value->field_utBtpTriggerResult.match(other_value.utBtpTriggerResult(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
}
return FALSE;
}

boolean UtBtpTriggerResult_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_utBtpTriggerResult.is_bound()) return TRUE;
return FALSE;
}

boolean UtBtpTriggerResult_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_utBtpTriggerResult.is_value()) return FALSE;
return TRUE;
}

void UtBtpTriggerResult_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtBtpTriggerResult UtBtpTriggerResult_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
UtBtpTriggerResult ret_val;
if (single_value->field_utBtpTriggerResult.is_bound()) {
ret_val.utBtpTriggerResult() = single_value->field_utBtpTriggerResult.valueof();
}
return ret_val;
}

void UtBtpTriggerResult_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UtBtpTriggerResult_template[list_length];
}

UtBtpTriggerResult_template& UtBtpTriggerResult_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
return value_list.list_value[list_index];
}

BOOLEAN_template& UtBtpTriggerResult_template::utBtpTriggerResult()
{
set_specific();
return single_value->field_utBtpTriggerResult;
}

const BOOLEAN_template& UtBtpTriggerResult_template::utBtpTriggerResult() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field utBtpTriggerResult of a non-specific template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
return single_value->field_utBtpTriggerResult;
}

int UtBtpTriggerResult_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
  }
  return 0;
}

void UtBtpTriggerResult_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ utBtpTriggerResult := ");
single_value->field_utBtpTriggerResult.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UtBtpTriggerResult_template::log_match(const UtBtpTriggerResult& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_utBtpTriggerResult.match(match_value.utBtpTriggerResult(), legacy)){
TTCN_Logger::log_logmatch_info(".utBtpTriggerResult");
single_value->field_utBtpTriggerResult.log_match(match_value.utBtpTriggerResult(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ utBtpTriggerResult := ");
single_value->field_utBtpTriggerResult.log_match(match_value.utBtpTriggerResult(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtBtpTriggerResult_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_utBtpTriggerResult.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
}
}

void UtBtpTriggerResult_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_utBtpTriggerResult.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtBtpTriggerResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult.");
}
}

void UtBtpTriggerResult_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsBtp_TypesAndValues.UtBtpTriggerResult'");
    }
    if (strcmp("utBtpTriggerResult", param_field) == 0) {
      utBtpTriggerResult().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsBtp_TypesAndValues.UtBtpTriggerResult'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtBtpTriggerResult_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsBtp_TypesAndValues.UtBtpTriggerResult has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) utBtpTriggerResult().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "utBtpTriggerResult")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          utBtpTriggerResult().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.UtBtpTriggerResult: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsBtp_TypesAndValues.UtBtpTriggerResult");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* UtBtpTriggerResult_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsBtp_TypesAndValues.UtBtpTriggerResult'");
    }
    if (strcmp("utBtpTriggerResult", param_field) == 0) {
      return utBtpTriggerResult().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.UtBtpTriggerResult'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_utBtpTriggerResult = single_value->field_utBtpTriggerResult.get_param(param_name);
    mp_field_utBtpTriggerResult->set_id(new Module_Param_FieldName(mcopystr("utBtpTriggerResult")));
    mp->add_elem(mp_field_utBtpTriggerResult);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void UtBtpTriggerResult_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_utBtpTriggerResult.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.UtBtpTriggerResult");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.UtBtpTriggerResult");
}

boolean UtBtpTriggerResult_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtBtpTriggerResult_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

UtBtpEventInd::UtBtpEventInd()
{
  bound_flag = FALSE;
}

UtBtpEventInd::UtBtpEventInd(const OCTETSTRING& par_rawPayload)
  :   field_rawPayload(par_rawPayload)
{
  bound_flag = TRUE;
}

UtBtpEventInd::UtBtpEventInd(const UtBtpEventInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
bound_flag = TRUE;
if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
else field_rawPayload.clean_up();
}

void UtBtpEventInd::clean_up()
{
field_rawPayload.clean_up();
bound_flag = FALSE;
}

UtBtpEventInd& UtBtpEventInd::operator=(const UtBtpEventInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
  bound_flag = TRUE;
  if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
  else field_rawPayload.clean_up();
}
return *this;
}

boolean UtBtpEventInd::operator==(const UtBtpEventInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_rawPayload==other_value.field_rawPayload;
}

boolean UtBtpEventInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_rawPayload.is_bound()) return TRUE;
return FALSE;
}
boolean UtBtpEventInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_rawPayload.is_value()) return FALSE;
return TRUE;
}
int UtBtpEventInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsBtp_TypesAndValues.UtBtpEventInd");
  return 1;
}

void UtBtpEventInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ rawPayload := ");
field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
}

void UtBtpEventInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsBtp_TypesAndValues.UtBtpEventInd'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.UtBtpEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsBtp_TypesAndValues.UtBtpEventInd has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.UtBtpEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsBtp_TypesAndValues.UtBtpEventInd");
  }
}

Module_Param* UtBtpEventInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsBtp_TypesAndValues.UtBtpEventInd'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.UtBtpEventInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_rawPayload = field_rawPayload.get_param(param_name);
  mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
  mp->add_elem(mp_field_rawPayload);
  return mp;
  }

void UtBtpEventInd::set_implicit_omit()
{
if (rawPayload().is_bound()) rawPayload().set_implicit_omit();
}

void UtBtpEventInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
field_rawPayload.encode_text(text_buf);
}

void UtBtpEventInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_rawPayload.decode_text(text_buf);
}

void UtBtpEventInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtBtpEventInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtBtpEventInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_rawPayload.RAW_decode(BtpRawPayload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int UtBtpEventInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BtpRawPayload_descr_.raw);
  encoded_length += field_rawPayload.RAW_encode(BtpRawPayload_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int UtBtpEventInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rawPayload");
    enc_len += field_rawPayload.JSON_encode(BtpRawPayload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int UtBtpEventInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "rawPayload", name_len)) {
         int ret_val = field_rawPayload.JSON_decode(BtpRawPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rawPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_rawPayload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rawPayload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct UtBtpEventInd_template::single_value_struct {
OCTETSTRING_template field_rawPayload;
};

void UtBtpEventInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_rawPayload = ANY_VALUE;
}
}
}

void UtBtpEventInd_template::copy_value(const UtBtpEventInd& other_value)
{
single_value = new single_value_struct;
if (other_value.rawPayload().is_bound()) {
  single_value->field_rawPayload = other_value.rawPayload();
} else {
  single_value->field_rawPayload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void UtBtpEventInd_template::copy_template(const UtBtpEventInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.rawPayload().get_selection()) {
single_value->field_rawPayload = other_value.rawPayload();
} else {
single_value->field_rawPayload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtBtpEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
break;
}
set_selection(other_value);
}

UtBtpEventInd_template::UtBtpEventInd_template()
{
}

UtBtpEventInd_template::UtBtpEventInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UtBtpEventInd_template::UtBtpEventInd_template(const UtBtpEventInd& other_value)
{
copy_value(other_value);
}

UtBtpEventInd_template::UtBtpEventInd_template(const OPTIONAL<UtBtpEventInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtBtpEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd from an unbound optional field.");
}
}

UtBtpEventInd_template::UtBtpEventInd_template(const UtBtpEventInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

UtBtpEventInd_template::~UtBtpEventInd_template()
{
clean_up();
}

UtBtpEventInd_template& UtBtpEventInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtBtpEventInd_template& UtBtpEventInd_template::operator=(const UtBtpEventInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtBtpEventInd_template& UtBtpEventInd_template::operator=(const OPTIONAL<UtBtpEventInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtBtpEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
}
return *this;
}

UtBtpEventInd_template& UtBtpEventInd_template::operator=(const UtBtpEventInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UtBtpEventInd_template::match(const UtBtpEventInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.rawPayload().is_bound()) return FALSE;
if(!single_value->field_rawPayload.match(other_value.rawPayload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
}
return FALSE;
}

boolean UtBtpEventInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_rawPayload.is_bound()) return TRUE;
return FALSE;
}

boolean UtBtpEventInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_rawPayload.is_value()) return FALSE;
return TRUE;
}

void UtBtpEventInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtBtpEventInd UtBtpEventInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
UtBtpEventInd ret_val;
if (single_value->field_rawPayload.is_bound()) {
ret_val.rawPayload() = single_value->field_rawPayload.valueof();
}
return ret_val;
}

void UtBtpEventInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UtBtpEventInd_template[list_length];
}

UtBtpEventInd_template& UtBtpEventInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& UtBtpEventInd_template::rawPayload()
{
set_specific();
return single_value->field_rawPayload;
}

const OCTETSTRING_template& UtBtpEventInd_template::rawPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawPayload of a non-specific template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
return single_value->field_rawPayload;
}

int UtBtpEventInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
  }
  return 0;
}

void UtBtpEventInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ rawPayload := ");
single_value->field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UtBtpEventInd_template::log_match(const UtBtpEventInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_rawPayload.match(match_value.rawPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".rawPayload");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ rawPayload := ");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtBtpEventInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_rawPayload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
}
}

void UtBtpEventInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_rawPayload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtBtpEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsBtp_TypesAndValues.UtBtpEventInd.");
}
}

void UtBtpEventInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsBtp_TypesAndValues.UtBtpEventInd'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsBtp_TypesAndValues.UtBtpEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtBtpEventInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsBtp_TypesAndValues.UtBtpEventInd has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsBtp_TypesAndValues.UtBtpEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsBtp_TypesAndValues.UtBtpEventInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* UtBtpEventInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsBtp_TypesAndValues.UtBtpEventInd'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsBtp_TypesAndValues.UtBtpEventInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_rawPayload = single_value->field_rawPayload.get_param(param_name);
    mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
    mp->add_elem(mp_field_rawPayload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void UtBtpEventInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_rawPayload.check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.UtBtpEventInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.UtBtpEventInd");
}

boolean UtBtpEventInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtBtpEventInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const UtBtpEventInd UtBtpEventIndList::UNBOUND_ELEM;
UtBtpEventIndList::UtBtpEventIndList()
{
val_ptr = NULL;
}

UtBtpEventIndList::UtBtpEventIndList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

UtBtpEventIndList::UtBtpEventIndList(const UtBtpEventIndList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

UtBtpEventIndList::~UtBtpEventIndList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void UtBtpEventIndList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

UtBtpEventIndList& UtBtpEventIndList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

UtBtpEventIndList& UtBtpEventIndList::operator=(const UtBtpEventIndList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean UtBtpEventIndList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
return val_ptr->n_elements == 0 ;
}

boolean UtBtpEventIndList::operator==(const UtBtpEventIndList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

UtBtpEventInd& UtBtpEventIndList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsBtp_TypesAndValues.UtBtpEventIndList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (UtBtpEventInd**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new UtBtpEventInd(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new UtBtpEventInd;
}
return *val_ptr->value_elements[index_value];
}

UtBtpEventInd& UtBtpEventIndList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
return (*this)[(int)index_value];
}

const UtBtpEventInd& UtBtpEventIndList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsBtp_TypesAndValues.UtBtpEventIndList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const UtBtpEventInd& UtBtpEventIndList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
return (*this)[(int)index_value];
}

UtBtpEventIndList UtBtpEventIndList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

UtBtpEventIndList UtBtpEventIndList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

UtBtpEventIndList UtBtpEventIndList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

UtBtpEventIndList UtBtpEventIndList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
UtBtpEventIndList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new UtBtpEventInd(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

UtBtpEventIndList UtBtpEventIndList::operator+(const UtBtpEventIndList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsBtp_TypesAndValues.UtBtpEventIndList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
UtBtpEventIndList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new UtBtpEventInd(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new UtBtpEventInd(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

UtBtpEventIndList UtBtpEventIndList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsBtp_TypesAndValues.UtBtpEventIndList","element");
UtBtpEventIndList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new UtBtpEventInd(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

UtBtpEventIndList UtBtpEventIndList::replace(int index, int len, const UtBtpEventIndList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsBtp_TypesAndValues.UtBtpEventIndList","element");
UtBtpEventIndList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new UtBtpEventInd(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new UtBtpEventInd(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new UtBtpEventInd(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

UtBtpEventIndList UtBtpEventIndList::replace(int index, int len, const UtBtpEventIndList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void UtBtpEventIndList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (UtBtpEventInd**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new UtBtpEventInd(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (UtBtpEventInd**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsBtp_TypesAndValues.UtBtpEventIndList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (UtBtpEventInd**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean UtBtpEventIndList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int UtBtpEventIndList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
return val_ptr->n_elements;
}

int UtBtpEventIndList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void UtBtpEventIndList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void UtBtpEventIndList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@LibItsBtp_TypesAndValues.UtBtpEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@LibItsBtp_TypesAndValues.UtBtpEventIndList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@LibItsBtp_TypesAndValues.UtBtpEventIndList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* UtBtpEventIndList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@LibItsBtp_TypesAndValues.UtBtpEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void UtBtpEventIndList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void UtBtpEventIndList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void UtBtpEventIndList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
val_ptr->value_elements = (UtBtpEventInd**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new UtBtpEventInd;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void UtBtpEventIndList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtBtpEventIndList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtBtpEventIndList::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int UtBtpEventIndList::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void UtBtpEventIndList_template::copy_value(const UtBtpEventIndList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (UtBtpEventInd_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new UtBtpEventInd_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new UtBtpEventInd_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void UtBtpEventIndList_template::copy_template(const UtBtpEventIndList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (UtBtpEventInd_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new UtBtpEventInd_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new UtBtpEventInd_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtBtpEventIndList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
break;
}
set_selection(other_value);
}

boolean UtBtpEventIndList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const UtBtpEventIndList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const UtBtpEventIndList*)value_ptr)[value_index], legacy);
else return ((const UtBtpEventIndList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

UtBtpEventIndList_template::UtBtpEventIndList_template()
{
}

UtBtpEventIndList_template::UtBtpEventIndList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

UtBtpEventIndList_template::UtBtpEventIndList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

UtBtpEventIndList_template::UtBtpEventIndList_template(const UtBtpEventIndList& other_value)
{
copy_value(other_value);
}

UtBtpEventIndList_template::UtBtpEventIndList_template(const OPTIONAL<UtBtpEventIndList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtBtpEventIndList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList from an unbound optional field.");
}
}

UtBtpEventIndList_template::UtBtpEventIndList_template(const UtBtpEventIndList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

UtBtpEventIndList_template::~UtBtpEventIndList_template()
{
clean_up();
}

void UtBtpEventIndList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtBtpEventIndList_template& UtBtpEventIndList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtBtpEventIndList_template& UtBtpEventIndList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

UtBtpEventIndList_template& UtBtpEventIndList_template::operator=(const UtBtpEventIndList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtBtpEventIndList_template& UtBtpEventIndList_template::operator=(const OPTIONAL<UtBtpEventIndList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtBtpEventIndList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
}
return *this;
}

UtBtpEventIndList_template& UtBtpEventIndList_template::operator=(const UtBtpEventIndList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

UtBtpEventInd_template& UtBtpEventIndList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsBtp_TypesAndValues.UtBtpEventIndList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
    break;
}
return *single_value.value_elements[index_value];
}

UtBtpEventInd_template& UtBtpEventIndList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
return (*this)[(int)index_value];
}

const UtBtpEventInd_template& UtBtpEventIndList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsBtp_TypesAndValues.UtBtpEventIndList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const UtBtpEventInd_template& UtBtpEventIndList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
return (*this)[(int)index_value];
}

void UtBtpEventIndList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (UtBtpEventInd_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new UtBtpEventInd_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new UtBtpEventInd_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (UtBtpEventInd_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int UtBtpEventIndList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int UtBtpEventIndList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList");
}

boolean UtBtpEventIndList_template::match(const UtBtpEventIndList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
}
return FALSE;
}

boolean UtBtpEventIndList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

UtBtpEventIndList UtBtpEventIndList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
UtBtpEventIndList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

UtBtpEventIndList UtBtpEventIndList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

UtBtpEventIndList UtBtpEventIndList_template::replace(int index, int len, const UtBtpEventIndList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

UtBtpEventIndList UtBtpEventIndList_template::replace(int index, int len, const UtBtpEventIndList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void UtBtpEventIndList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new UtBtpEventIndList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
}
set_selection(template_type);
}

UtBtpEventIndList_template& UtBtpEventIndList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
return value_list.list_value[list_index];
}

void UtBtpEventIndList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void UtBtpEventIndList_template::log_match(const UtBtpEventIndList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtBtpEventIndList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
}
}

void UtBtpEventIndList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
single_value.value_elements = (UtBtpEventInd_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new UtBtpEventInd_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtBtpEventIndList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
}
}

boolean UtBtpEventIndList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtBtpEventIndList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void UtBtpEventIndList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@LibItsBtp_TypesAndValues.UtBtpEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtBtpEventIndList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@LibItsBtp_TypesAndValues.UtBtpEventIndList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* UtBtpEventIndList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@LibItsBtp_TypesAndValues.UtBtpEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void UtBtpEventIndList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsBtp_TypesAndValues.UtBtpEventIndList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsBtp_TypesAndValues.UtBtpEventIndList");
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const UtBtpEventIndList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsBtp_TypesAndValues.UtBtpEventIndList.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("LibItsBtp_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsBtp_TypesAndValues");
LibCommon__BasicTypesAndValues::module_object.pre_init_module();
CAM__PDU__Descriptions::module_object.pre_init_module();
DENM__PDU__Descriptions::module_object.pre_init_module();
MAP__SPAT__ETSI::module_object.pre_init_module();
}

static void post_init_module()
{
TTCN_Location current_location("LibItsBtp_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsBtp_TypesAndValues");
LibCommon__BasicTypesAndValues::module_object.post_init_module();
}


} /* end of namespace */
