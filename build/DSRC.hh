// This C++ header file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef DSRC_HH
#define DSRC_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "REG_D.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the ASN.1 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef DSRC_HH
#endif

namespace DSRC {

/* Forward declarations of classes */

class MapData;
class MapData_template;
class LayerType;
class LayerType_template;
class IntersectionGeometryList;
class IntersectionGeometryList_template;
class IntersectionReferenceID;
class IntersectionReferenceID_template;
class Position3D__2;
class Position3D__2_template;
class LaneList;
class LaneList_template;
class LaneTypeAttributes;
class LaneTypeAttributes_template;
class LaneAttributes;
class LaneAttributes_template;
class NodeList2;
class NodeList2_template;
class NodeSet;
class NodeSet_template;
class Node;
class Node_template;
class NodeAttributeSet;
class NodeAttributeSet_template;
class NodeAttributeList;
class NodeAttributeList_template;
class NodeAttribute;
class NodeAttribute_template;
class SegmentAttributeList;
class SegmentAttributeList_template;
class SegmentAttribute;
class SegmentAttribute_template;
class LaneDataAttributeList;
class LaneDataAttributeList_template;
class LaneDataAttribute;
class LaneDataAttribute_template;
class SpeedLimitList;
class SpeedLimitList_template;
class SpeedLimitType;
class SpeedLimitType_template;
class RegulatorySpeedLimit;
class RegulatorySpeedLimit_template;
class RegionalNodeAttributeList;
class RegionalNodeAttributeList_template;
class ComputedLane_offsetXaxis;
class ComputedLane_offsetXaxis_template;
class ComputedLane_offsetYaxis;
class ComputedLane_offsetYaxis_template;
class ComputedLane;
class ComputedLane_template;
class GenericLane;
class GenericLane_template;
class ConnectsToList;
class ConnectsToList_template;
class ConnectingLane;
class ConnectingLane_template;
class Connection;
class Connection_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER OverlayLaneList;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template OverlayLaneList_template;
class IntersectionGeometry;
class IntersectionGeometry_template;
class PreemptPriorityList;
class PreemptPriorityList_template;
class RoadSegmentList;
class RoadSegmentList_template;
class RoadSegmentReferenceID;
class RoadSegmentReferenceID_template;
class RoadLaneSetList;
class RoadLaneSetList_template;
class RoadSegment;
class RoadSegment_template;
class DataParameters;
class DataParameters_template;
class RestrictionClassList;
class RestrictionClassList_template;
class RestrictionUserTypeList;
class RestrictionUserTypeList_template;
class RestrictionUserType;
class RestrictionUserType_template;
class RestrictionAppliesTo;
class RestrictionAppliesTo_template;
class RestrictionClassAssignment;
class RestrictionClassAssignment_template;
class IntersectionStateList;
class IntersectionStateList_template;
class MovementList;
class MovementList_template;
class MovementEventList;
class MovementEventList_template;
class MovementPhaseState;
class MovementPhaseState_template;
class MovementEvent;
class MovementEvent_template;
class TimeChangeDetails;
class TimeChangeDetails_template;
class AdvisorySpeedList;
class AdvisorySpeedList_template;
class AdvisorySpeedType;
class AdvisorySpeedType_template;
class AdvisorySpeed;
class AdvisorySpeed_template;
class MovementState;
class MovementState_template;
class ManeuverAssistList;
class ManeuverAssistList_template;
class ConnectionManeuverAssist;
class ConnectionManeuverAssist_template;
class IntersectionState;
class IntersectionState_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER EnabledLaneList;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template EnabledLaneList_template;
class SPAT;
class SPAT_template;

} /* end of namespace */

#ifndef DSRC_HH
#define DSRC_HH

namespace DSRC {

/* Type definitions */

typedef INTEGER DSRCmsgID2;
typedef INTEGER_template DSRCmsgID2_template;
typedef INTEGER MsgCount;
typedef INTEGER_template MsgCount_template;
typedef INTEGER DSRCmsgSubID;
typedef INTEGER_template DSRCmsgSubID_template;
typedef INTEGER LayerID;
typedef INTEGER_template LayerID_template;
typedef INTEGER IntersectionID;
typedef INTEGER_template IntersectionID_template;
typedef INTEGER RoadRegulatorID;
typedef INTEGER_template RoadRegulatorID_template;
typedef INTEGER Elevation2;
typedef INTEGER_template Elevation2_template;
typedef REG__D::Reg__Position3D RegionalPosition3D;
typedef REG__D::Reg__Position3D_template RegionalPosition3D_template;
typedef BITSTRING LaneDirection;
typedef BITSTRING_template LaneDirection_template;
typedef BITSTRING LaneSharing;
typedef BITSTRING_template LaneSharing_template;
typedef BITSTRING LaneAttributes__Vehicle;
typedef BITSTRING_template LaneAttributes__Vehicle_template;
typedef BITSTRING LaneAttributes__Crosswalk;
typedef BITSTRING_template LaneAttributes__Crosswalk_template;
typedef BITSTRING LaneAttributes__Bike;
typedef BITSTRING_template LaneAttributes__Bike_template;
typedef BITSTRING LaneAttributes__Sidewalk;
typedef BITSTRING_template LaneAttributes__Sidewalk_template;
typedef BITSTRING LaneAttributes__Barrier;
typedef BITSTRING_template LaneAttributes__Barrier_template;
typedef BITSTRING LaneAttributes__Striping;
typedef BITSTRING_template LaneAttributes__Striping_template;
typedef BITSTRING LaneAttributes__TrackedVehicle;
typedef BITSTRING_template LaneAttributes__TrackedVehicle_template;
typedef BITSTRING LaneAttributes__Parking;
typedef BITSTRING_template LaneAttributes__Parking_template;
typedef REGION::Reg__LaneAttributes RegionalLaneAttributes;
typedef REGION::Reg__LaneAttributes_template RegionalLaneAttributes_template;
typedef INTEGER DeltaAngle;
typedef INTEGER_template DeltaAngle_template;
typedef INTEGER RoadwayCrownAngle;
typedef INTEGER_template RoadwayCrownAngle_template;
typedef INTEGER MergeDivergeNodeAngle;
typedef INTEGER_template MergeDivergeNodeAngle_template;
typedef INTEGER Velocity;
typedef INTEGER_template Velocity_template;
typedef REGION::Reg__LaneDataAttribute RegionalLaneDataAttribute;
typedef REGION::Reg__LaneDataAttribute_template RegionalLaneDataAttribute_template;
typedef REGION::Reg__NodeAttribute RegionalNodeAttribute;
typedef REGION::Reg__NodeAttribute_template RegionalNodeAttribute_template;
typedef INTEGER DrivenLineOffsetSm;
typedef INTEGER_template DrivenLineOffsetSm_template;
typedef INTEGER DrivenLineOffsetLg;
typedef INTEGER_template DrivenLineOffsetLg_template;
typedef INTEGER Angle;
typedef INTEGER_template Angle_template;
typedef INTEGER Scale__B12;
typedef INTEGER_template Scale__B12_template;
typedef REGION::Reg__ComputedLane RegionalComputedLane;
typedef REGION::Reg__ComputedLane_template RegionalComputedLane_template;
typedef CHARSTRING DescriptiveName;
typedef CHARSTRING_template DescriptiveName_template;
typedef INTEGER ApproachID;
typedef INTEGER_template ApproachID_template;
typedef BITSTRING AllowedManeuvers;
typedef BITSTRING_template AllowedManeuvers_template;
typedef INTEGER RestrictionClassID;
typedef INTEGER_template RestrictionClassID_template;
typedef INTEGER LaneConnectionID;
typedef INTEGER_template LaneConnectionID_template;
typedef REGION::Reg__GenericLane RegionalGenericLane;
typedef REGION::Reg__GenericLane_template RegionalGenericLane_template;
typedef INTEGER LaneWidth;
typedef INTEGER_template LaneWidth_template;
typedef REGION::Reg__SignalControlZone RegionalSignalControlZone;
typedef REGION::Reg__SignalControlZone_template RegionalSignalControlZone_template;
typedef REGION::Reg__Intersection RegionalIntersection;
typedef REGION::Reg__Intersection_template RegionalIntersection_template;
typedef INTEGER RoadSegmentID;
typedef INTEGER_template RoadSegmentID_template;
typedef REGION::Reg__RoadSegment RegionalRoadSegment;
typedef REGION::Reg__RoadSegment_template RegionalRoadSegment_template;
typedef REG__D::Reg__RestrictionUserType RegionalRestrictionUserType;
typedef REG__D::Reg__RestrictionUserType_template RegionalRestrictionUserType_template;
typedef REG__D::Reg__MapData RegionalMapData;
typedef REG__D::Reg__MapData_template RegionalMapData_template;
typedef OCTETSTRING MsgCRC;
typedef OCTETSTRING_template MsgCRC_template;
typedef BITSTRING IntersectionStatusObject;
typedef BITSTRING_template IntersectionStatusObject_template;
typedef INTEGER TimeMark;
typedef INTEGER_template TimeMark_template;
typedef INTEGER TimeIntervalConfidence;
typedef INTEGER_template TimeIntervalConfidence_template;
typedef INTEGER SpeedAdvice;
typedef INTEGER_template SpeedAdvice_template;
typedef INTEGER ZoneLength;
typedef INTEGER_template ZoneLength_template;
typedef REGION::Reg__AdvisorySpeed RegionalAdvisorySpeed;
typedef REGION::Reg__AdvisorySpeed_template RegionalAdvisorySpeed_template;
typedef REGION::Reg__MovementEvent RegionalMovementEvent;
typedef REGION::Reg__MovementEvent_template RegionalMovementEvent_template;
typedef BOOLEAN WaitOnStopline;
typedef BOOLEAN_template WaitOnStopline_template;
typedef BOOLEAN PedestrianBicycleDetect;
typedef BOOLEAN_template PedestrianBicycleDetect_template;
typedef REG__D::Reg__ConnectionManeuverAssist RegionalConnectionManeuverAssist;
typedef REG__D::Reg__ConnectionManeuverAssist_template RegionalConnectionManeuverAssist_template;
typedef REGION::Reg__MovementState RegionalMovementState;
typedef REGION::Reg__MovementState_template RegionalMovementState_template;
typedef INTEGER MinuteOfTheYear;
typedef INTEGER_template MinuteOfTheYear_template;
typedef INTEGER DSecond2;
typedef INTEGER_template DSecond2_template;
typedef OCTETSTRING SignalControlState;
typedef OCTETSTRING_template SignalControlState_template;
typedef REG__D::Reg__IntersectionState RegionalIntersectionState;
typedef REG__D::Reg__IntersectionState_template RegionalIntersectionState_template;
typedef REGION::Reg__SPAT RegionalSPAT;
typedef REGION::Reg__SPAT_template RegionalSPAT_template;

/* Class definitions */

class MapData : public Base_Type {
  INTEGER field_msgID;
  OPTIONAL<INTEGER> field_msgSubID;
  INTEGER field_msgIssueRevision;
  OPTIONAL<LayerType> field_layerType;
  OPTIONAL<INTEGER> field_layerID;
  OPTIONAL<IntersectionGeometryList> field_intersections;
  OPTIONAL<RoadSegmentList> field_roadSegments;
  OPTIONAL<DataParameters> field_dataParameters;
  OPTIONAL<RestrictionClassList> field_restrictionList;
  OPTIONAL<REG__D::Reg__MapData> field_regional;
  OPTIONAL<OCTETSTRING> field_crc;
  boolean bound_flag;
public:
  MapData();
  MapData(const INTEGER& par_msgID,
    const OPTIONAL<INTEGER>& par_msgSubID,
    const INTEGER& par_msgIssueRevision,
    const OPTIONAL<LayerType>& par_layerType,
    const OPTIONAL<INTEGER>& par_layerID,
    const OPTIONAL<IntersectionGeometryList>& par_intersections,
    const OPTIONAL<RoadSegmentList>& par_roadSegments,
    const OPTIONAL<DataParameters>& par_dataParameters,
    const OPTIONAL<RestrictionClassList>& par_restrictionList,
    const OPTIONAL<REG__D::Reg__MapData>& par_regional,
    const OPTIONAL<OCTETSTRING>& par_crc);
  MapData(const MapData& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MapData& operator=(const MapData& other_value);
  boolean operator==(const MapData& other_value) const;
  inline boolean operator!=(const MapData& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& msgID()
    {return field_msgID;}
  inline const INTEGER& msgID() const
    {return field_msgID;}
  inline OPTIONAL<INTEGER>& msgSubID()
    {return field_msgSubID;}
  inline const OPTIONAL<INTEGER>& msgSubID() const
    {return field_msgSubID;}
  inline INTEGER& msgIssueRevision()
    {return field_msgIssueRevision;}
  inline const INTEGER& msgIssueRevision() const
    {return field_msgIssueRevision;}
  inline OPTIONAL<LayerType>& layerType()
    {return field_layerType;}
  inline const OPTIONAL<LayerType>& layerType() const
    {return field_layerType;}
  inline OPTIONAL<INTEGER>& layerID()
    {return field_layerID;}
  inline const OPTIONAL<INTEGER>& layerID() const
    {return field_layerID;}
  inline OPTIONAL<IntersectionGeometryList>& intersections()
    {return field_intersections;}
  inline const OPTIONAL<IntersectionGeometryList>& intersections() const
    {return field_intersections;}
  inline OPTIONAL<RoadSegmentList>& roadSegments()
    {return field_roadSegments;}
  inline const OPTIONAL<RoadSegmentList>& roadSegments() const
    {return field_roadSegments;}
  inline OPTIONAL<DataParameters>& dataParameters()
    {return field_dataParameters;}
  inline const OPTIONAL<DataParameters>& dataParameters() const
    {return field_dataParameters;}
  inline OPTIONAL<RestrictionClassList>& restrictionList()
    {return field_restrictionList;}
  inline const OPTIONAL<RestrictionClassList>& restrictionList() const
    {return field_restrictionList;}
  inline OPTIONAL<REG__D::Reg__MapData>& regional()
    {return field_regional;}
  inline const OPTIONAL<REG__D::Reg__MapData>& regional() const
    {return field_regional;}
  inline OPTIONAL<OCTETSTRING>& crc()
    {return field_crc;}
  inline const OPTIONAL<OCTETSTRING>& crc() const
    {return field_crc;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MapData_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MapData_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MapData& other_value);
void copy_template(const MapData_template& other_value);

public:
MapData_template();
MapData_template(template_sel other_value);
MapData_template(const MapData& other_value);
MapData_template(const OPTIONAL<MapData>& other_value);
MapData_template(const MapData_template& other_value);
~MapData_template();
MapData_template& operator=(template_sel other_value);
MapData_template& operator=(const MapData& other_value);
MapData_template& operator=(const OPTIONAL<MapData>& other_value);
MapData_template& operator=(const MapData_template& other_value);
boolean match(const MapData& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MapData valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MapData_template& list_item(unsigned int list_index) const;
INTEGER_template& msgID();
const INTEGER_template& msgID() const;
INTEGER_template& msgSubID();
const INTEGER_template& msgSubID() const;
INTEGER_template& msgIssueRevision();
const INTEGER_template& msgIssueRevision() const;
LayerType_template& layerType();
const LayerType_template& layerType() const;
INTEGER_template& layerID();
const INTEGER_template& layerID() const;
IntersectionGeometryList_template& intersections();
const IntersectionGeometryList_template& intersections() const;
RoadSegmentList_template& roadSegments();
const RoadSegmentList_template& roadSegments() const;
DataParameters_template& dataParameters();
const DataParameters_template& dataParameters() const;
RestrictionClassList_template& restrictionList();
const RestrictionClassList_template& restrictionList() const;
REG__D::Reg__MapData_template& regional();
const REG__D::Reg__MapData_template& regional() const;
OCTETSTRING_template& crc();
const OCTETSTRING_template& crc() const;
int size_of() const;
void log() const;
void log_match(const MapData& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LayerType : public Base_Type { // enum
friend class LayerType_template;
public:
enum enum_type { none__ = 0, mixedContent = 1, generalMapData = 2, intersectionData = 3, curveData = 4, roadwaySectionData = 5, parkingAreaData = 6, sharedLaneData = 7, UNKNOWN_VALUE = 8, UNBOUND_VALUE = 9 };
private:
enum_type enum_value;

public:
LayerType();
LayerType(int other_value);
LayerType(enum_type other_value);
LayerType(const LayerType& other_value);

LayerType& operator=(int other_value);
LayerType& operator=(enum_type other_value);
LayerType& operator=(const LayerType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const LayerType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const LayerType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const LayerType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const LayerType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const LayerType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const LayerType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const LayerType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LayerType_template : public Base_Template {
union {
LayerType::enum_type single_value;
struct {
unsigned int n_values;
LayerType_template *list_value;
} value_list;
};

void copy_template(const LayerType_template& other_value);

public:
LayerType_template();
LayerType_template(template_sel other_value);
LayerType_template(int other_value);
LayerType_template(LayerType::enum_type other_value);
LayerType_template(const LayerType& other_value);
LayerType_template(const OPTIONAL<LayerType>& other_value);
LayerType_template(const LayerType_template& other_value);
~LayerType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
LayerType_template& operator=(template_sel other_value);
LayerType_template& operator=(int other_value);
LayerType_template& operator=(LayerType::enum_type other_value);
LayerType_template& operator=(const LayerType& other_value);
LayerType_template& operator=(const OPTIONAL<LayerType>& other_value);
LayerType_template& operator=(const LayerType_template& other_value);

boolean match(LayerType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const LayerType& other_value, boolean legacy = FALSE) const;
LayerType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LayerType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const LayerType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class IntersectionGeometryList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
IntersectionGeometry **value_elements;
} *val_ptr;

static const IntersectionGeometry UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const IntersectionGeometryList& other_value);

public:
  typedef IntersectionGeometry of_type;
IntersectionGeometryList();
IntersectionGeometryList(null_type other_value);
IntersectionGeometryList(const IntersectionGeometryList& other_value);
~IntersectionGeometryList();

void clean_up();
IntersectionGeometryList& operator=(null_type other_value);
IntersectionGeometryList& operator=(const IntersectionGeometryList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const IntersectionGeometryList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const IntersectionGeometryList& other_value) const { return !(*this == other_value); }

IntersectionGeometry& operator[](int index_value);
IntersectionGeometry& operator[](const INTEGER& index_value);
const IntersectionGeometry& operator[](int index_value) const;
const IntersectionGeometry& operator[](const INTEGER& index_value) const;

IntersectionGeometryList operator<<=(int rotate_count) const;
IntersectionGeometryList operator<<=(const INTEGER& rotate_count) const;
IntersectionGeometryList operator>>=(int rotate_count) const;
IntersectionGeometryList operator>>=(const INTEGER& rotate_count) const;

IntersectionGeometryList operator+(const IntersectionGeometryList& other_value) const;

IntersectionGeometryList substr(int index, int returncount) const;

IntersectionGeometryList replace(int index, int len, const IntersectionGeometryList& repl) const;

IntersectionGeometryList replace(int index, int len, const IntersectionGeometryList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IntersectionGeometryList_template : public Record_Of_Template {
union {
struct {
int n_elements;
IntersectionGeometry_template **value_elements;
} single_value;
struct {
unsigned int n_values;
IntersectionGeometryList_template *list_value;
} value_list;
};
void copy_value(const IntersectionGeometryList& other_value);
void copy_template(const IntersectionGeometryList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
IntersectionGeometryList_template();
IntersectionGeometryList_template(template_sel other_value);
IntersectionGeometryList_template(null_type other_value);
IntersectionGeometryList_template(const IntersectionGeometryList& other_value);
IntersectionGeometryList_template(const OPTIONAL<IntersectionGeometryList>& other_value);
IntersectionGeometryList_template(const IntersectionGeometryList_template& other_value);
~IntersectionGeometryList_template();

void clean_up();
IntersectionGeometryList_template& operator=(template_sel other_value);
IntersectionGeometryList_template& operator=(null_type other_value);
IntersectionGeometryList_template& operator=(const IntersectionGeometryList& other_value);
IntersectionGeometryList_template& operator=(const OPTIONAL<IntersectionGeometryList>& other_value);
IntersectionGeometryList_template& operator=(const IntersectionGeometryList_template& other_value);

IntersectionGeometry_template& operator[](int index_value);
IntersectionGeometry_template& operator[](const INTEGER& index_value);
const IntersectionGeometry_template& operator[](int index_value) const;
const IntersectionGeometry_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const IntersectionGeometryList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
IntersectionGeometryList valueof() const;
IntersectionGeometryList substr(int index, int returncount) const;

IntersectionGeometryList replace(int index, int len, const IntersectionGeometryList_template& repl) const;

IntersectionGeometryList replace(int index, int len, const IntersectionGeometryList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
IntersectionGeometryList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const IntersectionGeometryList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class IntersectionReferenceID : public Base_Type {
  OPTIONAL<INTEGER> field_region;
  INTEGER field_id;
  boolean bound_flag;
public:
  IntersectionReferenceID();
  IntersectionReferenceID(const OPTIONAL<INTEGER>& par_region,
    const INTEGER& par_id);
  IntersectionReferenceID(const IntersectionReferenceID& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IntersectionReferenceID& operator=(const IntersectionReferenceID& other_value);
  boolean operator==(const IntersectionReferenceID& other_value) const;
  inline boolean operator!=(const IntersectionReferenceID& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& region()
    {return field_region;}
  inline const OPTIONAL<INTEGER>& region() const
    {return field_region;}
  inline INTEGER& id()
    {return field_id;}
  inline const INTEGER& id() const
    {return field_id;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IntersectionReferenceID_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IntersectionReferenceID_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IntersectionReferenceID& other_value);
void copy_template(const IntersectionReferenceID_template& other_value);

public:
IntersectionReferenceID_template();
IntersectionReferenceID_template(template_sel other_value);
IntersectionReferenceID_template(const IntersectionReferenceID& other_value);
IntersectionReferenceID_template(const OPTIONAL<IntersectionReferenceID>& other_value);
IntersectionReferenceID_template(const IntersectionReferenceID_template& other_value);
~IntersectionReferenceID_template();
IntersectionReferenceID_template& operator=(template_sel other_value);
IntersectionReferenceID_template& operator=(const IntersectionReferenceID& other_value);
IntersectionReferenceID_template& operator=(const OPTIONAL<IntersectionReferenceID>& other_value);
IntersectionReferenceID_template& operator=(const IntersectionReferenceID_template& other_value);
boolean match(const IntersectionReferenceID& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IntersectionReferenceID valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IntersectionReferenceID_template& list_item(unsigned int list_index) const;
INTEGER_template& region();
const INTEGER_template& region() const;
INTEGER_template& id();
const INTEGER_template& id() const;
int size_of() const;
void log() const;
void log_match(const IntersectionReferenceID& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Position3D__2 : public Base_Type {
  INTEGER field_lat;
  INTEGER field_long_;
  OPTIONAL<INTEGER> field_elevation;
  OPTIONAL<REG__D::Reg__Position3D> field_regional;
  boolean bound_flag;
public:
  Position3D__2();
  Position3D__2(const INTEGER& par_lat,
    const INTEGER& par_long_,
    const OPTIONAL<INTEGER>& par_elevation,
    const OPTIONAL<REG__D::Reg__Position3D>& par_regional);
  Position3D__2(const Position3D__2& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Position3D__2& operator=(const Position3D__2& other_value);
  boolean operator==(const Position3D__2& other_value) const;
  inline boolean operator!=(const Position3D__2& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& lat()
    {return field_lat;}
  inline const INTEGER& lat() const
    {return field_lat;}
  inline INTEGER& long_()
    {return field_long_;}
  inline const INTEGER& long_() const
    {return field_long_;}
  inline OPTIONAL<INTEGER>& elevation()
    {return field_elevation;}
  inline const OPTIONAL<INTEGER>& elevation() const
    {return field_elevation;}
  inline OPTIONAL<REG__D::Reg__Position3D>& regional()
    {return field_regional;}
  inline const OPTIONAL<REG__D::Reg__Position3D>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Position3D__2_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Position3D__2_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Position3D__2& other_value);
void copy_template(const Position3D__2_template& other_value);

public:
Position3D__2_template();
Position3D__2_template(template_sel other_value);
Position3D__2_template(const Position3D__2& other_value);
Position3D__2_template(const OPTIONAL<Position3D__2>& other_value);
Position3D__2_template(const Position3D__2_template& other_value);
~Position3D__2_template();
Position3D__2_template& operator=(template_sel other_value);
Position3D__2_template& operator=(const Position3D__2& other_value);
Position3D__2_template& operator=(const OPTIONAL<Position3D__2>& other_value);
Position3D__2_template& operator=(const Position3D__2_template& other_value);
boolean match(const Position3D__2& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Position3D__2 valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Position3D__2_template& list_item(unsigned int list_index) const;
INTEGER_template& lat();
const INTEGER_template& lat() const;
INTEGER_template& long_();
const INTEGER_template& long_() const;
INTEGER_template& elevation();
const INTEGER_template& elevation() const;
REG__D::Reg__Position3D_template& regional();
const REG__D::Reg__Position3D_template& regional() const;
int size_of() const;
void log() const;
void log_match(const Position3D__2& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LaneList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
GenericLane **value_elements;
} *val_ptr;

static const GenericLane UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const LaneList& other_value);

public:
  typedef GenericLane of_type;
LaneList();
LaneList(null_type other_value);
LaneList(const LaneList& other_value);
~LaneList();

void clean_up();
LaneList& operator=(null_type other_value);
LaneList& operator=(const LaneList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const LaneList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const LaneList& other_value) const { return !(*this == other_value); }

GenericLane& operator[](int index_value);
GenericLane& operator[](const INTEGER& index_value);
const GenericLane& operator[](int index_value) const;
const GenericLane& operator[](const INTEGER& index_value) const;

LaneList operator<<=(int rotate_count) const;
LaneList operator<<=(const INTEGER& rotate_count) const;
LaneList operator>>=(int rotate_count) const;
LaneList operator>>=(const INTEGER& rotate_count) const;

LaneList operator+(const LaneList& other_value) const;

LaneList substr(int index, int returncount) const;

LaneList replace(int index, int len, const LaneList& repl) const;

LaneList replace(int index, int len, const LaneList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LaneList_template : public Record_Of_Template {
union {
struct {
int n_elements;
GenericLane_template **value_elements;
} single_value;
struct {
unsigned int n_values;
LaneList_template *list_value;
} value_list;
};
void copy_value(const LaneList& other_value);
void copy_template(const LaneList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
LaneList_template();
LaneList_template(template_sel other_value);
LaneList_template(null_type other_value);
LaneList_template(const LaneList& other_value);
LaneList_template(const OPTIONAL<LaneList>& other_value);
LaneList_template(const LaneList_template& other_value);
~LaneList_template();

void clean_up();
LaneList_template& operator=(template_sel other_value);
LaneList_template& operator=(null_type other_value);
LaneList_template& operator=(const LaneList& other_value);
LaneList_template& operator=(const OPTIONAL<LaneList>& other_value);
LaneList_template& operator=(const LaneList_template& other_value);

GenericLane_template& operator[](int index_value);
GenericLane_template& operator[](const INTEGER& index_value);
const GenericLane_template& operator[](int index_value) const;
const GenericLane_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const LaneList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
LaneList valueof() const;
LaneList substr(int index, int returncount) const;

LaneList replace(int index, int len, const LaneList_template& repl) const;

LaneList replace(int index, int len, const LaneList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
LaneList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const LaneList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class LaneTypeAttributes : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_vehicle = 1, ALT_crosswalk = 2, ALT_bikeLane = 3, ALT_sidewalk = 4, ALT_median = 5, ALT_striping = 6, ALT_trackedVehicle = 7, ALT_parking = 8 };
private:
union_selection_type union_selection;
union {
BITSTRING *field_vehicle;
BITSTRING *field_crosswalk;
BITSTRING *field_bikeLane;
BITSTRING *field_sidewalk;
BITSTRING *field_median;
BITSTRING *field_striping;
BITSTRING *field_trackedVehicle;
BITSTRING *field_parking;
};
void copy_value(const LaneTypeAttributes& other_value);

public:
LaneTypeAttributes();
LaneTypeAttributes(const LaneTypeAttributes& other_value);
~LaneTypeAttributes();
LaneTypeAttributes& operator=(const LaneTypeAttributes& other_value);
boolean operator==(const LaneTypeAttributes& other_value) const;
inline boolean operator!=(const LaneTypeAttributes& other_value) const { return !(*this == other_value); }
BITSTRING& vehicle();
const BITSTRING& vehicle() const;
BITSTRING& crosswalk();
const BITSTRING& crosswalk() const;
BITSTRING& bikeLane();
const BITSTRING& bikeLane() const;
BITSTRING& sidewalk();
const BITSTRING& sidewalk() const;
BITSTRING& median();
const BITSTRING& median() const;
BITSTRING& striping();
const BITSTRING& striping() const;
BITSTRING& trackedVehicle();
const BITSTRING& trackedVehicle() const;
BITSTRING& parking();
const BITSTRING& parking() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class LaneTypeAttributes_template : public Base_Template {
union {
struct {
LaneTypeAttributes::union_selection_type union_selection;
union {
BITSTRING_template *field_vehicle;
BITSTRING_template *field_crosswalk;
BITSTRING_template *field_bikeLane;
BITSTRING_template *field_sidewalk;
BITSTRING_template *field_median;
BITSTRING_template *field_striping;
BITSTRING_template *field_trackedVehicle;
BITSTRING_template *field_parking;
};
} single_value;
struct {
unsigned int n_values;
LaneTypeAttributes_template *list_value;
} value_list;
};
void copy_value(const LaneTypeAttributes& other_value);

void copy_template(const LaneTypeAttributes_template& other_value);

public:
LaneTypeAttributes_template();
LaneTypeAttributes_template(template_sel other_value);
LaneTypeAttributes_template(const LaneTypeAttributes& other_value);
LaneTypeAttributes_template(const OPTIONAL<LaneTypeAttributes>& other_value);
LaneTypeAttributes_template(const LaneTypeAttributes_template& other_value);
~LaneTypeAttributes_template();
void clean_up();
LaneTypeAttributes_template& operator=(template_sel other_value);
LaneTypeAttributes_template& operator=(const LaneTypeAttributes& other_value);
LaneTypeAttributes_template& operator=(const OPTIONAL<LaneTypeAttributes>& other_value);
LaneTypeAttributes_template& operator=(const LaneTypeAttributes_template& other_value);
boolean match(const LaneTypeAttributes& other_value, boolean legacy = FALSE) const;
boolean is_value() const;LaneTypeAttributes valueof() const;
LaneTypeAttributes_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
BITSTRING_template& vehicle();
const BITSTRING_template& vehicle() const;
BITSTRING_template& crosswalk();
const BITSTRING_template& crosswalk() const;
BITSTRING_template& bikeLane();
const BITSTRING_template& bikeLane() const;
BITSTRING_template& sidewalk();
const BITSTRING_template& sidewalk() const;
BITSTRING_template& median();
const BITSTRING_template& median() const;
BITSTRING_template& striping();
const BITSTRING_template& striping() const;
BITSTRING_template& trackedVehicle();
const BITSTRING_template& trackedVehicle() const;
BITSTRING_template& parking();
const BITSTRING_template& parking() const;
boolean ischosen(LaneTypeAttributes::union_selection_type checked_selection) const;
void log() const;
void log_match(const LaneTypeAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class LaneAttributes : public Base_Type {
  BITSTRING field_directionalUse;
  BITSTRING field_sharedWith;
  LaneTypeAttributes field_laneType;
  OPTIONAL<REGION::Reg__LaneAttributes> field_regional;
  boolean bound_flag;
public:
  LaneAttributes();
  LaneAttributes(const BITSTRING& par_directionalUse,
    const BITSTRING& par_sharedWith,
    const LaneTypeAttributes& par_laneType,
    const OPTIONAL<REGION::Reg__LaneAttributes>& par_regional);
  LaneAttributes(const LaneAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LaneAttributes& operator=(const LaneAttributes& other_value);
  boolean operator==(const LaneAttributes& other_value) const;
  inline boolean operator!=(const LaneAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& directionalUse()
    {return field_directionalUse;}
  inline const BITSTRING& directionalUse() const
    {return field_directionalUse;}
  inline BITSTRING& sharedWith()
    {return field_sharedWith;}
  inline const BITSTRING& sharedWith() const
    {return field_sharedWith;}
  inline LaneTypeAttributes& laneType()
    {return field_laneType;}
  inline const LaneTypeAttributes& laneType() const
    {return field_laneType;}
  inline OPTIONAL<REGION::Reg__LaneAttributes>& regional()
    {return field_regional;}
  inline const OPTIONAL<REGION::Reg__LaneAttributes>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LaneAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LaneAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LaneAttributes& other_value);
void copy_template(const LaneAttributes_template& other_value);

public:
LaneAttributes_template();
LaneAttributes_template(template_sel other_value);
LaneAttributes_template(const LaneAttributes& other_value);
LaneAttributes_template(const OPTIONAL<LaneAttributes>& other_value);
LaneAttributes_template(const LaneAttributes_template& other_value);
~LaneAttributes_template();
LaneAttributes_template& operator=(template_sel other_value);
LaneAttributes_template& operator=(const LaneAttributes& other_value);
LaneAttributes_template& operator=(const OPTIONAL<LaneAttributes>& other_value);
LaneAttributes_template& operator=(const LaneAttributes_template& other_value);
boolean match(const LaneAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LaneAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LaneAttributes_template& list_item(unsigned int list_index) const;
BITSTRING_template& directionalUse();
const BITSTRING_template& directionalUse() const;
BITSTRING_template& sharedWith();
const BITSTRING_template& sharedWith() const;
LaneTypeAttributes_template& laneType();
const LaneTypeAttributes_template& laneType() const;
REGION::Reg__LaneAttributes_template& regional();
const REGION::Reg__LaneAttributes_template& regional() const;
int size_of() const;
void log() const;
void log_match(const LaneAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class NodeList2 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nodes = 1, ALT_computed = 2 };
private:
union_selection_type union_selection;
union {
NodeSet *field_nodes;
ComputedLane *field_computed;
};
void copy_value(const NodeList2& other_value);

public:
NodeList2();
NodeList2(const NodeList2& other_value);
~NodeList2();
NodeList2& operator=(const NodeList2& other_value);
boolean operator==(const NodeList2& other_value) const;
inline boolean operator!=(const NodeList2& other_value) const { return !(*this == other_value); }
NodeSet& nodes();
const NodeSet& nodes() const;
ComputedLane& computed();
const ComputedLane& computed() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class NodeList2_template : public Base_Template {
union {
struct {
NodeList2::union_selection_type union_selection;
union {
NodeSet_template *field_nodes;
ComputedLane_template *field_computed;
};
} single_value;
struct {
unsigned int n_values;
NodeList2_template *list_value;
} value_list;
};
void copy_value(const NodeList2& other_value);

void copy_template(const NodeList2_template& other_value);

public:
NodeList2_template();
NodeList2_template(template_sel other_value);
NodeList2_template(const NodeList2& other_value);
NodeList2_template(const OPTIONAL<NodeList2>& other_value);
NodeList2_template(const NodeList2_template& other_value);
~NodeList2_template();
void clean_up();
NodeList2_template& operator=(template_sel other_value);
NodeList2_template& operator=(const NodeList2& other_value);
NodeList2_template& operator=(const OPTIONAL<NodeList2>& other_value);
NodeList2_template& operator=(const NodeList2_template& other_value);
boolean match(const NodeList2& other_value, boolean legacy = FALSE) const;
boolean is_value() const;NodeList2 valueof() const;
NodeList2_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NodeSet_template& nodes();
const NodeSet_template& nodes() const;
ComputedLane_template& computed();
const ComputedLane_template& computed() const;
boolean ischosen(NodeList2::union_selection_type checked_selection) const;
void log() const;
void log_match(const NodeList2& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class NodeSet : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Node **value_elements;
} *val_ptr;

static const Node UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const NodeSet& other_value);

public:
  typedef Node of_type;
NodeSet();
NodeSet(null_type other_value);
NodeSet(const NodeSet& other_value);
~NodeSet();

void clean_up();
NodeSet& operator=(null_type other_value);
NodeSet& operator=(const NodeSet& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const NodeSet& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const NodeSet& other_value) const { return !(*this == other_value); }

Node& operator[](int index_value);
Node& operator[](const INTEGER& index_value);
const Node& operator[](int index_value) const;
const Node& operator[](const INTEGER& index_value) const;

NodeSet operator<<=(int rotate_count) const;
NodeSet operator<<=(const INTEGER& rotate_count) const;
NodeSet operator>>=(int rotate_count) const;
NodeSet operator>>=(const INTEGER& rotate_count) const;

NodeSet operator+(const NodeSet& other_value) const;

NodeSet substr(int index, int returncount) const;

NodeSet replace(int index, int len, const NodeSet& repl) const;

NodeSet replace(int index, int len, const NodeSet_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class NodeSet_template : public Record_Of_Template {
union {
struct {
int n_elements;
Node_template **value_elements;
} single_value;
struct {
unsigned int n_values;
NodeSet_template *list_value;
} value_list;
};
void copy_value(const NodeSet& other_value);
void copy_template(const NodeSet_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
NodeSet_template();
NodeSet_template(template_sel other_value);
NodeSet_template(null_type other_value);
NodeSet_template(const NodeSet& other_value);
NodeSet_template(const OPTIONAL<NodeSet>& other_value);
NodeSet_template(const NodeSet_template& other_value);
~NodeSet_template();

void clean_up();
NodeSet_template& operator=(template_sel other_value);
NodeSet_template& operator=(null_type other_value);
NodeSet_template& operator=(const NodeSet& other_value);
NodeSet_template& operator=(const OPTIONAL<NodeSet>& other_value);
NodeSet_template& operator=(const NodeSet_template& other_value);

Node_template& operator[](int index_value);
Node_template& operator[](const INTEGER& index_value);
const Node_template& operator[](int index_value) const;
const Node_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const NodeSet& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
NodeSet valueof() const;
NodeSet substr(int index, int returncount) const;

NodeSet replace(int index, int len, const NodeSet_template& repl) const;

NodeSet replace(int index, int len, const NodeSet& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
NodeSet_template& list_item(unsigned int list_index);
void log() const;
void log_match(const NodeSet& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Node : public Base_Type {
  DSRC2::NodeOffsetPoint field_delta;
  OPTIONAL<NodeAttributeSet> field_attributes;
  boolean bound_flag;
public:
  Node();
  Node(const DSRC2::NodeOffsetPoint& par_delta,
    const OPTIONAL<NodeAttributeSet>& par_attributes);
  Node(const Node& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Node& operator=(const Node& other_value);
  boolean operator==(const Node& other_value) const;
  inline boolean operator!=(const Node& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline DSRC2::NodeOffsetPoint& delta()
    {return field_delta;}
  inline const DSRC2::NodeOffsetPoint& delta() const
    {return field_delta;}
  inline OPTIONAL<NodeAttributeSet>& attributes()
    {return field_attributes;}
  inline const OPTIONAL<NodeAttributeSet>& attributes() const
    {return field_attributes;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Node_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Node_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Node& other_value);
void copy_template(const Node_template& other_value);

public:
Node_template();
Node_template(template_sel other_value);
Node_template(const Node& other_value);
Node_template(const OPTIONAL<Node>& other_value);
Node_template(const Node_template& other_value);
~Node_template();
Node_template& operator=(template_sel other_value);
Node_template& operator=(const Node& other_value);
Node_template& operator=(const OPTIONAL<Node>& other_value);
Node_template& operator=(const Node_template& other_value);
boolean match(const Node& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Node valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Node_template& list_item(unsigned int list_index) const;
DSRC2::NodeOffsetPoint_template& delta();
const DSRC2::NodeOffsetPoint_template& delta() const;
NodeAttributeSet_template& attributes();
const NodeAttributeSet_template& attributes() const;
int size_of() const;
void log() const;
void log_match(const Node& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class NodeAttributeSet : public Base_Type {
  OPTIONAL<NodeAttributeList> field_localNode;
  OPTIONAL<SegmentAttributeList> field_disabled;
  OPTIONAL<SegmentAttributeList> field_enabled;
  OPTIONAL<LaneDataAttributeList> field_data;
  OPTIONAL<RegionalNodeAttributeList> field_regional;
  OPTIONAL<INTEGER> field_dWidth;
  OPTIONAL<INTEGER> field_dElevation;
  boolean bound_flag;
public:
  NodeAttributeSet();
  NodeAttributeSet(const OPTIONAL<NodeAttributeList>& par_localNode,
    const OPTIONAL<SegmentAttributeList>& par_disabled,
    const OPTIONAL<SegmentAttributeList>& par_enabled,
    const OPTIONAL<LaneDataAttributeList>& par_data,
    const OPTIONAL<RegionalNodeAttributeList>& par_regional,
    const OPTIONAL<INTEGER>& par_dWidth,
    const OPTIONAL<INTEGER>& par_dElevation);
  NodeAttributeSet(const NodeAttributeSet& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  NodeAttributeSet& operator=(const NodeAttributeSet& other_value);
  boolean operator==(const NodeAttributeSet& other_value) const;
  inline boolean operator!=(const NodeAttributeSet& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<NodeAttributeList>& localNode()
    {return field_localNode;}
  inline const OPTIONAL<NodeAttributeList>& localNode() const
    {return field_localNode;}
  inline OPTIONAL<SegmentAttributeList>& disabled()
    {return field_disabled;}
  inline const OPTIONAL<SegmentAttributeList>& disabled() const
    {return field_disabled;}
  inline OPTIONAL<SegmentAttributeList>& enabled()
    {return field_enabled;}
  inline const OPTIONAL<SegmentAttributeList>& enabled() const
    {return field_enabled;}
  inline OPTIONAL<LaneDataAttributeList>& data()
    {return field_data;}
  inline const OPTIONAL<LaneDataAttributeList>& data() const
    {return field_data;}
  inline OPTIONAL<RegionalNodeAttributeList>& regional()
    {return field_regional;}
  inline const OPTIONAL<RegionalNodeAttributeList>& regional() const
    {return field_regional;}
  inline OPTIONAL<INTEGER>& dWidth()
    {return field_dWidth;}
  inline const OPTIONAL<INTEGER>& dWidth() const
    {return field_dWidth;}
  inline OPTIONAL<INTEGER>& dElevation()
    {return field_dElevation;}
  inline const OPTIONAL<INTEGER>& dElevation() const
    {return field_dElevation;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class NodeAttributeSet_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
NodeAttributeSet_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const NodeAttributeSet& other_value);
void copy_template(const NodeAttributeSet_template& other_value);

public:
NodeAttributeSet_template();
NodeAttributeSet_template(template_sel other_value);
NodeAttributeSet_template(const NodeAttributeSet& other_value);
NodeAttributeSet_template(const OPTIONAL<NodeAttributeSet>& other_value);
NodeAttributeSet_template(const NodeAttributeSet_template& other_value);
~NodeAttributeSet_template();
NodeAttributeSet_template& operator=(template_sel other_value);
NodeAttributeSet_template& operator=(const NodeAttributeSet& other_value);
NodeAttributeSet_template& operator=(const OPTIONAL<NodeAttributeSet>& other_value);
NodeAttributeSet_template& operator=(const NodeAttributeSet_template& other_value);
boolean match(const NodeAttributeSet& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
NodeAttributeSet valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NodeAttributeSet_template& list_item(unsigned int list_index) const;
NodeAttributeList_template& localNode();
const NodeAttributeList_template& localNode() const;
SegmentAttributeList_template& disabled();
const SegmentAttributeList_template& disabled() const;
SegmentAttributeList_template& enabled();
const SegmentAttributeList_template& enabled() const;
LaneDataAttributeList_template& data();
const LaneDataAttributeList_template& data() const;
RegionalNodeAttributeList_template& regional();
const RegionalNodeAttributeList_template& regional() const;
INTEGER_template& dWidth();
const INTEGER_template& dWidth() const;
INTEGER_template& dElevation();
const INTEGER_template& dElevation() const;
int size_of() const;
void log() const;
void log_match(const NodeAttributeSet& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class NodeAttributeList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
NodeAttribute **value_elements;
} *val_ptr;

static const NodeAttribute UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const NodeAttributeList& other_value);

public:
  typedef NodeAttribute of_type;
NodeAttributeList();
NodeAttributeList(null_type other_value);
NodeAttributeList(const NodeAttributeList& other_value);
~NodeAttributeList();

void clean_up();
NodeAttributeList& operator=(null_type other_value);
NodeAttributeList& operator=(const NodeAttributeList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const NodeAttributeList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const NodeAttributeList& other_value) const { return !(*this == other_value); }

NodeAttribute& operator[](int index_value);
NodeAttribute& operator[](const INTEGER& index_value);
const NodeAttribute& operator[](int index_value) const;
const NodeAttribute& operator[](const INTEGER& index_value) const;

NodeAttributeList operator<<=(int rotate_count) const;
NodeAttributeList operator<<=(const INTEGER& rotate_count) const;
NodeAttributeList operator>>=(int rotate_count) const;
NodeAttributeList operator>>=(const INTEGER& rotate_count) const;

NodeAttributeList operator+(const NodeAttributeList& other_value) const;

NodeAttributeList substr(int index, int returncount) const;

NodeAttributeList replace(int index, int len, const NodeAttributeList& repl) const;

NodeAttributeList replace(int index, int len, const NodeAttributeList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class NodeAttributeList_template : public Record_Of_Template {
union {
struct {
int n_elements;
NodeAttribute_template **value_elements;
} single_value;
struct {
unsigned int n_values;
NodeAttributeList_template *list_value;
} value_list;
};
void copy_value(const NodeAttributeList& other_value);
void copy_template(const NodeAttributeList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
NodeAttributeList_template();
NodeAttributeList_template(template_sel other_value);
NodeAttributeList_template(null_type other_value);
NodeAttributeList_template(const NodeAttributeList& other_value);
NodeAttributeList_template(const OPTIONAL<NodeAttributeList>& other_value);
NodeAttributeList_template(const NodeAttributeList_template& other_value);
~NodeAttributeList_template();

void clean_up();
NodeAttributeList_template& operator=(template_sel other_value);
NodeAttributeList_template& operator=(null_type other_value);
NodeAttributeList_template& operator=(const NodeAttributeList& other_value);
NodeAttributeList_template& operator=(const OPTIONAL<NodeAttributeList>& other_value);
NodeAttributeList_template& operator=(const NodeAttributeList_template& other_value);

NodeAttribute_template& operator[](int index_value);
NodeAttribute_template& operator[](const INTEGER& index_value);
const NodeAttribute_template& operator[](int index_value) const;
const NodeAttribute_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const NodeAttributeList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
NodeAttributeList valueof() const;
NodeAttributeList substr(int index, int returncount) const;

NodeAttributeList replace(int index, int len, const NodeAttributeList_template& repl) const;

NodeAttributeList replace(int index, int len, const NodeAttributeList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
NodeAttributeList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const NodeAttributeList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class NodeAttribute : public Base_Type { // enum
friend class NodeAttribute_template;
public:
enum enum_type { reserved = 0, stopLine = 1, roundedCapStyleA = 2, roundedCapStyleB = 3, mergePoint = 4, divergePoint = 5, downstreamStopLine = 6, downstreamStartNode = 7, closedToTraffic = 8, safeIsland = 9, curbPresentAtStepOff = 10, hydrantPresent = 11, UNKNOWN_VALUE = 12, UNBOUND_VALUE = 13 };
private:
enum_type enum_value;

public:
NodeAttribute();
NodeAttribute(int other_value);
NodeAttribute(enum_type other_value);
NodeAttribute(const NodeAttribute& other_value);

NodeAttribute& operator=(int other_value);
NodeAttribute& operator=(enum_type other_value);
NodeAttribute& operator=(const NodeAttribute& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const NodeAttribute& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const NodeAttribute& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const NodeAttribute& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const NodeAttribute& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const NodeAttribute& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const NodeAttribute& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const NodeAttribute& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class NodeAttribute_template : public Base_Template {
union {
NodeAttribute::enum_type single_value;
struct {
unsigned int n_values;
NodeAttribute_template *list_value;
} value_list;
};

void copy_template(const NodeAttribute_template& other_value);

public:
NodeAttribute_template();
NodeAttribute_template(template_sel other_value);
NodeAttribute_template(int other_value);
NodeAttribute_template(NodeAttribute::enum_type other_value);
NodeAttribute_template(const NodeAttribute& other_value);
NodeAttribute_template(const OPTIONAL<NodeAttribute>& other_value);
NodeAttribute_template(const NodeAttribute_template& other_value);
~NodeAttribute_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
NodeAttribute_template& operator=(template_sel other_value);
NodeAttribute_template& operator=(int other_value);
NodeAttribute_template& operator=(NodeAttribute::enum_type other_value);
NodeAttribute_template& operator=(const NodeAttribute& other_value);
NodeAttribute_template& operator=(const OPTIONAL<NodeAttribute>& other_value);
NodeAttribute_template& operator=(const NodeAttribute_template& other_value);

boolean match(NodeAttribute::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const NodeAttribute& other_value, boolean legacy = FALSE) const;
NodeAttribute::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NodeAttribute_template& list_item(unsigned int list_index);
void log() const;
void log_match(const NodeAttribute& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SegmentAttributeList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
SegmentAttribute **value_elements;
} *val_ptr;

static const SegmentAttribute UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SegmentAttributeList& other_value);

public:
  typedef SegmentAttribute of_type;
SegmentAttributeList();
SegmentAttributeList(null_type other_value);
SegmentAttributeList(const SegmentAttributeList& other_value);
~SegmentAttributeList();

void clean_up();
SegmentAttributeList& operator=(null_type other_value);
SegmentAttributeList& operator=(const SegmentAttributeList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SegmentAttributeList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SegmentAttributeList& other_value) const { return !(*this == other_value); }

SegmentAttribute& operator[](int index_value);
SegmentAttribute& operator[](const INTEGER& index_value);
const SegmentAttribute& operator[](int index_value) const;
const SegmentAttribute& operator[](const INTEGER& index_value) const;

SegmentAttributeList operator<<=(int rotate_count) const;
SegmentAttributeList operator<<=(const INTEGER& rotate_count) const;
SegmentAttributeList operator>>=(int rotate_count) const;
SegmentAttributeList operator>>=(const INTEGER& rotate_count) const;

SegmentAttributeList operator+(const SegmentAttributeList& other_value) const;

SegmentAttributeList substr(int index, int returncount) const;

SegmentAttributeList replace(int index, int len, const SegmentAttributeList& repl) const;

SegmentAttributeList replace(int index, int len, const SegmentAttributeList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SegmentAttributeList_template : public Record_Of_Template {
union {
struct {
int n_elements;
SegmentAttribute_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SegmentAttributeList_template *list_value;
} value_list;
};
void copy_value(const SegmentAttributeList& other_value);
void copy_template(const SegmentAttributeList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SegmentAttributeList_template();
SegmentAttributeList_template(template_sel other_value);
SegmentAttributeList_template(null_type other_value);
SegmentAttributeList_template(const SegmentAttributeList& other_value);
SegmentAttributeList_template(const OPTIONAL<SegmentAttributeList>& other_value);
SegmentAttributeList_template(const SegmentAttributeList_template& other_value);
~SegmentAttributeList_template();

void clean_up();
SegmentAttributeList_template& operator=(template_sel other_value);
SegmentAttributeList_template& operator=(null_type other_value);
SegmentAttributeList_template& operator=(const SegmentAttributeList& other_value);
SegmentAttributeList_template& operator=(const OPTIONAL<SegmentAttributeList>& other_value);
SegmentAttributeList_template& operator=(const SegmentAttributeList_template& other_value);

SegmentAttribute_template& operator[](int index_value);
SegmentAttribute_template& operator[](const INTEGER& index_value);
const SegmentAttribute_template& operator[](int index_value) const;
const SegmentAttribute_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SegmentAttributeList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SegmentAttributeList valueof() const;
SegmentAttributeList substr(int index, int returncount) const;

SegmentAttributeList replace(int index, int len, const SegmentAttributeList_template& repl) const;

SegmentAttributeList replace(int index, int len, const SegmentAttributeList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SegmentAttributeList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SegmentAttributeList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SegmentAttribute : public Base_Type { // enum
friend class SegmentAttribute_template;
public:
enum enum_type { reserved = 0, doNotBlock = 1, whiteLine = 2, mergingLaneLeft = 3, mergingLaneRight = 4, curbOnLeft = 5, curbOnRight = 6, loadingzoneOnLeft = 7, loadingzoneOnRight = 8, turnOutPointOnLeft = 9, turnOutPointOnRight = 10, adjacentParkingOnLeft = 11, adjacentParkingOnRight = 12, adjacentBikeLaneOnLeft = 13, adjacentBikeLaneOnRight = 14, sharedBikeLane = 15, bikeBoxInFront = 16, transitStopOnLeft = 17, transitStopOnRight = 18, transitStopInLane = 19, sharedWithTrackedVehicle = 20, safeIsland = 21, lowCurbsPresent = 22, rumbleStripPresent = 23, audibleSignalingPresent = 24, adaptiveTimingPresent = 25, rfSignalRequestPresent = 26, partialCurbIntrusion = 27, taperToLeft = 28, taperToRight = 29, taperToCenterLine = 30, parallelParking = 31, headInParking = 32, freeParking = 33, timeRestrictionsOnParking = 34, costToPark = 35, midBlockCurbPresent = 36, unEvenPavementPresent = 37, UNKNOWN_VALUE = 38, UNBOUND_VALUE = 39 };
private:
enum_type enum_value;

public:
SegmentAttribute();
SegmentAttribute(int other_value);
SegmentAttribute(enum_type other_value);
SegmentAttribute(const SegmentAttribute& other_value);

SegmentAttribute& operator=(int other_value);
SegmentAttribute& operator=(enum_type other_value);
SegmentAttribute& operator=(const SegmentAttribute& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SegmentAttribute& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SegmentAttribute& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SegmentAttribute& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SegmentAttribute& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SegmentAttribute& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SegmentAttribute& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SegmentAttribute& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SegmentAttribute_template : public Base_Template {
union {
SegmentAttribute::enum_type single_value;
struct {
unsigned int n_values;
SegmentAttribute_template *list_value;
} value_list;
};

void copy_template(const SegmentAttribute_template& other_value);

public:
SegmentAttribute_template();
SegmentAttribute_template(template_sel other_value);
SegmentAttribute_template(int other_value);
SegmentAttribute_template(SegmentAttribute::enum_type other_value);
SegmentAttribute_template(const SegmentAttribute& other_value);
SegmentAttribute_template(const OPTIONAL<SegmentAttribute>& other_value);
SegmentAttribute_template(const SegmentAttribute_template& other_value);
~SegmentAttribute_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SegmentAttribute_template& operator=(template_sel other_value);
SegmentAttribute_template& operator=(int other_value);
SegmentAttribute_template& operator=(SegmentAttribute::enum_type other_value);
SegmentAttribute_template& operator=(const SegmentAttribute& other_value);
SegmentAttribute_template& operator=(const OPTIONAL<SegmentAttribute>& other_value);
SegmentAttribute_template& operator=(const SegmentAttribute_template& other_value);

boolean match(SegmentAttribute::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SegmentAttribute& other_value, boolean legacy = FALSE) const;
SegmentAttribute::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SegmentAttribute_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SegmentAttribute& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class LaneDataAttributeList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
LaneDataAttribute **value_elements;
} *val_ptr;

static const LaneDataAttribute UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const LaneDataAttributeList& other_value);

public:
  typedef LaneDataAttribute of_type;
LaneDataAttributeList();
LaneDataAttributeList(null_type other_value);
LaneDataAttributeList(const LaneDataAttributeList& other_value);
~LaneDataAttributeList();

void clean_up();
LaneDataAttributeList& operator=(null_type other_value);
LaneDataAttributeList& operator=(const LaneDataAttributeList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const LaneDataAttributeList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const LaneDataAttributeList& other_value) const { return !(*this == other_value); }

LaneDataAttribute& operator[](int index_value);
LaneDataAttribute& operator[](const INTEGER& index_value);
const LaneDataAttribute& operator[](int index_value) const;
const LaneDataAttribute& operator[](const INTEGER& index_value) const;

LaneDataAttributeList operator<<=(int rotate_count) const;
LaneDataAttributeList operator<<=(const INTEGER& rotate_count) const;
LaneDataAttributeList operator>>=(int rotate_count) const;
LaneDataAttributeList operator>>=(const INTEGER& rotate_count) const;

LaneDataAttributeList operator+(const LaneDataAttributeList& other_value) const;

LaneDataAttributeList substr(int index, int returncount) const;

LaneDataAttributeList replace(int index, int len, const LaneDataAttributeList& repl) const;

LaneDataAttributeList replace(int index, int len, const LaneDataAttributeList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LaneDataAttributeList_template : public Record_Of_Template {
union {
struct {
int n_elements;
LaneDataAttribute_template **value_elements;
} single_value;
struct {
unsigned int n_values;
LaneDataAttributeList_template *list_value;
} value_list;
};
void copy_value(const LaneDataAttributeList& other_value);
void copy_template(const LaneDataAttributeList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
LaneDataAttributeList_template();
LaneDataAttributeList_template(template_sel other_value);
LaneDataAttributeList_template(null_type other_value);
LaneDataAttributeList_template(const LaneDataAttributeList& other_value);
LaneDataAttributeList_template(const OPTIONAL<LaneDataAttributeList>& other_value);
LaneDataAttributeList_template(const LaneDataAttributeList_template& other_value);
~LaneDataAttributeList_template();

void clean_up();
LaneDataAttributeList_template& operator=(template_sel other_value);
LaneDataAttributeList_template& operator=(null_type other_value);
LaneDataAttributeList_template& operator=(const LaneDataAttributeList& other_value);
LaneDataAttributeList_template& operator=(const OPTIONAL<LaneDataAttributeList>& other_value);
LaneDataAttributeList_template& operator=(const LaneDataAttributeList_template& other_value);

LaneDataAttribute_template& operator[](int index_value);
LaneDataAttribute_template& operator[](const INTEGER& index_value);
const LaneDataAttribute_template& operator[](int index_value) const;
const LaneDataAttribute_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const LaneDataAttributeList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
LaneDataAttributeList valueof() const;
LaneDataAttributeList substr(int index, int returncount) const;

LaneDataAttributeList replace(int index, int len, const LaneDataAttributeList_template& repl) const;

LaneDataAttributeList replace(int index, int len, const LaneDataAttributeList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
LaneDataAttributeList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const LaneDataAttributeList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class LaneDataAttribute : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_pathEndPointAngle = 1, ALT_laneCrownPointCenter = 2, ALT_laneCrownPointLeft = 3, ALT_laneCrownPointRight = 4, ALT_laneAngle = 5, ALT_speedLimits = 6, ALT_regional = 7 };
private:
union_selection_type union_selection;
union {
INTEGER *field_pathEndPointAngle;
INTEGER *field_laneCrownPointCenter;
INTEGER *field_laneCrownPointLeft;
INTEGER *field_laneCrownPointRight;
INTEGER *field_laneAngle;
SpeedLimitList *field_speedLimits;
REGION::Reg__LaneDataAttribute *field_regional;
};
void copy_value(const LaneDataAttribute& other_value);

public:
LaneDataAttribute();
LaneDataAttribute(const LaneDataAttribute& other_value);
~LaneDataAttribute();
LaneDataAttribute& operator=(const LaneDataAttribute& other_value);
boolean operator==(const LaneDataAttribute& other_value) const;
inline boolean operator!=(const LaneDataAttribute& other_value) const { return !(*this == other_value); }
INTEGER& pathEndPointAngle();
const INTEGER& pathEndPointAngle() const;
INTEGER& laneCrownPointCenter();
const INTEGER& laneCrownPointCenter() const;
INTEGER& laneCrownPointLeft();
const INTEGER& laneCrownPointLeft() const;
INTEGER& laneCrownPointRight();
const INTEGER& laneCrownPointRight() const;
INTEGER& laneAngle();
const INTEGER& laneAngle() const;
SpeedLimitList& speedLimits();
const SpeedLimitList& speedLimits() const;
REGION::Reg__LaneDataAttribute& regional();
const REGION::Reg__LaneDataAttribute& regional() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class LaneDataAttribute_template : public Base_Template {
union {
struct {
LaneDataAttribute::union_selection_type union_selection;
union {
INTEGER_template *field_pathEndPointAngle;
INTEGER_template *field_laneCrownPointCenter;
INTEGER_template *field_laneCrownPointLeft;
INTEGER_template *field_laneCrownPointRight;
INTEGER_template *field_laneAngle;
SpeedLimitList_template *field_speedLimits;
REGION::Reg__LaneDataAttribute_template *field_regional;
};
} single_value;
struct {
unsigned int n_values;
LaneDataAttribute_template *list_value;
} value_list;
};
void copy_value(const LaneDataAttribute& other_value);

void copy_template(const LaneDataAttribute_template& other_value);

public:
LaneDataAttribute_template();
LaneDataAttribute_template(template_sel other_value);
LaneDataAttribute_template(const LaneDataAttribute& other_value);
LaneDataAttribute_template(const OPTIONAL<LaneDataAttribute>& other_value);
LaneDataAttribute_template(const LaneDataAttribute_template& other_value);
~LaneDataAttribute_template();
void clean_up();
LaneDataAttribute_template& operator=(template_sel other_value);
LaneDataAttribute_template& operator=(const LaneDataAttribute& other_value);
LaneDataAttribute_template& operator=(const OPTIONAL<LaneDataAttribute>& other_value);
LaneDataAttribute_template& operator=(const LaneDataAttribute_template& other_value);
boolean match(const LaneDataAttribute& other_value, boolean legacy = FALSE) const;
boolean is_value() const;LaneDataAttribute valueof() const;
LaneDataAttribute_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& pathEndPointAngle();
const INTEGER_template& pathEndPointAngle() const;
INTEGER_template& laneCrownPointCenter();
const INTEGER_template& laneCrownPointCenter() const;
INTEGER_template& laneCrownPointLeft();
const INTEGER_template& laneCrownPointLeft() const;
INTEGER_template& laneCrownPointRight();
const INTEGER_template& laneCrownPointRight() const;
INTEGER_template& laneAngle();
const INTEGER_template& laneAngle() const;
SpeedLimitList_template& speedLimits();
const SpeedLimitList_template& speedLimits() const;
REGION::Reg__LaneDataAttribute_template& regional();
const REGION::Reg__LaneDataAttribute_template& regional() const;
boolean ischosen(LaneDataAttribute::union_selection_type checked_selection) const;
void log() const;
void log_match(const LaneDataAttribute& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SpeedLimitList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
RegulatorySpeedLimit **value_elements;
} *val_ptr;

static const RegulatorySpeedLimit UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SpeedLimitList& other_value);

public:
  typedef RegulatorySpeedLimit of_type;
SpeedLimitList();
SpeedLimitList(null_type other_value);
SpeedLimitList(const SpeedLimitList& other_value);
~SpeedLimitList();

void clean_up();
SpeedLimitList& operator=(null_type other_value);
SpeedLimitList& operator=(const SpeedLimitList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SpeedLimitList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SpeedLimitList& other_value) const { return !(*this == other_value); }

RegulatorySpeedLimit& operator[](int index_value);
RegulatorySpeedLimit& operator[](const INTEGER& index_value);
const RegulatorySpeedLimit& operator[](int index_value) const;
const RegulatorySpeedLimit& operator[](const INTEGER& index_value) const;

SpeedLimitList operator<<=(int rotate_count) const;
SpeedLimitList operator<<=(const INTEGER& rotate_count) const;
SpeedLimitList operator>>=(int rotate_count) const;
SpeedLimitList operator>>=(const INTEGER& rotate_count) const;

SpeedLimitList operator+(const SpeedLimitList& other_value) const;

SpeedLimitList substr(int index, int returncount) const;

SpeedLimitList replace(int index, int len, const SpeedLimitList& repl) const;

SpeedLimitList replace(int index, int len, const SpeedLimitList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SpeedLimitList_template : public Record_Of_Template {
union {
struct {
int n_elements;
RegulatorySpeedLimit_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SpeedLimitList_template *list_value;
} value_list;
};
void copy_value(const SpeedLimitList& other_value);
void copy_template(const SpeedLimitList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SpeedLimitList_template();
SpeedLimitList_template(template_sel other_value);
SpeedLimitList_template(null_type other_value);
SpeedLimitList_template(const SpeedLimitList& other_value);
SpeedLimitList_template(const OPTIONAL<SpeedLimitList>& other_value);
SpeedLimitList_template(const SpeedLimitList_template& other_value);
~SpeedLimitList_template();

void clean_up();
SpeedLimitList_template& operator=(template_sel other_value);
SpeedLimitList_template& operator=(null_type other_value);
SpeedLimitList_template& operator=(const SpeedLimitList& other_value);
SpeedLimitList_template& operator=(const OPTIONAL<SpeedLimitList>& other_value);
SpeedLimitList_template& operator=(const SpeedLimitList_template& other_value);

RegulatorySpeedLimit_template& operator[](int index_value);
RegulatorySpeedLimit_template& operator[](const INTEGER& index_value);
const RegulatorySpeedLimit_template& operator[](int index_value) const;
const RegulatorySpeedLimit_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SpeedLimitList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SpeedLimitList valueof() const;
SpeedLimitList substr(int index, int returncount) const;

SpeedLimitList replace(int index, int len, const SpeedLimitList_template& repl) const;

SpeedLimitList replace(int index, int len, const SpeedLimitList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SpeedLimitList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SpeedLimitList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SpeedLimitType : public Base_Type { // enum
friend class SpeedLimitType_template;
public:
enum enum_type { unknown = 0, maxSpeedInSchoolZone = 1, maxSpeedInSchoolZoneWhenChildrenArePresent = 2, maxSpeedInConstructionZone = 3, vehicleMinSpeed = 4, vehicleMaxSpeed = 5, vehicleNightMaxSpeed = 6, truckMinSpeed = 7, truckMaxSpeed = 8, truckNightMaxSpeed = 9, vehiclesWithTrailersMinSpeed = 10, vehiclesWithTrailersMaxSpeed = 11, vehiclesWithTrailersNightMaxSpeed = 12, UNKNOWN_VALUE = 13, UNBOUND_VALUE = 14 };
private:
enum_type enum_value;

public:
SpeedLimitType();
SpeedLimitType(int other_value);
SpeedLimitType(enum_type other_value);
SpeedLimitType(const SpeedLimitType& other_value);

SpeedLimitType& operator=(int other_value);
SpeedLimitType& operator=(enum_type other_value);
SpeedLimitType& operator=(const SpeedLimitType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SpeedLimitType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SpeedLimitType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SpeedLimitType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SpeedLimitType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SpeedLimitType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SpeedLimitType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SpeedLimitType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SpeedLimitType_template : public Base_Template {
union {
SpeedLimitType::enum_type single_value;
struct {
unsigned int n_values;
SpeedLimitType_template *list_value;
} value_list;
};

void copy_template(const SpeedLimitType_template& other_value);

public:
SpeedLimitType_template();
SpeedLimitType_template(template_sel other_value);
SpeedLimitType_template(int other_value);
SpeedLimitType_template(SpeedLimitType::enum_type other_value);
SpeedLimitType_template(const SpeedLimitType& other_value);
SpeedLimitType_template(const OPTIONAL<SpeedLimitType>& other_value);
SpeedLimitType_template(const SpeedLimitType_template& other_value);
~SpeedLimitType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SpeedLimitType_template& operator=(template_sel other_value);
SpeedLimitType_template& operator=(int other_value);
SpeedLimitType_template& operator=(SpeedLimitType::enum_type other_value);
SpeedLimitType_template& operator=(const SpeedLimitType& other_value);
SpeedLimitType_template& operator=(const OPTIONAL<SpeedLimitType>& other_value);
SpeedLimitType_template& operator=(const SpeedLimitType_template& other_value);

boolean match(SpeedLimitType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SpeedLimitType& other_value, boolean legacy = FALSE) const;
SpeedLimitType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SpeedLimitType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SpeedLimitType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RegulatorySpeedLimit : public Base_Type {
  SpeedLimitType field_type__;
  INTEGER field_speed;
  boolean bound_flag;
public:
  RegulatorySpeedLimit();
  RegulatorySpeedLimit(const SpeedLimitType& par_type__,
    const INTEGER& par_speed);
  RegulatorySpeedLimit(const RegulatorySpeedLimit& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RegulatorySpeedLimit& operator=(const RegulatorySpeedLimit& other_value);
  boolean operator==(const RegulatorySpeedLimit& other_value) const;
  inline boolean operator!=(const RegulatorySpeedLimit& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline SpeedLimitType& type__()
    {return field_type__;}
  inline const SpeedLimitType& type__() const
    {return field_type__;}
  inline INTEGER& speed()
    {return field_speed;}
  inline const INTEGER& speed() const
    {return field_speed;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RegulatorySpeedLimit_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RegulatorySpeedLimit_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RegulatorySpeedLimit& other_value);
void copy_template(const RegulatorySpeedLimit_template& other_value);

public:
RegulatorySpeedLimit_template();
RegulatorySpeedLimit_template(template_sel other_value);
RegulatorySpeedLimit_template(const RegulatorySpeedLimit& other_value);
RegulatorySpeedLimit_template(const OPTIONAL<RegulatorySpeedLimit>& other_value);
RegulatorySpeedLimit_template(const RegulatorySpeedLimit_template& other_value);
~RegulatorySpeedLimit_template();
RegulatorySpeedLimit_template& operator=(template_sel other_value);
RegulatorySpeedLimit_template& operator=(const RegulatorySpeedLimit& other_value);
RegulatorySpeedLimit_template& operator=(const OPTIONAL<RegulatorySpeedLimit>& other_value);
RegulatorySpeedLimit_template& operator=(const RegulatorySpeedLimit_template& other_value);
boolean match(const RegulatorySpeedLimit& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegulatorySpeedLimit valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegulatorySpeedLimit_template& list_item(unsigned int list_index) const;
SpeedLimitType_template& type__();
const SpeedLimitType_template& type__() const;
INTEGER_template& speed();
const INTEGER_template& speed() const;
int size_of() const;
void log() const;
void log_match(const RegulatorySpeedLimit& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RegionalNodeAttributeList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
REGION::Reg__NodeAttribute **value_elements;
} *val_ptr;

static const REGION::Reg__NodeAttribute UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RegionalNodeAttributeList& other_value);

public:
  typedef REGION::Reg__NodeAttribute of_type;
RegionalNodeAttributeList();
RegionalNodeAttributeList(null_type other_value);
RegionalNodeAttributeList(const RegionalNodeAttributeList& other_value);
~RegionalNodeAttributeList();

void clean_up();
RegionalNodeAttributeList& operator=(null_type other_value);
RegionalNodeAttributeList& operator=(const RegionalNodeAttributeList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RegionalNodeAttributeList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RegionalNodeAttributeList& other_value) const { return !(*this == other_value); }

REGION::Reg__NodeAttribute& operator[](int index_value);
REGION::Reg__NodeAttribute& operator[](const INTEGER& index_value);
const REGION::Reg__NodeAttribute& operator[](int index_value) const;
const REGION::Reg__NodeAttribute& operator[](const INTEGER& index_value) const;

RegionalNodeAttributeList operator<<=(int rotate_count) const;
RegionalNodeAttributeList operator<<=(const INTEGER& rotate_count) const;
RegionalNodeAttributeList operator>>=(int rotate_count) const;
RegionalNodeAttributeList operator>>=(const INTEGER& rotate_count) const;

RegionalNodeAttributeList operator+(const RegionalNodeAttributeList& other_value) const;

RegionalNodeAttributeList substr(int index, int returncount) const;

RegionalNodeAttributeList replace(int index, int len, const RegionalNodeAttributeList& repl) const;

RegionalNodeAttributeList replace(int index, int len, const RegionalNodeAttributeList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RegionalNodeAttributeList_template : public Record_Of_Template {
union {
struct {
int n_elements;
REGION::Reg__NodeAttribute_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RegionalNodeAttributeList_template *list_value;
} value_list;
};
void copy_value(const RegionalNodeAttributeList& other_value);
void copy_template(const RegionalNodeAttributeList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
RegionalNodeAttributeList_template();
RegionalNodeAttributeList_template(template_sel other_value);
RegionalNodeAttributeList_template(null_type other_value);
RegionalNodeAttributeList_template(const RegionalNodeAttributeList& other_value);
RegionalNodeAttributeList_template(const OPTIONAL<RegionalNodeAttributeList>& other_value);
RegionalNodeAttributeList_template(const RegionalNodeAttributeList_template& other_value);
~RegionalNodeAttributeList_template();

void clean_up();
RegionalNodeAttributeList_template& operator=(template_sel other_value);
RegionalNodeAttributeList_template& operator=(null_type other_value);
RegionalNodeAttributeList_template& operator=(const RegionalNodeAttributeList& other_value);
RegionalNodeAttributeList_template& operator=(const OPTIONAL<RegionalNodeAttributeList>& other_value);
RegionalNodeAttributeList_template& operator=(const RegionalNodeAttributeList_template& other_value);

REGION::Reg__NodeAttribute_template& operator[](int index_value);
REGION::Reg__NodeAttribute_template& operator[](const INTEGER& index_value);
const REGION::Reg__NodeAttribute_template& operator[](int index_value) const;
const REGION::Reg__NodeAttribute_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RegionalNodeAttributeList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RegionalNodeAttributeList valueof() const;
RegionalNodeAttributeList substr(int index, int returncount) const;

RegionalNodeAttributeList replace(int index, int len, const RegionalNodeAttributeList_template& repl) const;

RegionalNodeAttributeList replace(int index, int len, const RegionalNodeAttributeList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RegionalNodeAttributeList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RegionalNodeAttributeList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ComputedLane_offsetXaxis : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_small = 1, ALT_large = 2 };
private:
union_selection_type union_selection;
union {
INTEGER *field_small;
INTEGER *field_large;
};
void copy_value(const ComputedLane_offsetXaxis& other_value);

public:
ComputedLane_offsetXaxis();
ComputedLane_offsetXaxis(const ComputedLane_offsetXaxis& other_value);
~ComputedLane_offsetXaxis();
ComputedLane_offsetXaxis& operator=(const ComputedLane_offsetXaxis& other_value);
boolean operator==(const ComputedLane_offsetXaxis& other_value) const;
inline boolean operator!=(const ComputedLane_offsetXaxis& other_value) const { return !(*this == other_value); }
INTEGER& small();
const INTEGER& small() const;
INTEGER& large();
const INTEGER& large() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class ComputedLane_offsetXaxis_template : public Base_Template {
union {
struct {
ComputedLane_offsetXaxis::union_selection_type union_selection;
union {
INTEGER_template *field_small;
INTEGER_template *field_large;
};
} single_value;
struct {
unsigned int n_values;
ComputedLane_offsetXaxis_template *list_value;
} value_list;
};
void copy_value(const ComputedLane_offsetXaxis& other_value);

void copy_template(const ComputedLane_offsetXaxis_template& other_value);

public:
ComputedLane_offsetXaxis_template();
ComputedLane_offsetXaxis_template(template_sel other_value);
ComputedLane_offsetXaxis_template(const ComputedLane_offsetXaxis& other_value);
ComputedLane_offsetXaxis_template(const OPTIONAL<ComputedLane_offsetXaxis>& other_value);
ComputedLane_offsetXaxis_template(const ComputedLane_offsetXaxis_template& other_value);
~ComputedLane_offsetXaxis_template();
void clean_up();
ComputedLane_offsetXaxis_template& operator=(template_sel other_value);
ComputedLane_offsetXaxis_template& operator=(const ComputedLane_offsetXaxis& other_value);
ComputedLane_offsetXaxis_template& operator=(const OPTIONAL<ComputedLane_offsetXaxis>& other_value);
ComputedLane_offsetXaxis_template& operator=(const ComputedLane_offsetXaxis_template& other_value);
boolean match(const ComputedLane_offsetXaxis& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ComputedLane_offsetXaxis valueof() const;
ComputedLane_offsetXaxis_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& small();
const INTEGER_template& small() const;
INTEGER_template& large();
const INTEGER_template& large() const;
boolean ischosen(ComputedLane_offsetXaxis::union_selection_type checked_selection) const;
void log() const;
void log_match(const ComputedLane_offsetXaxis& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ComputedLane_offsetYaxis : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_small = 1, ALT_large = 2 };
private:
union_selection_type union_selection;
union {
INTEGER *field_small;
INTEGER *field_large;
};
void copy_value(const ComputedLane_offsetYaxis& other_value);

public:
ComputedLane_offsetYaxis();
ComputedLane_offsetYaxis(const ComputedLane_offsetYaxis& other_value);
~ComputedLane_offsetYaxis();
ComputedLane_offsetYaxis& operator=(const ComputedLane_offsetYaxis& other_value);
boolean operator==(const ComputedLane_offsetYaxis& other_value) const;
inline boolean operator!=(const ComputedLane_offsetYaxis& other_value) const { return !(*this == other_value); }
INTEGER& small();
const INTEGER& small() const;
INTEGER& large();
const INTEGER& large() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class ComputedLane_offsetYaxis_template : public Base_Template {
union {
struct {
ComputedLane_offsetYaxis::union_selection_type union_selection;
union {
INTEGER_template *field_small;
INTEGER_template *field_large;
};
} single_value;
struct {
unsigned int n_values;
ComputedLane_offsetYaxis_template *list_value;
} value_list;
};
void copy_value(const ComputedLane_offsetYaxis& other_value);

void copy_template(const ComputedLane_offsetYaxis_template& other_value);

public:
ComputedLane_offsetYaxis_template();
ComputedLane_offsetYaxis_template(template_sel other_value);
ComputedLane_offsetYaxis_template(const ComputedLane_offsetYaxis& other_value);
ComputedLane_offsetYaxis_template(const OPTIONAL<ComputedLane_offsetYaxis>& other_value);
ComputedLane_offsetYaxis_template(const ComputedLane_offsetYaxis_template& other_value);
~ComputedLane_offsetYaxis_template();
void clean_up();
ComputedLane_offsetYaxis_template& operator=(template_sel other_value);
ComputedLane_offsetYaxis_template& operator=(const ComputedLane_offsetYaxis& other_value);
ComputedLane_offsetYaxis_template& operator=(const OPTIONAL<ComputedLane_offsetYaxis>& other_value);
ComputedLane_offsetYaxis_template& operator=(const ComputedLane_offsetYaxis_template& other_value);
boolean match(const ComputedLane_offsetYaxis& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ComputedLane_offsetYaxis valueof() const;
ComputedLane_offsetYaxis_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& small();
const INTEGER_template& small() const;
INTEGER_template& large();
const INTEGER_template& large() const;
boolean ischosen(ComputedLane_offsetYaxis::union_selection_type checked_selection) const;
void log() const;
void log_match(const ComputedLane_offsetYaxis& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ComputedLane : public Base_Type {
  INTEGER field_referenceLaneId;
  ComputedLane_offsetXaxis field_offsetXaxis;
  ComputedLane_offsetYaxis field_offsetYaxis;
  OPTIONAL<INTEGER> field_rotateXY;
  OPTIONAL<INTEGER> field_scaleXaxis;
  OPTIONAL<INTEGER> field_scaleYaxis;
  OPTIONAL<REGION::Reg__ComputedLane> field_regional;
  boolean bound_flag;
public:
  ComputedLane();
  ComputedLane(const INTEGER& par_referenceLaneId,
    const ComputedLane_offsetXaxis& par_offsetXaxis,
    const ComputedLane_offsetYaxis& par_offsetYaxis,
    const OPTIONAL<INTEGER>& par_rotateXY,
    const OPTIONAL<INTEGER>& par_scaleXaxis,
    const OPTIONAL<INTEGER>& par_scaleYaxis,
    const OPTIONAL<REGION::Reg__ComputedLane>& par_regional);
  ComputedLane(const ComputedLane& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ComputedLane& operator=(const ComputedLane& other_value);
  boolean operator==(const ComputedLane& other_value) const;
  inline boolean operator!=(const ComputedLane& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& referenceLaneId()
    {return field_referenceLaneId;}
  inline const INTEGER& referenceLaneId() const
    {return field_referenceLaneId;}
  inline ComputedLane_offsetXaxis& offsetXaxis()
    {return field_offsetXaxis;}
  inline const ComputedLane_offsetXaxis& offsetXaxis() const
    {return field_offsetXaxis;}
  inline ComputedLane_offsetYaxis& offsetYaxis()
    {return field_offsetYaxis;}
  inline const ComputedLane_offsetYaxis& offsetYaxis() const
    {return field_offsetYaxis;}
  inline OPTIONAL<INTEGER>& rotateXY()
    {return field_rotateXY;}
  inline const OPTIONAL<INTEGER>& rotateXY() const
    {return field_rotateXY;}
  inline OPTIONAL<INTEGER>& scaleXaxis()
    {return field_scaleXaxis;}
  inline const OPTIONAL<INTEGER>& scaleXaxis() const
    {return field_scaleXaxis;}
  inline OPTIONAL<INTEGER>& scaleYaxis()
    {return field_scaleYaxis;}
  inline const OPTIONAL<INTEGER>& scaleYaxis() const
    {return field_scaleYaxis;}
  inline OPTIONAL<REGION::Reg__ComputedLane>& regional()
    {return field_regional;}
  inline const OPTIONAL<REGION::Reg__ComputedLane>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ComputedLane_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ComputedLane_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ComputedLane& other_value);
void copy_template(const ComputedLane_template& other_value);

public:
ComputedLane_template();
ComputedLane_template(template_sel other_value);
ComputedLane_template(const ComputedLane& other_value);
ComputedLane_template(const OPTIONAL<ComputedLane>& other_value);
ComputedLane_template(const ComputedLane_template& other_value);
~ComputedLane_template();
ComputedLane_template& operator=(template_sel other_value);
ComputedLane_template& operator=(const ComputedLane& other_value);
ComputedLane_template& operator=(const OPTIONAL<ComputedLane>& other_value);
ComputedLane_template& operator=(const ComputedLane_template& other_value);
boolean match(const ComputedLane& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ComputedLane valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ComputedLane_template& list_item(unsigned int list_index) const;
INTEGER_template& referenceLaneId();
const INTEGER_template& referenceLaneId() const;
ComputedLane_offsetXaxis_template& offsetXaxis();
const ComputedLane_offsetXaxis_template& offsetXaxis() const;
ComputedLane_offsetYaxis_template& offsetYaxis();
const ComputedLane_offsetYaxis_template& offsetYaxis() const;
INTEGER_template& rotateXY();
const INTEGER_template& rotateXY() const;
INTEGER_template& scaleXaxis();
const INTEGER_template& scaleXaxis() const;
INTEGER_template& scaleYaxis();
const INTEGER_template& scaleYaxis() const;
REGION::Reg__ComputedLane_template& regional();
const REGION::Reg__ComputedLane_template& regional() const;
int size_of() const;
void log() const;
void log_match(const ComputedLane& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GenericLane : public Base_Type {
  INTEGER field_laneID;
  OPTIONAL<CHARSTRING> field_name;
  OPTIONAL<INTEGER> field_ingressApproach;
  OPTIONAL<INTEGER> field_egressApproach;
  LaneAttributes field_laneAttributes;
  OPTIONAL<BITSTRING> field_maneuvers;
  NodeList2 field_nodeList;
  OPTIONAL<ConnectsToList> field_connectsTo;
  OPTIONAL<OverlayLaneList> field_overlays;
  OPTIONAL<REGION::Reg__GenericLane> field_regional;
  boolean bound_flag;
public:
  GenericLane();
  GenericLane(const INTEGER& par_laneID,
    const OPTIONAL<CHARSTRING>& par_name,
    const OPTIONAL<INTEGER>& par_ingressApproach,
    const OPTIONAL<INTEGER>& par_egressApproach,
    const LaneAttributes& par_laneAttributes,
    const OPTIONAL<BITSTRING>& par_maneuvers,
    const NodeList2& par_nodeList,
    const OPTIONAL<ConnectsToList>& par_connectsTo,
    const OPTIONAL<OverlayLaneList>& par_overlays,
    const OPTIONAL<REGION::Reg__GenericLane>& par_regional);
  GenericLane(const GenericLane& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GenericLane& operator=(const GenericLane& other_value);
  boolean operator==(const GenericLane& other_value) const;
  inline boolean operator!=(const GenericLane& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& laneID()
    {return field_laneID;}
  inline const INTEGER& laneID() const
    {return field_laneID;}
  inline OPTIONAL<CHARSTRING>& name()
    {return field_name;}
  inline const OPTIONAL<CHARSTRING>& name() const
    {return field_name;}
  inline OPTIONAL<INTEGER>& ingressApproach()
    {return field_ingressApproach;}
  inline const OPTIONAL<INTEGER>& ingressApproach() const
    {return field_ingressApproach;}
  inline OPTIONAL<INTEGER>& egressApproach()
    {return field_egressApproach;}
  inline const OPTIONAL<INTEGER>& egressApproach() const
    {return field_egressApproach;}
  inline LaneAttributes& laneAttributes()
    {return field_laneAttributes;}
  inline const LaneAttributes& laneAttributes() const
    {return field_laneAttributes;}
  inline OPTIONAL<BITSTRING>& maneuvers()
    {return field_maneuvers;}
  inline const OPTIONAL<BITSTRING>& maneuvers() const
    {return field_maneuvers;}
  inline NodeList2& nodeList()
    {return field_nodeList;}
  inline const NodeList2& nodeList() const
    {return field_nodeList;}
  inline OPTIONAL<ConnectsToList>& connectsTo()
    {return field_connectsTo;}
  inline const OPTIONAL<ConnectsToList>& connectsTo() const
    {return field_connectsTo;}
  inline OPTIONAL<OverlayLaneList>& overlays()
    {return field_overlays;}
  inline const OPTIONAL<OverlayLaneList>& overlays() const
    {return field_overlays;}
  inline OPTIONAL<REGION::Reg__GenericLane>& regional()
    {return field_regional;}
  inline const OPTIONAL<REGION::Reg__GenericLane>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GenericLane_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GenericLane_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GenericLane& other_value);
void copy_template(const GenericLane_template& other_value);

public:
GenericLane_template();
GenericLane_template(template_sel other_value);
GenericLane_template(const GenericLane& other_value);
GenericLane_template(const OPTIONAL<GenericLane>& other_value);
GenericLane_template(const GenericLane_template& other_value);
~GenericLane_template();
GenericLane_template& operator=(template_sel other_value);
GenericLane_template& operator=(const GenericLane& other_value);
GenericLane_template& operator=(const OPTIONAL<GenericLane>& other_value);
GenericLane_template& operator=(const GenericLane_template& other_value);
boolean match(const GenericLane& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GenericLane valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GenericLane_template& list_item(unsigned int list_index) const;
INTEGER_template& laneID();
const INTEGER_template& laneID() const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
INTEGER_template& ingressApproach();
const INTEGER_template& ingressApproach() const;
INTEGER_template& egressApproach();
const INTEGER_template& egressApproach() const;
LaneAttributes_template& laneAttributes();
const LaneAttributes_template& laneAttributes() const;
BITSTRING_template& maneuvers();
const BITSTRING_template& maneuvers() const;
NodeList2_template& nodeList();
const NodeList2_template& nodeList() const;
ConnectsToList_template& connectsTo();
const ConnectsToList_template& connectsTo() const;
OverlayLaneList_template& overlays();
const OverlayLaneList_template& overlays() const;
REGION::Reg__GenericLane_template& regional();
const REGION::Reg__GenericLane_template& regional() const;
int size_of() const;
void log() const;
void log_match(const GenericLane& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ConnectsToList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Connection **value_elements;
} *val_ptr;

static const Connection UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ConnectsToList& other_value);

public:
  typedef Connection of_type;
ConnectsToList();
ConnectsToList(null_type other_value);
ConnectsToList(const ConnectsToList& other_value);
~ConnectsToList();

void clean_up();
ConnectsToList& operator=(null_type other_value);
ConnectsToList& operator=(const ConnectsToList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ConnectsToList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ConnectsToList& other_value) const { return !(*this == other_value); }

Connection& operator[](int index_value);
Connection& operator[](const INTEGER& index_value);
const Connection& operator[](int index_value) const;
const Connection& operator[](const INTEGER& index_value) const;

ConnectsToList operator<<=(int rotate_count) const;
ConnectsToList operator<<=(const INTEGER& rotate_count) const;
ConnectsToList operator>>=(int rotate_count) const;
ConnectsToList operator>>=(const INTEGER& rotate_count) const;

ConnectsToList operator+(const ConnectsToList& other_value) const;

ConnectsToList substr(int index, int returncount) const;

ConnectsToList replace(int index, int len, const ConnectsToList& repl) const;

ConnectsToList replace(int index, int len, const ConnectsToList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ConnectsToList_template : public Record_Of_Template {
union {
struct {
int n_elements;
Connection_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ConnectsToList_template *list_value;
} value_list;
};
void copy_value(const ConnectsToList& other_value);
void copy_template(const ConnectsToList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ConnectsToList_template();
ConnectsToList_template(template_sel other_value);
ConnectsToList_template(null_type other_value);
ConnectsToList_template(const ConnectsToList& other_value);
ConnectsToList_template(const OPTIONAL<ConnectsToList>& other_value);
ConnectsToList_template(const ConnectsToList_template& other_value);
~ConnectsToList_template();

void clean_up();
ConnectsToList_template& operator=(template_sel other_value);
ConnectsToList_template& operator=(null_type other_value);
ConnectsToList_template& operator=(const ConnectsToList& other_value);
ConnectsToList_template& operator=(const OPTIONAL<ConnectsToList>& other_value);
ConnectsToList_template& operator=(const ConnectsToList_template& other_value);

Connection_template& operator[](int index_value);
Connection_template& operator[](const INTEGER& index_value);
const Connection_template& operator[](int index_value) const;
const Connection_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ConnectsToList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ConnectsToList valueof() const;
ConnectsToList substr(int index, int returncount) const;

ConnectsToList replace(int index, int len, const ConnectsToList_template& repl) const;

ConnectsToList replace(int index, int len, const ConnectsToList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ConnectsToList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ConnectsToList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ConnectingLane : public Base_Type {
  INTEGER field_lane;
  OPTIONAL<BITSTRING> field_maneuver;
  boolean bound_flag;
public:
  ConnectingLane();
  ConnectingLane(const INTEGER& par_lane,
    const OPTIONAL<BITSTRING>& par_maneuver);
  ConnectingLane(const ConnectingLane& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ConnectingLane& operator=(const ConnectingLane& other_value);
  boolean operator==(const ConnectingLane& other_value) const;
  inline boolean operator!=(const ConnectingLane& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& lane()
    {return field_lane;}
  inline const INTEGER& lane() const
    {return field_lane;}
  inline OPTIONAL<BITSTRING>& maneuver()
    {return field_maneuver;}
  inline const OPTIONAL<BITSTRING>& maneuver() const
    {return field_maneuver;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ConnectingLane_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ConnectingLane_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ConnectingLane& other_value);
void copy_template(const ConnectingLane_template& other_value);

public:
ConnectingLane_template();
ConnectingLane_template(template_sel other_value);
ConnectingLane_template(const ConnectingLane& other_value);
ConnectingLane_template(const OPTIONAL<ConnectingLane>& other_value);
ConnectingLane_template(const ConnectingLane_template& other_value);
~ConnectingLane_template();
ConnectingLane_template& operator=(template_sel other_value);
ConnectingLane_template& operator=(const ConnectingLane& other_value);
ConnectingLane_template& operator=(const OPTIONAL<ConnectingLane>& other_value);
ConnectingLane_template& operator=(const ConnectingLane_template& other_value);
boolean match(const ConnectingLane& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ConnectingLane valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ConnectingLane_template& list_item(unsigned int list_index) const;
INTEGER_template& lane();
const INTEGER_template& lane() const;
BITSTRING_template& maneuver();
const BITSTRING_template& maneuver() const;
int size_of() const;
void log() const;
void log_match(const ConnectingLane& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Connection : public Base_Type {
  ConnectingLane field_connectingLane;
  OPTIONAL<IntersectionReferenceID> field_remoteIntersection;
  OPTIONAL<INTEGER> field_signalGroup;
  OPTIONAL<INTEGER> field_userClass;
  OPTIONAL<INTEGER> field_connectionID;
  boolean bound_flag;
public:
  Connection();
  Connection(const ConnectingLane& par_connectingLane,
    const OPTIONAL<IntersectionReferenceID>& par_remoteIntersection,
    const OPTIONAL<INTEGER>& par_signalGroup,
    const OPTIONAL<INTEGER>& par_userClass,
    const OPTIONAL<INTEGER>& par_connectionID);
  Connection(const Connection& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Connection& operator=(const Connection& other_value);
  boolean operator==(const Connection& other_value) const;
  inline boolean operator!=(const Connection& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ConnectingLane& connectingLane()
    {return field_connectingLane;}
  inline const ConnectingLane& connectingLane() const
    {return field_connectingLane;}
  inline OPTIONAL<IntersectionReferenceID>& remoteIntersection()
    {return field_remoteIntersection;}
  inline const OPTIONAL<IntersectionReferenceID>& remoteIntersection() const
    {return field_remoteIntersection;}
  inline OPTIONAL<INTEGER>& signalGroup()
    {return field_signalGroup;}
  inline const OPTIONAL<INTEGER>& signalGroup() const
    {return field_signalGroup;}
  inline OPTIONAL<INTEGER>& userClass()
    {return field_userClass;}
  inline const OPTIONAL<INTEGER>& userClass() const
    {return field_userClass;}
  inline OPTIONAL<INTEGER>& connectionID()
    {return field_connectionID;}
  inline const OPTIONAL<INTEGER>& connectionID() const
    {return field_connectionID;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Connection_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Connection_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Connection& other_value);
void copy_template(const Connection_template& other_value);

public:
Connection_template();
Connection_template(template_sel other_value);
Connection_template(const Connection& other_value);
Connection_template(const OPTIONAL<Connection>& other_value);
Connection_template(const Connection_template& other_value);
~Connection_template();
Connection_template& operator=(template_sel other_value);
Connection_template& operator=(const Connection& other_value);
Connection_template& operator=(const OPTIONAL<Connection>& other_value);
Connection_template& operator=(const Connection_template& other_value);
boolean match(const Connection& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Connection valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Connection_template& list_item(unsigned int list_index) const;
ConnectingLane_template& connectingLane();
const ConnectingLane_template& connectingLane() const;
IntersectionReferenceID_template& remoteIntersection();
const IntersectionReferenceID_template& remoteIntersection() const;
INTEGER_template& signalGroup();
const INTEGER_template& signalGroup() const;
INTEGER_template& userClass();
const INTEGER_template& userClass() const;
INTEGER_template& connectionID();
const INTEGER_template& connectionID() const;
int size_of() const;
void log() const;
void log_match(const Connection& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class IntersectionGeometry : public Base_Type {
  OPTIONAL<CHARSTRING> field_name;
  IntersectionReferenceID field_id;
  INTEGER field_revision;
  Position3D__2 field_refPoint;
  OPTIONAL<INTEGER> field_laneWidth;
  OPTIONAL<SpeedLimitList> field_speedLimits;
  LaneList field_laneSet;
  OPTIONAL<PreemptPriorityList> field_preemptPriorityData;
  OPTIONAL<REGION::Reg__Intersection> field_regional;
  boolean bound_flag;
public:
  IntersectionGeometry();
  IntersectionGeometry(const OPTIONAL<CHARSTRING>& par_name,
    const IntersectionReferenceID& par_id,
    const INTEGER& par_revision,
    const Position3D__2& par_refPoint,
    const OPTIONAL<INTEGER>& par_laneWidth,
    const OPTIONAL<SpeedLimitList>& par_speedLimits,
    const LaneList& par_laneSet,
    const OPTIONAL<PreemptPriorityList>& par_preemptPriorityData,
    const OPTIONAL<REGION::Reg__Intersection>& par_regional);
  IntersectionGeometry(const IntersectionGeometry& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IntersectionGeometry& operator=(const IntersectionGeometry& other_value);
  boolean operator==(const IntersectionGeometry& other_value) const;
  inline boolean operator!=(const IntersectionGeometry& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& name()
    {return field_name;}
  inline const OPTIONAL<CHARSTRING>& name() const
    {return field_name;}
  inline IntersectionReferenceID& id()
    {return field_id;}
  inline const IntersectionReferenceID& id() const
    {return field_id;}
  inline INTEGER& revision()
    {return field_revision;}
  inline const INTEGER& revision() const
    {return field_revision;}
  inline Position3D__2& refPoint()
    {return field_refPoint;}
  inline const Position3D__2& refPoint() const
    {return field_refPoint;}
  inline OPTIONAL<INTEGER>& laneWidth()
    {return field_laneWidth;}
  inline const OPTIONAL<INTEGER>& laneWidth() const
    {return field_laneWidth;}
  inline OPTIONAL<SpeedLimitList>& speedLimits()
    {return field_speedLimits;}
  inline const OPTIONAL<SpeedLimitList>& speedLimits() const
    {return field_speedLimits;}
  inline LaneList& laneSet()
    {return field_laneSet;}
  inline const LaneList& laneSet() const
    {return field_laneSet;}
  inline OPTIONAL<PreemptPriorityList>& preemptPriorityData()
    {return field_preemptPriorityData;}
  inline const OPTIONAL<PreemptPriorityList>& preemptPriorityData() const
    {return field_preemptPriorityData;}
  inline OPTIONAL<REGION::Reg__Intersection>& regional()
    {return field_regional;}
  inline const OPTIONAL<REGION::Reg__Intersection>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IntersectionGeometry_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IntersectionGeometry_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IntersectionGeometry& other_value);
void copy_template(const IntersectionGeometry_template& other_value);

public:
IntersectionGeometry_template();
IntersectionGeometry_template(template_sel other_value);
IntersectionGeometry_template(const IntersectionGeometry& other_value);
IntersectionGeometry_template(const OPTIONAL<IntersectionGeometry>& other_value);
IntersectionGeometry_template(const IntersectionGeometry_template& other_value);
~IntersectionGeometry_template();
IntersectionGeometry_template& operator=(template_sel other_value);
IntersectionGeometry_template& operator=(const IntersectionGeometry& other_value);
IntersectionGeometry_template& operator=(const OPTIONAL<IntersectionGeometry>& other_value);
IntersectionGeometry_template& operator=(const IntersectionGeometry_template& other_value);
boolean match(const IntersectionGeometry& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IntersectionGeometry valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IntersectionGeometry_template& list_item(unsigned int list_index) const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
IntersectionReferenceID_template& id();
const IntersectionReferenceID_template& id() const;
INTEGER_template& revision();
const INTEGER_template& revision() const;
Position3D__2_template& refPoint();
const Position3D__2_template& refPoint() const;
INTEGER_template& laneWidth();
const INTEGER_template& laneWidth() const;
SpeedLimitList_template& speedLimits();
const SpeedLimitList_template& speedLimits() const;
LaneList_template& laneSet();
const LaneList_template& laneSet() const;
PreemptPriorityList_template& preemptPriorityData();
const PreemptPriorityList_template& preemptPriorityData() const;
REGION::Reg__Intersection_template& regional();
const REGION::Reg__Intersection_template& regional() const;
int size_of() const;
void log() const;
void log_match(const IntersectionGeometry& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PreemptPriorityList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
REGION::Reg__SignalControlZone **value_elements;
} *val_ptr;

static const REGION::Reg__SignalControlZone UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PreemptPriorityList& other_value);

public:
  typedef REGION::Reg__SignalControlZone of_type;
PreemptPriorityList();
PreemptPriorityList(null_type other_value);
PreemptPriorityList(const PreemptPriorityList& other_value);
~PreemptPriorityList();

void clean_up();
PreemptPriorityList& operator=(null_type other_value);
PreemptPriorityList& operator=(const PreemptPriorityList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PreemptPriorityList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PreemptPriorityList& other_value) const { return !(*this == other_value); }

REGION::Reg__SignalControlZone& operator[](int index_value);
REGION::Reg__SignalControlZone& operator[](const INTEGER& index_value);
const REGION::Reg__SignalControlZone& operator[](int index_value) const;
const REGION::Reg__SignalControlZone& operator[](const INTEGER& index_value) const;

PreemptPriorityList operator<<=(int rotate_count) const;
PreemptPriorityList operator<<=(const INTEGER& rotate_count) const;
PreemptPriorityList operator>>=(int rotate_count) const;
PreemptPriorityList operator>>=(const INTEGER& rotate_count) const;

PreemptPriorityList operator+(const PreemptPriorityList& other_value) const;

PreemptPriorityList substr(int index, int returncount) const;

PreemptPriorityList replace(int index, int len, const PreemptPriorityList& repl) const;

PreemptPriorityList replace(int index, int len, const PreemptPriorityList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PreemptPriorityList_template : public Record_Of_Template {
union {
struct {
int n_elements;
REGION::Reg__SignalControlZone_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PreemptPriorityList_template *list_value;
} value_list;
};
void copy_value(const PreemptPriorityList& other_value);
void copy_template(const PreemptPriorityList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
PreemptPriorityList_template();
PreemptPriorityList_template(template_sel other_value);
PreemptPriorityList_template(null_type other_value);
PreemptPriorityList_template(const PreemptPriorityList& other_value);
PreemptPriorityList_template(const OPTIONAL<PreemptPriorityList>& other_value);
PreemptPriorityList_template(const PreemptPriorityList_template& other_value);
~PreemptPriorityList_template();

void clean_up();
PreemptPriorityList_template& operator=(template_sel other_value);
PreemptPriorityList_template& operator=(null_type other_value);
PreemptPriorityList_template& operator=(const PreemptPriorityList& other_value);
PreemptPriorityList_template& operator=(const OPTIONAL<PreemptPriorityList>& other_value);
PreemptPriorityList_template& operator=(const PreemptPriorityList_template& other_value);

REGION::Reg__SignalControlZone_template& operator[](int index_value);
REGION::Reg__SignalControlZone_template& operator[](const INTEGER& index_value);
const REGION::Reg__SignalControlZone_template& operator[](int index_value) const;
const REGION::Reg__SignalControlZone_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PreemptPriorityList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PreemptPriorityList valueof() const;
PreemptPriorityList substr(int index, int returncount) const;

PreemptPriorityList replace(int index, int len, const PreemptPriorityList_template& repl) const;

PreemptPriorityList replace(int index, int len, const PreemptPriorityList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PreemptPriorityList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PreemptPriorityList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RoadSegmentList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
RoadSegment **value_elements;
} *val_ptr;

static const RoadSegment UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RoadSegmentList& other_value);

public:
  typedef RoadSegment of_type;
RoadSegmentList();
RoadSegmentList(null_type other_value);
RoadSegmentList(const RoadSegmentList& other_value);
~RoadSegmentList();

void clean_up();
RoadSegmentList& operator=(null_type other_value);
RoadSegmentList& operator=(const RoadSegmentList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RoadSegmentList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RoadSegmentList& other_value) const { return !(*this == other_value); }

RoadSegment& operator[](int index_value);
RoadSegment& operator[](const INTEGER& index_value);
const RoadSegment& operator[](int index_value) const;
const RoadSegment& operator[](const INTEGER& index_value) const;

RoadSegmentList operator<<=(int rotate_count) const;
RoadSegmentList operator<<=(const INTEGER& rotate_count) const;
RoadSegmentList operator>>=(int rotate_count) const;
RoadSegmentList operator>>=(const INTEGER& rotate_count) const;

RoadSegmentList operator+(const RoadSegmentList& other_value) const;

RoadSegmentList substr(int index, int returncount) const;

RoadSegmentList replace(int index, int len, const RoadSegmentList& repl) const;

RoadSegmentList replace(int index, int len, const RoadSegmentList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RoadSegmentList_template : public Record_Of_Template {
union {
struct {
int n_elements;
RoadSegment_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RoadSegmentList_template *list_value;
} value_list;
};
void copy_value(const RoadSegmentList& other_value);
void copy_template(const RoadSegmentList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
RoadSegmentList_template();
RoadSegmentList_template(template_sel other_value);
RoadSegmentList_template(null_type other_value);
RoadSegmentList_template(const RoadSegmentList& other_value);
RoadSegmentList_template(const OPTIONAL<RoadSegmentList>& other_value);
RoadSegmentList_template(const RoadSegmentList_template& other_value);
~RoadSegmentList_template();

void clean_up();
RoadSegmentList_template& operator=(template_sel other_value);
RoadSegmentList_template& operator=(null_type other_value);
RoadSegmentList_template& operator=(const RoadSegmentList& other_value);
RoadSegmentList_template& operator=(const OPTIONAL<RoadSegmentList>& other_value);
RoadSegmentList_template& operator=(const RoadSegmentList_template& other_value);

RoadSegment_template& operator[](int index_value);
RoadSegment_template& operator[](const INTEGER& index_value);
const RoadSegment_template& operator[](int index_value) const;
const RoadSegment_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RoadSegmentList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RoadSegmentList valueof() const;
RoadSegmentList substr(int index, int returncount) const;

RoadSegmentList replace(int index, int len, const RoadSegmentList_template& repl) const;

RoadSegmentList replace(int index, int len, const RoadSegmentList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RoadSegmentList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RoadSegmentList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RoadSegmentReferenceID : public Base_Type {
  OPTIONAL<INTEGER> field_region;
  INTEGER field_id;
  boolean bound_flag;
public:
  RoadSegmentReferenceID();
  RoadSegmentReferenceID(const OPTIONAL<INTEGER>& par_region,
    const INTEGER& par_id);
  RoadSegmentReferenceID(const RoadSegmentReferenceID& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RoadSegmentReferenceID& operator=(const RoadSegmentReferenceID& other_value);
  boolean operator==(const RoadSegmentReferenceID& other_value) const;
  inline boolean operator!=(const RoadSegmentReferenceID& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& region()
    {return field_region;}
  inline const OPTIONAL<INTEGER>& region() const
    {return field_region;}
  inline INTEGER& id()
    {return field_id;}
  inline const INTEGER& id() const
    {return field_id;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RoadSegmentReferenceID_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RoadSegmentReferenceID_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RoadSegmentReferenceID& other_value);
void copy_template(const RoadSegmentReferenceID_template& other_value);

public:
RoadSegmentReferenceID_template();
RoadSegmentReferenceID_template(template_sel other_value);
RoadSegmentReferenceID_template(const RoadSegmentReferenceID& other_value);
RoadSegmentReferenceID_template(const OPTIONAL<RoadSegmentReferenceID>& other_value);
RoadSegmentReferenceID_template(const RoadSegmentReferenceID_template& other_value);
~RoadSegmentReferenceID_template();
RoadSegmentReferenceID_template& operator=(template_sel other_value);
RoadSegmentReferenceID_template& operator=(const RoadSegmentReferenceID& other_value);
RoadSegmentReferenceID_template& operator=(const OPTIONAL<RoadSegmentReferenceID>& other_value);
RoadSegmentReferenceID_template& operator=(const RoadSegmentReferenceID_template& other_value);
boolean match(const RoadSegmentReferenceID& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RoadSegmentReferenceID valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RoadSegmentReferenceID_template& list_item(unsigned int list_index) const;
INTEGER_template& region();
const INTEGER_template& region() const;
INTEGER_template& id();
const INTEGER_template& id() const;
int size_of() const;
void log() const;
void log_match(const RoadSegmentReferenceID& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RoadLaneSetList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
GenericLane **value_elements;
} *val_ptr;

static const GenericLane UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RoadLaneSetList& other_value);

public:
  typedef GenericLane of_type;
RoadLaneSetList();
RoadLaneSetList(null_type other_value);
RoadLaneSetList(const RoadLaneSetList& other_value);
~RoadLaneSetList();

void clean_up();
RoadLaneSetList& operator=(null_type other_value);
RoadLaneSetList& operator=(const RoadLaneSetList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RoadLaneSetList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RoadLaneSetList& other_value) const { return !(*this == other_value); }

GenericLane& operator[](int index_value);
GenericLane& operator[](const INTEGER& index_value);
const GenericLane& operator[](int index_value) const;
const GenericLane& operator[](const INTEGER& index_value) const;

RoadLaneSetList operator<<=(int rotate_count) const;
RoadLaneSetList operator<<=(const INTEGER& rotate_count) const;
RoadLaneSetList operator>>=(int rotate_count) const;
RoadLaneSetList operator>>=(const INTEGER& rotate_count) const;

RoadLaneSetList operator+(const RoadLaneSetList& other_value) const;

RoadLaneSetList substr(int index, int returncount) const;

RoadLaneSetList replace(int index, int len, const RoadLaneSetList& repl) const;

RoadLaneSetList replace(int index, int len, const RoadLaneSetList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RoadLaneSetList_template : public Record_Of_Template {
union {
struct {
int n_elements;
GenericLane_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RoadLaneSetList_template *list_value;
} value_list;
};
void copy_value(const RoadLaneSetList& other_value);
void copy_template(const RoadLaneSetList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
RoadLaneSetList_template();
RoadLaneSetList_template(template_sel other_value);
RoadLaneSetList_template(null_type other_value);
RoadLaneSetList_template(const RoadLaneSetList& other_value);
RoadLaneSetList_template(const OPTIONAL<RoadLaneSetList>& other_value);
RoadLaneSetList_template(const RoadLaneSetList_template& other_value);
~RoadLaneSetList_template();

void clean_up();
RoadLaneSetList_template& operator=(template_sel other_value);
RoadLaneSetList_template& operator=(null_type other_value);
RoadLaneSetList_template& operator=(const RoadLaneSetList& other_value);
RoadLaneSetList_template& operator=(const OPTIONAL<RoadLaneSetList>& other_value);
RoadLaneSetList_template& operator=(const RoadLaneSetList_template& other_value);

GenericLane_template& operator[](int index_value);
GenericLane_template& operator[](const INTEGER& index_value);
const GenericLane_template& operator[](int index_value) const;
const GenericLane_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RoadLaneSetList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RoadLaneSetList valueof() const;
RoadLaneSetList substr(int index, int returncount) const;

RoadLaneSetList replace(int index, int len, const RoadLaneSetList_template& repl) const;

RoadLaneSetList replace(int index, int len, const RoadLaneSetList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RoadLaneSetList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RoadLaneSetList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RoadSegment : public Base_Type {
  OPTIONAL<CHARSTRING> field_name;
  RoadSegmentReferenceID field_id;
  INTEGER field_revision;
  Position3D__2 field_refPoint;
  OPTIONAL<INTEGER> field_laneWidth;
  OPTIONAL<SpeedLimitList> field_speedLimits;
  RoadLaneSetList field_roadLaneSet;
  OPTIONAL<REGION::Reg__RoadSegment> field_regional;
  boolean bound_flag;
public:
  RoadSegment();
  RoadSegment(const OPTIONAL<CHARSTRING>& par_name,
    const RoadSegmentReferenceID& par_id,
    const INTEGER& par_revision,
    const Position3D__2& par_refPoint,
    const OPTIONAL<INTEGER>& par_laneWidth,
    const OPTIONAL<SpeedLimitList>& par_speedLimits,
    const RoadLaneSetList& par_roadLaneSet,
    const OPTIONAL<REGION::Reg__RoadSegment>& par_regional);
  RoadSegment(const RoadSegment& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RoadSegment& operator=(const RoadSegment& other_value);
  boolean operator==(const RoadSegment& other_value) const;
  inline boolean operator!=(const RoadSegment& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& name()
    {return field_name;}
  inline const OPTIONAL<CHARSTRING>& name() const
    {return field_name;}
  inline RoadSegmentReferenceID& id()
    {return field_id;}
  inline const RoadSegmentReferenceID& id() const
    {return field_id;}
  inline INTEGER& revision()
    {return field_revision;}
  inline const INTEGER& revision() const
    {return field_revision;}
  inline Position3D__2& refPoint()
    {return field_refPoint;}
  inline const Position3D__2& refPoint() const
    {return field_refPoint;}
  inline OPTIONAL<INTEGER>& laneWidth()
    {return field_laneWidth;}
  inline const OPTIONAL<INTEGER>& laneWidth() const
    {return field_laneWidth;}
  inline OPTIONAL<SpeedLimitList>& speedLimits()
    {return field_speedLimits;}
  inline const OPTIONAL<SpeedLimitList>& speedLimits() const
    {return field_speedLimits;}
  inline RoadLaneSetList& roadLaneSet()
    {return field_roadLaneSet;}
  inline const RoadLaneSetList& roadLaneSet() const
    {return field_roadLaneSet;}
  inline OPTIONAL<REGION::Reg__RoadSegment>& regional()
    {return field_regional;}
  inline const OPTIONAL<REGION::Reg__RoadSegment>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RoadSegment_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RoadSegment_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RoadSegment& other_value);
void copy_template(const RoadSegment_template& other_value);

public:
RoadSegment_template();
RoadSegment_template(template_sel other_value);
RoadSegment_template(const RoadSegment& other_value);
RoadSegment_template(const OPTIONAL<RoadSegment>& other_value);
RoadSegment_template(const RoadSegment_template& other_value);
~RoadSegment_template();
RoadSegment_template& operator=(template_sel other_value);
RoadSegment_template& operator=(const RoadSegment& other_value);
RoadSegment_template& operator=(const OPTIONAL<RoadSegment>& other_value);
RoadSegment_template& operator=(const RoadSegment_template& other_value);
boolean match(const RoadSegment& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RoadSegment valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RoadSegment_template& list_item(unsigned int list_index) const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
RoadSegmentReferenceID_template& id();
const RoadSegmentReferenceID_template& id() const;
INTEGER_template& revision();
const INTEGER_template& revision() const;
Position3D__2_template& refPoint();
const Position3D__2_template& refPoint() const;
INTEGER_template& laneWidth();
const INTEGER_template& laneWidth() const;
SpeedLimitList_template& speedLimits();
const SpeedLimitList_template& speedLimits() const;
RoadLaneSetList_template& roadLaneSet();
const RoadLaneSetList_template& roadLaneSet() const;
REGION::Reg__RoadSegment_template& regional();
const REGION::Reg__RoadSegment_template& regional() const;
int size_of() const;
void log() const;
void log_match(const RoadSegment& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DataParameters : public Base_Type {
  OPTIONAL<CHARSTRING> field_processMethod;
  OPTIONAL<CHARSTRING> field_processAgency;
  OPTIONAL<CHARSTRING> field_lastCheckedDate;
  OPTIONAL<CHARSTRING> field_geoidUsed;
  boolean bound_flag;
public:
  DataParameters();
  DataParameters(const OPTIONAL<CHARSTRING>& par_processMethod,
    const OPTIONAL<CHARSTRING>& par_processAgency,
    const OPTIONAL<CHARSTRING>& par_lastCheckedDate,
    const OPTIONAL<CHARSTRING>& par_geoidUsed);
  DataParameters(const DataParameters& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DataParameters& operator=(const DataParameters& other_value);
  boolean operator==(const DataParameters& other_value) const;
  inline boolean operator!=(const DataParameters& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& processMethod()
    {return field_processMethod;}
  inline const OPTIONAL<CHARSTRING>& processMethod() const
    {return field_processMethod;}
  inline OPTIONAL<CHARSTRING>& processAgency()
    {return field_processAgency;}
  inline const OPTIONAL<CHARSTRING>& processAgency() const
    {return field_processAgency;}
  inline OPTIONAL<CHARSTRING>& lastCheckedDate()
    {return field_lastCheckedDate;}
  inline const OPTIONAL<CHARSTRING>& lastCheckedDate() const
    {return field_lastCheckedDate;}
  inline OPTIONAL<CHARSTRING>& geoidUsed()
    {return field_geoidUsed;}
  inline const OPTIONAL<CHARSTRING>& geoidUsed() const
    {return field_geoidUsed;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DataParameters_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DataParameters_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DataParameters& other_value);
void copy_template(const DataParameters_template& other_value);

public:
DataParameters_template();
DataParameters_template(template_sel other_value);
DataParameters_template(const DataParameters& other_value);
DataParameters_template(const OPTIONAL<DataParameters>& other_value);
DataParameters_template(const DataParameters_template& other_value);
~DataParameters_template();
DataParameters_template& operator=(template_sel other_value);
DataParameters_template& operator=(const DataParameters& other_value);
DataParameters_template& operator=(const OPTIONAL<DataParameters>& other_value);
DataParameters_template& operator=(const DataParameters_template& other_value);
boolean match(const DataParameters& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DataParameters valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DataParameters_template& list_item(unsigned int list_index) const;
CHARSTRING_template& processMethod();
const CHARSTRING_template& processMethod() const;
CHARSTRING_template& processAgency();
const CHARSTRING_template& processAgency() const;
CHARSTRING_template& lastCheckedDate();
const CHARSTRING_template& lastCheckedDate() const;
CHARSTRING_template& geoidUsed();
const CHARSTRING_template& geoidUsed() const;
int size_of() const;
void log() const;
void log_match(const DataParameters& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RestrictionClassList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
RestrictionClassAssignment **value_elements;
} *val_ptr;

static const RestrictionClassAssignment UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RestrictionClassList& other_value);

public:
  typedef RestrictionClassAssignment of_type;
RestrictionClassList();
RestrictionClassList(null_type other_value);
RestrictionClassList(const RestrictionClassList& other_value);
~RestrictionClassList();

void clean_up();
RestrictionClassList& operator=(null_type other_value);
RestrictionClassList& operator=(const RestrictionClassList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RestrictionClassList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RestrictionClassList& other_value) const { return !(*this == other_value); }

RestrictionClassAssignment& operator[](int index_value);
RestrictionClassAssignment& operator[](const INTEGER& index_value);
const RestrictionClassAssignment& operator[](int index_value) const;
const RestrictionClassAssignment& operator[](const INTEGER& index_value) const;

RestrictionClassList operator<<=(int rotate_count) const;
RestrictionClassList operator<<=(const INTEGER& rotate_count) const;
RestrictionClassList operator>>=(int rotate_count) const;
RestrictionClassList operator>>=(const INTEGER& rotate_count) const;

RestrictionClassList operator+(const RestrictionClassList& other_value) const;

RestrictionClassList substr(int index, int returncount) const;

RestrictionClassList replace(int index, int len, const RestrictionClassList& repl) const;

RestrictionClassList replace(int index, int len, const RestrictionClassList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RestrictionClassList_template : public Record_Of_Template {
union {
struct {
int n_elements;
RestrictionClassAssignment_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RestrictionClassList_template *list_value;
} value_list;
};
void copy_value(const RestrictionClassList& other_value);
void copy_template(const RestrictionClassList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
RestrictionClassList_template();
RestrictionClassList_template(template_sel other_value);
RestrictionClassList_template(null_type other_value);
RestrictionClassList_template(const RestrictionClassList& other_value);
RestrictionClassList_template(const OPTIONAL<RestrictionClassList>& other_value);
RestrictionClassList_template(const RestrictionClassList_template& other_value);
~RestrictionClassList_template();

void clean_up();
RestrictionClassList_template& operator=(template_sel other_value);
RestrictionClassList_template& operator=(null_type other_value);
RestrictionClassList_template& operator=(const RestrictionClassList& other_value);
RestrictionClassList_template& operator=(const OPTIONAL<RestrictionClassList>& other_value);
RestrictionClassList_template& operator=(const RestrictionClassList_template& other_value);

RestrictionClassAssignment_template& operator[](int index_value);
RestrictionClassAssignment_template& operator[](const INTEGER& index_value);
const RestrictionClassAssignment_template& operator[](int index_value) const;
const RestrictionClassAssignment_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RestrictionClassList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RestrictionClassList valueof() const;
RestrictionClassList substr(int index, int returncount) const;

RestrictionClassList replace(int index, int len, const RestrictionClassList_template& repl) const;

RestrictionClassList replace(int index, int len, const RestrictionClassList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RestrictionClassList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RestrictionClassList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RestrictionUserTypeList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
RestrictionUserType **value_elements;
} *val_ptr;

static const RestrictionUserType UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RestrictionUserTypeList& other_value);

public:
  typedef RestrictionUserType of_type;
RestrictionUserTypeList();
RestrictionUserTypeList(null_type other_value);
RestrictionUserTypeList(const RestrictionUserTypeList& other_value);
~RestrictionUserTypeList();

void clean_up();
RestrictionUserTypeList& operator=(null_type other_value);
RestrictionUserTypeList& operator=(const RestrictionUserTypeList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RestrictionUserTypeList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RestrictionUserTypeList& other_value) const { return !(*this == other_value); }

RestrictionUserType& operator[](int index_value);
RestrictionUserType& operator[](const INTEGER& index_value);
const RestrictionUserType& operator[](int index_value) const;
const RestrictionUserType& operator[](const INTEGER& index_value) const;

RestrictionUserTypeList operator<<=(int rotate_count) const;
RestrictionUserTypeList operator<<=(const INTEGER& rotate_count) const;
RestrictionUserTypeList operator>>=(int rotate_count) const;
RestrictionUserTypeList operator>>=(const INTEGER& rotate_count) const;

RestrictionUserTypeList operator+(const RestrictionUserTypeList& other_value) const;

RestrictionUserTypeList substr(int index, int returncount) const;

RestrictionUserTypeList replace(int index, int len, const RestrictionUserTypeList& repl) const;

RestrictionUserTypeList replace(int index, int len, const RestrictionUserTypeList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RestrictionUserTypeList_template : public Record_Of_Template {
union {
struct {
int n_elements;
RestrictionUserType_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RestrictionUserTypeList_template *list_value;
} value_list;
};
void copy_value(const RestrictionUserTypeList& other_value);
void copy_template(const RestrictionUserTypeList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
RestrictionUserTypeList_template();
RestrictionUserTypeList_template(template_sel other_value);
RestrictionUserTypeList_template(null_type other_value);
RestrictionUserTypeList_template(const RestrictionUserTypeList& other_value);
RestrictionUserTypeList_template(const OPTIONAL<RestrictionUserTypeList>& other_value);
RestrictionUserTypeList_template(const RestrictionUserTypeList_template& other_value);
~RestrictionUserTypeList_template();

void clean_up();
RestrictionUserTypeList_template& operator=(template_sel other_value);
RestrictionUserTypeList_template& operator=(null_type other_value);
RestrictionUserTypeList_template& operator=(const RestrictionUserTypeList& other_value);
RestrictionUserTypeList_template& operator=(const OPTIONAL<RestrictionUserTypeList>& other_value);
RestrictionUserTypeList_template& operator=(const RestrictionUserTypeList_template& other_value);

RestrictionUserType_template& operator[](int index_value);
RestrictionUserType_template& operator[](const INTEGER& index_value);
const RestrictionUserType_template& operator[](int index_value) const;
const RestrictionUserType_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RestrictionUserTypeList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RestrictionUserTypeList valueof() const;
RestrictionUserTypeList substr(int index, int returncount) const;

RestrictionUserTypeList replace(int index, int len, const RestrictionUserTypeList_template& repl) const;

RestrictionUserTypeList replace(int index, int len, const RestrictionUserTypeList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RestrictionUserTypeList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RestrictionUserTypeList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RestrictionUserType : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_basicType = 1, ALT_regional = 2 };
private:
union_selection_type union_selection;
union {
RestrictionAppliesTo *field_basicType;
REG__D::Reg__RestrictionUserType *field_regional;
};
void copy_value(const RestrictionUserType& other_value);

public:
RestrictionUserType();
RestrictionUserType(const RestrictionUserType& other_value);
~RestrictionUserType();
RestrictionUserType& operator=(const RestrictionUserType& other_value);
boolean operator==(const RestrictionUserType& other_value) const;
inline boolean operator!=(const RestrictionUserType& other_value) const { return !(*this == other_value); }
RestrictionAppliesTo& basicType();
const RestrictionAppliesTo& basicType() const;
REG__D::Reg__RestrictionUserType& regional();
const REG__D::Reg__RestrictionUserType& regional() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class RestrictionUserType_template : public Base_Template {
union {
struct {
RestrictionUserType::union_selection_type union_selection;
union {
RestrictionAppliesTo_template *field_basicType;
REG__D::Reg__RestrictionUserType_template *field_regional;
};
} single_value;
struct {
unsigned int n_values;
RestrictionUserType_template *list_value;
} value_list;
};
void copy_value(const RestrictionUserType& other_value);

void copy_template(const RestrictionUserType_template& other_value);

public:
RestrictionUserType_template();
RestrictionUserType_template(template_sel other_value);
RestrictionUserType_template(const RestrictionUserType& other_value);
RestrictionUserType_template(const OPTIONAL<RestrictionUserType>& other_value);
RestrictionUserType_template(const RestrictionUserType_template& other_value);
~RestrictionUserType_template();
void clean_up();
RestrictionUserType_template& operator=(template_sel other_value);
RestrictionUserType_template& operator=(const RestrictionUserType& other_value);
RestrictionUserType_template& operator=(const OPTIONAL<RestrictionUserType>& other_value);
RestrictionUserType_template& operator=(const RestrictionUserType_template& other_value);
boolean match(const RestrictionUserType& other_value, boolean legacy = FALSE) const;
boolean is_value() const;RestrictionUserType valueof() const;
RestrictionUserType_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
RestrictionAppliesTo_template& basicType();
const RestrictionAppliesTo_template& basicType() const;
REG__D::Reg__RestrictionUserType_template& regional();
const REG__D::Reg__RestrictionUserType_template& regional() const;
boolean ischosen(RestrictionUserType::union_selection_type checked_selection) const;
void log() const;
void log_match(const RestrictionUserType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RestrictionAppliesTo : public Base_Type { // enum
friend class RestrictionAppliesTo_template;
public:
enum enum_type { none__ = 0, equippedTransit = 1, equippedTaxis = 2, equippedOther = 3, emissionCompliant = 4, equippedBicycle = 5, weightCompliant = 6, heightCompliant = 7, pedestrians = 8, slowMovingPersons = 9, wheelchairUsers = 10, visualDisabilities = 11, audioDisabilities = 12, otherUnknownDisabilities = 13, UNKNOWN_VALUE = 14, UNBOUND_VALUE = 15 };
private:
enum_type enum_value;

public:
RestrictionAppliesTo();
RestrictionAppliesTo(int other_value);
RestrictionAppliesTo(enum_type other_value);
RestrictionAppliesTo(const RestrictionAppliesTo& other_value);

RestrictionAppliesTo& operator=(int other_value);
RestrictionAppliesTo& operator=(enum_type other_value);
RestrictionAppliesTo& operator=(const RestrictionAppliesTo& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const RestrictionAppliesTo& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RestrictionAppliesTo& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const RestrictionAppliesTo& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const RestrictionAppliesTo& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const RestrictionAppliesTo& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const RestrictionAppliesTo& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const RestrictionAppliesTo& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RestrictionAppliesTo_template : public Base_Template {
union {
RestrictionAppliesTo::enum_type single_value;
struct {
unsigned int n_values;
RestrictionAppliesTo_template *list_value;
} value_list;
};

void copy_template(const RestrictionAppliesTo_template& other_value);

public:
RestrictionAppliesTo_template();
RestrictionAppliesTo_template(template_sel other_value);
RestrictionAppliesTo_template(int other_value);
RestrictionAppliesTo_template(RestrictionAppliesTo::enum_type other_value);
RestrictionAppliesTo_template(const RestrictionAppliesTo& other_value);
RestrictionAppliesTo_template(const OPTIONAL<RestrictionAppliesTo>& other_value);
RestrictionAppliesTo_template(const RestrictionAppliesTo_template& other_value);
~RestrictionAppliesTo_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
RestrictionAppliesTo_template& operator=(template_sel other_value);
RestrictionAppliesTo_template& operator=(int other_value);
RestrictionAppliesTo_template& operator=(RestrictionAppliesTo::enum_type other_value);
RestrictionAppliesTo_template& operator=(const RestrictionAppliesTo& other_value);
RestrictionAppliesTo_template& operator=(const OPTIONAL<RestrictionAppliesTo>& other_value);
RestrictionAppliesTo_template& operator=(const RestrictionAppliesTo_template& other_value);

boolean match(RestrictionAppliesTo::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const RestrictionAppliesTo& other_value, boolean legacy = FALSE) const;
RestrictionAppliesTo::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RestrictionAppliesTo_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RestrictionAppliesTo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RestrictionClassAssignment : public Base_Type {
  INTEGER field_id;
  RestrictionUserTypeList field_users;
  boolean bound_flag;
public:
  RestrictionClassAssignment();
  RestrictionClassAssignment(const INTEGER& par_id,
    const RestrictionUserTypeList& par_users);
  RestrictionClassAssignment(const RestrictionClassAssignment& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RestrictionClassAssignment& operator=(const RestrictionClassAssignment& other_value);
  boolean operator==(const RestrictionClassAssignment& other_value) const;
  inline boolean operator!=(const RestrictionClassAssignment& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& id()
    {return field_id;}
  inline const INTEGER& id() const
    {return field_id;}
  inline RestrictionUserTypeList& users()
    {return field_users;}
  inline const RestrictionUserTypeList& users() const
    {return field_users;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RestrictionClassAssignment_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RestrictionClassAssignment_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RestrictionClassAssignment& other_value);
void copy_template(const RestrictionClassAssignment_template& other_value);

public:
RestrictionClassAssignment_template();
RestrictionClassAssignment_template(template_sel other_value);
RestrictionClassAssignment_template(const RestrictionClassAssignment& other_value);
RestrictionClassAssignment_template(const OPTIONAL<RestrictionClassAssignment>& other_value);
RestrictionClassAssignment_template(const RestrictionClassAssignment_template& other_value);
~RestrictionClassAssignment_template();
RestrictionClassAssignment_template& operator=(template_sel other_value);
RestrictionClassAssignment_template& operator=(const RestrictionClassAssignment& other_value);
RestrictionClassAssignment_template& operator=(const OPTIONAL<RestrictionClassAssignment>& other_value);
RestrictionClassAssignment_template& operator=(const RestrictionClassAssignment_template& other_value);
boolean match(const RestrictionClassAssignment& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RestrictionClassAssignment valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RestrictionClassAssignment_template& list_item(unsigned int list_index) const;
INTEGER_template& id();
const INTEGER_template& id() const;
RestrictionUserTypeList_template& users();
const RestrictionUserTypeList_template& users() const;
int size_of() const;
void log() const;
void log_match(const RestrictionClassAssignment& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class IntersectionStateList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
IntersectionState **value_elements;
} *val_ptr;

static const IntersectionState UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const IntersectionStateList& other_value);

public:
  typedef IntersectionState of_type;
IntersectionStateList();
IntersectionStateList(null_type other_value);
IntersectionStateList(const IntersectionStateList& other_value);
~IntersectionStateList();

void clean_up();
IntersectionStateList& operator=(null_type other_value);
IntersectionStateList& operator=(const IntersectionStateList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const IntersectionStateList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const IntersectionStateList& other_value) const { return !(*this == other_value); }

IntersectionState& operator[](int index_value);
IntersectionState& operator[](const INTEGER& index_value);
const IntersectionState& operator[](int index_value) const;
const IntersectionState& operator[](const INTEGER& index_value) const;

IntersectionStateList operator<<=(int rotate_count) const;
IntersectionStateList operator<<=(const INTEGER& rotate_count) const;
IntersectionStateList operator>>=(int rotate_count) const;
IntersectionStateList operator>>=(const INTEGER& rotate_count) const;

IntersectionStateList operator+(const IntersectionStateList& other_value) const;

IntersectionStateList substr(int index, int returncount) const;

IntersectionStateList replace(int index, int len, const IntersectionStateList& repl) const;

IntersectionStateList replace(int index, int len, const IntersectionStateList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IntersectionStateList_template : public Record_Of_Template {
union {
struct {
int n_elements;
IntersectionState_template **value_elements;
} single_value;
struct {
unsigned int n_values;
IntersectionStateList_template *list_value;
} value_list;
};
void copy_value(const IntersectionStateList& other_value);
void copy_template(const IntersectionStateList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
IntersectionStateList_template();
IntersectionStateList_template(template_sel other_value);
IntersectionStateList_template(null_type other_value);
IntersectionStateList_template(const IntersectionStateList& other_value);
IntersectionStateList_template(const OPTIONAL<IntersectionStateList>& other_value);
IntersectionStateList_template(const IntersectionStateList_template& other_value);
~IntersectionStateList_template();

void clean_up();
IntersectionStateList_template& operator=(template_sel other_value);
IntersectionStateList_template& operator=(null_type other_value);
IntersectionStateList_template& operator=(const IntersectionStateList& other_value);
IntersectionStateList_template& operator=(const OPTIONAL<IntersectionStateList>& other_value);
IntersectionStateList_template& operator=(const IntersectionStateList_template& other_value);

IntersectionState_template& operator[](int index_value);
IntersectionState_template& operator[](const INTEGER& index_value);
const IntersectionState_template& operator[](int index_value) const;
const IntersectionState_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const IntersectionStateList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
IntersectionStateList valueof() const;
IntersectionStateList substr(int index, int returncount) const;

IntersectionStateList replace(int index, int len, const IntersectionStateList_template& repl) const;

IntersectionStateList replace(int index, int len, const IntersectionStateList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
IntersectionStateList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const IntersectionStateList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MovementList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
MovementState **value_elements;
} *val_ptr;

static const MovementState UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const MovementList& other_value);

public:
  typedef MovementState of_type;
MovementList();
MovementList(null_type other_value);
MovementList(const MovementList& other_value);
~MovementList();

void clean_up();
MovementList& operator=(null_type other_value);
MovementList& operator=(const MovementList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const MovementList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MovementList& other_value) const { return !(*this == other_value); }

MovementState& operator[](int index_value);
MovementState& operator[](const INTEGER& index_value);
const MovementState& operator[](int index_value) const;
const MovementState& operator[](const INTEGER& index_value) const;

MovementList operator<<=(int rotate_count) const;
MovementList operator<<=(const INTEGER& rotate_count) const;
MovementList operator>>=(int rotate_count) const;
MovementList operator>>=(const INTEGER& rotate_count) const;

MovementList operator+(const MovementList& other_value) const;

MovementList substr(int index, int returncount) const;

MovementList replace(int index, int len, const MovementList& repl) const;

MovementList replace(int index, int len, const MovementList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MovementList_template : public Record_Of_Template {
union {
struct {
int n_elements;
MovementState_template **value_elements;
} single_value;
struct {
unsigned int n_values;
MovementList_template *list_value;
} value_list;
};
void copy_value(const MovementList& other_value);
void copy_template(const MovementList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
MovementList_template();
MovementList_template(template_sel other_value);
MovementList_template(null_type other_value);
MovementList_template(const MovementList& other_value);
MovementList_template(const OPTIONAL<MovementList>& other_value);
MovementList_template(const MovementList_template& other_value);
~MovementList_template();

void clean_up();
MovementList_template& operator=(template_sel other_value);
MovementList_template& operator=(null_type other_value);
MovementList_template& operator=(const MovementList& other_value);
MovementList_template& operator=(const OPTIONAL<MovementList>& other_value);
MovementList_template& operator=(const MovementList_template& other_value);

MovementState_template& operator[](int index_value);
MovementState_template& operator[](const INTEGER& index_value);
const MovementState_template& operator[](int index_value) const;
const MovementState_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const MovementList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
MovementList valueof() const;
MovementList substr(int index, int returncount) const;

MovementList replace(int index, int len, const MovementList_template& repl) const;

MovementList replace(int index, int len, const MovementList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
MovementList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MovementList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MovementEventList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
MovementEvent **value_elements;
} *val_ptr;

static const MovementEvent UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const MovementEventList& other_value);

public:
  typedef MovementEvent of_type;
MovementEventList();
MovementEventList(null_type other_value);
MovementEventList(const MovementEventList& other_value);
~MovementEventList();

void clean_up();
MovementEventList& operator=(null_type other_value);
MovementEventList& operator=(const MovementEventList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const MovementEventList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MovementEventList& other_value) const { return !(*this == other_value); }

MovementEvent& operator[](int index_value);
MovementEvent& operator[](const INTEGER& index_value);
const MovementEvent& operator[](int index_value) const;
const MovementEvent& operator[](const INTEGER& index_value) const;

MovementEventList operator<<=(int rotate_count) const;
MovementEventList operator<<=(const INTEGER& rotate_count) const;
MovementEventList operator>>=(int rotate_count) const;
MovementEventList operator>>=(const INTEGER& rotate_count) const;

MovementEventList operator+(const MovementEventList& other_value) const;

MovementEventList substr(int index, int returncount) const;

MovementEventList replace(int index, int len, const MovementEventList& repl) const;

MovementEventList replace(int index, int len, const MovementEventList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MovementEventList_template : public Record_Of_Template {
union {
struct {
int n_elements;
MovementEvent_template **value_elements;
} single_value;
struct {
unsigned int n_values;
MovementEventList_template *list_value;
} value_list;
};
void copy_value(const MovementEventList& other_value);
void copy_template(const MovementEventList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
MovementEventList_template();
MovementEventList_template(template_sel other_value);
MovementEventList_template(null_type other_value);
MovementEventList_template(const MovementEventList& other_value);
MovementEventList_template(const OPTIONAL<MovementEventList>& other_value);
MovementEventList_template(const MovementEventList_template& other_value);
~MovementEventList_template();

void clean_up();
MovementEventList_template& operator=(template_sel other_value);
MovementEventList_template& operator=(null_type other_value);
MovementEventList_template& operator=(const MovementEventList& other_value);
MovementEventList_template& operator=(const OPTIONAL<MovementEventList>& other_value);
MovementEventList_template& operator=(const MovementEventList_template& other_value);

MovementEvent_template& operator[](int index_value);
MovementEvent_template& operator[](const INTEGER& index_value);
const MovementEvent_template& operator[](int index_value) const;
const MovementEvent_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const MovementEventList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
MovementEventList valueof() const;
MovementEventList substr(int index, int returncount) const;

MovementEventList replace(int index, int len, const MovementEventList_template& repl) const;

MovementEventList replace(int index, int len, const MovementEventList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
MovementEventList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MovementEventList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MovementPhaseState : public Base_Type { // enum
friend class MovementPhaseState_template;
public:
enum enum_type { unavailable = 0, dark = 1, stop__Then__Proceed = 2, stop__And__Remain = 3, pre__Movement = 4, permissive__Movement__Allowed = 5, protected__Movement__Allowed = 6, permissive__clearance = 7, protected__clearance = 8, caution__Conflicting__Traffic = 9, UNKNOWN_VALUE = 10, UNBOUND_VALUE = 11 };
private:
enum_type enum_value;

public:
MovementPhaseState();
MovementPhaseState(int other_value);
MovementPhaseState(enum_type other_value);
MovementPhaseState(const MovementPhaseState& other_value);

MovementPhaseState& operator=(int other_value);
MovementPhaseState& operator=(enum_type other_value);
MovementPhaseState& operator=(const MovementPhaseState& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const MovementPhaseState& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MovementPhaseState& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const MovementPhaseState& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const MovementPhaseState& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const MovementPhaseState& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const MovementPhaseState& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const MovementPhaseState& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MovementPhaseState_template : public Base_Template {
union {
MovementPhaseState::enum_type single_value;
struct {
unsigned int n_values;
MovementPhaseState_template *list_value;
} value_list;
};

void copy_template(const MovementPhaseState_template& other_value);

public:
MovementPhaseState_template();
MovementPhaseState_template(template_sel other_value);
MovementPhaseState_template(int other_value);
MovementPhaseState_template(MovementPhaseState::enum_type other_value);
MovementPhaseState_template(const MovementPhaseState& other_value);
MovementPhaseState_template(const OPTIONAL<MovementPhaseState>& other_value);
MovementPhaseState_template(const MovementPhaseState_template& other_value);
~MovementPhaseState_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
MovementPhaseState_template& operator=(template_sel other_value);
MovementPhaseState_template& operator=(int other_value);
MovementPhaseState_template& operator=(MovementPhaseState::enum_type other_value);
MovementPhaseState_template& operator=(const MovementPhaseState& other_value);
MovementPhaseState_template& operator=(const OPTIONAL<MovementPhaseState>& other_value);
MovementPhaseState_template& operator=(const MovementPhaseState_template& other_value);

boolean match(MovementPhaseState::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const MovementPhaseState& other_value, boolean legacy = FALSE) const;
MovementPhaseState::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MovementPhaseState_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MovementPhaseState& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MovementEvent : public Base_Type {
  MovementPhaseState field_eventState;
  OPTIONAL<TimeChangeDetails> field_timing;
  OPTIONAL<AdvisorySpeedList> field_speeds;
  OPTIONAL<REGION::Reg__MovementEvent> field_regional;
  boolean bound_flag;
public:
  MovementEvent();
  MovementEvent(const MovementPhaseState& par_eventState,
    const OPTIONAL<TimeChangeDetails>& par_timing,
    const OPTIONAL<AdvisorySpeedList>& par_speeds,
    const OPTIONAL<REGION::Reg__MovementEvent>& par_regional);
  MovementEvent(const MovementEvent& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MovementEvent& operator=(const MovementEvent& other_value);
  boolean operator==(const MovementEvent& other_value) const;
  inline boolean operator!=(const MovementEvent& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline MovementPhaseState& eventState()
    {return field_eventState;}
  inline const MovementPhaseState& eventState() const
    {return field_eventState;}
  inline OPTIONAL<TimeChangeDetails>& timing()
    {return field_timing;}
  inline const OPTIONAL<TimeChangeDetails>& timing() const
    {return field_timing;}
  inline OPTIONAL<AdvisorySpeedList>& speeds()
    {return field_speeds;}
  inline const OPTIONAL<AdvisorySpeedList>& speeds() const
    {return field_speeds;}
  inline OPTIONAL<REGION::Reg__MovementEvent>& regional()
    {return field_regional;}
  inline const OPTIONAL<REGION::Reg__MovementEvent>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MovementEvent_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MovementEvent_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MovementEvent& other_value);
void copy_template(const MovementEvent_template& other_value);

public:
MovementEvent_template();
MovementEvent_template(template_sel other_value);
MovementEvent_template(const MovementEvent& other_value);
MovementEvent_template(const OPTIONAL<MovementEvent>& other_value);
MovementEvent_template(const MovementEvent_template& other_value);
~MovementEvent_template();
MovementEvent_template& operator=(template_sel other_value);
MovementEvent_template& operator=(const MovementEvent& other_value);
MovementEvent_template& operator=(const OPTIONAL<MovementEvent>& other_value);
MovementEvent_template& operator=(const MovementEvent_template& other_value);
boolean match(const MovementEvent& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MovementEvent valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MovementEvent_template& list_item(unsigned int list_index) const;
MovementPhaseState_template& eventState();
const MovementPhaseState_template& eventState() const;
TimeChangeDetails_template& timing();
const TimeChangeDetails_template& timing() const;
AdvisorySpeedList_template& speeds();
const AdvisorySpeedList_template& speeds() const;
REGION::Reg__MovementEvent_template& regional();
const REGION::Reg__MovementEvent_template& regional() const;
int size_of() const;
void log() const;
void log_match(const MovementEvent& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TimeChangeDetails : public Base_Type {
  OPTIONAL<INTEGER> field_startTime;
  INTEGER field_minEndTime;
  OPTIONAL<INTEGER> field_maxEndTime;
  OPTIONAL<INTEGER> field_likelyTime;
  OPTIONAL<INTEGER> field_confidence;
  OPTIONAL<INTEGER> field_nextTime;
  boolean bound_flag;
public:
  TimeChangeDetails();
  TimeChangeDetails(const OPTIONAL<INTEGER>& par_startTime,
    const INTEGER& par_minEndTime,
    const OPTIONAL<INTEGER>& par_maxEndTime,
    const OPTIONAL<INTEGER>& par_likelyTime,
    const OPTIONAL<INTEGER>& par_confidence,
    const OPTIONAL<INTEGER>& par_nextTime);
  TimeChangeDetails(const TimeChangeDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TimeChangeDetails& operator=(const TimeChangeDetails& other_value);
  boolean operator==(const TimeChangeDetails& other_value) const;
  inline boolean operator!=(const TimeChangeDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& startTime()
    {return field_startTime;}
  inline const OPTIONAL<INTEGER>& startTime() const
    {return field_startTime;}
  inline INTEGER& minEndTime()
    {return field_minEndTime;}
  inline const INTEGER& minEndTime() const
    {return field_minEndTime;}
  inline OPTIONAL<INTEGER>& maxEndTime()
    {return field_maxEndTime;}
  inline const OPTIONAL<INTEGER>& maxEndTime() const
    {return field_maxEndTime;}
  inline OPTIONAL<INTEGER>& likelyTime()
    {return field_likelyTime;}
  inline const OPTIONAL<INTEGER>& likelyTime() const
    {return field_likelyTime;}
  inline OPTIONAL<INTEGER>& confidence()
    {return field_confidence;}
  inline const OPTIONAL<INTEGER>& confidence() const
    {return field_confidence;}
  inline OPTIONAL<INTEGER>& nextTime()
    {return field_nextTime;}
  inline const OPTIONAL<INTEGER>& nextTime() const
    {return field_nextTime;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TimeChangeDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TimeChangeDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TimeChangeDetails& other_value);
void copy_template(const TimeChangeDetails_template& other_value);

public:
TimeChangeDetails_template();
TimeChangeDetails_template(template_sel other_value);
TimeChangeDetails_template(const TimeChangeDetails& other_value);
TimeChangeDetails_template(const OPTIONAL<TimeChangeDetails>& other_value);
TimeChangeDetails_template(const TimeChangeDetails_template& other_value);
~TimeChangeDetails_template();
TimeChangeDetails_template& operator=(template_sel other_value);
TimeChangeDetails_template& operator=(const TimeChangeDetails& other_value);
TimeChangeDetails_template& operator=(const OPTIONAL<TimeChangeDetails>& other_value);
TimeChangeDetails_template& operator=(const TimeChangeDetails_template& other_value);
boolean match(const TimeChangeDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TimeChangeDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TimeChangeDetails_template& list_item(unsigned int list_index) const;
INTEGER_template& startTime();
const INTEGER_template& startTime() const;
INTEGER_template& minEndTime();
const INTEGER_template& minEndTime() const;
INTEGER_template& maxEndTime();
const INTEGER_template& maxEndTime() const;
INTEGER_template& likelyTime();
const INTEGER_template& likelyTime() const;
INTEGER_template& confidence();
const INTEGER_template& confidence() const;
INTEGER_template& nextTime();
const INTEGER_template& nextTime() const;
int size_of() const;
void log() const;
void log_match(const TimeChangeDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AdvisorySpeedList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
AdvisorySpeed **value_elements;
} *val_ptr;

static const AdvisorySpeed UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const AdvisorySpeedList& other_value);

public:
  typedef AdvisorySpeed of_type;
AdvisorySpeedList();
AdvisorySpeedList(null_type other_value);
AdvisorySpeedList(const AdvisorySpeedList& other_value);
~AdvisorySpeedList();

void clean_up();
AdvisorySpeedList& operator=(null_type other_value);
AdvisorySpeedList& operator=(const AdvisorySpeedList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const AdvisorySpeedList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AdvisorySpeedList& other_value) const { return !(*this == other_value); }

AdvisorySpeed& operator[](int index_value);
AdvisorySpeed& operator[](const INTEGER& index_value);
const AdvisorySpeed& operator[](int index_value) const;
const AdvisorySpeed& operator[](const INTEGER& index_value) const;

AdvisorySpeedList operator<<=(int rotate_count) const;
AdvisorySpeedList operator<<=(const INTEGER& rotate_count) const;
AdvisorySpeedList operator>>=(int rotate_count) const;
AdvisorySpeedList operator>>=(const INTEGER& rotate_count) const;

AdvisorySpeedList operator+(const AdvisorySpeedList& other_value) const;

AdvisorySpeedList substr(int index, int returncount) const;

AdvisorySpeedList replace(int index, int len, const AdvisorySpeedList& repl) const;

AdvisorySpeedList replace(int index, int len, const AdvisorySpeedList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AdvisorySpeedList_template : public Record_Of_Template {
union {
struct {
int n_elements;
AdvisorySpeed_template **value_elements;
} single_value;
struct {
unsigned int n_values;
AdvisorySpeedList_template *list_value;
} value_list;
};
void copy_value(const AdvisorySpeedList& other_value);
void copy_template(const AdvisorySpeedList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
AdvisorySpeedList_template();
AdvisorySpeedList_template(template_sel other_value);
AdvisorySpeedList_template(null_type other_value);
AdvisorySpeedList_template(const AdvisorySpeedList& other_value);
AdvisorySpeedList_template(const OPTIONAL<AdvisorySpeedList>& other_value);
AdvisorySpeedList_template(const AdvisorySpeedList_template& other_value);
~AdvisorySpeedList_template();

void clean_up();
AdvisorySpeedList_template& operator=(template_sel other_value);
AdvisorySpeedList_template& operator=(null_type other_value);
AdvisorySpeedList_template& operator=(const AdvisorySpeedList& other_value);
AdvisorySpeedList_template& operator=(const OPTIONAL<AdvisorySpeedList>& other_value);
AdvisorySpeedList_template& operator=(const AdvisorySpeedList_template& other_value);

AdvisorySpeed_template& operator[](int index_value);
AdvisorySpeed_template& operator[](const INTEGER& index_value);
const AdvisorySpeed_template& operator[](int index_value) const;
const AdvisorySpeed_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const AdvisorySpeedList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
AdvisorySpeedList valueof() const;
AdvisorySpeedList substr(int index, int returncount) const;

AdvisorySpeedList replace(int index, int len, const AdvisorySpeedList_template& repl) const;

AdvisorySpeedList replace(int index, int len, const AdvisorySpeedList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
AdvisorySpeedList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const AdvisorySpeedList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AdvisorySpeedType : public Base_Type { // enum
friend class AdvisorySpeedType_template;
public:
enum enum_type { none__ = 0, greenwave = 1, ecoDrive = 2, transit = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
AdvisorySpeedType();
AdvisorySpeedType(int other_value);
AdvisorySpeedType(enum_type other_value);
AdvisorySpeedType(const AdvisorySpeedType& other_value);

AdvisorySpeedType& operator=(int other_value);
AdvisorySpeedType& operator=(enum_type other_value);
AdvisorySpeedType& operator=(const AdvisorySpeedType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const AdvisorySpeedType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AdvisorySpeedType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const AdvisorySpeedType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const AdvisorySpeedType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const AdvisorySpeedType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const AdvisorySpeedType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const AdvisorySpeedType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AdvisorySpeedType_template : public Base_Template {
union {
AdvisorySpeedType::enum_type single_value;
struct {
unsigned int n_values;
AdvisorySpeedType_template *list_value;
} value_list;
};

void copy_template(const AdvisorySpeedType_template& other_value);

public:
AdvisorySpeedType_template();
AdvisorySpeedType_template(template_sel other_value);
AdvisorySpeedType_template(int other_value);
AdvisorySpeedType_template(AdvisorySpeedType::enum_type other_value);
AdvisorySpeedType_template(const AdvisorySpeedType& other_value);
AdvisorySpeedType_template(const OPTIONAL<AdvisorySpeedType>& other_value);
AdvisorySpeedType_template(const AdvisorySpeedType_template& other_value);
~AdvisorySpeedType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
AdvisorySpeedType_template& operator=(template_sel other_value);
AdvisorySpeedType_template& operator=(int other_value);
AdvisorySpeedType_template& operator=(AdvisorySpeedType::enum_type other_value);
AdvisorySpeedType_template& operator=(const AdvisorySpeedType& other_value);
AdvisorySpeedType_template& operator=(const OPTIONAL<AdvisorySpeedType>& other_value);
AdvisorySpeedType_template& operator=(const AdvisorySpeedType_template& other_value);

boolean match(AdvisorySpeedType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const AdvisorySpeedType& other_value, boolean legacy = FALSE) const;
AdvisorySpeedType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AdvisorySpeedType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const AdvisorySpeedType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AdvisorySpeed : public Base_Type {
  AdvisorySpeedType field_type__;
  OPTIONAL<INTEGER> field_speed;
  OPTIONAL<INTEGER> field_confidence;
  OPTIONAL<INTEGER> field_distance;
  OPTIONAL<INTEGER> field_class_;
  OPTIONAL<REGION::Reg__AdvisorySpeed> field_regional;
  boolean bound_flag;
public:
  AdvisorySpeed();
  AdvisorySpeed(const AdvisorySpeedType& par_type__,
    const OPTIONAL<INTEGER>& par_speed,
    const OPTIONAL<INTEGER>& par_confidence,
    const OPTIONAL<INTEGER>& par_distance,
    const OPTIONAL<INTEGER>& par_class_,
    const OPTIONAL<REGION::Reg__AdvisorySpeed>& par_regional);
  AdvisorySpeed(const AdvisorySpeed& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AdvisorySpeed& operator=(const AdvisorySpeed& other_value);
  boolean operator==(const AdvisorySpeed& other_value) const;
  inline boolean operator!=(const AdvisorySpeed& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline AdvisorySpeedType& type__()
    {return field_type__;}
  inline const AdvisorySpeedType& type__() const
    {return field_type__;}
  inline OPTIONAL<INTEGER>& speed()
    {return field_speed;}
  inline const OPTIONAL<INTEGER>& speed() const
    {return field_speed;}
  inline OPTIONAL<INTEGER>& confidence()
    {return field_confidence;}
  inline const OPTIONAL<INTEGER>& confidence() const
    {return field_confidence;}
  inline OPTIONAL<INTEGER>& distance()
    {return field_distance;}
  inline const OPTIONAL<INTEGER>& distance() const
    {return field_distance;}
  inline OPTIONAL<INTEGER>& class_()
    {return field_class_;}
  inline const OPTIONAL<INTEGER>& class_() const
    {return field_class_;}
  inline OPTIONAL<REGION::Reg__AdvisorySpeed>& regional()
    {return field_regional;}
  inline const OPTIONAL<REGION::Reg__AdvisorySpeed>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AdvisorySpeed_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AdvisorySpeed_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AdvisorySpeed& other_value);
void copy_template(const AdvisorySpeed_template& other_value);

public:
AdvisorySpeed_template();
AdvisorySpeed_template(template_sel other_value);
AdvisorySpeed_template(const AdvisorySpeed& other_value);
AdvisorySpeed_template(const OPTIONAL<AdvisorySpeed>& other_value);
AdvisorySpeed_template(const AdvisorySpeed_template& other_value);
~AdvisorySpeed_template();
AdvisorySpeed_template& operator=(template_sel other_value);
AdvisorySpeed_template& operator=(const AdvisorySpeed& other_value);
AdvisorySpeed_template& operator=(const OPTIONAL<AdvisorySpeed>& other_value);
AdvisorySpeed_template& operator=(const AdvisorySpeed_template& other_value);
boolean match(const AdvisorySpeed& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AdvisorySpeed valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AdvisorySpeed_template& list_item(unsigned int list_index) const;
AdvisorySpeedType_template& type__();
const AdvisorySpeedType_template& type__() const;
INTEGER_template& speed();
const INTEGER_template& speed() const;
INTEGER_template& confidence();
const INTEGER_template& confidence() const;
INTEGER_template& distance();
const INTEGER_template& distance() const;
INTEGER_template& class_();
const INTEGER_template& class_() const;
REGION::Reg__AdvisorySpeed_template& regional();
const REGION::Reg__AdvisorySpeed_template& regional() const;
int size_of() const;
void log() const;
void log_match(const AdvisorySpeed& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MovementState : public Base_Type {
  OPTIONAL<CHARSTRING> field_movementName;
  INTEGER field_signalGroup;
  MovementEventList field_state__time__speed;
  OPTIONAL<ManeuverAssistList> field_maneuverAssistList;
  OPTIONAL<REGION::Reg__MovementState> field_regional;
  boolean bound_flag;
public:
  MovementState();
  MovementState(const OPTIONAL<CHARSTRING>& par_movementName,
    const INTEGER& par_signalGroup,
    const MovementEventList& par_state__time__speed,
    const OPTIONAL<ManeuverAssistList>& par_maneuverAssistList,
    const OPTIONAL<REGION::Reg__MovementState>& par_regional);
  MovementState(const MovementState& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MovementState& operator=(const MovementState& other_value);
  boolean operator==(const MovementState& other_value) const;
  inline boolean operator!=(const MovementState& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& movementName()
    {return field_movementName;}
  inline const OPTIONAL<CHARSTRING>& movementName() const
    {return field_movementName;}
  inline INTEGER& signalGroup()
    {return field_signalGroup;}
  inline const INTEGER& signalGroup() const
    {return field_signalGroup;}
  inline MovementEventList& state__time__speed()
    {return field_state__time__speed;}
  inline const MovementEventList& state__time__speed() const
    {return field_state__time__speed;}
  inline OPTIONAL<ManeuverAssistList>& maneuverAssistList()
    {return field_maneuverAssistList;}
  inline const OPTIONAL<ManeuverAssistList>& maneuverAssistList() const
    {return field_maneuverAssistList;}
  inline OPTIONAL<REGION::Reg__MovementState>& regional()
    {return field_regional;}
  inline const OPTIONAL<REGION::Reg__MovementState>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class MovementState_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MovementState_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MovementState& other_value);
void copy_template(const MovementState_template& other_value);

public:
MovementState_template();
MovementState_template(template_sel other_value);
MovementState_template(const MovementState& other_value);
MovementState_template(const OPTIONAL<MovementState>& other_value);
MovementState_template(const MovementState_template& other_value);
~MovementState_template();
MovementState_template& operator=(template_sel other_value);
MovementState_template& operator=(const MovementState& other_value);
MovementState_template& operator=(const OPTIONAL<MovementState>& other_value);
MovementState_template& operator=(const MovementState_template& other_value);
boolean match(const MovementState& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MovementState valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MovementState_template& list_item(unsigned int list_index) const;
CHARSTRING_template& movementName();
const CHARSTRING_template& movementName() const;
INTEGER_template& signalGroup();
const INTEGER_template& signalGroup() const;
MovementEventList_template& state__time__speed();
const MovementEventList_template& state__time__speed() const;
ManeuverAssistList_template& maneuverAssistList();
const ManeuverAssistList_template& maneuverAssistList() const;
REGION::Reg__MovementState_template& regional();
const REGION::Reg__MovementState_template& regional() const;
int size_of() const;
void log() const;
void log_match(const MovementState& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ManeuverAssistList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ConnectionManeuverAssist **value_elements;
} *val_ptr;

static const ConnectionManeuverAssist UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ManeuverAssistList& other_value);

public:
  typedef ConnectionManeuverAssist of_type;
ManeuverAssistList();
ManeuverAssistList(null_type other_value);
ManeuverAssistList(const ManeuverAssistList& other_value);
~ManeuverAssistList();

void clean_up();
ManeuverAssistList& operator=(null_type other_value);
ManeuverAssistList& operator=(const ManeuverAssistList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ManeuverAssistList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ManeuverAssistList& other_value) const { return !(*this == other_value); }

ConnectionManeuverAssist& operator[](int index_value);
ConnectionManeuverAssist& operator[](const INTEGER& index_value);
const ConnectionManeuverAssist& operator[](int index_value) const;
const ConnectionManeuverAssist& operator[](const INTEGER& index_value) const;

ManeuverAssistList operator<<=(int rotate_count) const;
ManeuverAssistList operator<<=(const INTEGER& rotate_count) const;
ManeuverAssistList operator>>=(int rotate_count) const;
ManeuverAssistList operator>>=(const INTEGER& rotate_count) const;

ManeuverAssistList operator+(const ManeuverAssistList& other_value) const;

ManeuverAssistList substr(int index, int returncount) const;

ManeuverAssistList replace(int index, int len, const ManeuverAssistList& repl) const;

ManeuverAssistList replace(int index, int len, const ManeuverAssistList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ManeuverAssistList_template : public Record_Of_Template {
union {
struct {
int n_elements;
ConnectionManeuverAssist_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ManeuverAssistList_template *list_value;
} value_list;
};
void copy_value(const ManeuverAssistList& other_value);
void copy_template(const ManeuverAssistList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ManeuverAssistList_template();
ManeuverAssistList_template(template_sel other_value);
ManeuverAssistList_template(null_type other_value);
ManeuverAssistList_template(const ManeuverAssistList& other_value);
ManeuverAssistList_template(const OPTIONAL<ManeuverAssistList>& other_value);
ManeuverAssistList_template(const ManeuverAssistList_template& other_value);
~ManeuverAssistList_template();

void clean_up();
ManeuverAssistList_template& operator=(template_sel other_value);
ManeuverAssistList_template& operator=(null_type other_value);
ManeuverAssistList_template& operator=(const ManeuverAssistList& other_value);
ManeuverAssistList_template& operator=(const OPTIONAL<ManeuverAssistList>& other_value);
ManeuverAssistList_template& operator=(const ManeuverAssistList_template& other_value);

ConnectionManeuverAssist_template& operator[](int index_value);
ConnectionManeuverAssist_template& operator[](const INTEGER& index_value);
const ConnectionManeuverAssist_template& operator[](int index_value) const;
const ConnectionManeuverAssist_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ManeuverAssistList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ManeuverAssistList valueof() const;
ManeuverAssistList substr(int index, int returncount) const;

ManeuverAssistList replace(int index, int len, const ManeuverAssistList_template& repl) const;

ManeuverAssistList replace(int index, int len, const ManeuverAssistList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ManeuverAssistList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ManeuverAssistList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ConnectionManeuverAssist : public Base_Type {
  INTEGER field_connectionID;
  OPTIONAL<INTEGER> field_queueLength;
  OPTIONAL<INTEGER> field_availableStorageLength;
  OPTIONAL<BOOLEAN> field_waitOnStop;
  OPTIONAL<BOOLEAN> field_pedBicycleDetect;
  OPTIONAL<REG__D::Reg__ConnectionManeuverAssist> field_regional;
  boolean bound_flag;
public:
  ConnectionManeuverAssist();
  ConnectionManeuverAssist(const INTEGER& par_connectionID,
    const OPTIONAL<INTEGER>& par_queueLength,
    const OPTIONAL<INTEGER>& par_availableStorageLength,
    const OPTIONAL<BOOLEAN>& par_waitOnStop,
    const OPTIONAL<BOOLEAN>& par_pedBicycleDetect,
    const OPTIONAL<REG__D::Reg__ConnectionManeuverAssist>& par_regional);
  ConnectionManeuverAssist(const ConnectionManeuverAssist& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ConnectionManeuverAssist& operator=(const ConnectionManeuverAssist& other_value);
  boolean operator==(const ConnectionManeuverAssist& other_value) const;
  inline boolean operator!=(const ConnectionManeuverAssist& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& connectionID()
    {return field_connectionID;}
  inline const INTEGER& connectionID() const
    {return field_connectionID;}
  inline OPTIONAL<INTEGER>& queueLength()
    {return field_queueLength;}
  inline const OPTIONAL<INTEGER>& queueLength() const
    {return field_queueLength;}
  inline OPTIONAL<INTEGER>& availableStorageLength()
    {return field_availableStorageLength;}
  inline const OPTIONAL<INTEGER>& availableStorageLength() const
    {return field_availableStorageLength;}
  inline OPTIONAL<BOOLEAN>& waitOnStop()
    {return field_waitOnStop;}
  inline const OPTIONAL<BOOLEAN>& waitOnStop() const
    {return field_waitOnStop;}
  inline OPTIONAL<BOOLEAN>& pedBicycleDetect()
    {return field_pedBicycleDetect;}
  inline const OPTIONAL<BOOLEAN>& pedBicycleDetect() const
    {return field_pedBicycleDetect;}
  inline OPTIONAL<REG__D::Reg__ConnectionManeuverAssist>& regional()
    {return field_regional;}
  inline const OPTIONAL<REG__D::Reg__ConnectionManeuverAssist>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ConnectionManeuverAssist_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ConnectionManeuverAssist_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ConnectionManeuverAssist& other_value);
void copy_template(const ConnectionManeuverAssist_template& other_value);

public:
ConnectionManeuverAssist_template();
ConnectionManeuverAssist_template(template_sel other_value);
ConnectionManeuverAssist_template(const ConnectionManeuverAssist& other_value);
ConnectionManeuverAssist_template(const OPTIONAL<ConnectionManeuverAssist>& other_value);
ConnectionManeuverAssist_template(const ConnectionManeuverAssist_template& other_value);
~ConnectionManeuverAssist_template();
ConnectionManeuverAssist_template& operator=(template_sel other_value);
ConnectionManeuverAssist_template& operator=(const ConnectionManeuverAssist& other_value);
ConnectionManeuverAssist_template& operator=(const OPTIONAL<ConnectionManeuverAssist>& other_value);
ConnectionManeuverAssist_template& operator=(const ConnectionManeuverAssist_template& other_value);
boolean match(const ConnectionManeuverAssist& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ConnectionManeuverAssist valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ConnectionManeuverAssist_template& list_item(unsigned int list_index) const;
INTEGER_template& connectionID();
const INTEGER_template& connectionID() const;
INTEGER_template& queueLength();
const INTEGER_template& queueLength() const;
INTEGER_template& availableStorageLength();
const INTEGER_template& availableStorageLength() const;
BOOLEAN_template& waitOnStop();
const BOOLEAN_template& waitOnStop() const;
BOOLEAN_template& pedBicycleDetect();
const BOOLEAN_template& pedBicycleDetect() const;
REG__D::Reg__ConnectionManeuverAssist_template& regional();
const REG__D::Reg__ConnectionManeuverAssist_template& regional() const;
int size_of() const;
void log() const;
void log_match(const ConnectionManeuverAssist& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class IntersectionState : public Base_Type {
  OPTIONAL<CHARSTRING> field_name;
  IntersectionReferenceID field_id;
  INTEGER field_revision;
  BITSTRING field_status;
  OPTIONAL<INTEGER> field_moy;
  OPTIONAL<INTEGER> field_timeStamp;
  OPTIONAL<EnabledLaneList> field_enabledLanes;
  MovementList field_states;
  OPTIONAL<ManeuverAssistList> field_maneuverAssistList;
  OPTIONAL<OCTETSTRING> field_priority;
  OPTIONAL<OCTETSTRING> field_preempt;
  OPTIONAL<REG__D::Reg__IntersectionState> field_regional;
  boolean bound_flag;
public:
  IntersectionState();
  IntersectionState(const OPTIONAL<CHARSTRING>& par_name,
    const IntersectionReferenceID& par_id,
    const INTEGER& par_revision,
    const BITSTRING& par_status,
    const OPTIONAL<INTEGER>& par_moy,
    const OPTIONAL<INTEGER>& par_timeStamp,
    const OPTIONAL<EnabledLaneList>& par_enabledLanes,
    const MovementList& par_states,
    const OPTIONAL<ManeuverAssistList>& par_maneuverAssistList,
    const OPTIONAL<OCTETSTRING>& par_priority,
    const OPTIONAL<OCTETSTRING>& par_preempt,
    const OPTIONAL<REG__D::Reg__IntersectionState>& par_regional);
  IntersectionState(const IntersectionState& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IntersectionState& operator=(const IntersectionState& other_value);
  boolean operator==(const IntersectionState& other_value) const;
  inline boolean operator!=(const IntersectionState& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& name()
    {return field_name;}
  inline const OPTIONAL<CHARSTRING>& name() const
    {return field_name;}
  inline IntersectionReferenceID& id()
    {return field_id;}
  inline const IntersectionReferenceID& id() const
    {return field_id;}
  inline INTEGER& revision()
    {return field_revision;}
  inline const INTEGER& revision() const
    {return field_revision;}
  inline BITSTRING& status()
    {return field_status;}
  inline const BITSTRING& status() const
    {return field_status;}
  inline OPTIONAL<INTEGER>& moy()
    {return field_moy;}
  inline const OPTIONAL<INTEGER>& moy() const
    {return field_moy;}
  inline OPTIONAL<INTEGER>& timeStamp()
    {return field_timeStamp;}
  inline const OPTIONAL<INTEGER>& timeStamp() const
    {return field_timeStamp;}
  inline OPTIONAL<EnabledLaneList>& enabledLanes()
    {return field_enabledLanes;}
  inline const OPTIONAL<EnabledLaneList>& enabledLanes() const
    {return field_enabledLanes;}
  inline MovementList& states()
    {return field_states;}
  inline const MovementList& states() const
    {return field_states;}
  inline OPTIONAL<ManeuverAssistList>& maneuverAssistList()
    {return field_maneuverAssistList;}
  inline const OPTIONAL<ManeuverAssistList>& maneuverAssistList() const
    {return field_maneuverAssistList;}
  inline OPTIONAL<OCTETSTRING>& priority()
    {return field_priority;}
  inline const OPTIONAL<OCTETSTRING>& priority() const
    {return field_priority;}
  inline OPTIONAL<OCTETSTRING>& preempt()
    {return field_preempt;}
  inline const OPTIONAL<OCTETSTRING>& preempt() const
    {return field_preempt;}
  inline OPTIONAL<REG__D::Reg__IntersectionState>& regional()
    {return field_regional;}
  inline const OPTIONAL<REG__D::Reg__IntersectionState>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class IntersectionState_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IntersectionState_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IntersectionState& other_value);
void copy_template(const IntersectionState_template& other_value);

public:
IntersectionState_template();
IntersectionState_template(template_sel other_value);
IntersectionState_template(const IntersectionState& other_value);
IntersectionState_template(const OPTIONAL<IntersectionState>& other_value);
IntersectionState_template(const IntersectionState_template& other_value);
~IntersectionState_template();
IntersectionState_template& operator=(template_sel other_value);
IntersectionState_template& operator=(const IntersectionState& other_value);
IntersectionState_template& operator=(const OPTIONAL<IntersectionState>& other_value);
IntersectionState_template& operator=(const IntersectionState_template& other_value);
boolean match(const IntersectionState& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IntersectionState valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IntersectionState_template& list_item(unsigned int list_index) const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
IntersectionReferenceID_template& id();
const IntersectionReferenceID_template& id() const;
INTEGER_template& revision();
const INTEGER_template& revision() const;
BITSTRING_template& status();
const BITSTRING_template& status() const;
INTEGER_template& moy();
const INTEGER_template& moy() const;
INTEGER_template& timeStamp();
const INTEGER_template& timeStamp() const;
EnabledLaneList_template& enabledLanes();
const EnabledLaneList_template& enabledLanes() const;
MovementList_template& states();
const MovementList_template& states() const;
ManeuverAssistList_template& maneuverAssistList();
const ManeuverAssistList_template& maneuverAssistList() const;
OCTETSTRING_template& priority();
const OCTETSTRING_template& priority() const;
OCTETSTRING_template& preempt();
const OCTETSTRING_template& preempt() const;
REG__D::Reg__IntersectionState_template& regional();
const REG__D::Reg__IntersectionState_template& regional() const;
int size_of() const;
void log() const;
void log_match(const IntersectionState& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SPAT : public Base_Type {
  INTEGER field_msgID;
  OPTIONAL<INTEGER> field_msgSubID;
  OPTIONAL<CHARSTRING> field_name;
  IntersectionStateList field_intersections;
  OPTIONAL<REGION::Reg__SPAT> field_regional;
  boolean bound_flag;
public:
  SPAT();
  SPAT(const INTEGER& par_msgID,
    const OPTIONAL<INTEGER>& par_msgSubID,
    const OPTIONAL<CHARSTRING>& par_name,
    const IntersectionStateList& par_intersections,
    const OPTIONAL<REGION::Reg__SPAT>& par_regional);
  SPAT(const SPAT& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SPAT& operator=(const SPAT& other_value);
  boolean operator==(const SPAT& other_value) const;
  inline boolean operator!=(const SPAT& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& msgID()
    {return field_msgID;}
  inline const INTEGER& msgID() const
    {return field_msgID;}
  inline OPTIONAL<INTEGER>& msgSubID()
    {return field_msgSubID;}
  inline const OPTIONAL<INTEGER>& msgSubID() const
    {return field_msgSubID;}
  inline OPTIONAL<CHARSTRING>& name()
    {return field_name;}
  inline const OPTIONAL<CHARSTRING>& name() const
    {return field_name;}
  inline IntersectionStateList& intersections()
    {return field_intersections;}
  inline const IntersectionStateList& intersections() const
    {return field_intersections;}
  inline OPTIONAL<REGION::Reg__SPAT>& regional()
    {return field_regional;}
  inline const OPTIONAL<REGION::Reg__SPAT>& regional() const
    {return field_regional;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SPAT_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SPAT_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SPAT& other_value);
void copy_template(const SPAT_template& other_value);

public:
SPAT_template();
SPAT_template(template_sel other_value);
SPAT_template(const SPAT& other_value);
SPAT_template(const OPTIONAL<SPAT>& other_value);
SPAT_template(const SPAT_template& other_value);
~SPAT_template();
SPAT_template& operator=(template_sel other_value);
SPAT_template& operator=(const SPAT& other_value);
SPAT_template& operator=(const OPTIONAL<SPAT>& other_value);
SPAT_template& operator=(const SPAT_template& other_value);
boolean match(const SPAT& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SPAT valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SPAT_template& list_item(unsigned int list_index) const;
INTEGER_template& msgID();
const INTEGER_template& msgID() const;
INTEGER_template& msgSubID();
const INTEGER_template& msgSubID() const;
CHARSTRING_template& name();
const CHARSTRING_template& name() const;
IntersectionStateList_template& intersections();
const IntersectionStateList_template& intersections() const;
REGION::Reg__SPAT_template& regional();
const REGION::Reg__SPAT_template& regional() const;
int size_of() const;
void log() const;
void log_match(const SPAT& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const IntersectionGeometryList& other_value);
inline boolean operator!=(null_type null_value, const IntersectionGeometryList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const LaneList& other_value);
inline boolean operator!=(null_type null_value, const LaneList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const NodeSet& other_value);
inline boolean operator!=(null_type null_value, const NodeSet& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const NodeAttributeList& other_value);
inline boolean operator!=(null_type null_value, const NodeAttributeList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const SegmentAttributeList& other_value);
inline boolean operator!=(null_type null_value, const SegmentAttributeList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const LaneDataAttributeList& other_value);
inline boolean operator!=(null_type null_value, const LaneDataAttributeList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const SpeedLimitList& other_value);
inline boolean operator!=(null_type null_value, const SpeedLimitList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const RegionalNodeAttributeList& other_value);
inline boolean operator!=(null_type null_value, const RegionalNodeAttributeList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ConnectsToList& other_value);
inline boolean operator!=(null_type null_value, const ConnectsToList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PreemptPriorityList& other_value);
inline boolean operator!=(null_type null_value, const PreemptPriorityList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const RoadSegmentList& other_value);
inline boolean operator!=(null_type null_value, const RoadSegmentList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const RoadLaneSetList& other_value);
inline boolean operator!=(null_type null_value, const RoadLaneSetList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const RestrictionClassList& other_value);
inline boolean operator!=(null_type null_value, const RestrictionClassList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const RestrictionUserTypeList& other_value);
inline boolean operator!=(null_type null_value, const RestrictionUserTypeList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const IntersectionStateList& other_value);
inline boolean operator!=(null_type null_value, const IntersectionStateList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const MovementList& other_value);
inline boolean operator!=(null_type null_value, const MovementList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const MovementEventList& other_value);
inline boolean operator!=(null_type null_value, const MovementEventList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const AdvisorySpeedList& other_value);
inline boolean operator!=(null_type null_value, const AdvisorySpeedList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ManeuverAssistList& other_value);
inline boolean operator!=(null_type null_value, const ManeuverAssistList& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_Typedescriptor_t& DSRCmsgID2_descr_;
extern const ASN_BERdescriptor_t MapData_msgID_ber_;
extern const TTCN_Typedescriptor_t MapData_msgID_descr_;
extern const TTCN_Typedescriptor_t& MsgCount_descr_;
extern const ASN_BERdescriptor_t MapData_msgIssueRevision_ber_;
extern const TTCN_Typedescriptor_t MapData_msgIssueRevision_descr_;
extern const TTCN_JSONdescriptor_t MapData_json_;
extern const TTCN_Typedescriptor_t MapData_descr_;
extern const TTCN_Typedescriptor_t& DSRCmsgSubID_descr_;
extern const ASN_BERdescriptor_t MapData_msgSubID_ber_;
extern const TTCN_Typedescriptor_t MapData_msgSubID_descr_;
extern const TTCN_JSONdescriptor_t LayerType_json_;
extern const TTCN_Typedescriptor_t LayerType_descr_;
extern const ASN_BERdescriptor_t MapData_layerType_ber_;
extern const TTCN_Typedescriptor_t MapData_layerType_descr_;
extern const TTCN_Typedescriptor_t& LayerID_descr_;
extern const ASN_BERdescriptor_t MapData_layerID_ber_;
extern const TTCN_Typedescriptor_t MapData_layerID_descr_;
extern const TTCN_JSONdescriptor_t IntersectionGeometryList_json_;
extern const TTCN_Typedescriptor_t IntersectionGeometryList_descr_;
extern const TTCN_Typedescriptor_t& IntersectionID_descr_;
extern const ASN_BERdescriptor_t IntersectionReferenceID_id_ber_;
extern const TTCN_Typedescriptor_t IntersectionReferenceID_id_descr_;
extern const TTCN_JSONdescriptor_t IntersectionReferenceID_json_;
extern const TTCN_Typedescriptor_t IntersectionReferenceID_descr_;
extern const TTCN_Typedescriptor_t& RoadRegulatorID_descr_;
extern const ASN_BERdescriptor_t IntersectionReferenceID_region_ber_;
extern const TTCN_Typedescriptor_t IntersectionReferenceID_region_descr_;
extern const ASN_BERdescriptor_t IntersectionGeometry_id_ber_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_id_descr_;
extern const ASN_BERdescriptor_t IntersectionGeometry_revision_ber_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_revision_descr_;
extern const ASN_BERdescriptor_t Position3D__2_lat_ber_;
extern const TTCN_Typedescriptor_t Position3D__2_lat_descr_;
extern const ASN_BERdescriptor_t Position3D__2_long__ber_;
extern const TTCN_Typedescriptor_t Position3D__2_long__descr_;
extern const TTCN_JSONdescriptor_t Position3D__2_json_;
extern const TTCN_Typedescriptor_t Position3D__2_descr_;
extern const TTCN_Typedescriptor_t& Elevation2_descr_;
extern const ASN_BERdescriptor_t Position3D__2_elevation_ber_;
extern const TTCN_Typedescriptor_t Position3D__2_elevation_descr_;
extern const TTCN_Typedescriptor_t& RegionalPosition3D_descr_;
extern const ASN_BERdescriptor_t Position3D__2_regional_ber_;
extern const TTCN_Typedescriptor_t Position3D__2_regional_descr_;
extern const ASN_BERdescriptor_t IntersectionGeometry_refPoint_ber_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_refPoint_descr_;
extern const TTCN_JSONdescriptor_t LaneList_json_;
extern const TTCN_Typedescriptor_t LaneList_descr_;
extern const ASN_BERdescriptor_t GenericLane_laneID_ber_;
extern const TTCN_Typedescriptor_t GenericLane_laneID_descr_;
extern const TTCN_Typedescriptor_t& LaneDirection_descr_;
extern const ASN_BERdescriptor_t LaneAttributes_directionalUse_ber_;
extern const TTCN_Typedescriptor_t LaneAttributes_directionalUse_descr_;
extern const TTCN_Typedescriptor_t& LaneSharing_descr_;
extern const ASN_BERdescriptor_t LaneAttributes_sharedWith_ber_;
extern const TTCN_Typedescriptor_t LaneAttributes_sharedWith_descr_;
extern const TTCN_JSONdescriptor_t LaneTypeAttributes_json_;
extern const TTCN_Typedescriptor_t LaneTypeAttributes_descr_;
extern const TTCN_Typedescriptor_t& LaneAttributes__Vehicle_descr_;
extern const ASN_BERdescriptor_t LaneTypeAttributes_vehicle_ber_;
extern const TTCN_Typedescriptor_t LaneTypeAttributes_vehicle_descr_;
extern const TTCN_Typedescriptor_t& LaneAttributes__Crosswalk_descr_;
extern const ASN_BERdescriptor_t LaneTypeAttributes_crosswalk_ber_;
extern const TTCN_Typedescriptor_t LaneTypeAttributes_crosswalk_descr_;
extern const TTCN_Typedescriptor_t& LaneAttributes__Bike_descr_;
extern const ASN_BERdescriptor_t LaneTypeAttributes_bikeLane_ber_;
extern const TTCN_Typedescriptor_t LaneTypeAttributes_bikeLane_descr_;
extern const TTCN_Typedescriptor_t& LaneAttributes__Sidewalk_descr_;
extern const ASN_BERdescriptor_t LaneTypeAttributes_sidewalk_ber_;
extern const TTCN_Typedescriptor_t LaneTypeAttributes_sidewalk_descr_;
extern const TTCN_Typedescriptor_t& LaneAttributes__Barrier_descr_;
extern const ASN_BERdescriptor_t LaneTypeAttributes_median_ber_;
extern const TTCN_Typedescriptor_t LaneTypeAttributes_median_descr_;
extern const TTCN_Typedescriptor_t& LaneAttributes__Striping_descr_;
extern const ASN_BERdescriptor_t LaneTypeAttributes_striping_ber_;
extern const TTCN_Typedescriptor_t LaneTypeAttributes_striping_descr_;
extern const TTCN_Typedescriptor_t& LaneAttributes__TrackedVehicle_descr_;
extern const ASN_BERdescriptor_t LaneTypeAttributes_trackedVehicle_ber_;
extern const TTCN_Typedescriptor_t LaneTypeAttributes_trackedVehicle_descr_;
extern const TTCN_Typedescriptor_t& LaneAttributes__Parking_descr_;
extern const ASN_BERdescriptor_t LaneTypeAttributes_parking_ber_;
extern const TTCN_Typedescriptor_t LaneTypeAttributes_parking_descr_;
extern const ASN_BERdescriptor_t LaneAttributes_laneType_ber_;
extern const TTCN_Typedescriptor_t LaneAttributes_laneType_descr_;
extern const TTCN_JSONdescriptor_t LaneAttributes_json_;
extern const TTCN_Typedescriptor_t LaneAttributes_descr_;
extern const TTCN_Typedescriptor_t& RegionalLaneAttributes_descr_;
extern const ASN_BERdescriptor_t LaneAttributes_regional_ber_;
extern const TTCN_Typedescriptor_t LaneAttributes_regional_descr_;
extern const ASN_BERdescriptor_t GenericLane_laneAttributes_ber_;
extern const TTCN_Typedescriptor_t GenericLane_laneAttributes_descr_;
extern const TTCN_JSONdescriptor_t NodeList2_json_;
extern const TTCN_Typedescriptor_t NodeList2_descr_;
extern const TTCN_JSONdescriptor_t NodeSet_json_;
extern const TTCN_Typedescriptor_t NodeSet_descr_;
extern const ASN_BERdescriptor_t Node_delta_ber_;
extern const TTCN_Typedescriptor_t Node_delta_descr_;
extern const TTCN_JSONdescriptor_t Node_json_;
extern const TTCN_Typedescriptor_t Node_descr_;
extern const TTCN_JSONdescriptor_t NodeAttributeSet_json_;
extern const TTCN_Typedescriptor_t NodeAttributeSet_descr_;
extern const TTCN_JSONdescriptor_t NodeAttributeList_json_;
extern const TTCN_Typedescriptor_t NodeAttributeList_descr_;
extern const TTCN_JSONdescriptor_t NodeAttribute_json_;
extern const TTCN_Typedescriptor_t NodeAttribute_descr_;
extern const ASN_BERdescriptor_t NodeAttributeSet_localNode_ber_;
extern const TTCN_Typedescriptor_t NodeAttributeSet_localNode_descr_;
extern const TTCN_JSONdescriptor_t SegmentAttributeList_json_;
extern const TTCN_Typedescriptor_t SegmentAttributeList_descr_;
extern const TTCN_JSONdescriptor_t SegmentAttribute_json_;
extern const TTCN_Typedescriptor_t SegmentAttribute_descr_;
extern const ASN_BERdescriptor_t NodeAttributeSet_disabled_ber_;
extern const TTCN_Typedescriptor_t NodeAttributeSet_disabled_descr_;
extern const ASN_BERdescriptor_t NodeAttributeSet_enabled_ber_;
extern const TTCN_Typedescriptor_t NodeAttributeSet_enabled_descr_;
extern const TTCN_JSONdescriptor_t LaneDataAttributeList_json_;
extern const TTCN_Typedescriptor_t LaneDataAttributeList_descr_;
extern const TTCN_JSONdescriptor_t LaneDataAttribute_json_;
extern const TTCN_Typedescriptor_t LaneDataAttribute_descr_;
extern const TTCN_Typedescriptor_t& DeltaAngle_descr_;
extern const ASN_BERdescriptor_t LaneDataAttribute_pathEndPointAngle_ber_;
extern const TTCN_Typedescriptor_t LaneDataAttribute_pathEndPointAngle_descr_;
extern const TTCN_Typedescriptor_t& RoadwayCrownAngle_descr_;
extern const ASN_BERdescriptor_t LaneDataAttribute_laneCrownPointCenter_ber_;
extern const TTCN_Typedescriptor_t LaneDataAttribute_laneCrownPointCenter_descr_;
extern const ASN_BERdescriptor_t LaneDataAttribute_laneCrownPointLeft_ber_;
extern const TTCN_Typedescriptor_t LaneDataAttribute_laneCrownPointLeft_descr_;
extern const ASN_BERdescriptor_t LaneDataAttribute_laneCrownPointRight_ber_;
extern const TTCN_Typedescriptor_t LaneDataAttribute_laneCrownPointRight_descr_;
extern const TTCN_Typedescriptor_t& MergeDivergeNodeAngle_descr_;
extern const ASN_BERdescriptor_t LaneDataAttribute_laneAngle_ber_;
extern const TTCN_Typedescriptor_t LaneDataAttribute_laneAngle_descr_;
extern const TTCN_JSONdescriptor_t SpeedLimitList_json_;
extern const TTCN_Typedescriptor_t SpeedLimitList_descr_;
extern const TTCN_JSONdescriptor_t SpeedLimitType_json_;
extern const TTCN_Typedescriptor_t SpeedLimitType_descr_;
extern const ASN_BERdescriptor_t RegulatorySpeedLimit_type___ber_;
extern const TTCN_Typedescriptor_t RegulatorySpeedLimit_type___descr_;
extern const TTCN_Typedescriptor_t& Velocity_descr_;
extern const ASN_BERdescriptor_t RegulatorySpeedLimit_speed_ber_;
extern const TTCN_Typedescriptor_t RegulatorySpeedLimit_speed_descr_;
extern const TTCN_JSONdescriptor_t RegulatorySpeedLimit_json_;
extern const TTCN_Typedescriptor_t RegulatorySpeedLimit_descr_;
extern const ASN_BERdescriptor_t LaneDataAttribute_speedLimits_ber_;
extern const TTCN_Typedescriptor_t LaneDataAttribute_speedLimits_descr_;
extern const TTCN_Typedescriptor_t& RegionalLaneDataAttribute_descr_;
extern const ASN_BERdescriptor_t LaneDataAttribute_regional_ber_;
extern const TTCN_Typedescriptor_t LaneDataAttribute_regional_descr_;
extern const ASN_BERdescriptor_t NodeAttributeSet_data_ber_;
extern const TTCN_Typedescriptor_t NodeAttributeSet_data_descr_;
extern const TTCN_JSONdescriptor_t RegionalNodeAttributeList_json_;
extern const TTCN_Typedescriptor_t RegionalNodeAttributeList_descr_;
extern const TTCN_Typedescriptor_t& RegionalNodeAttribute_descr_;
extern const ASN_BERdescriptor_t NodeAttributeSet_regional_ber_;
extern const TTCN_Typedescriptor_t NodeAttributeSet_regional_descr_;
extern const ASN_BERdescriptor_t NodeAttributeSet_dWidth_ber_;
extern const TTCN_Typedescriptor_t NodeAttributeSet_dWidth_descr_;
extern const ASN_BERdescriptor_t NodeAttributeSet_dElevation_ber_;
extern const TTCN_Typedescriptor_t NodeAttributeSet_dElevation_descr_;
extern const ASN_BERdescriptor_t Node_attributes_ber_;
extern const TTCN_Typedescriptor_t Node_attributes_descr_;
extern const ASN_BERdescriptor_t NodeList2_nodes_ber_;
extern const TTCN_Typedescriptor_t NodeList2_nodes_descr_;
extern const ASN_BERdescriptor_t ComputedLane_referenceLaneId_ber_;
extern const TTCN_Typedescriptor_t ComputedLane_referenceLaneId_descr_;
extern const ASN_BERdescriptor_t ComputedLane_offsetXaxis_ber_;
extern const TTCN_JSONdescriptor_t ComputedLane_offsetXaxis_json_;
extern const TTCN_Typedescriptor_t ComputedLane_offsetXaxis_descr_;
extern const TTCN_Typedescriptor_t& DrivenLineOffsetSm_descr_;
extern const ASN_BERdescriptor_t ComputedLane_offsetXaxis_small_ber_;
extern const TTCN_Typedescriptor_t ComputedLane_offsetXaxis_small_descr_;
extern const TTCN_Typedescriptor_t& DrivenLineOffsetLg_descr_;
extern const ASN_BERdescriptor_t ComputedLane_offsetXaxis_large_ber_;
extern const TTCN_Typedescriptor_t ComputedLane_offsetXaxis_large_descr_;
extern const ASN_BERdescriptor_t ComputedLane_offsetYaxis_ber_;
extern const TTCN_JSONdescriptor_t ComputedLane_offsetYaxis_json_;
extern const TTCN_Typedescriptor_t ComputedLane_offsetYaxis_descr_;
extern const ASN_BERdescriptor_t ComputedLane_offsetYaxis_small_ber_;
extern const TTCN_Typedescriptor_t ComputedLane_offsetYaxis_small_descr_;
extern const ASN_BERdescriptor_t ComputedLane_offsetYaxis_large_ber_;
extern const TTCN_Typedescriptor_t ComputedLane_offsetYaxis_large_descr_;
extern const TTCN_JSONdescriptor_t ComputedLane_json_;
extern const TTCN_Typedescriptor_t ComputedLane_descr_;
extern const TTCN_Typedescriptor_t& Angle_descr_;
extern const ASN_BERdescriptor_t ComputedLane_rotateXY_ber_;
extern const TTCN_Typedescriptor_t ComputedLane_rotateXY_descr_;
extern const TTCN_Typedescriptor_t& Scale__B12_descr_;
extern const ASN_BERdescriptor_t ComputedLane_scaleXaxis_ber_;
extern const TTCN_Typedescriptor_t ComputedLane_scaleXaxis_descr_;
extern const ASN_BERdescriptor_t ComputedLane_scaleYaxis_ber_;
extern const TTCN_Typedescriptor_t ComputedLane_scaleYaxis_descr_;
extern const TTCN_Typedescriptor_t& RegionalComputedLane_descr_;
extern const ASN_BERdescriptor_t ComputedLane_regional_ber_;
extern const TTCN_Typedescriptor_t ComputedLane_regional_descr_;
extern const ASN_BERdescriptor_t NodeList2_computed_ber_;
extern const TTCN_Typedescriptor_t NodeList2_computed_descr_;
extern const ASN_BERdescriptor_t GenericLane_nodeList_ber_;
extern const TTCN_Typedescriptor_t GenericLane_nodeList_descr_;
extern const TTCN_JSONdescriptor_t GenericLane_json_;
extern const TTCN_Typedescriptor_t GenericLane_descr_;
extern const TTCN_Typedescriptor_t& DescriptiveName_descr_;
extern const ASN_BERdescriptor_t GenericLane_name_ber_;
extern const TTCN_Typedescriptor_t GenericLane_name_descr_;
extern const TTCN_Typedescriptor_t& ApproachID_descr_;
extern const ASN_BERdescriptor_t GenericLane_ingressApproach_ber_;
extern const TTCN_Typedescriptor_t GenericLane_ingressApproach_descr_;
extern const ASN_BERdescriptor_t GenericLane_egressApproach_ber_;
extern const TTCN_Typedescriptor_t GenericLane_egressApproach_descr_;
extern const TTCN_Typedescriptor_t& AllowedManeuvers_descr_;
extern const ASN_BERdescriptor_t GenericLane_maneuvers_ber_;
extern const TTCN_Typedescriptor_t GenericLane_maneuvers_descr_;
extern const TTCN_JSONdescriptor_t ConnectsToList_json_;
extern const TTCN_Typedescriptor_t ConnectsToList_descr_;
extern const ASN_BERdescriptor_t ConnectingLane_lane_ber_;
extern const TTCN_Typedescriptor_t ConnectingLane_lane_descr_;
extern const TTCN_JSONdescriptor_t ConnectingLane_json_;
extern const TTCN_Typedescriptor_t ConnectingLane_descr_;
extern const ASN_BERdescriptor_t ConnectingLane_maneuver_ber_;
extern const TTCN_Typedescriptor_t ConnectingLane_maneuver_descr_;
extern const ASN_BERdescriptor_t Connection_connectingLane_ber_;
extern const TTCN_Typedescriptor_t Connection_connectingLane_descr_;
extern const TTCN_JSONdescriptor_t Connection_json_;
extern const TTCN_Typedescriptor_t Connection_descr_;
extern const ASN_BERdescriptor_t Connection_remoteIntersection_ber_;
extern const TTCN_Typedescriptor_t Connection_remoteIntersection_descr_;
extern const ASN_BERdescriptor_t Connection_signalGroup_ber_;
extern const TTCN_Typedescriptor_t Connection_signalGroup_descr_;
extern const TTCN_Typedescriptor_t& RestrictionClassID_descr_;
extern const ASN_BERdescriptor_t Connection_userClass_ber_;
extern const TTCN_Typedescriptor_t Connection_userClass_descr_;
extern const TTCN_Typedescriptor_t& LaneConnectionID_descr_;
extern const ASN_BERdescriptor_t Connection_connectionID_ber_;
extern const TTCN_Typedescriptor_t Connection_connectionID_descr_;
extern const ASN_BERdescriptor_t GenericLane_connectsTo_ber_;
extern const TTCN_Typedescriptor_t GenericLane_connectsTo_descr_;
extern const TTCN_JSONdescriptor_t OverlayLaneList_json_;
extern const TTCN_Typedescriptor_t OverlayLaneList_descr_;
extern const ASN_BERdescriptor_t GenericLane_overlays_ber_;
extern const TTCN_Typedescriptor_t GenericLane_overlays_descr_;
extern const TTCN_Typedescriptor_t& RegionalGenericLane_descr_;
extern const ASN_BERdescriptor_t GenericLane_regional_ber_;
extern const TTCN_Typedescriptor_t GenericLane_regional_descr_;
extern const ASN_BERdescriptor_t IntersectionGeometry_laneSet_ber_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_laneSet_descr_;
extern const TTCN_JSONdescriptor_t IntersectionGeometry_json_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_descr_;
extern const ASN_BERdescriptor_t IntersectionGeometry_name_ber_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_name_descr_;
extern const TTCN_Typedescriptor_t& LaneWidth_descr_;
extern const ASN_BERdescriptor_t IntersectionGeometry_laneWidth_ber_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_laneWidth_descr_;
extern const ASN_BERdescriptor_t IntersectionGeometry_speedLimits_ber_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_speedLimits_descr_;
extern const TTCN_JSONdescriptor_t PreemptPriorityList_json_;
extern const TTCN_Typedescriptor_t PreemptPriorityList_descr_;
extern const TTCN_Typedescriptor_t& RegionalSignalControlZone_descr_;
extern const ASN_BERdescriptor_t IntersectionGeometry_preemptPriorityData_ber_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_preemptPriorityData_descr_;
extern const TTCN_Typedescriptor_t& RegionalIntersection_descr_;
extern const ASN_BERdescriptor_t IntersectionGeometry_regional_ber_;
extern const TTCN_Typedescriptor_t IntersectionGeometry_regional_descr_;
extern const ASN_BERdescriptor_t MapData_intersections_ber_;
extern const TTCN_Typedescriptor_t MapData_intersections_descr_;
extern const TTCN_JSONdescriptor_t RoadSegmentList_json_;
extern const TTCN_Typedescriptor_t RoadSegmentList_descr_;
extern const TTCN_Typedescriptor_t& RoadSegmentID_descr_;
extern const ASN_BERdescriptor_t RoadSegmentReferenceID_id_ber_;
extern const TTCN_Typedescriptor_t RoadSegmentReferenceID_id_descr_;
extern const TTCN_JSONdescriptor_t RoadSegmentReferenceID_json_;
extern const TTCN_Typedescriptor_t RoadSegmentReferenceID_descr_;
extern const ASN_BERdescriptor_t RoadSegmentReferenceID_region_ber_;
extern const TTCN_Typedescriptor_t RoadSegmentReferenceID_region_descr_;
extern const ASN_BERdescriptor_t RoadSegment_id_ber_;
extern const TTCN_Typedescriptor_t RoadSegment_id_descr_;
extern const ASN_BERdescriptor_t RoadSegment_revision_ber_;
extern const TTCN_Typedescriptor_t RoadSegment_revision_descr_;
extern const ASN_BERdescriptor_t RoadSegment_refPoint_ber_;
extern const TTCN_Typedescriptor_t RoadSegment_refPoint_descr_;
extern const TTCN_JSONdescriptor_t RoadLaneSetList_json_;
extern const TTCN_Typedescriptor_t RoadLaneSetList_descr_;
extern const ASN_BERdescriptor_t RoadSegment_roadLaneSet_ber_;
extern const TTCN_Typedescriptor_t RoadSegment_roadLaneSet_descr_;
extern const TTCN_JSONdescriptor_t RoadSegment_json_;
extern const TTCN_Typedescriptor_t RoadSegment_descr_;
extern const ASN_BERdescriptor_t RoadSegment_name_ber_;
extern const TTCN_Typedescriptor_t RoadSegment_name_descr_;
extern const ASN_BERdescriptor_t RoadSegment_laneWidth_ber_;
extern const TTCN_Typedescriptor_t RoadSegment_laneWidth_descr_;
extern const ASN_BERdescriptor_t RoadSegment_speedLimits_ber_;
extern const TTCN_Typedescriptor_t RoadSegment_speedLimits_descr_;
extern const TTCN_Typedescriptor_t& RegionalRoadSegment_descr_;
extern const ASN_BERdescriptor_t RoadSegment_regional_ber_;
extern const TTCN_Typedescriptor_t RoadSegment_regional_descr_;
extern const ASN_BERdescriptor_t MapData_roadSegments_ber_;
extern const TTCN_Typedescriptor_t MapData_roadSegments_descr_;
extern const TTCN_JSONdescriptor_t DataParameters_json_;
extern const TTCN_Typedescriptor_t DataParameters_descr_;
extern const ASN_BERdescriptor_t DataParameters_processMethod_ber_;
extern const TTCN_Typedescriptor_t DataParameters_processMethod_descr_;
extern const ASN_BERdescriptor_t DataParameters_processAgency_ber_;
extern const TTCN_Typedescriptor_t DataParameters_processAgency_descr_;
extern const ASN_BERdescriptor_t DataParameters_lastCheckedDate_ber_;
extern const TTCN_Typedescriptor_t DataParameters_lastCheckedDate_descr_;
extern const ASN_BERdescriptor_t DataParameters_geoidUsed_ber_;
extern const TTCN_Typedescriptor_t DataParameters_geoidUsed_descr_;
extern const ASN_BERdescriptor_t MapData_dataParameters_ber_;
extern const TTCN_Typedescriptor_t MapData_dataParameters_descr_;
extern const TTCN_JSONdescriptor_t RestrictionClassList_json_;
extern const TTCN_Typedescriptor_t RestrictionClassList_descr_;
extern const ASN_BERdescriptor_t RestrictionClassAssignment_id_ber_;
extern const TTCN_Typedescriptor_t RestrictionClassAssignment_id_descr_;
extern const TTCN_JSONdescriptor_t RestrictionUserTypeList_json_;
extern const TTCN_Typedescriptor_t RestrictionUserTypeList_descr_;
extern const TTCN_JSONdescriptor_t RestrictionUserType_json_;
extern const TTCN_Typedescriptor_t RestrictionUserType_descr_;
extern const TTCN_JSONdescriptor_t RestrictionAppliesTo_json_;
extern const TTCN_Typedescriptor_t RestrictionAppliesTo_descr_;
extern const ASN_BERdescriptor_t RestrictionUserType_basicType_ber_;
extern const TTCN_Typedescriptor_t RestrictionUserType_basicType_descr_;
extern const TTCN_Typedescriptor_t& RegionalRestrictionUserType_descr_;
extern const ASN_BERdescriptor_t RestrictionUserType_regional_ber_;
extern const TTCN_Typedescriptor_t RestrictionUserType_regional_descr_;
extern const ASN_BERdescriptor_t RestrictionClassAssignment_users_ber_;
extern const TTCN_Typedescriptor_t RestrictionClassAssignment_users_descr_;
extern const TTCN_JSONdescriptor_t RestrictionClassAssignment_json_;
extern const TTCN_Typedescriptor_t RestrictionClassAssignment_descr_;
extern const ASN_BERdescriptor_t MapData_restrictionList_ber_;
extern const TTCN_Typedescriptor_t MapData_restrictionList_descr_;
extern const TTCN_Typedescriptor_t& RegionalMapData_descr_;
extern const ASN_BERdescriptor_t MapData_regional_ber_;
extern const TTCN_Typedescriptor_t MapData_regional_descr_;
extern const TTCN_Typedescriptor_t& MsgCRC_descr_;
extern const ASN_BERdescriptor_t MapData_crc_ber_;
extern const TTCN_Typedescriptor_t MapData_crc_descr_;
extern const ASN_BERdescriptor_t SPAT_msgID_ber_;
extern const TTCN_Typedescriptor_t SPAT_msgID_descr_;
extern const TTCN_JSONdescriptor_t IntersectionStateList_json_;
extern const TTCN_Typedescriptor_t IntersectionStateList_descr_;
extern const ASN_BERdescriptor_t IntersectionState_id_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_id_descr_;
extern const ASN_BERdescriptor_t IntersectionState_revision_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_revision_descr_;
extern const TTCN_Typedescriptor_t& IntersectionStatusObject_descr_;
extern const ASN_BERdescriptor_t IntersectionState_status_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_status_descr_;
extern const TTCN_JSONdescriptor_t MovementList_json_;
extern const TTCN_Typedescriptor_t MovementList_descr_;
extern const ASN_BERdescriptor_t MovementState_signalGroup_ber_;
extern const TTCN_Typedescriptor_t MovementState_signalGroup_descr_;
extern const TTCN_JSONdescriptor_t MovementEventList_json_;
extern const TTCN_Typedescriptor_t MovementEventList_descr_;
extern const TTCN_JSONdescriptor_t MovementPhaseState_json_;
extern const TTCN_Typedescriptor_t MovementPhaseState_descr_;
extern const ASN_BERdescriptor_t MovementEvent_eventState_ber_;
extern const TTCN_Typedescriptor_t MovementEvent_eventState_descr_;
extern const TTCN_JSONdescriptor_t MovementEvent_json_;
extern const TTCN_Typedescriptor_t MovementEvent_descr_;
extern const TTCN_Typedescriptor_t& TimeMark_descr_;
extern const ASN_BERdescriptor_t TimeChangeDetails_minEndTime_ber_;
extern const TTCN_Typedescriptor_t TimeChangeDetails_minEndTime_descr_;
extern const TTCN_JSONdescriptor_t TimeChangeDetails_json_;
extern const TTCN_Typedescriptor_t TimeChangeDetails_descr_;
extern const ASN_BERdescriptor_t TimeChangeDetails_startTime_ber_;
extern const TTCN_Typedescriptor_t TimeChangeDetails_startTime_descr_;
extern const ASN_BERdescriptor_t TimeChangeDetails_maxEndTime_ber_;
extern const TTCN_Typedescriptor_t TimeChangeDetails_maxEndTime_descr_;
extern const ASN_BERdescriptor_t TimeChangeDetails_likelyTime_ber_;
extern const TTCN_Typedescriptor_t TimeChangeDetails_likelyTime_descr_;
extern const TTCN_Typedescriptor_t& TimeIntervalConfidence_descr_;
extern const ASN_BERdescriptor_t TimeChangeDetails_confidence_ber_;
extern const TTCN_Typedescriptor_t TimeChangeDetails_confidence_descr_;
extern const ASN_BERdescriptor_t TimeChangeDetails_nextTime_ber_;
extern const TTCN_Typedescriptor_t TimeChangeDetails_nextTime_descr_;
extern const ASN_BERdescriptor_t MovementEvent_timing_ber_;
extern const TTCN_Typedescriptor_t MovementEvent_timing_descr_;
extern const TTCN_JSONdescriptor_t AdvisorySpeedList_json_;
extern const TTCN_Typedescriptor_t AdvisorySpeedList_descr_;
extern const TTCN_JSONdescriptor_t AdvisorySpeedType_json_;
extern const TTCN_Typedescriptor_t AdvisorySpeedType_descr_;
extern const ASN_BERdescriptor_t AdvisorySpeed_type___ber_;
extern const TTCN_Typedescriptor_t AdvisorySpeed_type___descr_;
extern const TTCN_JSONdescriptor_t AdvisorySpeed_json_;
extern const TTCN_Typedescriptor_t AdvisorySpeed_descr_;
extern const TTCN_Typedescriptor_t& SpeedAdvice_descr_;
extern const ASN_BERdescriptor_t AdvisorySpeed_speed_ber_;
extern const TTCN_Typedescriptor_t AdvisorySpeed_speed_descr_;
extern const ASN_BERdescriptor_t AdvisorySpeed_confidence_ber_;
extern const TTCN_Typedescriptor_t AdvisorySpeed_confidence_descr_;
extern const TTCN_Typedescriptor_t& ZoneLength_descr_;
extern const ASN_BERdescriptor_t AdvisorySpeed_distance_ber_;
extern const TTCN_Typedescriptor_t AdvisorySpeed_distance_descr_;
extern const ASN_BERdescriptor_t AdvisorySpeed_class__ber_;
extern const TTCN_Typedescriptor_t AdvisorySpeed_class__descr_;
extern const TTCN_Typedescriptor_t& RegionalAdvisorySpeed_descr_;
extern const ASN_BERdescriptor_t AdvisorySpeed_regional_ber_;
extern const TTCN_Typedescriptor_t AdvisorySpeed_regional_descr_;
extern const ASN_BERdescriptor_t MovementEvent_speeds_ber_;
extern const TTCN_Typedescriptor_t MovementEvent_speeds_descr_;
extern const TTCN_Typedescriptor_t& RegionalMovementEvent_descr_;
extern const ASN_BERdescriptor_t MovementEvent_regional_ber_;
extern const TTCN_Typedescriptor_t MovementEvent_regional_descr_;
extern const ASN_BERdescriptor_t MovementState_state__time__speed_ber_;
extern const TTCN_Typedescriptor_t MovementState_state__time__speed_descr_;
extern const TTCN_JSONdescriptor_t MovementState_json_;
extern const TTCN_Typedescriptor_t MovementState_descr_;
extern const ASN_BERdescriptor_t MovementState_movementName_ber_;
extern const TTCN_Typedescriptor_t MovementState_movementName_descr_;
extern const TTCN_JSONdescriptor_t ManeuverAssistList_json_;
extern const TTCN_Typedescriptor_t ManeuverAssistList_descr_;
extern const ASN_BERdescriptor_t ConnectionManeuverAssist_connectionID_ber_;
extern const TTCN_Typedescriptor_t ConnectionManeuverAssist_connectionID_descr_;
extern const TTCN_JSONdescriptor_t ConnectionManeuverAssist_json_;
extern const TTCN_Typedescriptor_t ConnectionManeuverAssist_descr_;
extern const ASN_BERdescriptor_t ConnectionManeuverAssist_queueLength_ber_;
extern const TTCN_Typedescriptor_t ConnectionManeuverAssist_queueLength_descr_;
extern const ASN_BERdescriptor_t ConnectionManeuverAssist_availableStorageLength_ber_;
extern const TTCN_Typedescriptor_t ConnectionManeuverAssist_availableStorageLength_descr_;
extern const TTCN_Typedescriptor_t& WaitOnStopline_descr_;
extern const ASN_BERdescriptor_t ConnectionManeuverAssist_waitOnStop_ber_;
extern const TTCN_Typedescriptor_t ConnectionManeuverAssist_waitOnStop_descr_;
extern const TTCN_Typedescriptor_t& PedestrianBicycleDetect_descr_;
extern const ASN_BERdescriptor_t ConnectionManeuverAssist_pedBicycleDetect_ber_;
extern const TTCN_Typedescriptor_t ConnectionManeuverAssist_pedBicycleDetect_descr_;
extern const TTCN_Typedescriptor_t& RegionalConnectionManeuverAssist_descr_;
extern const ASN_BERdescriptor_t ConnectionManeuverAssist_regional_ber_;
extern const TTCN_Typedescriptor_t ConnectionManeuverAssist_regional_descr_;
extern const ASN_BERdescriptor_t MovementState_maneuverAssistList_ber_;
extern const TTCN_Typedescriptor_t MovementState_maneuverAssistList_descr_;
extern const TTCN_Typedescriptor_t& RegionalMovementState_descr_;
extern const ASN_BERdescriptor_t MovementState_regional_ber_;
extern const TTCN_Typedescriptor_t MovementState_regional_descr_;
extern const ASN_BERdescriptor_t IntersectionState_states_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_states_descr_;
extern const TTCN_JSONdescriptor_t IntersectionState_json_;
extern const TTCN_Typedescriptor_t IntersectionState_descr_;
extern const ASN_BERdescriptor_t IntersectionState_name_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_name_descr_;
extern const TTCN_Typedescriptor_t& MinuteOfTheYear_descr_;
extern const ASN_BERdescriptor_t IntersectionState_moy_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_moy_descr_;
extern const TTCN_Typedescriptor_t& DSecond2_descr_;
extern const ASN_BERdescriptor_t IntersectionState_timeStamp_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_timeStamp_descr_;
extern const TTCN_JSONdescriptor_t EnabledLaneList_json_;
extern const TTCN_Typedescriptor_t EnabledLaneList_descr_;
extern const ASN_BERdescriptor_t IntersectionState_enabledLanes_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_enabledLanes_descr_;
extern const ASN_BERdescriptor_t IntersectionState_maneuverAssistList_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_maneuverAssistList_descr_;
extern const TTCN_Typedescriptor_t& SignalControlState_descr_;
extern const ASN_BERdescriptor_t IntersectionState_priority_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_priority_descr_;
extern const ASN_BERdescriptor_t IntersectionState_preempt_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_preempt_descr_;
extern const TTCN_Typedescriptor_t& RegionalIntersectionState_descr_;
extern const ASN_BERdescriptor_t IntersectionState_regional_ber_;
extern const TTCN_Typedescriptor_t IntersectionState_regional_descr_;
extern const ASN_BERdescriptor_t SPAT_intersections_ber_;
extern const TTCN_Typedescriptor_t SPAT_intersections_descr_;
extern const TTCN_JSONdescriptor_t SPAT_json_;
extern const TTCN_Typedescriptor_t SPAT_descr_;
extern const ASN_BERdescriptor_t SPAT_msgSubID_ber_;
extern const TTCN_Typedescriptor_t SPAT_msgSubID_descr_;
extern const ASN_BERdescriptor_t SPAT_name_ber_;
extern const TTCN_Typedescriptor_t SPAT_name_descr_;
extern const TTCN_Typedescriptor_t& RegionalSPAT_descr_;
extern const ASN_BERdescriptor_t SPAT_regional_ber_;
extern const TTCN_Typedescriptor_t SPAT_regional_descr_;
extern const INTEGER& mapData__P;
extern const INTEGER& signalPhaseAndTimingMessage__P;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
