// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "LibItsCam_TypesAndValues.hh"

namespace LibItsCam__TypesAndValues {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const unsigned char bs_0_bits[] = { 0 },
bs_8_bits[] = { 0 },
bs_16_bits[] = { 128 },
bs_7_bits[] = { 64 },
bs_15_bits[] = { 64 },
bs_6_bits[] = { 32 },
bs_14_bits[] = { 32 },
bs_5_bits[] = { 16 },
bs_13_bits[] = { 16 },
bs_4_bits[] = { 8 },
bs_12_bits[] = { 8 },
bs_3_bits[] = { 4 },
bs_11_bits[] = { 36 },
bs_2_bits[] = { 2 },
bs_10_bits[] = { 66 },
bs_1_bits[] = { 1 },
bs_9_bits[] = { 129 };
static const BITSTRING bs_0(7, bs_0_bits),
bs_8(8, bs_8_bits),
bs_16(8, bs_16_bits),
bs_7(7, bs_7_bits),
bs_15(8, bs_15_bits),
bs_6(7, bs_6_bits),
bs_14(8, bs_14_bits),
bs_5(7, bs_5_bits),
bs_13(8, bs_13_bits),
bs_4(7, bs_4_bits),
bs_12(8, bs_12_bits),
bs_3(7, bs_3_bits),
bs_11(8, bs_11_bits),
bs_2(7, bs_2_bits),
bs_10(8, bs_10_bits),
bs_1(7, bs_1_bits),
bs_9(8, bs_9_bits);
static const unsigned char module_checksum[] = { 0x66, 0x65, 0x93, 0xc8, 0xff, 0xd5, 0x33, 0x48, 0x61, 0xb3, 0x22, 0xe8, 0x6f, 0xca, 0x73, 0xb5 };

/* Global variable definitions */

static INTEGER const_c__protocolVersionCam;
const INTEGER& c__protocolVersionCam = const_c__protocolVersionCam;
static INTEGER const_c__messageIdCam;
const INTEGER& c__messageIdCam = const_c__messageIdCam;
static FLOAT const_c__lowFrequencyGenerationTime;
const FLOAT& c__lowFrequencyGenerationTime = const_c__lowFrequencyGenerationTime;
static FLOAT const_c__specialVehicleGenerationTime;
const FLOAT& c__specialVehicleGenerationTime = const_c__specialVehicleGenerationTime;
static BITSTRING const_c__accCtrlIdle;
const BITSTRING& c__accCtrlIdle = const_c__accCtrlIdle;
static BITSTRING const_c__brakePedalEngaged;
const BITSTRING& c__brakePedalEngaged = const_c__brakePedalEngaged;
static BITSTRING const_c__gasPedalEngaged;
const BITSTRING& c__gasPedalEngaged = const_c__gasPedalEngaged;
static BITSTRING const_c__emergencyBrakeEngaged;
const BITSTRING& c__emergencyBrakeEngaged = const_c__emergencyBrakeEngaged;
static BITSTRING const_c__collisionWarningEngaged;
const BITSTRING& c__collisionWarningEngaged = const_c__collisionWarningEngaged;
static BITSTRING const_c__accEngaged;
const BITSTRING& c__accEngaged = const_c__accEngaged;
static BITSTRING const_c__cruiseControlEngaged;
const BITSTRING& c__cruiseControlEngaged = const_c__cruiseControlEngaged;
static BITSTRING const_c__speedLimiterEngaged;
const BITSTRING& c__speedLimiterEngaged = const_c__speedLimiterEngaged;
static BITSTRING const_c__elAllLightsOff;
const BITSTRING& c__elAllLightsOff = const_c__elAllLightsOff;
static BITSTRING const_c__lowBeamHeadlightsOn;
const BITSTRING& c__lowBeamHeadlightsOn = const_c__lowBeamHeadlightsOn;
static BITSTRING const_c__highBeamHeadlightsOn;
const BITSTRING& c__highBeamHeadlightsOn = const_c__highBeamHeadlightsOn;
static BITSTRING const_c__leftTurnSignalOn;
const BITSTRING& c__leftTurnSignalOn = const_c__leftTurnSignalOn;
static BITSTRING const_c__rightTurnSignalOn;
const BITSTRING& c__rightTurnSignalOn = const_c__rightTurnSignalOn;
static BITSTRING const_c__daytimeRunningLightsOn;
const BITSTRING& c__daytimeRunningLightsOn = const_c__daytimeRunningLightsOn;
static BITSTRING const_c__reverseLightOn;
const BITSTRING& c__reverseLightOn = const_c__reverseLightOn;
static BITSTRING const_c__fogLightOn;
const BITSTRING& c__fogLightOn = const_c__fogLightOn;
static BITSTRING const_c__parkingLightsOn;
const BITSTRING& c__parkingLightsOn = const_c__parkingLightsOn;
static ITS__Container::VehicleRole const_c__vehicleRole__publicTransport;
const ITS__Container::VehicleRole& c__vehicleRole__publicTransport = const_c__vehicleRole__publicTransport;
static ITS__Container::VehicleRole const_c__vehicleRole__specialTransport;
const ITS__Container::VehicleRole& c__vehicleRole__specialTransport = const_c__vehicleRole__specialTransport;
static ITS__Container::VehicleRole const_c__vehicleRole__dangerousGoods;
const ITS__Container::VehicleRole& c__vehicleRole__dangerousGoods = const_c__vehicleRole__dangerousGoods;
static ITS__Container::VehicleRole const_c__vehicleRole__roadWork;
const ITS__Container::VehicleRole& c__vehicleRole__roadWork = const_c__vehicleRole__roadWork;
static ITS__Container::VehicleRole const_c__vehicleRole__rescue;
const ITS__Container::VehicleRole& c__vehicleRole__rescue = const_c__vehicleRole__rescue;
static ITS__Container::VehicleRole const_c__vehicleRole__emergency;
const ITS__Container::VehicleRole& c__vehicleRole__emergency = const_c__vehicleRole__emergency;
static ITS__Container::VehicleRole const_c__vehicleRole__safetyCar;
const ITS__Container::VehicleRole& c__vehicleRole__safetyCar = const_c__vehicleRole__safetyCar;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__explosives1;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__explosives1 = const_c__dangerousGoodsBasic__explosives1;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__explosives2;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__explosives2 = const_c__dangerousGoodsBasic__explosives2;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__explosives3;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__explosives3 = const_c__dangerousGoodsBasic__explosives3;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__explosives4;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__explosives4 = const_c__dangerousGoodsBasic__explosives4;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__explosives5;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__explosives5 = const_c__dangerousGoodsBasic__explosives5;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__explosives6;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__explosives6 = const_c__dangerousGoodsBasic__explosives6;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__flammableGases;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__flammableGases = const_c__dangerousGoodsBasic__flammableGases;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__nonFlammableGases;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__nonFlammableGases = const_c__dangerousGoodsBasic__nonFlammableGases;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__toxicGases;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__toxicGases = const_c__dangerousGoodsBasic__toxicGases;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__flammableLiquids;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__flammableLiquids = const_c__dangerousGoodsBasic__flammableLiquids;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__flammableSolids;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__flammableSolids = const_c__dangerousGoodsBasic__flammableSolids;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__substancesLiableToSpontaneousCombustion;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__substancesLiableToSpontaneousCombustion = const_c__dangerousGoodsBasic__substancesLiableToSpontaneousCombustion;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__substancesEmittingFlammableGasesUponContactWithWater;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__substancesEmittingFlammableGasesUponContactWithWater = const_c__dangerousGoodsBasic__substancesEmittingFlammableGasesUponContactWithWater;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__oxidizingSubstances;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__oxidizingSubstances = const_c__dangerousGoodsBasic__oxidizingSubstances;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__organicPeroxides;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__organicPeroxides = const_c__dangerousGoodsBasic__organicPeroxides;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__toxicSubstances;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__toxicSubstances = const_c__dangerousGoodsBasic__toxicSubstances;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__infectiousSubstances;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__infectiousSubstances = const_c__dangerousGoodsBasic__infectiousSubstances;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__radioactiveMaterial;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__radioactiveMaterial = const_c__dangerousGoodsBasic__radioactiveMaterial;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__corrosiveSubstances;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__corrosiveSubstances = const_c__dangerousGoodsBasic__corrosiveSubstances;
static ITS__Container::DangerousGoodsBasic const_c__dangerousGoodsBasic__miscellaneousDangerousSubstances;
const ITS__Container::DangerousGoodsBasic& c__dangerousGoodsBasic__miscellaneousDangerousSubstances = const_c__dangerousGoodsBasic__miscellaneousDangerousSubstances;
const TTCN_RAWdescriptor_t UtCamTrigger_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtCamTrigger
const TTCN_JSONdescriptor_t UtCamTrigger_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t UtCamTrigger_descr_ = { "@LibItsCam_TypesAndValues.UtCamTrigger", NULL, &UtCamTrigger_raw_, NULL, NULL, &UtCamTrigger_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UtCamTrigger_changeSpeed_xer_ = { {"changeSpeed>\n", "changeSpeed>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t UtCamTrigger_changeSpeed_descr_ = { "@LibItsCam_TypesAndValues.UtCamTrigger.changeSpeed", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int16_raw_, &INTEGER_text_, &UtCamTrigger_changeSpeed_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtCamTriggerResult_utCamTriggerResult_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       UtCamTriggerResult_utCamTriggerResult_xer_ = { {"utCamTriggerResult>\n", "utCamTriggerResult>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t UtCamTriggerResult_utCamTriggerResult_descr_ = { "@LibItsCam_TypesAndValues.UtCamTriggerResult.utCamTriggerResult", &BOOLEAN_ber_, &UtCamTriggerResult_utCamTriggerResult_raw_, &BOOLEAN_text_, &UtCamTriggerResult_utCamTriggerResult_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtCamTriggerResult_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtCamTriggerResult
const TTCN_JSONdescriptor_t UtCamTriggerResult_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t UtCamTriggerResult_descr_ = { "@LibItsCam_TypesAndValues.UtCamTriggerResult", NULL, &UtCamTriggerResult_raw_, NULL, NULL, &UtCamTriggerResult_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtCamEventInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtCamEventInd
const TTCN_JSONdescriptor_t UtCamEventInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t UtCamEventInd_descr_ = { "@LibItsCam_TypesAndValues.UtCamEventInd", NULL, &UtCamEventInd_raw_, NULL, NULL, &UtCamEventInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtCamEventIndList_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtCamEventIndList
const TTCN_Typedescriptor_t UtCamEventIndList_descr_ = { "@LibItsCam_TypesAndValues.UtCamEventIndList", NULL, &UtCamEventIndList_raw_, NULL, NULL, NULL, &UtCamEventInd_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 0;
TTCN_Module module_object("LibItsCam_TypesAndValues", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

void UtCamTrigger::copy_value(const UtCamTrigger& other_value)
{
switch (other_value.union_selection) {
case ALT_changeCurvature:
field_changeCurvature = new INTEGER(*other_value.field_changeCurvature);
break;
case ALT_changeSpeed:
field_changeSpeed = new INTEGER(*other_value.field_changeSpeed);
break;
case ALT_setAccelerationControlStatus:
field_setAccelerationControlStatus = new BITSTRING(*other_value.field_setAccelerationControlStatus);
break;
case ALT_setExteriorLightsStatus:
field_setExteriorLightsStatus = new BITSTRING(*other_value.field_setExteriorLightsStatus);
break;
case ALT_changeHeading:
field_changeHeading = new INTEGER(*other_value.field_changeHeading);
break;
case ALT_setDriveDirection:
field_setDriveDirection = new ITS__Container::DriveDirection(*other_value.field_setDriveDirection);
break;
case ALT_changeYawRate:
field_changeYawRate = new INTEGER(*other_value.field_changeYawRate);
break;
case ALT_setStationType:
field_setStationType = new INTEGER(*other_value.field_setStationType);
break;
case ALT_setVehicleRole:
field_setVehicleRole = new ITS__Container::VehicleRole(*other_value.field_setVehicleRole);
break;
case ALT_setEmbarkationStatus:
field_setEmbarkationStatus = new BOOLEAN(*other_value.field_setEmbarkationStatus);
break;
case ALT_setPtActivation:
field_setPtActivation = new ITS__Container::PtActivation(*other_value.field_setPtActivation);
break;
case ALT_setDangerousGoods:
field_setDangerousGoods = new ITS__Container::DangerousGoodsBasic(*other_value.field_setDangerousGoods);
break;
case ALT_setLightBarSirene:
field_setLightBarSirene = new BITSTRING(*other_value.field_setLightBarSirene);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
union_selection = other_value.union_selection;
}

UtCamTrigger::UtCamTrigger()
{
union_selection = UNBOUND_VALUE;
}

UtCamTrigger::UtCamTrigger(const UtCamTrigger& other_value)
: Base_Type(){
copy_value(other_value);
}

UtCamTrigger::~UtCamTrigger()
{
clean_up();
}

UtCamTrigger& UtCamTrigger::operator=(const UtCamTrigger& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean UtCamTrigger::operator==(const UtCamTrigger& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_changeCurvature:
return *field_changeCurvature == *other_value.field_changeCurvature;
case ALT_changeSpeed:
return *field_changeSpeed == *other_value.field_changeSpeed;
case ALT_setAccelerationControlStatus:
return *field_setAccelerationControlStatus == *other_value.field_setAccelerationControlStatus;
case ALT_setExteriorLightsStatus:
return *field_setExteriorLightsStatus == *other_value.field_setExteriorLightsStatus;
case ALT_changeHeading:
return *field_changeHeading == *other_value.field_changeHeading;
case ALT_setDriveDirection:
return *field_setDriveDirection == *other_value.field_setDriveDirection;
case ALT_changeYawRate:
return *field_changeYawRate == *other_value.field_changeYawRate;
case ALT_setStationType:
return *field_setStationType == *other_value.field_setStationType;
case ALT_setVehicleRole:
return *field_setVehicleRole == *other_value.field_setVehicleRole;
case ALT_setEmbarkationStatus:
return *field_setEmbarkationStatus == *other_value.field_setEmbarkationStatus;
case ALT_setPtActivation:
return *field_setPtActivation == *other_value.field_setPtActivation;
case ALT_setDangerousGoods:
return *field_setDangerousGoods == *other_value.field_setDangerousGoods;
case ALT_setLightBarSirene:
return *field_setLightBarSirene == *other_value.field_setLightBarSirene;
default:
return FALSE;
}
}

INTEGER& UtCamTrigger::changeCurvature()
{
if (union_selection != ALT_changeCurvature) {
clean_up();
field_changeCurvature = new INTEGER;
union_selection = ALT_changeCurvature;
}
return *field_changeCurvature;
}

const INTEGER& UtCamTrigger::changeCurvature() const
{
if (union_selection != ALT_changeCurvature) TTCN_error("Using non-selected field changeCurvature in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_changeCurvature;
}

INTEGER& UtCamTrigger::changeSpeed()
{
if (union_selection != ALT_changeSpeed) {
clean_up();
field_changeSpeed = new INTEGER;
union_selection = ALT_changeSpeed;
}
return *field_changeSpeed;
}

const INTEGER& UtCamTrigger::changeSpeed() const
{
if (union_selection != ALT_changeSpeed) TTCN_error("Using non-selected field changeSpeed in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_changeSpeed;
}

BITSTRING& UtCamTrigger::setAccelerationControlStatus()
{
if (union_selection != ALT_setAccelerationControlStatus) {
clean_up();
field_setAccelerationControlStatus = new BITSTRING;
union_selection = ALT_setAccelerationControlStatus;
}
return *field_setAccelerationControlStatus;
}

const BITSTRING& UtCamTrigger::setAccelerationControlStatus() const
{
if (union_selection != ALT_setAccelerationControlStatus) TTCN_error("Using non-selected field setAccelerationControlStatus in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_setAccelerationControlStatus;
}

BITSTRING& UtCamTrigger::setExteriorLightsStatus()
{
if (union_selection != ALT_setExteriorLightsStatus) {
clean_up();
field_setExteriorLightsStatus = new BITSTRING;
union_selection = ALT_setExteriorLightsStatus;
}
return *field_setExteriorLightsStatus;
}

const BITSTRING& UtCamTrigger::setExteriorLightsStatus() const
{
if (union_selection != ALT_setExteriorLightsStatus) TTCN_error("Using non-selected field setExteriorLightsStatus in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_setExteriorLightsStatus;
}

INTEGER& UtCamTrigger::changeHeading()
{
if (union_selection != ALT_changeHeading) {
clean_up();
field_changeHeading = new INTEGER;
union_selection = ALT_changeHeading;
}
return *field_changeHeading;
}

const INTEGER& UtCamTrigger::changeHeading() const
{
if (union_selection != ALT_changeHeading) TTCN_error("Using non-selected field changeHeading in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_changeHeading;
}

ITS__Container::DriveDirection& UtCamTrigger::setDriveDirection()
{
if (union_selection != ALT_setDriveDirection) {
clean_up();
field_setDriveDirection = new ITS__Container::DriveDirection;
union_selection = ALT_setDriveDirection;
}
return *field_setDriveDirection;
}

const ITS__Container::DriveDirection& UtCamTrigger::setDriveDirection() const
{
if (union_selection != ALT_setDriveDirection) TTCN_error("Using non-selected field setDriveDirection in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_setDriveDirection;
}

INTEGER& UtCamTrigger::changeYawRate()
{
if (union_selection != ALT_changeYawRate) {
clean_up();
field_changeYawRate = new INTEGER;
union_selection = ALT_changeYawRate;
}
return *field_changeYawRate;
}

const INTEGER& UtCamTrigger::changeYawRate() const
{
if (union_selection != ALT_changeYawRate) TTCN_error("Using non-selected field changeYawRate in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_changeYawRate;
}

INTEGER& UtCamTrigger::setStationType()
{
if (union_selection != ALT_setStationType) {
clean_up();
field_setStationType = new INTEGER;
union_selection = ALT_setStationType;
}
return *field_setStationType;
}

const INTEGER& UtCamTrigger::setStationType() const
{
if (union_selection != ALT_setStationType) TTCN_error("Using non-selected field setStationType in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_setStationType;
}

ITS__Container::VehicleRole& UtCamTrigger::setVehicleRole()
{
if (union_selection != ALT_setVehicleRole) {
clean_up();
field_setVehicleRole = new ITS__Container::VehicleRole;
union_selection = ALT_setVehicleRole;
}
return *field_setVehicleRole;
}

const ITS__Container::VehicleRole& UtCamTrigger::setVehicleRole() const
{
if (union_selection != ALT_setVehicleRole) TTCN_error("Using non-selected field setVehicleRole in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_setVehicleRole;
}

BOOLEAN& UtCamTrigger::setEmbarkationStatus()
{
if (union_selection != ALT_setEmbarkationStatus) {
clean_up();
field_setEmbarkationStatus = new BOOLEAN;
union_selection = ALT_setEmbarkationStatus;
}
return *field_setEmbarkationStatus;
}

const BOOLEAN& UtCamTrigger::setEmbarkationStatus() const
{
if (union_selection != ALT_setEmbarkationStatus) TTCN_error("Using non-selected field setEmbarkationStatus in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_setEmbarkationStatus;
}

ITS__Container::PtActivation& UtCamTrigger::setPtActivation()
{
if (union_selection != ALT_setPtActivation) {
clean_up();
field_setPtActivation = new ITS__Container::PtActivation;
union_selection = ALT_setPtActivation;
}
return *field_setPtActivation;
}

const ITS__Container::PtActivation& UtCamTrigger::setPtActivation() const
{
if (union_selection != ALT_setPtActivation) TTCN_error("Using non-selected field setPtActivation in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_setPtActivation;
}

ITS__Container::DangerousGoodsBasic& UtCamTrigger::setDangerousGoods()
{
if (union_selection != ALT_setDangerousGoods) {
clean_up();
field_setDangerousGoods = new ITS__Container::DangerousGoodsBasic;
union_selection = ALT_setDangerousGoods;
}
return *field_setDangerousGoods;
}

const ITS__Container::DangerousGoodsBasic& UtCamTrigger::setDangerousGoods() const
{
if (union_selection != ALT_setDangerousGoods) TTCN_error("Using non-selected field setDangerousGoods in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_setDangerousGoods;
}

BITSTRING& UtCamTrigger::setLightBarSirene()
{
if (union_selection != ALT_setLightBarSirene) {
clean_up();
field_setLightBarSirene = new BITSTRING;
union_selection = ALT_setLightBarSirene;
}
return *field_setLightBarSirene;
}

const BITSTRING& UtCamTrigger::setLightBarSirene() const
{
if (union_selection != ALT_setLightBarSirene) TTCN_error("Using non-selected field setLightBarSirene in a value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *field_setLightBarSirene;
}

boolean UtCamTrigger::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return union_selection == checked_selection;
}

boolean UtCamTrigger::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean UtCamTrigger::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_changeCurvature: return field_changeCurvature->is_value();
case ALT_changeSpeed: return field_changeSpeed->is_value();
case ALT_setAccelerationControlStatus: return field_setAccelerationControlStatus->is_value();
case ALT_setExteriorLightsStatus: return field_setExteriorLightsStatus->is_value();
case ALT_changeHeading: return field_changeHeading->is_value();
case ALT_setDriveDirection: return field_setDriveDirection->is_value();
case ALT_changeYawRate: return field_changeYawRate->is_value();
case ALT_setStationType: return field_setStationType->is_value();
case ALT_setVehicleRole: return field_setVehicleRole->is_value();
case ALT_setEmbarkationStatus: return field_setEmbarkationStatus->is_value();
case ALT_setPtActivation: return field_setPtActivation->is_value();
case ALT_setDangerousGoods: return field_setDangerousGoods->is_value();
case ALT_setLightBarSirene: return field_setLightBarSirene->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void UtCamTrigger::clean_up()
{
switch (union_selection) {
case ALT_changeCurvature:
  delete field_changeCurvature;
  break;
case ALT_changeSpeed:
  delete field_changeSpeed;
  break;
case ALT_setAccelerationControlStatus:
  delete field_setAccelerationControlStatus;
  break;
case ALT_setExteriorLightsStatus:
  delete field_setExteriorLightsStatus;
  break;
case ALT_changeHeading:
  delete field_changeHeading;
  break;
case ALT_setDriveDirection:
  delete field_setDriveDirection;
  break;
case ALT_changeYawRate:
  delete field_changeYawRate;
  break;
case ALT_setStationType:
  delete field_setStationType;
  break;
case ALT_setVehicleRole:
  delete field_setVehicleRole;
  break;
case ALT_setEmbarkationStatus:
  delete field_setEmbarkationStatus;
  break;
case ALT_setPtActivation:
  delete field_setPtActivation;
  break;
case ALT_setDangerousGoods:
  delete field_setDangerousGoods;
  break;
case ALT_setLightBarSirene:
  delete field_setLightBarSirene;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void UtCamTrigger::log() const
{
switch (union_selection) {
case ALT_changeCurvature:
TTCN_Logger::log_event_str("{ changeCurvature := ");
field_changeCurvature->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_changeSpeed:
TTCN_Logger::log_event_str("{ changeSpeed := ");
field_changeSpeed->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setAccelerationControlStatus:
TTCN_Logger::log_event_str("{ setAccelerationControlStatus := ");
field_setAccelerationControlStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setExteriorLightsStatus:
TTCN_Logger::log_event_str("{ setExteriorLightsStatus := ");
field_setExteriorLightsStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_changeHeading:
TTCN_Logger::log_event_str("{ changeHeading := ");
field_changeHeading->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setDriveDirection:
TTCN_Logger::log_event_str("{ setDriveDirection := ");
field_setDriveDirection->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_changeYawRate:
TTCN_Logger::log_event_str("{ changeYawRate := ");
field_changeYawRate->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setStationType:
TTCN_Logger::log_event_str("{ setStationType := ");
field_setStationType->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setVehicleRole:
TTCN_Logger::log_event_str("{ setVehicleRole := ");
field_setVehicleRole->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setEmbarkationStatus:
TTCN_Logger::log_event_str("{ setEmbarkationStatus := ");
field_setEmbarkationStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setPtActivation:
TTCN_Logger::log_event_str("{ setPtActivation := ");
field_setPtActivation->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setDangerousGoods:
TTCN_Logger::log_event_str("{ setDangerousGoods := ");
field_setDangerousGoods->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setLightBarSirene:
TTCN_Logger::log_event_str("{ setLightBarSirene := ");
field_setLightBarSirene->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void UtCamTrigger::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsCam_TypesAndValues.UtCamTrigger'");
    }
    if (strcmp("changeCurvature", param_field) == 0) {
      changeCurvature().set_param(param);
      return;
    } else if (strcmp("changeSpeed", param_field) == 0) {
      changeSpeed().set_param(param);
      return;
    } else if (strcmp("setAccelerationControlStatus", param_field) == 0) {
      setAccelerationControlStatus().set_param(param);
      return;
    } else if (strcmp("setExteriorLightsStatus", param_field) == 0) {
      setExteriorLightsStatus().set_param(param);
      return;
    } else if (strcmp("changeHeading", param_field) == 0) {
      changeHeading().set_param(param);
      return;
    } else if (strcmp("setDriveDirection", param_field) == 0) {
      setDriveDirection().set_param(param);
      return;
    } else if (strcmp("changeYawRate", param_field) == 0) {
      changeYawRate().set_param(param);
      return;
    } else if (strcmp("setStationType", param_field) == 0) {
      setStationType().set_param(param);
      return;
    } else if (strcmp("setVehicleRole", param_field) == 0) {
      setVehicleRole().set_param(param);
      return;
    } else if (strcmp("setEmbarkationStatus", param_field) == 0) {
      setEmbarkationStatus().set_param(param);
      return;
    } else if (strcmp("setPtActivation", param_field) == 0) {
      setPtActivation().set_param(param);
      return;
    } else if (strcmp("setDangerousGoods", param_field) == 0) {
      setDangerousGoods().set_param(param);
      return;
    } else if (strcmp("setLightBarSirene", param_field) == 0) {
      setLightBarSirene().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsCam_TypesAndValues.UtCamTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "changeCurvature")) {
    changeCurvature().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "changeSpeed")) {
    changeSpeed().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setAccelerationControlStatus")) {
    setAccelerationControlStatus().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setExteriorLightsStatus")) {
    setExteriorLightsStatus().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "changeHeading")) {
    changeHeading().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setDriveDirection")) {
    setDriveDirection().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "changeYawRate")) {
    changeYawRate().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setStationType")) {
    setStationType().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setVehicleRole")) {
    setVehicleRole().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setEmbarkationStatus")) {
    setEmbarkationStatus().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setPtActivation")) {
    setPtActivation().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setDangerousGoods")) {
    setDangerousGoods().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setLightBarSirene")) {
    setLightBarSirene().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsCam_TypesAndValues.UtCamTrigger.", mp_last->get_id()->get_name());
}

Module_Param* UtCamTrigger::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsCam_TypesAndValues.UtCamTrigger'");
    }
    if (strcmp("changeCurvature", param_field) == 0) {
      return changeCurvature().get_param(param_name);
    } else if (strcmp("changeSpeed", param_field) == 0) {
      return changeSpeed().get_param(param_name);
    } else if (strcmp("setAccelerationControlStatus", param_field) == 0) {
      return setAccelerationControlStatus().get_param(param_name);
    } else if (strcmp("setExteriorLightsStatus", param_field) == 0) {
      return setExteriorLightsStatus().get_param(param_name);
    } else if (strcmp("changeHeading", param_field) == 0) {
      return changeHeading().get_param(param_name);
    } else if (strcmp("setDriveDirection", param_field) == 0) {
      return setDriveDirection().get_param(param_name);
    } else if (strcmp("changeYawRate", param_field) == 0) {
      return changeYawRate().get_param(param_name);
    } else if (strcmp("setStationType", param_field) == 0) {
      return setStationType().get_param(param_name);
    } else if (strcmp("setVehicleRole", param_field) == 0) {
      return setVehicleRole().get_param(param_name);
    } else if (strcmp("setEmbarkationStatus", param_field) == 0) {
      return setEmbarkationStatus().get_param(param_name);
    } else if (strcmp("setPtActivation", param_field) == 0) {
      return setPtActivation().get_param(param_name);
    } else if (strcmp("setDangerousGoods", param_field) == 0) {
      return setDangerousGoods().get_param(param_name);
    } else if (strcmp("setLightBarSirene", param_field) == 0) {
      return setLightBarSirene().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `UtCamTrigger'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_changeCurvature:
    mp_field = field_changeCurvature->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("changeCurvature")));
    break;
  case ALT_changeSpeed:
    mp_field = field_changeSpeed->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("changeSpeed")));
    break;
  case ALT_setAccelerationControlStatus:
    mp_field = field_setAccelerationControlStatus->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setAccelerationControlStatus")));
    break;
  case ALT_setExteriorLightsStatus:
    mp_field = field_setExteriorLightsStatus->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setExteriorLightsStatus")));
    break;
  case ALT_changeHeading:
    mp_field = field_changeHeading->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("changeHeading")));
    break;
  case ALT_setDriveDirection:
    mp_field = field_setDriveDirection->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setDriveDirection")));
    break;
  case ALT_changeYawRate:
    mp_field = field_changeYawRate->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("changeYawRate")));
    break;
  case ALT_setStationType:
    mp_field = field_setStationType->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setStationType")));
    break;
  case ALT_setVehicleRole:
    mp_field = field_setVehicleRole->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setVehicleRole")));
    break;
  case ALT_setEmbarkationStatus:
    mp_field = field_setEmbarkationStatus->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setEmbarkationStatus")));
    break;
  case ALT_setPtActivation:
    mp_field = field_setPtActivation->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setPtActivation")));
    break;
  case ALT_setDangerousGoods:
    mp_field = field_setDangerousGoods->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setDangerousGoods")));
    break;
  case ALT_setLightBarSirene:
    mp_field = field_setLightBarSirene->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setLightBarSirene")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void UtCamTrigger::set_implicit_omit()
{
switch (union_selection) {
case ALT_changeCurvature:
field_changeCurvature->set_implicit_omit(); break;
case ALT_changeSpeed:
field_changeSpeed->set_implicit_omit(); break;
case ALT_setAccelerationControlStatus:
field_setAccelerationControlStatus->set_implicit_omit(); break;
case ALT_setExteriorLightsStatus:
field_setExteriorLightsStatus->set_implicit_omit(); break;
case ALT_changeHeading:
field_changeHeading->set_implicit_omit(); break;
case ALT_setDriveDirection:
field_setDriveDirection->set_implicit_omit(); break;
case ALT_changeYawRate:
field_changeYawRate->set_implicit_omit(); break;
case ALT_setStationType:
field_setStationType->set_implicit_omit(); break;
case ALT_setVehicleRole:
field_setVehicleRole->set_implicit_omit(); break;
case ALT_setEmbarkationStatus:
field_setEmbarkationStatus->set_implicit_omit(); break;
case ALT_setPtActivation:
field_setPtActivation->set_implicit_omit(); break;
case ALT_setDangerousGoods:
field_setDangerousGoods->set_implicit_omit(); break;
case ALT_setLightBarSirene:
field_setLightBarSirene->set_implicit_omit(); break;
default: break;
}
}

void UtCamTrigger::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_changeCurvature:
field_changeCurvature->encode_text(text_buf);
break;
case ALT_changeSpeed:
field_changeSpeed->encode_text(text_buf);
break;
case ALT_setAccelerationControlStatus:
field_setAccelerationControlStatus->encode_text(text_buf);
break;
case ALT_setExteriorLightsStatus:
field_setExteriorLightsStatus->encode_text(text_buf);
break;
case ALT_changeHeading:
field_changeHeading->encode_text(text_buf);
break;
case ALT_setDriveDirection:
field_setDriveDirection->encode_text(text_buf);
break;
case ALT_changeYawRate:
field_changeYawRate->encode_text(text_buf);
break;
case ALT_setStationType:
field_setStationType->encode_text(text_buf);
break;
case ALT_setVehicleRole:
field_setVehicleRole->encode_text(text_buf);
break;
case ALT_setEmbarkationStatus:
field_setEmbarkationStatus->encode_text(text_buf);
break;
case ALT_setPtActivation:
field_setPtActivation->encode_text(text_buf);
break;
case ALT_setDangerousGoods:
field_setDangerousGoods->encode_text(text_buf);
break;
case ALT_setLightBarSirene:
field_setLightBarSirene->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
}

void UtCamTrigger::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_changeCurvature:
changeCurvature().decode_text(text_buf);
break;
case ALT_changeSpeed:
changeSpeed().decode_text(text_buf);
break;
case ALT_setAccelerationControlStatus:
setAccelerationControlStatus().decode_text(text_buf);
break;
case ALT_setExteriorLightsStatus:
setExteriorLightsStatus().decode_text(text_buf);
break;
case ALT_changeHeading:
changeHeading().decode_text(text_buf);
break;
case ALT_setDriveDirection:
setDriveDirection().decode_text(text_buf);
break;
case ALT_changeYawRate:
changeYawRate().decode_text(text_buf);
break;
case ALT_setStationType:
setStationType().decode_text(text_buf);
break;
case ALT_setVehicleRole:
setVehicleRole().decode_text(text_buf);
break;
case ALT_setEmbarkationStatus:
setEmbarkationStatus().decode_text(text_buf);
break;
case ALT_setPtActivation:
setPtActivation().decode_text(text_buf);
break;
case ALT_setDangerousGoods:
setDangerousGoods().decode_text(text_buf);
break;
case ALT_setLightBarSirene:
setLightBarSirene().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
}

void UtCamTrigger::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtCamTrigger::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtCamTrigger::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = changeCurvature().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = changeSpeed().RAW_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = setAccelerationControlStatus().RAW_decode(BITSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = setExteriorLightsStatus().RAW_decode(BITSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = changeHeading().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 5:
      decoded_length = setDriveDirection().RAW_decode(ITS__Container::DriveDirection_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 6:
      decoded_length = changeYawRate().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 7:
      decoded_length = setStationType().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 8:
      decoded_length = setVehicleRole().RAW_decode(ITS__Container::VehicleRole_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 9:
      decoded_length = setEmbarkationStatus().RAW_decode(BOOLEAN_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 10:
      decoded_length = setPtActivation().RAW_decode(ITS__Container::PtActivation_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 11:
      decoded_length = setDangerousGoods().RAW_decode(ITS__Container::DangerousGoodsBasic_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 12:
      decoded_length = setLightBarSirene().RAW_decode(BITSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = changeCurvature().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = changeSpeed().RAW_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setAccelerationControlStatus().RAW_decode(BITSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setExteriorLightsStatus().RAW_decode(BITSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = changeHeading().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setDriveDirection().RAW_decode(ITS__Container::DriveDirection_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = changeYawRate().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setStationType().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setVehicleRole().RAW_decode(ITS__Container::VehicleRole_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setEmbarkationStatus().RAW_decode(BOOLEAN_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setPtActivation().RAW_decode(ITS__Container::PtActivation_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setDangerousGoods().RAW_decode(ITS__Container::DangerousGoodsBasic_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setLightBarSirene().RAW_decode(BITSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int UtCamTrigger::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 13;  myleaf.body.node.nodes = init_nodes_of_enc_tree(13);
  memset(myleaf.body.node.nodes, 0, 13 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_changeCurvature:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, INTEGER_descr_.raw);
    encoded_length = field_changeCurvature->RAW_encode(INTEGER_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &INTEGER_descr_;
    break;
  case ALT_changeSpeed:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, LibCommon__BasicTypesAndValues::Int16_descr_.raw);
    encoded_length = field_changeSpeed->RAW_encode(LibCommon__BasicTypesAndValues::Int16_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &LibCommon__BasicTypesAndValues::Int16_descr_;
    break;
  case ALT_setAccelerationControlStatus:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, BITSTRING_descr_.raw);
    encoded_length = field_setAccelerationControlStatus->RAW_encode(BITSTRING_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &BITSTRING_descr_;
    break;
  case ALT_setExteriorLightsStatus:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, BITSTRING_descr_.raw);
    encoded_length = field_setExteriorLightsStatus->RAW_encode(BITSTRING_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &BITSTRING_descr_;
    break;
  case ALT_changeHeading:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, INTEGER_descr_.raw);
    encoded_length = field_changeHeading->RAW_encode(INTEGER_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &INTEGER_descr_;
    break;
  case ALT_setDriveDirection:
    myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 5, ITS__Container::DriveDirection_descr_.raw);
    encoded_length = field_setDriveDirection->RAW_encode(ITS__Container::DriveDirection_descr_, *myleaf.body.node.nodes[5]);
    myleaf.body.node.nodes[5]->coding_descr = &ITS__Container::DriveDirection_descr_;
    break;
  case ALT_changeYawRate:
    myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 6, INTEGER_descr_.raw);
    encoded_length = field_changeYawRate->RAW_encode(INTEGER_descr_, *myleaf.body.node.nodes[6]);
    myleaf.body.node.nodes[6]->coding_descr = &INTEGER_descr_;
    break;
  case ALT_setStationType:
    myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 7, INTEGER_descr_.raw);
    encoded_length = field_setStationType->RAW_encode(INTEGER_descr_, *myleaf.body.node.nodes[7]);
    myleaf.body.node.nodes[7]->coding_descr = &INTEGER_descr_;
    break;
  case ALT_setVehicleRole:
    myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 8, ITS__Container::VehicleRole_descr_.raw);
    encoded_length = field_setVehicleRole->RAW_encode(ITS__Container::VehicleRole_descr_, *myleaf.body.node.nodes[8]);
    myleaf.body.node.nodes[8]->coding_descr = &ITS__Container::VehicleRole_descr_;
    break;
  case ALT_setEmbarkationStatus:
    myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 9, BOOLEAN_descr_.raw);
    encoded_length = field_setEmbarkationStatus->RAW_encode(BOOLEAN_descr_, *myleaf.body.node.nodes[9]);
    myleaf.body.node.nodes[9]->coding_descr = &BOOLEAN_descr_;
    break;
  case ALT_setPtActivation:
    myleaf.body.node.nodes[10] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 10, ITS__Container::PtActivation_descr_.raw);
    encoded_length = field_setPtActivation->RAW_encode(ITS__Container::PtActivation_descr_, *myleaf.body.node.nodes[10]);
    myleaf.body.node.nodes[10]->coding_descr = &ITS__Container::PtActivation_descr_;
    break;
  case ALT_setDangerousGoods:
    myleaf.body.node.nodes[11] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 11, ITS__Container::DangerousGoodsBasic_descr_.raw);
    encoded_length = field_setDangerousGoods->RAW_encode(ITS__Container::DangerousGoodsBasic_descr_, *myleaf.body.node.nodes[11]);
    myleaf.body.node.nodes[11]->coding_descr = &ITS__Container::DangerousGoodsBasic_descr_;
    break;
  case ALT_setLightBarSirene:
    myleaf.body.node.nodes[12] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 12, BITSTRING_descr_.raw);
    encoded_length = field_setLightBarSirene->RAW_encode(BITSTRING_descr_, *myleaf.body.node.nodes[12]);
    myleaf.body.node.nodes[12]->coding_descr = &BITSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int UtCamTrigger::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_changeCurvature:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "changeCurvature");
    enc_len += field_changeCurvature->JSON_encode(INTEGER_descr_, p_tok);
    break;
  case ALT_changeSpeed:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "changeSpeed");
    enc_len += field_changeSpeed->JSON_encode(LibCommon__BasicTypesAndValues::Int16_descr_, p_tok);
    break;
  case ALT_setAccelerationControlStatus:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setAccelerationControlStatus");
    enc_len += field_setAccelerationControlStatus->JSON_encode(BITSTRING_descr_, p_tok);
    break;
  case ALT_setExteriorLightsStatus:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setExteriorLightsStatus");
    enc_len += field_setExteriorLightsStatus->JSON_encode(BITSTRING_descr_, p_tok);
    break;
  case ALT_changeHeading:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "changeHeading");
    enc_len += field_changeHeading->JSON_encode(INTEGER_descr_, p_tok);
    break;
  case ALT_setDriveDirection:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setDriveDirection");
    enc_len += field_setDriveDirection->JSON_encode(ITS__Container::DriveDirection_descr_, p_tok);
    break;
  case ALT_changeYawRate:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "changeYawRate");
    enc_len += field_changeYawRate->JSON_encode(INTEGER_descr_, p_tok);
    break;
  case ALT_setStationType:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setStationType");
    enc_len += field_setStationType->JSON_encode(INTEGER_descr_, p_tok);
    break;
  case ALT_setVehicleRole:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setVehicleRole");
    enc_len += field_setVehicleRole->JSON_encode(ITS__Container::VehicleRole_descr_, p_tok);
    break;
  case ALT_setEmbarkationStatus:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setEmbarkationStatus");
    enc_len += field_setEmbarkationStatus->JSON_encode(BOOLEAN_descr_, p_tok);
    break;
  case ALT_setPtActivation:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setPtActivation");
    enc_len += field_setPtActivation->JSON_encode(ITS__Container::PtActivation_descr_, p_tok);
    break;
  case ALT_setDangerousGoods:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setDangerousGoods");
    enc_len += field_setDangerousGoods->JSON_encode(ITS__Container::DangerousGoodsBasic_descr_, p_tok);
    break;
  case ALT_setLightBarSirene:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setLightBarSirene");
    enc_len += field_setLightBarSirene->JSON_encode(BITSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsCam_TypesAndValues.UtCamTrigger.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int UtCamTrigger::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "changeCurvature", name_len)) {
      int ret_val = changeCurvature().JSON_decode(INTEGER_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "changeCurvature");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "changeSpeed", name_len)) {
      int ret_val = changeSpeed().JSON_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "changeSpeed");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setAccelerationControlStatus", name_len)) {
      int ret_val = setAccelerationControlStatus().JSON_decode(BITSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setAccelerationControlStatus");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setExteriorLightsStatus", name_len)) {
      int ret_val = setExteriorLightsStatus().JSON_decode(BITSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setExteriorLightsStatus");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "changeHeading", name_len)) {
      int ret_val = changeHeading().JSON_decode(INTEGER_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "changeHeading");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setDriveDirection", name_len)) {
      int ret_val = setDriveDirection().JSON_decode(ITS__Container::DriveDirection_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setDriveDirection");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "changeYawRate", name_len)) {
      int ret_val = changeYawRate().JSON_decode(INTEGER_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "changeYawRate");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setStationType", name_len)) {
      int ret_val = setStationType().JSON_decode(INTEGER_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setStationType");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setVehicleRole", name_len)) {
      int ret_val = setVehicleRole().JSON_decode(ITS__Container::VehicleRole_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setVehicleRole");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setEmbarkationStatus", name_len)) {
      int ret_val = setEmbarkationStatus().JSON_decode(BOOLEAN_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setEmbarkationStatus");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setPtActivation", name_len)) {
      int ret_val = setPtActivation().JSON_decode(ITS__Container::PtActivation_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setPtActivation");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setDangerousGoods", name_len)) {
      int ret_val = setDangerousGoods().JSON_decode(ITS__Container::DangerousGoodsBasic_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setDangerousGoods");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setLightBarSirene", name_len)) {
      int ret_val = setLightBarSirene().JSON_decode(BITSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setLightBarSirene");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void UtCamTrigger_template::copy_value(const UtCamTrigger& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case UtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature = new INTEGER_template(other_value.changeCurvature());
break;
case UtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed = new INTEGER_template(other_value.changeSpeed());
break;
case UtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus = new BITSTRING_template(other_value.setAccelerationControlStatus());
break;
case UtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus = new BITSTRING_template(other_value.setExteriorLightsStatus());
break;
case UtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading = new INTEGER_template(other_value.changeHeading());
break;
case UtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection = new ITS__Container::DriveDirection_template(other_value.setDriveDirection());
break;
case UtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate = new INTEGER_template(other_value.changeYawRate());
break;
case UtCamTrigger::ALT_setStationType:
single_value.field_setStationType = new INTEGER_template(other_value.setStationType());
break;
case UtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole = new ITS__Container::VehicleRole_template(other_value.setVehicleRole());
break;
case UtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus = new BOOLEAN_template(other_value.setEmbarkationStatus());
break;
case UtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation = new ITS__Container::PtActivation_template(other_value.setPtActivation());
break;
case UtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods = new ITS__Container::DangerousGoodsBasic_template(other_value.setDangerousGoods());
break;
case UtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene = new BITSTRING_template(other_value.setLightBarSirene());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
set_selection(SPECIFIC_VALUE);
}

void UtCamTrigger_template::copy_template(const UtCamTrigger_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case UtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature = new INTEGER_template(*other_value.single_value.field_changeCurvature);
break;
case UtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed = new INTEGER_template(*other_value.single_value.field_changeSpeed);
break;
case UtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus = new BITSTRING_template(*other_value.single_value.field_setAccelerationControlStatus);
break;
case UtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus = new BITSTRING_template(*other_value.single_value.field_setExteriorLightsStatus);
break;
case UtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading = new INTEGER_template(*other_value.single_value.field_changeHeading);
break;
case UtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection = new ITS__Container::DriveDirection_template(*other_value.single_value.field_setDriveDirection);
break;
case UtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate = new INTEGER_template(*other_value.single_value.field_changeYawRate);
break;
case UtCamTrigger::ALT_setStationType:
single_value.field_setStationType = new INTEGER_template(*other_value.single_value.field_setStationType);
break;
case UtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole = new ITS__Container::VehicleRole_template(*other_value.single_value.field_setVehicleRole);
break;
case UtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus = new BOOLEAN_template(*other_value.single_value.field_setEmbarkationStatus);
break;
case UtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation = new ITS__Container::PtActivation_template(*other_value.single_value.field_setPtActivation);
break;
case UtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods = new ITS__Container::DangerousGoodsBasic_template(*other_value.single_value.field_setDangerousGoods);
break;
case UtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene = new BITSTRING_template(*other_value.single_value.field_setLightBarSirene);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtCamTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
set_selection(other_value);
}

UtCamTrigger_template::UtCamTrigger_template()
{
}

UtCamTrigger_template::UtCamTrigger_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UtCamTrigger_template::UtCamTrigger_template(const UtCamTrigger& other_value)
{
copy_value(other_value);
}

UtCamTrigger_template::UtCamTrigger_template(const OPTIONAL<UtCamTrigger>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtCamTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsCam_TypesAndValues.UtCamTrigger from an unbound optional field.");
}
}

UtCamTrigger_template::UtCamTrigger_template(const UtCamTrigger_template& other_value)
: Base_Template(){
copy_template(other_value);
}

UtCamTrigger_template::~UtCamTrigger_template()
{
clean_up();
}

void UtCamTrigger_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case UtCamTrigger::ALT_changeCurvature:
delete single_value.field_changeCurvature;
break;
case UtCamTrigger::ALT_changeSpeed:
delete single_value.field_changeSpeed;
break;
case UtCamTrigger::ALT_setAccelerationControlStatus:
delete single_value.field_setAccelerationControlStatus;
break;
case UtCamTrigger::ALT_setExteriorLightsStatus:
delete single_value.field_setExteriorLightsStatus;
break;
case UtCamTrigger::ALT_changeHeading:
delete single_value.field_changeHeading;
break;
case UtCamTrigger::ALT_setDriveDirection:
delete single_value.field_setDriveDirection;
break;
case UtCamTrigger::ALT_changeYawRate:
delete single_value.field_changeYawRate;
break;
case UtCamTrigger::ALT_setStationType:
delete single_value.field_setStationType;
break;
case UtCamTrigger::ALT_setVehicleRole:
delete single_value.field_setVehicleRole;
break;
case UtCamTrigger::ALT_setEmbarkationStatus:
delete single_value.field_setEmbarkationStatus;
break;
case UtCamTrigger::ALT_setPtActivation:
delete single_value.field_setPtActivation;
break;
case UtCamTrigger::ALT_setDangerousGoods:
delete single_value.field_setDangerousGoods;
break;
case UtCamTrigger::ALT_setLightBarSirene:
delete single_value.field_setLightBarSirene;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtCamTrigger_template& UtCamTrigger_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtCamTrigger_template& UtCamTrigger_template::operator=(const UtCamTrigger& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtCamTrigger_template& UtCamTrigger_template::operator=(const OPTIONAL<UtCamTrigger>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtCamTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
return *this;
}

UtCamTrigger_template& UtCamTrigger_template::operator=(const UtCamTrigger_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UtCamTrigger_template::match(const UtCamTrigger& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
UtCamTrigger::union_selection_type value_selection = other_value.get_selection();
if (value_selection == UtCamTrigger::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case UtCamTrigger::ALT_changeCurvature:
return single_value.field_changeCurvature->match(other_value.changeCurvature(), legacy);
case UtCamTrigger::ALT_changeSpeed:
return single_value.field_changeSpeed->match(other_value.changeSpeed(), legacy);
case UtCamTrigger::ALT_setAccelerationControlStatus:
return single_value.field_setAccelerationControlStatus->match(other_value.setAccelerationControlStatus(), legacy);
case UtCamTrigger::ALT_setExteriorLightsStatus:
return single_value.field_setExteriorLightsStatus->match(other_value.setExteriorLightsStatus(), legacy);
case UtCamTrigger::ALT_changeHeading:
return single_value.field_changeHeading->match(other_value.changeHeading(), legacy);
case UtCamTrigger::ALT_setDriveDirection:
return single_value.field_setDriveDirection->match(other_value.setDriveDirection(), legacy);
case UtCamTrigger::ALT_changeYawRate:
return single_value.field_changeYawRate->match(other_value.changeYawRate(), legacy);
case UtCamTrigger::ALT_setStationType:
return single_value.field_setStationType->match(other_value.setStationType(), legacy);
case UtCamTrigger::ALT_setVehicleRole:
return single_value.field_setVehicleRole->match(other_value.setVehicleRole(), legacy);
case UtCamTrigger::ALT_setEmbarkationStatus:
return single_value.field_setEmbarkationStatus->match(other_value.setEmbarkationStatus(), legacy);
case UtCamTrigger::ALT_setPtActivation:
return single_value.field_setPtActivation->match(other_value.setPtActivation(), legacy);
case UtCamTrigger::ALT_setDangerousGoods:
return single_value.field_setDangerousGoods->match(other_value.setDangerousGoods(), legacy);
case UtCamTrigger::ALT_setLightBarSirene:
return single_value.field_setLightBarSirene->match(other_value.setLightBarSirene(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
return FALSE;
}

boolean UtCamTrigger_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case UtCamTrigger::ALT_changeCurvature:
return single_value.field_changeCurvature->is_value();
case UtCamTrigger::ALT_changeSpeed:
return single_value.field_changeSpeed->is_value();
case UtCamTrigger::ALT_setAccelerationControlStatus:
return single_value.field_setAccelerationControlStatus->is_value();
case UtCamTrigger::ALT_setExteriorLightsStatus:
return single_value.field_setExteriorLightsStatus->is_value();
case UtCamTrigger::ALT_changeHeading:
return single_value.field_changeHeading->is_value();
case UtCamTrigger::ALT_setDriveDirection:
return single_value.field_setDriveDirection->is_value();
case UtCamTrigger::ALT_changeYawRate:
return single_value.field_changeYawRate->is_value();
case UtCamTrigger::ALT_setStationType:
return single_value.field_setStationType->is_value();
case UtCamTrigger::ALT_setVehicleRole:
return single_value.field_setVehicleRole->is_value();
case UtCamTrigger::ALT_setEmbarkationStatus:
return single_value.field_setEmbarkationStatus->is_value();
case UtCamTrigger::ALT_setPtActivation:
return single_value.field_setPtActivation->is_value();
case UtCamTrigger::ALT_setDangerousGoods:
return single_value.field_setDangerousGoods->is_value();
case UtCamTrigger::ALT_setLightBarSirene:
return single_value.field_setLightBarSirene->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
}

UtCamTrigger UtCamTrigger_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
UtCamTrigger ret_val;
switch (single_value.union_selection) {
case UtCamTrigger::ALT_changeCurvature:
ret_val.changeCurvature() = single_value.field_changeCurvature->valueof();
break;
case UtCamTrigger::ALT_changeSpeed:
ret_val.changeSpeed() = single_value.field_changeSpeed->valueof();
break;
case UtCamTrigger::ALT_setAccelerationControlStatus:
ret_val.setAccelerationControlStatus() = single_value.field_setAccelerationControlStatus->valueof();
break;
case UtCamTrigger::ALT_setExteriorLightsStatus:
ret_val.setExteriorLightsStatus() = single_value.field_setExteriorLightsStatus->valueof();
break;
case UtCamTrigger::ALT_changeHeading:
ret_val.changeHeading() = single_value.field_changeHeading->valueof();
break;
case UtCamTrigger::ALT_setDriveDirection:
ret_val.setDriveDirection() = single_value.field_setDriveDirection->valueof();
break;
case UtCamTrigger::ALT_changeYawRate:
ret_val.changeYawRate() = single_value.field_changeYawRate->valueof();
break;
case UtCamTrigger::ALT_setStationType:
ret_val.setStationType() = single_value.field_setStationType->valueof();
break;
case UtCamTrigger::ALT_setVehicleRole:
ret_val.setVehicleRole() = single_value.field_setVehicleRole->valueof();
break;
case UtCamTrigger::ALT_setEmbarkationStatus:
ret_val.setEmbarkationStatus() = single_value.field_setEmbarkationStatus->valueof();
break;
case UtCamTrigger::ALT_setPtActivation:
ret_val.setPtActivation() = single_value.field_setPtActivation->valueof();
break;
case UtCamTrigger::ALT_setDangerousGoods:
ret_val.setDangerousGoods() = single_value.field_setDangerousGoods->valueof();
break;
case UtCamTrigger::ALT_setLightBarSirene:
ret_val.setLightBarSirene() = single_value.field_setLightBarSirene->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
return ret_val;
}

UtCamTrigger_template& UtCamTrigger_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return value_list.list_value[list_index];
}
void UtCamTrigger_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UtCamTrigger_template[list_length];
}

INTEGER_template& UtCamTrigger_template::changeCurvature()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_changeCurvature) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_changeCurvature = new INTEGER_template(ANY_VALUE);
else single_value.field_changeCurvature = new INTEGER_template;
single_value.union_selection = UtCamTrigger::ALT_changeCurvature;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_changeCurvature;
}

const INTEGER_template& UtCamTrigger_template::changeCurvature() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field changeCurvature in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_changeCurvature) TTCN_error("Accessing non-selected field changeCurvature in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_changeCurvature;
}

INTEGER_template& UtCamTrigger_template::changeSpeed()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_changeSpeed) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_changeSpeed = new INTEGER_template(ANY_VALUE);
else single_value.field_changeSpeed = new INTEGER_template;
single_value.union_selection = UtCamTrigger::ALT_changeSpeed;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_changeSpeed;
}

const INTEGER_template& UtCamTrigger_template::changeSpeed() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field changeSpeed in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_changeSpeed) TTCN_error("Accessing non-selected field changeSpeed in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_changeSpeed;
}

BITSTRING_template& UtCamTrigger_template::setAccelerationControlStatus()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_setAccelerationControlStatus) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setAccelerationControlStatus = new BITSTRING_template(ANY_VALUE);
else single_value.field_setAccelerationControlStatus = new BITSTRING_template;
single_value.union_selection = UtCamTrigger::ALT_setAccelerationControlStatus;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setAccelerationControlStatus;
}

const BITSTRING_template& UtCamTrigger_template::setAccelerationControlStatus() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setAccelerationControlStatus in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_setAccelerationControlStatus) TTCN_error("Accessing non-selected field setAccelerationControlStatus in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_setAccelerationControlStatus;
}

BITSTRING_template& UtCamTrigger_template::setExteriorLightsStatus()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_setExteriorLightsStatus) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setExteriorLightsStatus = new BITSTRING_template(ANY_VALUE);
else single_value.field_setExteriorLightsStatus = new BITSTRING_template;
single_value.union_selection = UtCamTrigger::ALT_setExteriorLightsStatus;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setExteriorLightsStatus;
}

const BITSTRING_template& UtCamTrigger_template::setExteriorLightsStatus() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setExteriorLightsStatus in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_setExteriorLightsStatus) TTCN_error("Accessing non-selected field setExteriorLightsStatus in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_setExteriorLightsStatus;
}

INTEGER_template& UtCamTrigger_template::changeHeading()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_changeHeading) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_changeHeading = new INTEGER_template(ANY_VALUE);
else single_value.field_changeHeading = new INTEGER_template;
single_value.union_selection = UtCamTrigger::ALT_changeHeading;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_changeHeading;
}

const INTEGER_template& UtCamTrigger_template::changeHeading() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field changeHeading in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_changeHeading) TTCN_error("Accessing non-selected field changeHeading in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_changeHeading;
}

ITS__Container::DriveDirection_template& UtCamTrigger_template::setDriveDirection()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_setDriveDirection) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setDriveDirection = new ITS__Container::DriveDirection_template(ANY_VALUE);
else single_value.field_setDriveDirection = new ITS__Container::DriveDirection_template;
single_value.union_selection = UtCamTrigger::ALT_setDriveDirection;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setDriveDirection;
}

const ITS__Container::DriveDirection_template& UtCamTrigger_template::setDriveDirection() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setDriveDirection in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_setDriveDirection) TTCN_error("Accessing non-selected field setDriveDirection in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_setDriveDirection;
}

INTEGER_template& UtCamTrigger_template::changeYawRate()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_changeYawRate) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_changeYawRate = new INTEGER_template(ANY_VALUE);
else single_value.field_changeYawRate = new INTEGER_template;
single_value.union_selection = UtCamTrigger::ALT_changeYawRate;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_changeYawRate;
}

const INTEGER_template& UtCamTrigger_template::changeYawRate() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field changeYawRate in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_changeYawRate) TTCN_error("Accessing non-selected field changeYawRate in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_changeYawRate;
}

INTEGER_template& UtCamTrigger_template::setStationType()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_setStationType) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setStationType = new INTEGER_template(ANY_VALUE);
else single_value.field_setStationType = new INTEGER_template;
single_value.union_selection = UtCamTrigger::ALT_setStationType;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setStationType;
}

const INTEGER_template& UtCamTrigger_template::setStationType() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setStationType in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_setStationType) TTCN_error("Accessing non-selected field setStationType in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_setStationType;
}

ITS__Container::VehicleRole_template& UtCamTrigger_template::setVehicleRole()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_setVehicleRole) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setVehicleRole = new ITS__Container::VehicleRole_template(ANY_VALUE);
else single_value.field_setVehicleRole = new ITS__Container::VehicleRole_template;
single_value.union_selection = UtCamTrigger::ALT_setVehicleRole;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setVehicleRole;
}

const ITS__Container::VehicleRole_template& UtCamTrigger_template::setVehicleRole() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setVehicleRole in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_setVehicleRole) TTCN_error("Accessing non-selected field setVehicleRole in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_setVehicleRole;
}

BOOLEAN_template& UtCamTrigger_template::setEmbarkationStatus()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_setEmbarkationStatus) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setEmbarkationStatus = new BOOLEAN_template(ANY_VALUE);
else single_value.field_setEmbarkationStatus = new BOOLEAN_template;
single_value.union_selection = UtCamTrigger::ALT_setEmbarkationStatus;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setEmbarkationStatus;
}

const BOOLEAN_template& UtCamTrigger_template::setEmbarkationStatus() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setEmbarkationStatus in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_setEmbarkationStatus) TTCN_error("Accessing non-selected field setEmbarkationStatus in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_setEmbarkationStatus;
}

ITS__Container::PtActivation_template& UtCamTrigger_template::setPtActivation()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_setPtActivation) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setPtActivation = new ITS__Container::PtActivation_template(ANY_VALUE);
else single_value.field_setPtActivation = new ITS__Container::PtActivation_template;
single_value.union_selection = UtCamTrigger::ALT_setPtActivation;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setPtActivation;
}

const ITS__Container::PtActivation_template& UtCamTrigger_template::setPtActivation() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setPtActivation in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_setPtActivation) TTCN_error("Accessing non-selected field setPtActivation in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_setPtActivation;
}

ITS__Container::DangerousGoodsBasic_template& UtCamTrigger_template::setDangerousGoods()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_setDangerousGoods) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setDangerousGoods = new ITS__Container::DangerousGoodsBasic_template(ANY_VALUE);
else single_value.field_setDangerousGoods = new ITS__Container::DangerousGoodsBasic_template;
single_value.union_selection = UtCamTrigger::ALT_setDangerousGoods;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setDangerousGoods;
}

const ITS__Container::DangerousGoodsBasic_template& UtCamTrigger_template::setDangerousGoods() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setDangerousGoods in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_setDangerousGoods) TTCN_error("Accessing non-selected field setDangerousGoods in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_setDangerousGoods;
}

BITSTRING_template& UtCamTrigger_template::setLightBarSirene()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtCamTrigger::ALT_setLightBarSirene) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setLightBarSirene = new BITSTRING_template(ANY_VALUE);
else single_value.field_setLightBarSirene = new BITSTRING_template;
single_value.union_selection = UtCamTrigger::ALT_setLightBarSirene;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setLightBarSirene;
}

const BITSTRING_template& UtCamTrigger_template::setLightBarSirene() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setLightBarSirene in a non-specific template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
if (single_value.union_selection != UtCamTrigger::ALT_setLightBarSirene) TTCN_error("Accessing non-selected field setLightBarSirene in a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return *single_value.field_setLightBarSirene;
}

boolean UtCamTrigger_template::ischosen(UtCamTrigger::union_selection_type checked_selection) const
{
if (checked_selection == UtCamTrigger::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == UtCamTrigger::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsCam_TypesAndValues.UtCamTrigger containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsCam_TypesAndValues.UtCamTrigger, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsCam_TypesAndValues.UtCamTrigger");
}
return FALSE;
}

void UtCamTrigger_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case UtCamTrigger::ALT_changeCurvature:
TTCN_Logger::log_event_str("{ changeCurvature := ");
single_value.field_changeCurvature->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_changeSpeed:
TTCN_Logger::log_event_str("{ changeSpeed := ");
single_value.field_changeSpeed->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_setAccelerationControlStatus:
TTCN_Logger::log_event_str("{ setAccelerationControlStatus := ");
single_value.field_setAccelerationControlStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_setExteriorLightsStatus:
TTCN_Logger::log_event_str("{ setExteriorLightsStatus := ");
single_value.field_setExteriorLightsStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_changeHeading:
TTCN_Logger::log_event_str("{ changeHeading := ");
single_value.field_changeHeading->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_setDriveDirection:
TTCN_Logger::log_event_str("{ setDriveDirection := ");
single_value.field_setDriveDirection->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_changeYawRate:
TTCN_Logger::log_event_str("{ changeYawRate := ");
single_value.field_changeYawRate->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_setStationType:
TTCN_Logger::log_event_str("{ setStationType := ");
single_value.field_setStationType->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_setVehicleRole:
TTCN_Logger::log_event_str("{ setVehicleRole := ");
single_value.field_setVehicleRole->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_setEmbarkationStatus:
TTCN_Logger::log_event_str("{ setEmbarkationStatus := ");
single_value.field_setEmbarkationStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_setPtActivation:
TTCN_Logger::log_event_str("{ setPtActivation := ");
single_value.field_setPtActivation->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_setDangerousGoods:
TTCN_Logger::log_event_str("{ setDangerousGoods := ");
single_value.field_setDangerousGoods->log();
TTCN_Logger::log_event_str(" }");
break;
case UtCamTrigger::ALT_setLightBarSirene:
TTCN_Logger::log_event_str("{ setLightBarSirene := ");
single_value.field_setLightBarSirene->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UtCamTrigger_template::log_match(const UtCamTrigger& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case UtCamTrigger::ALT_changeCurvature:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".changeCurvature");
single_value.field_changeCurvature->log_match(match_value.changeCurvature(), legacy);
} else {
TTCN_Logger::log_event_str("{ changeCurvature := ");
single_value.field_changeCurvature->log_match(match_value.changeCurvature(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_changeSpeed:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".changeSpeed");
single_value.field_changeSpeed->log_match(match_value.changeSpeed(), legacy);
} else {
TTCN_Logger::log_event_str("{ changeSpeed := ");
single_value.field_changeSpeed->log_match(match_value.changeSpeed(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_setAccelerationControlStatus:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setAccelerationControlStatus");
single_value.field_setAccelerationControlStatus->log_match(match_value.setAccelerationControlStatus(), legacy);
} else {
TTCN_Logger::log_event_str("{ setAccelerationControlStatus := ");
single_value.field_setAccelerationControlStatus->log_match(match_value.setAccelerationControlStatus(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_setExteriorLightsStatus:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setExteriorLightsStatus");
single_value.field_setExteriorLightsStatus->log_match(match_value.setExteriorLightsStatus(), legacy);
} else {
TTCN_Logger::log_event_str("{ setExteriorLightsStatus := ");
single_value.field_setExteriorLightsStatus->log_match(match_value.setExteriorLightsStatus(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_changeHeading:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".changeHeading");
single_value.field_changeHeading->log_match(match_value.changeHeading(), legacy);
} else {
TTCN_Logger::log_event_str("{ changeHeading := ");
single_value.field_changeHeading->log_match(match_value.changeHeading(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_setDriveDirection:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setDriveDirection");
single_value.field_setDriveDirection->log_match(match_value.setDriveDirection(), legacy);
} else {
TTCN_Logger::log_event_str("{ setDriveDirection := ");
single_value.field_setDriveDirection->log_match(match_value.setDriveDirection(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_changeYawRate:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".changeYawRate");
single_value.field_changeYawRate->log_match(match_value.changeYawRate(), legacy);
} else {
TTCN_Logger::log_event_str("{ changeYawRate := ");
single_value.field_changeYawRate->log_match(match_value.changeYawRate(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_setStationType:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setStationType");
single_value.field_setStationType->log_match(match_value.setStationType(), legacy);
} else {
TTCN_Logger::log_event_str("{ setStationType := ");
single_value.field_setStationType->log_match(match_value.setStationType(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_setVehicleRole:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setVehicleRole");
single_value.field_setVehicleRole->log_match(match_value.setVehicleRole(), legacy);
} else {
TTCN_Logger::log_event_str("{ setVehicleRole := ");
single_value.field_setVehicleRole->log_match(match_value.setVehicleRole(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_setEmbarkationStatus:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setEmbarkationStatus");
single_value.field_setEmbarkationStatus->log_match(match_value.setEmbarkationStatus(), legacy);
} else {
TTCN_Logger::log_event_str("{ setEmbarkationStatus := ");
single_value.field_setEmbarkationStatus->log_match(match_value.setEmbarkationStatus(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_setPtActivation:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setPtActivation");
single_value.field_setPtActivation->log_match(match_value.setPtActivation(), legacy);
} else {
TTCN_Logger::log_event_str("{ setPtActivation := ");
single_value.field_setPtActivation->log_match(match_value.setPtActivation(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_setDangerousGoods:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setDangerousGoods");
single_value.field_setDangerousGoods->log_match(match_value.setDangerousGoods(), legacy);
} else {
TTCN_Logger::log_event_str("{ setDangerousGoods := ");
single_value.field_setDangerousGoods->log_match(match_value.setDangerousGoods(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtCamTrigger::ALT_setLightBarSirene:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setLightBarSirene");
single_value.field_setLightBarSirene->log_match(match_value.setLightBarSirene(), legacy);
} else {
TTCN_Logger::log_event_str("{ setLightBarSirene := ");
single_value.field_setLightBarSirene->log_match(match_value.setLightBarSirene(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtCamTrigger_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case UtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature->encode_text(text_buf);
break;
case UtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed->encode_text(text_buf);
break;
case UtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus->encode_text(text_buf);
break;
case UtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus->encode_text(text_buf);
break;
case UtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading->encode_text(text_buf);
break;
case UtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection->encode_text(text_buf);
break;
case UtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate->encode_text(text_buf);
break;
case UtCamTrigger::ALT_setStationType:
single_value.field_setStationType->encode_text(text_buf);
break;
case UtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole->encode_text(text_buf);
break;
case UtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus->encode_text(text_buf);
break;
case UtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation->encode_text(text_buf);
break;
case UtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods->encode_text(text_buf);
break;
case UtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
}

void UtCamTrigger_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = UtCamTrigger::UNBOUND_VALUE;
UtCamTrigger::union_selection_type new_selection = (UtCamTrigger::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case UtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature = new INTEGER_template;
single_value.field_changeCurvature->decode_text(text_buf);
break;
case UtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed = new INTEGER_template;
single_value.field_changeSpeed->decode_text(text_buf);
break;
case UtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus = new BITSTRING_template;
single_value.field_setAccelerationControlStatus->decode_text(text_buf);
break;
case UtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus = new BITSTRING_template;
single_value.field_setExteriorLightsStatus->decode_text(text_buf);
break;
case UtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading = new INTEGER_template;
single_value.field_changeHeading->decode_text(text_buf);
break;
case UtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection = new ITS__Container::DriveDirection_template;
single_value.field_setDriveDirection->decode_text(text_buf);
break;
case UtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate = new INTEGER_template;
single_value.field_changeYawRate->decode_text(text_buf);
break;
case UtCamTrigger::ALT_setStationType:
single_value.field_setStationType = new INTEGER_template;
single_value.field_setStationType->decode_text(text_buf);
break;
case UtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole = new ITS__Container::VehicleRole_template;
single_value.field_setVehicleRole->decode_text(text_buf);
break;
case UtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus = new BOOLEAN_template;
single_value.field_setEmbarkationStatus->decode_text(text_buf);
break;
case UtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation = new ITS__Container::PtActivation_template;
single_value.field_setPtActivation->decode_text(text_buf);
break;
case UtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods = new ITS__Container::DangerousGoodsBasic_template;
single_value.field_setDangerousGoods->decode_text(text_buf);
break;
case UtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene = new BITSTRING_template;
single_value.field_setLightBarSirene->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtCamTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
}

boolean UtCamTrigger_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtCamTrigger_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void UtCamTrigger_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsCam_TypesAndValues.UtCamTrigger'");
    }
    if (strcmp("changeCurvature", param_field) == 0) {
      changeCurvature().set_param(param);
      return;
    } else if (strcmp("changeSpeed", param_field) == 0) {
      changeSpeed().set_param(param);
      return;
    } else if (strcmp("setAccelerationControlStatus", param_field) == 0) {
      setAccelerationControlStatus().set_param(param);
      return;
    } else if (strcmp("setExteriorLightsStatus", param_field) == 0) {
      setExteriorLightsStatus().set_param(param);
      return;
    } else if (strcmp("changeHeading", param_field) == 0) {
      changeHeading().set_param(param);
      return;
    } else if (strcmp("setDriveDirection", param_field) == 0) {
      setDriveDirection().set_param(param);
      return;
    } else if (strcmp("changeYawRate", param_field) == 0) {
      changeYawRate().set_param(param);
      return;
    } else if (strcmp("setStationType", param_field) == 0) {
      setStationType().set_param(param);
      return;
    } else if (strcmp("setVehicleRole", param_field) == 0) {
      setVehicleRole().set_param(param);
      return;
    } else if (strcmp("setEmbarkationStatus", param_field) == 0) {
      setEmbarkationStatus().set_param(param);
      return;
    } else if (strcmp("setPtActivation", param_field) == 0) {
      setPtActivation().set_param(param);
      return;
    } else if (strcmp("setDangerousGoods", param_field) == 0) {
      setDangerousGoods().set_param(param);
      return;
    } else if (strcmp("setLightBarSirene", param_field) == 0) {
      setLightBarSirene().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsCam_TypesAndValues.UtCamTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtCamTrigger_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsCam_TypesAndValues.UtCamTrigger");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "changeCurvature")) {
      changeCurvature().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "changeSpeed")) {
      changeSpeed().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setAccelerationControlStatus")) {
      setAccelerationControlStatus().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setExteriorLightsStatus")) {
      setExteriorLightsStatus().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "changeHeading")) {
      changeHeading().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setDriveDirection")) {
      setDriveDirection().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "changeYawRate")) {
      changeYawRate().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setStationType")) {
      setStationType().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setVehicleRole")) {
      setVehicleRole().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setEmbarkationStatus")) {
      setEmbarkationStatus().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setPtActivation")) {
      setPtActivation().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setDangerousGoods")) {
      setDangerousGoods().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setLightBarSirene")) {
      setLightBarSirene().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsCam_TypesAndValues.UtCamTrigger.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsCam_TypesAndValues.UtCamTrigger");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* UtCamTrigger_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsCam_TypesAndValues.UtCamTrigger'");
    }
    if (strcmp("changeCurvature", param_field) == 0) {
      return changeCurvature().get_param(param_name);
    } else if (strcmp("changeSpeed", param_field) == 0) {
      return changeSpeed().get_param(param_name);
    } else if (strcmp("setAccelerationControlStatus", param_field) == 0) {
      return setAccelerationControlStatus().get_param(param_name);
    } else if (strcmp("setExteriorLightsStatus", param_field) == 0) {
      return setExteriorLightsStatus().get_param(param_name);
    } else if (strcmp("changeHeading", param_field) == 0) {
      return changeHeading().get_param(param_name);
    } else if (strcmp("setDriveDirection", param_field) == 0) {
      return setDriveDirection().get_param(param_name);
    } else if (strcmp("changeYawRate", param_field) == 0) {
      return changeYawRate().get_param(param_name);
    } else if (strcmp("setStationType", param_field) == 0) {
      return setStationType().get_param(param_name);
    } else if (strcmp("setVehicleRole", param_field) == 0) {
      return setVehicleRole().get_param(param_name);
    } else if (strcmp("setEmbarkationStatus", param_field) == 0) {
      return setEmbarkationStatus().get_param(param_name);
    } else if (strcmp("setPtActivation", param_field) == 0) {
      return setPtActivation().get_param(param_name);
    } else if (strcmp("setDangerousGoods", param_field) == 0) {
      return setDangerousGoods().get_param(param_name);
    } else if (strcmp("setLightBarSirene", param_field) == 0) {
      return setLightBarSirene().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `UtCamTrigger'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case UtCamTrigger::ALT_changeCurvature:
      mp_field = single_value.field_changeCurvature->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("changeCurvature")));
      break;
    case UtCamTrigger::ALT_changeSpeed:
      mp_field = single_value.field_changeSpeed->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("changeSpeed")));
      break;
    case UtCamTrigger::ALT_setAccelerationControlStatus:
      mp_field = single_value.field_setAccelerationControlStatus->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setAccelerationControlStatus")));
      break;
    case UtCamTrigger::ALT_setExteriorLightsStatus:
      mp_field = single_value.field_setExteriorLightsStatus->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setExteriorLightsStatus")));
      break;
    case UtCamTrigger::ALT_changeHeading:
      mp_field = single_value.field_changeHeading->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("changeHeading")));
      break;
    case UtCamTrigger::ALT_setDriveDirection:
      mp_field = single_value.field_setDriveDirection->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setDriveDirection")));
      break;
    case UtCamTrigger::ALT_changeYawRate:
      mp_field = single_value.field_changeYawRate->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("changeYawRate")));
      break;
    case UtCamTrigger::ALT_setStationType:
      mp_field = single_value.field_setStationType->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setStationType")));
      break;
    case UtCamTrigger::ALT_setVehicleRole:
      mp_field = single_value.field_setVehicleRole->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setVehicleRole")));
      break;
    case UtCamTrigger::ALT_setEmbarkationStatus:
      mp_field = single_value.field_setEmbarkationStatus->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setEmbarkationStatus")));
      break;
    case UtCamTrigger::ALT_setPtActivation:
      mp_field = single_value.field_setPtActivation->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setPtActivation")));
      break;
    case UtCamTrigger::ALT_setDangerousGoods:
      mp_field = single_value.field_setDangerousGoods->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setDangerousGoods")));
      break;
    case UtCamTrigger::ALT_setLightBarSirene:
      mp_field = single_value.field_setLightBarSirene->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setLightBarSirene")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void UtCamTrigger_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case UtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_setStationType:
single_value.field_setStationType->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
case UtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsCam_TypesAndValues.UtCamTrigger.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTrigger");
}

UtCamTriggerResult::UtCamTriggerResult()
{
  bound_flag = FALSE;
}

UtCamTriggerResult::UtCamTriggerResult(const BOOLEAN& par_utCamTriggerResult)
  :   field_utCamTriggerResult(par_utCamTriggerResult)
{
  bound_flag = TRUE;
}

UtCamTriggerResult::UtCamTriggerResult(const UtCamTriggerResult& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
bound_flag = TRUE;
if (other_value.utCamTriggerResult().is_bound()) field_utCamTriggerResult = other_value.utCamTriggerResult();
else field_utCamTriggerResult.clean_up();
}

void UtCamTriggerResult::clean_up()
{
field_utCamTriggerResult.clean_up();
bound_flag = FALSE;
}

UtCamTriggerResult& UtCamTriggerResult::operator=(const UtCamTriggerResult& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
  bound_flag = TRUE;
  if (other_value.utCamTriggerResult().is_bound()) field_utCamTriggerResult = other_value.utCamTriggerResult();
  else field_utCamTriggerResult.clean_up();
}
return *this;
}

boolean UtCamTriggerResult::operator==(const UtCamTriggerResult& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_utCamTriggerResult==other_value.field_utCamTriggerResult;
}

boolean UtCamTriggerResult::is_bound() const
{
if (bound_flag) return TRUE;
if(field_utCamTriggerResult.is_bound()) return TRUE;
return FALSE;
}
boolean UtCamTriggerResult::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_utCamTriggerResult.is_value()) return FALSE;
return TRUE;
}
int UtCamTriggerResult::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsCam_TypesAndValues.UtCamTriggerResult");
  return 1;
}

void UtCamTriggerResult::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ utCamTriggerResult := ");
field_utCamTriggerResult.log();
TTCN_Logger::log_event_str(" }");
}

void UtCamTriggerResult::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsCam_TypesAndValues.UtCamTriggerResult'");
    }
    if (strcmp("utCamTriggerResult", param_field) == 0) {
      utCamTriggerResult().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsCam_TypesAndValues.UtCamTriggerResult'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsCam_TypesAndValues.UtCamTriggerResult has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) utCamTriggerResult().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "utCamTriggerResult")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          utCamTriggerResult().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsCam_TypesAndValues.UtCamTriggerResult: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsCam_TypesAndValues.UtCamTriggerResult");
  }
}

Module_Param* UtCamTriggerResult::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsCam_TypesAndValues.UtCamTriggerResult'");
    }
    if (strcmp("utCamTriggerResult", param_field) == 0) {
      return utCamTriggerResult().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsCam_TypesAndValues.UtCamTriggerResult'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_utCamTriggerResult = field_utCamTriggerResult.get_param(param_name);
  mp_field_utCamTriggerResult->set_id(new Module_Param_FieldName(mcopystr("utCamTriggerResult")));
  mp->add_elem(mp_field_utCamTriggerResult);
  return mp;
  }

void UtCamTriggerResult::set_implicit_omit()
{
if (utCamTriggerResult().is_bound()) utCamTriggerResult().set_implicit_omit();
}

void UtCamTriggerResult::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
field_utCamTriggerResult.encode_text(text_buf);
}

void UtCamTriggerResult::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_utCamTriggerResult.decode_text(text_buf);
}

void UtCamTriggerResult::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtCamTriggerResult::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtCamTriggerResult::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_utCamTriggerResult.RAW_decode(UtCamTriggerResult_utCamTriggerResult_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int UtCamTriggerResult::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, UtCamTriggerResult_utCamTriggerResult_descr_.raw);
  encoded_length += field_utCamTriggerResult.RAW_encode(UtCamTriggerResult_utCamTriggerResult_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int UtCamTriggerResult::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "utCamTriggerResult");
    enc_len += field_utCamTriggerResult.JSON_encode(UtCamTriggerResult_utCamTriggerResult_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int UtCamTriggerResult::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "utCamTriggerResult", name_len)) {
         int ret_val = field_utCamTriggerResult.JSON_decode(UtCamTriggerResult_utCamTriggerResult_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "utCamTriggerResult");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_utCamTriggerResult.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "utCamTriggerResult");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct UtCamTriggerResult_template::single_value_struct {
BOOLEAN_template field_utCamTriggerResult;
};

void UtCamTriggerResult_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_utCamTriggerResult = ANY_VALUE;
}
}
}

void UtCamTriggerResult_template::copy_value(const UtCamTriggerResult& other_value)
{
single_value = new single_value_struct;
if (other_value.utCamTriggerResult().is_bound()) {
  single_value->field_utCamTriggerResult = other_value.utCamTriggerResult();
} else {
  single_value->field_utCamTriggerResult.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void UtCamTriggerResult_template::copy_template(const UtCamTriggerResult_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.utCamTriggerResult().get_selection()) {
single_value->field_utCamTriggerResult = other_value.utCamTriggerResult();
} else {
single_value->field_utCamTriggerResult.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtCamTriggerResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
break;
}
set_selection(other_value);
}

UtCamTriggerResult_template::UtCamTriggerResult_template()
{
}

UtCamTriggerResult_template::UtCamTriggerResult_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UtCamTriggerResult_template::UtCamTriggerResult_template(const UtCamTriggerResult& other_value)
{
copy_value(other_value);
}

UtCamTriggerResult_template::UtCamTriggerResult_template(const OPTIONAL<UtCamTriggerResult>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtCamTriggerResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult from an unbound optional field.");
}
}

UtCamTriggerResult_template::UtCamTriggerResult_template(const UtCamTriggerResult_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

UtCamTriggerResult_template::~UtCamTriggerResult_template()
{
clean_up();
}

UtCamTriggerResult_template& UtCamTriggerResult_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtCamTriggerResult_template& UtCamTriggerResult_template::operator=(const UtCamTriggerResult& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtCamTriggerResult_template& UtCamTriggerResult_template::operator=(const OPTIONAL<UtCamTriggerResult>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtCamTriggerResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
}
return *this;
}

UtCamTriggerResult_template& UtCamTriggerResult_template::operator=(const UtCamTriggerResult_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UtCamTriggerResult_template::match(const UtCamTriggerResult& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.utCamTriggerResult().is_bound()) return FALSE;
if(!single_value->field_utCamTriggerResult.match(other_value.utCamTriggerResult(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
}
return FALSE;
}

boolean UtCamTriggerResult_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_utCamTriggerResult.is_bound()) return TRUE;
return FALSE;
}

boolean UtCamTriggerResult_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_utCamTriggerResult.is_value()) return FALSE;
return TRUE;
}

void UtCamTriggerResult_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtCamTriggerResult UtCamTriggerResult_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
UtCamTriggerResult ret_val;
if (single_value->field_utCamTriggerResult.is_bound()) {
ret_val.utCamTriggerResult() = single_value->field_utCamTriggerResult.valueof();
}
return ret_val;
}

void UtCamTriggerResult_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UtCamTriggerResult_template[list_length];
}

UtCamTriggerResult_template& UtCamTriggerResult_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
return value_list.list_value[list_index];
}

BOOLEAN_template& UtCamTriggerResult_template::utCamTriggerResult()
{
set_specific();
return single_value->field_utCamTriggerResult;
}

const BOOLEAN_template& UtCamTriggerResult_template::utCamTriggerResult() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field utCamTriggerResult of a non-specific template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
return single_value->field_utCamTriggerResult;
}

int UtCamTriggerResult_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
  }
  return 0;
}

void UtCamTriggerResult_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ utCamTriggerResult := ");
single_value->field_utCamTriggerResult.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UtCamTriggerResult_template::log_match(const UtCamTriggerResult& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_utCamTriggerResult.match(match_value.utCamTriggerResult(), legacy)){
TTCN_Logger::log_logmatch_info(".utCamTriggerResult");
single_value->field_utCamTriggerResult.log_match(match_value.utCamTriggerResult(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ utCamTriggerResult := ");
single_value->field_utCamTriggerResult.log_match(match_value.utCamTriggerResult(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtCamTriggerResult_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_utCamTriggerResult.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
}
}

void UtCamTriggerResult_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_utCamTriggerResult.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtCamTriggerResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsCam_TypesAndValues.UtCamTriggerResult.");
}
}

void UtCamTriggerResult_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsCam_TypesAndValues.UtCamTriggerResult'");
    }
    if (strcmp("utCamTriggerResult", param_field) == 0) {
      utCamTriggerResult().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsCam_TypesAndValues.UtCamTriggerResult'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtCamTriggerResult_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsCam_TypesAndValues.UtCamTriggerResult has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) utCamTriggerResult().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "utCamTriggerResult")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          utCamTriggerResult().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsCam_TypesAndValues.UtCamTriggerResult: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsCam_TypesAndValues.UtCamTriggerResult");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* UtCamTriggerResult_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsCam_TypesAndValues.UtCamTriggerResult'");
    }
    if (strcmp("utCamTriggerResult", param_field) == 0) {
      return utCamTriggerResult().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsCam_TypesAndValues.UtCamTriggerResult'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_utCamTriggerResult = single_value->field_utCamTriggerResult.get_param(param_name);
    mp_field_utCamTriggerResult->set_id(new Module_Param_FieldName(mcopystr("utCamTriggerResult")));
    mp->add_elem(mp_field_utCamTriggerResult);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void UtCamTriggerResult_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_utCamTriggerResult.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTriggerResult");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamTriggerResult");
}

boolean UtCamTriggerResult_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtCamTriggerResult_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

UtCamEventInd::UtCamEventInd()
{
  bound_flag = FALSE;
}

UtCamEventInd::UtCamEventInd(const CAM__PDU__Descriptions::CAM& par_camMsg)
  :   field_camMsg(par_camMsg)
{
  bound_flag = TRUE;
}

UtCamEventInd::UtCamEventInd(const UtCamEventInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsCam_TypesAndValues.UtCamEventInd.");
bound_flag = TRUE;
if (other_value.camMsg().is_bound()) field_camMsg = other_value.camMsg();
else field_camMsg.clean_up();
}

void UtCamEventInd::clean_up()
{
field_camMsg.clean_up();
bound_flag = FALSE;
}

UtCamEventInd& UtCamEventInd::operator=(const UtCamEventInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsCam_TypesAndValues.UtCamEventInd.");
  bound_flag = TRUE;
  if (other_value.camMsg().is_bound()) field_camMsg = other_value.camMsg();
  else field_camMsg.clean_up();
}
return *this;
}

boolean UtCamEventInd::operator==(const UtCamEventInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_camMsg==other_value.field_camMsg;
}

boolean UtCamEventInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_camMsg.is_bound()) return TRUE;
return FALSE;
}
boolean UtCamEventInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_camMsg.is_value()) return FALSE;
return TRUE;
}
int UtCamEventInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsCam_TypesAndValues.UtCamEventInd");
  return 1;
}

void UtCamEventInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ camMsg := ");
field_camMsg.log();
TTCN_Logger::log_event_str(" }");
}

void UtCamEventInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsCam_TypesAndValues.UtCamEventInd'");
    }
    if (strcmp("camMsg", param_field) == 0) {
      camMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsCam_TypesAndValues.UtCamEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsCam_TypesAndValues.UtCamEventInd has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) camMsg().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "camMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          camMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsCam_TypesAndValues.UtCamEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsCam_TypesAndValues.UtCamEventInd");
  }
}

Module_Param* UtCamEventInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsCam_TypesAndValues.UtCamEventInd'");
    }
    if (strcmp("camMsg", param_field) == 0) {
      return camMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsCam_TypesAndValues.UtCamEventInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_camMsg = field_camMsg.get_param(param_name);
  mp_field_camMsg->set_id(new Module_Param_FieldName(mcopystr("camMsg")));
  mp->add_elem(mp_field_camMsg);
  return mp;
  }

void UtCamEventInd::set_implicit_omit()
{
if (camMsg().is_bound()) camMsg().set_implicit_omit();
}

void UtCamEventInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsCam_TypesAndValues.UtCamEventInd.");
field_camMsg.encode_text(text_buf);
}

void UtCamEventInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_camMsg.decode_text(text_buf);
}

void UtCamEventInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtCamEventInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtCamEventInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_camMsg.RAW_decode(CAM__PDU__Descriptions::CAM_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int UtCamEventInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CAM__PDU__Descriptions::CAM_descr_.raw);
  encoded_length += field_camMsg.RAW_encode(CAM__PDU__Descriptions::CAM_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int UtCamEventInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsCam_TypesAndValues.UtCamEventInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "camMsg");
    enc_len += field_camMsg.JSON_encode(CAM__PDU__Descriptions::CAM_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int UtCamEventInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "camMsg", name_len)) {
         int ret_val = field_camMsg.JSON_decode(CAM__PDU__Descriptions::CAM_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "camMsg");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_camMsg.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "camMsg");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct UtCamEventInd_template::single_value_struct {
CAM__PDU__Descriptions::CAM_template field_camMsg;
};

void UtCamEventInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_camMsg = ANY_VALUE;
}
}
}

void UtCamEventInd_template::copy_value(const UtCamEventInd& other_value)
{
single_value = new single_value_struct;
if (other_value.camMsg().is_bound()) {
  single_value->field_camMsg = other_value.camMsg();
} else {
  single_value->field_camMsg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void UtCamEventInd_template::copy_template(const UtCamEventInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.camMsg().get_selection()) {
single_value->field_camMsg = other_value.camMsg();
} else {
single_value->field_camMsg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtCamEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
break;
}
set_selection(other_value);
}

UtCamEventInd_template::UtCamEventInd_template()
{
}

UtCamEventInd_template::UtCamEventInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UtCamEventInd_template::UtCamEventInd_template(const UtCamEventInd& other_value)
{
copy_value(other_value);
}

UtCamEventInd_template::UtCamEventInd_template(const OPTIONAL<UtCamEventInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtCamEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsCam_TypesAndValues.UtCamEventInd from an unbound optional field.");
}
}

UtCamEventInd_template::UtCamEventInd_template(const UtCamEventInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

UtCamEventInd_template::~UtCamEventInd_template()
{
clean_up();
}

UtCamEventInd_template& UtCamEventInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtCamEventInd_template& UtCamEventInd_template::operator=(const UtCamEventInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtCamEventInd_template& UtCamEventInd_template::operator=(const OPTIONAL<UtCamEventInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtCamEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
}
return *this;
}

UtCamEventInd_template& UtCamEventInd_template::operator=(const UtCamEventInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UtCamEventInd_template::match(const UtCamEventInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.camMsg().is_bound()) return FALSE;
if(!single_value->field_camMsg.match(other_value.camMsg(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
}
return FALSE;
}

boolean UtCamEventInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_camMsg.is_bound()) return TRUE;
return FALSE;
}

boolean UtCamEventInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_camMsg.is_value()) return FALSE;
return TRUE;
}

void UtCamEventInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtCamEventInd UtCamEventInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
UtCamEventInd ret_val;
if (single_value->field_camMsg.is_bound()) {
ret_val.camMsg() = single_value->field_camMsg.valueof();
}
return ret_val;
}

void UtCamEventInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UtCamEventInd_template[list_length];
}

UtCamEventInd_template& UtCamEventInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
return value_list.list_value[list_index];
}

CAM__PDU__Descriptions::CAM_template& UtCamEventInd_template::camMsg()
{
set_specific();
return single_value->field_camMsg;
}

const CAM__PDU__Descriptions::CAM_template& UtCamEventInd_template::camMsg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field camMsg of a non-specific template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
return single_value->field_camMsg;
}

int UtCamEventInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
  }
  return 0;
}

void UtCamEventInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ camMsg := ");
single_value->field_camMsg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UtCamEventInd_template::log_match(const UtCamEventInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_camMsg.match(match_value.camMsg(), legacy)){
TTCN_Logger::log_logmatch_info(".camMsg");
single_value->field_camMsg.log_match(match_value.camMsg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ camMsg := ");
single_value->field_camMsg.log_match(match_value.camMsg(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtCamEventInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_camMsg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
}
}

void UtCamEventInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_camMsg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtCamEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsCam_TypesAndValues.UtCamEventInd.");
}
}

void UtCamEventInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsCam_TypesAndValues.UtCamEventInd'");
    }
    if (strcmp("camMsg", param_field) == 0) {
      camMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsCam_TypesAndValues.UtCamEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtCamEventInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsCam_TypesAndValues.UtCamEventInd has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) camMsg().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "camMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          camMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsCam_TypesAndValues.UtCamEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsCam_TypesAndValues.UtCamEventInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* UtCamEventInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsCam_TypesAndValues.UtCamEventInd'");
    }
    if (strcmp("camMsg", param_field) == 0) {
      return camMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsCam_TypesAndValues.UtCamEventInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_camMsg = single_value->field_camMsg.get_param(param_name);
    mp_field_camMsg->set_id(new Module_Param_FieldName(mcopystr("camMsg")));
    mp->add_elem(mp_field_camMsg);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void UtCamEventInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_camMsg.check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamEventInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamEventInd");
}

boolean UtCamEventInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtCamEventInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const UtCamEventInd UtCamEventIndList::UNBOUND_ELEM;
UtCamEventIndList::UtCamEventIndList()
{
val_ptr = NULL;
}

UtCamEventIndList::UtCamEventIndList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

UtCamEventIndList::UtCamEventIndList(const UtCamEventIndList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

UtCamEventIndList::~UtCamEventIndList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void UtCamEventIndList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

UtCamEventIndList& UtCamEventIndList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

UtCamEventIndList& UtCamEventIndList::operator=(const UtCamEventIndList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean UtCamEventIndList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
return val_ptr->n_elements == 0 ;
}

boolean UtCamEventIndList::operator==(const UtCamEventIndList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

UtCamEventInd& UtCamEventIndList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsCam_TypesAndValues.UtCamEventIndList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (UtCamEventInd**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new UtCamEventInd(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new UtCamEventInd;
}
return *val_ptr->value_elements[index_value];
}

UtCamEventInd& UtCamEventIndList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
return (*this)[(int)index_value];
}

const UtCamEventInd& UtCamEventIndList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsCam_TypesAndValues.UtCamEventIndList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsCam_TypesAndValues.UtCamEventIndList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const UtCamEventInd& UtCamEventIndList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
return (*this)[(int)index_value];
}

UtCamEventIndList UtCamEventIndList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

UtCamEventIndList UtCamEventIndList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

UtCamEventIndList UtCamEventIndList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

UtCamEventIndList UtCamEventIndList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
UtCamEventIndList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new UtCamEventInd(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

UtCamEventIndList UtCamEventIndList::operator+(const UtCamEventIndList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsCam_TypesAndValues.UtCamEventIndList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
UtCamEventIndList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new UtCamEventInd(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new UtCamEventInd(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

UtCamEventIndList UtCamEventIndList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsCam_TypesAndValues.UtCamEventIndList","element");
UtCamEventIndList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new UtCamEventInd(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

UtCamEventIndList UtCamEventIndList::replace(int index, int len, const UtCamEventIndList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsCam_TypesAndValues.UtCamEventIndList","element");
UtCamEventIndList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new UtCamEventInd(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new UtCamEventInd(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new UtCamEventInd(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

UtCamEventIndList UtCamEventIndList::replace(int index, int len, const UtCamEventIndList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void UtCamEventIndList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (UtCamEventInd**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new UtCamEventInd(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (UtCamEventInd**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsCam_TypesAndValues.UtCamEventIndList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (UtCamEventInd**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean UtCamEventIndList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int UtCamEventIndList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
return val_ptr->n_elements;
}

int UtCamEventIndList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void UtCamEventIndList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void UtCamEventIndList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@LibItsCam_TypesAndValues.UtCamEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@LibItsCam_TypesAndValues.UtCamEventIndList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@LibItsCam_TypesAndValues.UtCamEventIndList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* UtCamEventIndList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@LibItsCam_TypesAndValues.UtCamEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void UtCamEventIndList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void UtCamEventIndList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void UtCamEventIndList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
val_ptr->value_elements = (UtCamEventInd**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new UtCamEventInd;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void UtCamEventIndList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtCamEventIndList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtCamEventIndList::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int UtCamEventIndList::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void UtCamEventIndList_template::copy_value(const UtCamEventIndList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsCam_TypesAndValues.UtCamEventIndList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (UtCamEventInd_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new UtCamEventInd_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new UtCamEventInd_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void UtCamEventIndList_template::copy_template(const UtCamEventIndList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (UtCamEventInd_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new UtCamEventInd_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new UtCamEventInd_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtCamEventIndList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
break;
}
set_selection(other_value);
}

boolean UtCamEventIndList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const UtCamEventIndList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const UtCamEventIndList*)value_ptr)[value_index], legacy);
else return ((const UtCamEventIndList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

UtCamEventIndList_template::UtCamEventIndList_template()
{
}

UtCamEventIndList_template::UtCamEventIndList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

UtCamEventIndList_template::UtCamEventIndList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

UtCamEventIndList_template::UtCamEventIndList_template(const UtCamEventIndList& other_value)
{
copy_value(other_value);
}

UtCamEventIndList_template::UtCamEventIndList_template(const OPTIONAL<UtCamEventIndList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtCamEventIndList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsCam_TypesAndValues.UtCamEventIndList from an unbound optional field.");
}
}

UtCamEventIndList_template::UtCamEventIndList_template(const UtCamEventIndList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

UtCamEventIndList_template::~UtCamEventIndList_template()
{
clean_up();
}

void UtCamEventIndList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtCamEventIndList_template& UtCamEventIndList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtCamEventIndList_template& UtCamEventIndList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

UtCamEventIndList_template& UtCamEventIndList_template::operator=(const UtCamEventIndList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtCamEventIndList_template& UtCamEventIndList_template::operator=(const OPTIONAL<UtCamEventIndList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtCamEventIndList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
}
return *this;
}

UtCamEventIndList_template& UtCamEventIndList_template::operator=(const UtCamEventIndList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

UtCamEventInd_template& UtCamEventIndList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsCam_TypesAndValues.UtCamEventIndList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsCam_TypesAndValues.UtCamEventIndList.");
    break;
}
return *single_value.value_elements[index_value];
}

UtCamEventInd_template& UtCamEventIndList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
return (*this)[(int)index_value];
}

const UtCamEventInd_template& UtCamEventIndList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsCam_TypesAndValues.UtCamEventIndList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsCam_TypesAndValues.UtCamEventIndList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsCam_TypesAndValues.UtCamEventIndList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const UtCamEventInd_template& UtCamEventIndList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
return (*this)[(int)index_value];
}

void UtCamEventIndList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (UtCamEventInd_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new UtCamEventInd_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new UtCamEventInd_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (UtCamEventInd_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int UtCamEventIndList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int UtCamEventIndList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventIndList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventIndList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventIndList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventIndList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventIndList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsCam_TypesAndValues.UtCamEventIndList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamEventIndList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsCam_TypesAndValues.UtCamEventIndList");
}

boolean UtCamEventIndList_template::match(const UtCamEventIndList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
}
return FALSE;
}

boolean UtCamEventIndList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

UtCamEventIndList UtCamEventIndList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
UtCamEventIndList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

UtCamEventIndList UtCamEventIndList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

UtCamEventIndList UtCamEventIndList_template::replace(int index, int len, const UtCamEventIndList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

UtCamEventIndList UtCamEventIndList_template::replace(int index, int len, const UtCamEventIndList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void UtCamEventIndList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new UtCamEventIndList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
}
set_selection(template_type);
}

UtCamEventIndList_template& UtCamEventIndList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
return value_list.list_value[list_index];
}

void UtCamEventIndList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void UtCamEventIndList_template::log_match(const UtCamEventIndList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtCamEventIndList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
}
}

void UtCamEventIndList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
single_value.value_elements = (UtCamEventInd_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new UtCamEventInd_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtCamEventIndList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
}
}

boolean UtCamEventIndList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtCamEventIndList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void UtCamEventIndList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@LibItsCam_TypesAndValues.UtCamEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtCamEventIndList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@LibItsCam_TypesAndValues.UtCamEventIndList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* UtCamEventIndList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@LibItsCam_TypesAndValues.UtCamEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void UtCamEventIndList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamEventIndList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsCam_TypesAndValues.UtCamEventIndList");
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const UtCamEventIndList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsCam_TypesAndValues.UtCamEventIndList.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("LibItsCam_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsCam_TypesAndValues");
LibCommon__BasicTypesAndValues::module_object.pre_init_module();
LibCommon__DataStrings::module_object.pre_init_module();
CAM__PDU__Descriptions::module_object.pre_init_module();
DENM__PDU__Descriptions::module_object.pre_init_module();
current_location.update_lineno(24);
/* LibItsCam_TypesAndValues.ttcn, line 24 */
const_c__protocolVersionCam = 1;
current_location.update_lineno(25);
/* LibItsCam_TypesAndValues.ttcn, line 25 */
const_c__messageIdCam = 2;
current_location.update_lineno(27);
/* LibItsCam_TypesAndValues.ttcn, line 27 */
const_c__lowFrequencyGenerationTime = 5.0e-1;
current_location.update_lineno(28);
/* LibItsCam_TypesAndValues.ttcn, line 28 */
const_c__specialVehicleGenerationTime = 5.0e-1;
current_location.update_lineno(30);
/* LibItsCam_TypesAndValues.ttcn, line 30 */
const_c__accCtrlIdle = bs_0;
current_location.update_lineno(31);
/* LibItsCam_TypesAndValues.ttcn, line 31 */
const_c__brakePedalEngaged = bs_1;
current_location.update_lineno(32);
/* LibItsCam_TypesAndValues.ttcn, line 32 */
const_c__gasPedalEngaged = bs_2;
current_location.update_lineno(33);
/* LibItsCam_TypesAndValues.ttcn, line 33 */
const_c__emergencyBrakeEngaged = bs_3;
current_location.update_lineno(34);
/* LibItsCam_TypesAndValues.ttcn, line 34 */
const_c__collisionWarningEngaged = bs_4;
current_location.update_lineno(35);
/* LibItsCam_TypesAndValues.ttcn, line 35 */
const_c__accEngaged = bs_5;
current_location.update_lineno(36);
/* LibItsCam_TypesAndValues.ttcn, line 36 */
const_c__cruiseControlEngaged = bs_6;
current_location.update_lineno(37);
/* LibItsCam_TypesAndValues.ttcn, line 37 */
const_c__speedLimiterEngaged = bs_7;
current_location.update_lineno(39);
/* LibItsCam_TypesAndValues.ttcn, line 39 */
const_c__elAllLightsOff = bs_8;
current_location.update_lineno(40);
/* LibItsCam_TypesAndValues.ttcn, line 40 */
const_c__lowBeamHeadlightsOn = bs_9;
current_location.update_lineno(41);
/* LibItsCam_TypesAndValues.ttcn, line 41 */
const_c__highBeamHeadlightsOn = bs_10;
current_location.update_lineno(42);
/* LibItsCam_TypesAndValues.ttcn, line 42 */
const_c__leftTurnSignalOn = bs_11;
current_location.update_lineno(43);
/* LibItsCam_TypesAndValues.ttcn, line 43 */
const_c__rightTurnSignalOn = bs_12;
current_location.update_lineno(44);
/* LibItsCam_TypesAndValues.ttcn, line 44 */
const_c__daytimeRunningLightsOn = bs_13;
current_location.update_lineno(45);
/* LibItsCam_TypesAndValues.ttcn, line 45 */
const_c__reverseLightOn = bs_14;
current_location.update_lineno(46);
/* LibItsCam_TypesAndValues.ttcn, line 46 */
const_c__fogLightOn = bs_15;
current_location.update_lineno(47);
/* LibItsCam_TypesAndValues.ttcn, line 47 */
const_c__parkingLightsOn = bs_16;
current_location.update_lineno(49);
/* LibItsCam_TypesAndValues.ttcn, line 49 */
const_c__vehicleRole__publicTransport = ITS__Container::VehicleRole::publicTransport;
current_location.update_lineno(50);
/* LibItsCam_TypesAndValues.ttcn, line 50 */
const_c__vehicleRole__specialTransport = ITS__Container::VehicleRole::specialTransport;
current_location.update_lineno(51);
/* LibItsCam_TypesAndValues.ttcn, line 51 */
const_c__vehicleRole__dangerousGoods = ITS__Container::VehicleRole::dangerousGoods;
current_location.update_lineno(52);
/* LibItsCam_TypesAndValues.ttcn, line 52 */
const_c__vehicleRole__roadWork = ITS__Container::VehicleRole::roadWork;
current_location.update_lineno(53);
/* LibItsCam_TypesAndValues.ttcn, line 53 */
const_c__vehicleRole__rescue = ITS__Container::VehicleRole::rescue;
current_location.update_lineno(54);
/* LibItsCam_TypesAndValues.ttcn, line 54 */
const_c__vehicleRole__emergency = ITS__Container::VehicleRole::emergency;
current_location.update_lineno(55);
/* LibItsCam_TypesAndValues.ttcn, line 55 */
const_c__vehicleRole__safetyCar = ITS__Container::VehicleRole::safetyCar;
current_location.update_lineno(57);
/* LibItsCam_TypesAndValues.ttcn, line 57 */
const_c__dangerousGoodsBasic__explosives1 = ITS__Container::DangerousGoodsBasic::explosives1;
current_location.update_lineno(58);
/* LibItsCam_TypesAndValues.ttcn, line 58 */
const_c__dangerousGoodsBasic__explosives2 = ITS__Container::DangerousGoodsBasic::explosives2;
current_location.update_lineno(59);
/* LibItsCam_TypesAndValues.ttcn, line 59 */
const_c__dangerousGoodsBasic__explosives3 = ITS__Container::DangerousGoodsBasic::explosives3;
current_location.update_lineno(60);
/* LibItsCam_TypesAndValues.ttcn, line 60 */
const_c__dangerousGoodsBasic__explosives4 = ITS__Container::DangerousGoodsBasic::explosives4;
current_location.update_lineno(61);
/* LibItsCam_TypesAndValues.ttcn, line 61 */
const_c__dangerousGoodsBasic__explosives5 = ITS__Container::DangerousGoodsBasic::explosives5;
current_location.update_lineno(62);
/* LibItsCam_TypesAndValues.ttcn, line 62 */
const_c__dangerousGoodsBasic__explosives6 = ITS__Container::DangerousGoodsBasic::explosives6;
current_location.update_lineno(63);
/* LibItsCam_TypesAndValues.ttcn, line 63 */
const_c__dangerousGoodsBasic__flammableGases = ITS__Container::DangerousGoodsBasic::flammableGases;
current_location.update_lineno(64);
/* LibItsCam_TypesAndValues.ttcn, line 64 */
const_c__dangerousGoodsBasic__nonFlammableGases = ITS__Container::DangerousGoodsBasic::nonFlammableGases;
current_location.update_lineno(65);
/* LibItsCam_TypesAndValues.ttcn, line 65 */
const_c__dangerousGoodsBasic__toxicGases = ITS__Container::DangerousGoodsBasic::toxicGases;
current_location.update_lineno(66);
/* LibItsCam_TypesAndValues.ttcn, line 66 */
const_c__dangerousGoodsBasic__flammableLiquids = ITS__Container::DangerousGoodsBasic::flammableLiquids;
current_location.update_lineno(67);
/* LibItsCam_TypesAndValues.ttcn, line 67 */
const_c__dangerousGoodsBasic__flammableSolids = ITS__Container::DangerousGoodsBasic::flammableSolids;
current_location.update_lineno(68);
/* LibItsCam_TypesAndValues.ttcn, line 68 */
const_c__dangerousGoodsBasic__substancesLiableToSpontaneousCombustion = ITS__Container::DangerousGoodsBasic::substancesLiableToSpontaneousCombustion;
current_location.update_lineno(69);
/* LibItsCam_TypesAndValues.ttcn, line 69 */
const_c__dangerousGoodsBasic__substancesEmittingFlammableGasesUponContactWithWater = ITS__Container::DangerousGoodsBasic::substancesEmittingFlammableGasesUponContactWithWater;
current_location.update_lineno(70);
/* LibItsCam_TypesAndValues.ttcn, line 70 */
const_c__dangerousGoodsBasic__oxidizingSubstances = ITS__Container::DangerousGoodsBasic::oxidizingSubstances;
current_location.update_lineno(71);
/* LibItsCam_TypesAndValues.ttcn, line 71 */
const_c__dangerousGoodsBasic__organicPeroxides = ITS__Container::DangerousGoodsBasic::organicPeroxides;
current_location.update_lineno(72);
/* LibItsCam_TypesAndValues.ttcn, line 72 */
const_c__dangerousGoodsBasic__toxicSubstances = ITS__Container::DangerousGoodsBasic::toxicSubstances;
current_location.update_lineno(73);
/* LibItsCam_TypesAndValues.ttcn, line 73 */
const_c__dangerousGoodsBasic__infectiousSubstances = ITS__Container::DangerousGoodsBasic::infectiousSubstances;
current_location.update_lineno(74);
/* LibItsCam_TypesAndValues.ttcn, line 74 */
const_c__dangerousGoodsBasic__radioactiveMaterial = ITS__Container::DangerousGoodsBasic::radioactiveMaterial;
current_location.update_lineno(75);
/* LibItsCam_TypesAndValues.ttcn, line 75 */
const_c__dangerousGoodsBasic__corrosiveSubstances = ITS__Container::DangerousGoodsBasic::corrosiveSubstances;
current_location.update_lineno(76);
/* LibItsCam_TypesAndValues.ttcn, line 76 */
const_c__dangerousGoodsBasic__miscellaneousDangerousSubstances = ITS__Container::DangerousGoodsBasic::miscellaneousDangerousSubstances;
}

static void post_init_module()
{
TTCN_Location current_location("LibItsCam_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsCam_TypesAndValues");
LibCommon__BasicTypesAndValues::module_object.post_init_module();
LibCommon__DataStrings::module_object.post_init_module();
}


} /* end of namespace */
