// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef LibItsBtp__TypesAndValues_HH
#define LibItsBtp__TypesAndValues_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "LibCommon_BasicTypesAndValues.hh"
#include "CAM_PDU_Descriptions.hh"
#include "DENM_PDU_Descriptions.hh"
#include "MAP_SPAT_ETSI.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef LibItsBtp__TypesAndValues_HH
#endif

namespace LibItsBtp__TypesAndValues {

/* Forward declarations of classes */

class BtpHeader;
class BtpHeader_template;
class BtpAHeader;
class BtpAHeader_template;
class BtpBHeader;
class BtpBHeader_template;
class BtpPacket;
class BtpPacket_template;
class BtpPayload;
class BtpPayload_template;
class DecodedBtpPayload;
class DecodedBtpPayload_template;
class UtBtpTrigger;
class UtBtpTrigger_template;
class GenerateBtpA;
class GenerateBtpA_template;
class GenerateBtpB;
class GenerateBtpB_template;
class UtBtpTriggerResult;
class UtBtpTriggerResult_template;
class UtBtpEventInd;
class UtBtpEventInd_template;
class UtBtpEventIndList;
class UtBtpEventIndList_template;

} /* end of namespace */

#ifndef LibItsBtp__TypesAndValues_HH
#define LibItsBtp__TypesAndValues_HH

namespace LibItsBtp__TypesAndValues {

/* Type definitions */

typedef INTEGER BtpPortId;
typedef INTEGER_template BtpPortId_template;
typedef INTEGER BtpPortInfo;
typedef INTEGER_template BtpPortInfo_template;
typedef OCTETSTRING BtpRawPayload;
typedef OCTETSTRING_template BtpRawPayload_template;

/* Class definitions */

class BtpHeader : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_btpAHeader = 1, ALT_btpBHeader = 2 };
private:
union_selection_type union_selection;
union {
BtpAHeader *field_btpAHeader;
BtpBHeader *field_btpBHeader;
};
void copy_value(const BtpHeader& other_value);

public:
BtpHeader();
BtpHeader(const BtpHeader& other_value);
~BtpHeader();
BtpHeader& operator=(const BtpHeader& other_value);
boolean operator==(const BtpHeader& other_value) const;
inline boolean operator!=(const BtpHeader& other_value) const { return !(*this == other_value); }
BtpAHeader& btpAHeader();
const BtpAHeader& btpAHeader() const;
BtpBHeader& btpBHeader();
const BtpBHeader& btpBHeader() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BtpHeader_template : public Base_Template {
union {
struct {
BtpHeader::union_selection_type union_selection;
union {
BtpAHeader_template *field_btpAHeader;
BtpBHeader_template *field_btpBHeader;
};
} single_value;
struct {
unsigned int n_values;
BtpHeader_template *list_value;
} value_list;
};
void copy_value(const BtpHeader& other_value);

void copy_template(const BtpHeader_template& other_value);

public:
BtpHeader_template();
BtpHeader_template(template_sel other_value);
BtpHeader_template(const BtpHeader& other_value);
BtpHeader_template(const OPTIONAL<BtpHeader>& other_value);
BtpHeader_template(const BtpHeader_template& other_value);
~BtpHeader_template();
void clean_up();
BtpHeader_template& operator=(template_sel other_value);
BtpHeader_template& operator=(const BtpHeader& other_value);
BtpHeader_template& operator=(const OPTIONAL<BtpHeader>& other_value);
BtpHeader_template& operator=(const BtpHeader_template& other_value);
boolean match(const BtpHeader& other_value, boolean legacy = FALSE) const;
boolean is_value() const;BtpHeader valueof() const;
BtpHeader_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
BtpAHeader_template& btpAHeader();
const BtpAHeader_template& btpAHeader() const;
BtpBHeader_template& btpBHeader();
const BtpBHeader_template& btpBHeader() const;
boolean ischosen(BtpHeader::union_selection_type checked_selection) const;
void log() const;
void log_match(const BtpHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class BtpAHeader : public Base_Type {
  INTEGER field_destinationPort;
  INTEGER field_sourcePort;
  boolean bound_flag;
public:
  BtpAHeader();
  BtpAHeader(const INTEGER& par_destinationPort,
    const INTEGER& par_sourcePort);
  BtpAHeader(const BtpAHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BtpAHeader& operator=(const BtpAHeader& other_value);
  boolean operator==(const BtpAHeader& other_value) const;
  inline boolean operator!=(const BtpAHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& destinationPort()
    {return field_destinationPort;}
  inline const INTEGER& destinationPort() const
    {return field_destinationPort;}
  inline INTEGER& sourcePort()
    {return field_sourcePort;}
  inline const INTEGER& sourcePort() const
    {return field_sourcePort;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BtpAHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BtpAHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BtpAHeader& other_value);
void copy_template(const BtpAHeader_template& other_value);

public:
BtpAHeader_template();
BtpAHeader_template(template_sel other_value);
BtpAHeader_template(const BtpAHeader& other_value);
BtpAHeader_template(const OPTIONAL<BtpAHeader>& other_value);
BtpAHeader_template(const BtpAHeader_template& other_value);
~BtpAHeader_template();
BtpAHeader_template& operator=(template_sel other_value);
BtpAHeader_template& operator=(const BtpAHeader& other_value);
BtpAHeader_template& operator=(const OPTIONAL<BtpAHeader>& other_value);
BtpAHeader_template& operator=(const BtpAHeader_template& other_value);
boolean match(const BtpAHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BtpAHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BtpAHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& destinationPort();
const INTEGER_template& destinationPort() const;
INTEGER_template& sourcePort();
const INTEGER_template& sourcePort() const;
int size_of() const;
void log() const;
void log_match(const BtpAHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BtpBHeader : public Base_Type {
  INTEGER field_destinationPort;
  INTEGER field_destinationPortInfo;
  boolean bound_flag;
public:
  BtpBHeader();
  BtpBHeader(const INTEGER& par_destinationPort,
    const INTEGER& par_destinationPortInfo);
  BtpBHeader(const BtpBHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BtpBHeader& operator=(const BtpBHeader& other_value);
  boolean operator==(const BtpBHeader& other_value) const;
  inline boolean operator!=(const BtpBHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& destinationPort()
    {return field_destinationPort;}
  inline const INTEGER& destinationPort() const
    {return field_destinationPort;}
  inline INTEGER& destinationPortInfo()
    {return field_destinationPortInfo;}
  inline const INTEGER& destinationPortInfo() const
    {return field_destinationPortInfo;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BtpBHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BtpBHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BtpBHeader& other_value);
void copy_template(const BtpBHeader_template& other_value);

public:
BtpBHeader_template();
BtpBHeader_template(template_sel other_value);
BtpBHeader_template(const BtpBHeader& other_value);
BtpBHeader_template(const OPTIONAL<BtpBHeader>& other_value);
BtpBHeader_template(const BtpBHeader_template& other_value);
~BtpBHeader_template();
BtpBHeader_template& operator=(template_sel other_value);
BtpBHeader_template& operator=(const BtpBHeader& other_value);
BtpBHeader_template& operator=(const OPTIONAL<BtpBHeader>& other_value);
BtpBHeader_template& operator=(const BtpBHeader_template& other_value);
boolean match(const BtpBHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BtpBHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BtpBHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& destinationPort();
const INTEGER_template& destinationPort() const;
INTEGER_template& destinationPortInfo();
const INTEGER_template& destinationPortInfo() const;
int size_of() const;
void log() const;
void log_match(const BtpBHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BtpPacket : public Base_Type {
  BtpHeader field_header;
  OPTIONAL<BtpPayload> field_payload;
  boolean bound_flag;
public:
  BtpPacket();
  BtpPacket(const BtpHeader& par_header,
    const OPTIONAL<BtpPayload>& par_payload);
  BtpPacket(const BtpPacket& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BtpPacket& operator=(const BtpPacket& other_value);
  boolean operator==(const BtpPacket& other_value) const;
  inline boolean operator!=(const BtpPacket& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BtpHeader& header()
    {return field_header;}
  inline const BtpHeader& header() const
    {return field_header;}
  inline OPTIONAL<BtpPayload>& payload()
    {return field_payload;}
  inline const OPTIONAL<BtpPayload>& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BtpPacket_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BtpPacket_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BtpPacket& other_value);
void copy_template(const BtpPacket_template& other_value);

public:
BtpPacket_template();
BtpPacket_template(template_sel other_value);
BtpPacket_template(const BtpPacket& other_value);
BtpPacket_template(const OPTIONAL<BtpPacket>& other_value);
BtpPacket_template(const BtpPacket_template& other_value);
~BtpPacket_template();
BtpPacket_template& operator=(template_sel other_value);
BtpPacket_template& operator=(const BtpPacket& other_value);
BtpPacket_template& operator=(const OPTIONAL<BtpPacket>& other_value);
BtpPacket_template& operator=(const BtpPacket_template& other_value);
boolean match(const BtpPacket& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BtpPacket valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BtpPacket_template& list_item(unsigned int list_index) const;
BtpHeader_template& header();
const BtpHeader_template& header() const;
BtpPayload_template& payload();
const BtpPayload_template& payload() const;
int size_of() const;
void log() const;
void log_match(const BtpPacket& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BtpPayload : public Base_Type {
  OPTIONAL<DecodedBtpPayload> field_decodedPayload;
  OCTETSTRING field_rawPayload;
  boolean bound_flag;
public:
  BtpPayload();
  BtpPayload(const OPTIONAL<DecodedBtpPayload>& par_decodedPayload,
    const OCTETSTRING& par_rawPayload);
  BtpPayload(const BtpPayload& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BtpPayload& operator=(const BtpPayload& other_value);
  boolean operator==(const BtpPayload& other_value) const;
  inline boolean operator!=(const BtpPayload& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<DecodedBtpPayload>& decodedPayload()
    {return field_decodedPayload;}
  inline const OPTIONAL<DecodedBtpPayload>& decodedPayload() const
    {return field_decodedPayload;}
  inline OCTETSTRING& rawPayload()
    {return field_rawPayload;}
  inline const OCTETSTRING& rawPayload() const
    {return field_rawPayload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BtpPayload_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BtpPayload_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BtpPayload& other_value);
void copy_template(const BtpPayload_template& other_value);

public:
BtpPayload_template();
BtpPayload_template(template_sel other_value);
BtpPayload_template(const BtpPayload& other_value);
BtpPayload_template(const OPTIONAL<BtpPayload>& other_value);
BtpPayload_template(const BtpPayload_template& other_value);
~BtpPayload_template();
BtpPayload_template& operator=(template_sel other_value);
BtpPayload_template& operator=(const BtpPayload& other_value);
BtpPayload_template& operator=(const OPTIONAL<BtpPayload>& other_value);
BtpPayload_template& operator=(const BtpPayload_template& other_value);
boolean match(const BtpPayload& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BtpPayload valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BtpPayload_template& list_item(unsigned int list_index) const;
DecodedBtpPayload_template& decodedPayload();
const DecodedBtpPayload_template& decodedPayload() const;
OCTETSTRING_template& rawPayload();
const OCTETSTRING_template& rawPayload() const;
int size_of() const;
void log() const;
void log_match(const BtpPayload& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DecodedBtpPayload : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_camPacket = 1, ALT_denmPacket = 2, ALT_mapPacket = 3, ALT_spatPacket = 4 };
private:
union_selection_type union_selection;
union {
CAM__PDU__Descriptions::CAM *field_camPacket;
DENM__PDU__Descriptions::DENM *field_denmPacket;
MAP__SPAT__ETSI::MAP__PDU *field_mapPacket;
MAP__SPAT__ETSI::SPAT__PDU *field_spatPacket;
};
void copy_value(const DecodedBtpPayload& other_value);

public:
DecodedBtpPayload();
DecodedBtpPayload(const DecodedBtpPayload& other_value);
~DecodedBtpPayload();
DecodedBtpPayload& operator=(const DecodedBtpPayload& other_value);
boolean operator==(const DecodedBtpPayload& other_value) const;
inline boolean operator!=(const DecodedBtpPayload& other_value) const { return !(*this == other_value); }
CAM__PDU__Descriptions::CAM& camPacket();
const CAM__PDU__Descriptions::CAM& camPacket() const;
DENM__PDU__Descriptions::DENM& denmPacket();
const DENM__PDU__Descriptions::DENM& denmPacket() const;
MAP__SPAT__ETSI::MAP__PDU& mapPacket();
const MAP__SPAT__ETSI::MAP__PDU& mapPacket() const;
MAP__SPAT__ETSI::SPAT__PDU& spatPacket();
const MAP__SPAT__ETSI::SPAT__PDU& spatPacket() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DecodedBtpPayload_template : public Base_Template {
union {
struct {
DecodedBtpPayload::union_selection_type union_selection;
union {
CAM__PDU__Descriptions::CAM_template *field_camPacket;
DENM__PDU__Descriptions::DENM_template *field_denmPacket;
MAP__SPAT__ETSI::MAP__PDU_template *field_mapPacket;
MAP__SPAT__ETSI::SPAT__PDU_template *field_spatPacket;
};
} single_value;
struct {
unsigned int n_values;
DecodedBtpPayload_template *list_value;
} value_list;
};
void copy_value(const DecodedBtpPayload& other_value);

void copy_template(const DecodedBtpPayload_template& other_value);

public:
DecodedBtpPayload_template();
DecodedBtpPayload_template(template_sel other_value);
DecodedBtpPayload_template(const DecodedBtpPayload& other_value);
DecodedBtpPayload_template(const OPTIONAL<DecodedBtpPayload>& other_value);
DecodedBtpPayload_template(const DecodedBtpPayload_template& other_value);
~DecodedBtpPayload_template();
void clean_up();
DecodedBtpPayload_template& operator=(template_sel other_value);
DecodedBtpPayload_template& operator=(const DecodedBtpPayload& other_value);
DecodedBtpPayload_template& operator=(const OPTIONAL<DecodedBtpPayload>& other_value);
DecodedBtpPayload_template& operator=(const DecodedBtpPayload_template& other_value);
boolean match(const DecodedBtpPayload& other_value, boolean legacy = FALSE) const;
boolean is_value() const;DecodedBtpPayload valueof() const;
DecodedBtpPayload_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
CAM__PDU__Descriptions::CAM_template& camPacket();
const CAM__PDU__Descriptions::CAM_template& camPacket() const;
DENM__PDU__Descriptions::DENM_template& denmPacket();
const DENM__PDU__Descriptions::DENM_template& denmPacket() const;
MAP__SPAT__ETSI::MAP__PDU_template& mapPacket();
const MAP__SPAT__ETSI::MAP__PDU_template& mapPacket() const;
MAP__SPAT__ETSI::SPAT__PDU_template& spatPacket();
const MAP__SPAT__ETSI::SPAT__PDU_template& spatPacket() const;
boolean ischosen(DecodedBtpPayload::union_selection_type checked_selection) const;
void log() const;
void log_match(const DecodedBtpPayload& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class UtBtpTrigger : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_btpA = 1, ALT_btpB = 2 };
private:
union_selection_type union_selection;
union {
GenerateBtpA *field_btpA;
GenerateBtpB *field_btpB;
};
void copy_value(const UtBtpTrigger& other_value);

public:
UtBtpTrigger();
UtBtpTrigger(const UtBtpTrigger& other_value);
~UtBtpTrigger();
UtBtpTrigger& operator=(const UtBtpTrigger& other_value);
boolean operator==(const UtBtpTrigger& other_value) const;
inline boolean operator!=(const UtBtpTrigger& other_value) const { return !(*this == other_value); }
GenerateBtpA& btpA();
const GenerateBtpA& btpA() const;
GenerateBtpB& btpB();
const GenerateBtpB& btpB() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtBtpTrigger_template : public Base_Template {
union {
struct {
UtBtpTrigger::union_selection_type union_selection;
union {
GenerateBtpA_template *field_btpA;
GenerateBtpB_template *field_btpB;
};
} single_value;
struct {
unsigned int n_values;
UtBtpTrigger_template *list_value;
} value_list;
};
void copy_value(const UtBtpTrigger& other_value);

void copy_template(const UtBtpTrigger_template& other_value);

public:
UtBtpTrigger_template();
UtBtpTrigger_template(template_sel other_value);
UtBtpTrigger_template(const UtBtpTrigger& other_value);
UtBtpTrigger_template(const OPTIONAL<UtBtpTrigger>& other_value);
UtBtpTrigger_template(const UtBtpTrigger_template& other_value);
~UtBtpTrigger_template();
void clean_up();
UtBtpTrigger_template& operator=(template_sel other_value);
UtBtpTrigger_template& operator=(const UtBtpTrigger& other_value);
UtBtpTrigger_template& operator=(const OPTIONAL<UtBtpTrigger>& other_value);
UtBtpTrigger_template& operator=(const UtBtpTrigger_template& other_value);
boolean match(const UtBtpTrigger& other_value, boolean legacy = FALSE) const;
boolean is_value() const;UtBtpTrigger valueof() const;
UtBtpTrigger_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
GenerateBtpA_template& btpA();
const GenerateBtpA_template& btpA() const;
GenerateBtpB_template& btpB();
const GenerateBtpB_template& btpB() const;
boolean ischosen(UtBtpTrigger::union_selection_type checked_selection) const;
void log() const;
void log_match(const UtBtpTrigger& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GenerateBtpA : public Base_Type {
  BtpAHeader field_btpAHeader;
  boolean bound_flag;
public:
  GenerateBtpA();
  GenerateBtpA(const BtpAHeader& par_btpAHeader);
  GenerateBtpA(const GenerateBtpA& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GenerateBtpA& operator=(const GenerateBtpA& other_value);
  boolean operator==(const GenerateBtpA& other_value) const;
  inline boolean operator!=(const GenerateBtpA& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BtpAHeader& btpAHeader()
    {return field_btpAHeader;}
  inline const BtpAHeader& btpAHeader() const
    {return field_btpAHeader;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GenerateBtpA_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GenerateBtpA_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GenerateBtpA& other_value);
void copy_template(const GenerateBtpA_template& other_value);

public:
GenerateBtpA_template();
GenerateBtpA_template(template_sel other_value);
GenerateBtpA_template(const GenerateBtpA& other_value);
GenerateBtpA_template(const OPTIONAL<GenerateBtpA>& other_value);
GenerateBtpA_template(const GenerateBtpA_template& other_value);
~GenerateBtpA_template();
GenerateBtpA_template& operator=(template_sel other_value);
GenerateBtpA_template& operator=(const GenerateBtpA& other_value);
GenerateBtpA_template& operator=(const OPTIONAL<GenerateBtpA>& other_value);
GenerateBtpA_template& operator=(const GenerateBtpA_template& other_value);
boolean match(const GenerateBtpA& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GenerateBtpA valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GenerateBtpA_template& list_item(unsigned int list_index) const;
BtpAHeader_template& btpAHeader();
const BtpAHeader_template& btpAHeader() const;
int size_of() const;
void log() const;
void log_match(const GenerateBtpA& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GenerateBtpB : public Base_Type {
  BtpBHeader field_btpBHeader;
  boolean bound_flag;
public:
  GenerateBtpB();
  GenerateBtpB(const BtpBHeader& par_btpBHeader);
  GenerateBtpB(const GenerateBtpB& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GenerateBtpB& operator=(const GenerateBtpB& other_value);
  boolean operator==(const GenerateBtpB& other_value) const;
  inline boolean operator!=(const GenerateBtpB& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BtpBHeader& btpBHeader()
    {return field_btpBHeader;}
  inline const BtpBHeader& btpBHeader() const
    {return field_btpBHeader;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GenerateBtpB_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GenerateBtpB_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GenerateBtpB& other_value);
void copy_template(const GenerateBtpB_template& other_value);

public:
GenerateBtpB_template();
GenerateBtpB_template(template_sel other_value);
GenerateBtpB_template(const GenerateBtpB& other_value);
GenerateBtpB_template(const OPTIONAL<GenerateBtpB>& other_value);
GenerateBtpB_template(const GenerateBtpB_template& other_value);
~GenerateBtpB_template();
GenerateBtpB_template& operator=(template_sel other_value);
GenerateBtpB_template& operator=(const GenerateBtpB& other_value);
GenerateBtpB_template& operator=(const OPTIONAL<GenerateBtpB>& other_value);
GenerateBtpB_template& operator=(const GenerateBtpB_template& other_value);
boolean match(const GenerateBtpB& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GenerateBtpB valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GenerateBtpB_template& list_item(unsigned int list_index) const;
BtpBHeader_template& btpBHeader();
const BtpBHeader_template& btpBHeader() const;
int size_of() const;
void log() const;
void log_match(const GenerateBtpB& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtBtpTriggerResult : public Base_Type {
  BOOLEAN field_utBtpTriggerResult;
  boolean bound_flag;
public:
  UtBtpTriggerResult();
  UtBtpTriggerResult(const BOOLEAN& par_utBtpTriggerResult);
  UtBtpTriggerResult(const UtBtpTriggerResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtBtpTriggerResult& operator=(const UtBtpTriggerResult& other_value);
  boolean operator==(const UtBtpTriggerResult& other_value) const;
  inline boolean operator!=(const UtBtpTriggerResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& utBtpTriggerResult()
    {return field_utBtpTriggerResult;}
  inline const BOOLEAN& utBtpTriggerResult() const
    {return field_utBtpTriggerResult;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtBtpTriggerResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtBtpTriggerResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtBtpTriggerResult& other_value);
void copy_template(const UtBtpTriggerResult_template& other_value);

public:
UtBtpTriggerResult_template();
UtBtpTriggerResult_template(template_sel other_value);
UtBtpTriggerResult_template(const UtBtpTriggerResult& other_value);
UtBtpTriggerResult_template(const OPTIONAL<UtBtpTriggerResult>& other_value);
UtBtpTriggerResult_template(const UtBtpTriggerResult_template& other_value);
~UtBtpTriggerResult_template();
UtBtpTriggerResult_template& operator=(template_sel other_value);
UtBtpTriggerResult_template& operator=(const UtBtpTriggerResult& other_value);
UtBtpTriggerResult_template& operator=(const OPTIONAL<UtBtpTriggerResult>& other_value);
UtBtpTriggerResult_template& operator=(const UtBtpTriggerResult_template& other_value);
boolean match(const UtBtpTriggerResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtBtpTriggerResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtBtpTriggerResult_template& list_item(unsigned int list_index) const;
BOOLEAN_template& utBtpTriggerResult();
const BOOLEAN_template& utBtpTriggerResult() const;
int size_of() const;
void log() const;
void log_match(const UtBtpTriggerResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtBtpEventInd : public Base_Type {
  OCTETSTRING field_rawPayload;
  boolean bound_flag;
public:
  UtBtpEventInd();
  UtBtpEventInd(const OCTETSTRING& par_rawPayload);
  UtBtpEventInd(const UtBtpEventInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtBtpEventInd& operator=(const UtBtpEventInd& other_value);
  boolean operator==(const UtBtpEventInd& other_value) const;
  inline boolean operator!=(const UtBtpEventInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& rawPayload()
    {return field_rawPayload;}
  inline const OCTETSTRING& rawPayload() const
    {return field_rawPayload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtBtpEventInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtBtpEventInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtBtpEventInd& other_value);
void copy_template(const UtBtpEventInd_template& other_value);

public:
UtBtpEventInd_template();
UtBtpEventInd_template(template_sel other_value);
UtBtpEventInd_template(const UtBtpEventInd& other_value);
UtBtpEventInd_template(const OPTIONAL<UtBtpEventInd>& other_value);
UtBtpEventInd_template(const UtBtpEventInd_template& other_value);
~UtBtpEventInd_template();
UtBtpEventInd_template& operator=(template_sel other_value);
UtBtpEventInd_template& operator=(const UtBtpEventInd& other_value);
UtBtpEventInd_template& operator=(const OPTIONAL<UtBtpEventInd>& other_value);
UtBtpEventInd_template& operator=(const UtBtpEventInd_template& other_value);
boolean match(const UtBtpEventInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtBtpEventInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtBtpEventInd_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& rawPayload();
const OCTETSTRING_template& rawPayload() const;
int size_of() const;
void log() const;
void log_match(const UtBtpEventInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtBtpEventIndList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UtBtpEventInd **value_elements;
} *val_ptr;

static const UtBtpEventInd UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const UtBtpEventIndList& other_value);

public:
  typedef UtBtpEventInd of_type;
UtBtpEventIndList();
UtBtpEventIndList(null_type other_value);
UtBtpEventIndList(const UtBtpEventIndList& other_value);
~UtBtpEventIndList();

void clean_up();
UtBtpEventIndList& operator=(null_type other_value);
UtBtpEventIndList& operator=(const UtBtpEventIndList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const UtBtpEventIndList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UtBtpEventIndList& other_value) const { return !(*this == other_value); }

UtBtpEventInd& operator[](int index_value);
UtBtpEventInd& operator[](const INTEGER& index_value);
const UtBtpEventInd& operator[](int index_value) const;
const UtBtpEventInd& operator[](const INTEGER& index_value) const;

UtBtpEventIndList operator<<=(int rotate_count) const;
UtBtpEventIndList operator<<=(const INTEGER& rotate_count) const;
UtBtpEventIndList operator>>=(int rotate_count) const;
UtBtpEventIndList operator>>=(const INTEGER& rotate_count) const;

UtBtpEventIndList operator+(const UtBtpEventIndList& other_value) const;

UtBtpEventIndList substr(int index, int returncount) const;

UtBtpEventIndList replace(int index, int len, const UtBtpEventIndList& repl) const;

UtBtpEventIndList replace(int index, int len, const UtBtpEventIndList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UtBtpEventIndList_template : public Record_Of_Template {
union {
struct {
int n_elements;
UtBtpEventInd_template **value_elements;
} single_value;
struct {
unsigned int n_values;
UtBtpEventIndList_template *list_value;
} value_list;
};
void copy_value(const UtBtpEventIndList& other_value);
void copy_template(const UtBtpEventIndList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
UtBtpEventIndList_template();
UtBtpEventIndList_template(template_sel other_value);
UtBtpEventIndList_template(null_type other_value);
UtBtpEventIndList_template(const UtBtpEventIndList& other_value);
UtBtpEventIndList_template(const OPTIONAL<UtBtpEventIndList>& other_value);
UtBtpEventIndList_template(const UtBtpEventIndList_template& other_value);
~UtBtpEventIndList_template();

void clean_up();
UtBtpEventIndList_template& operator=(template_sel other_value);
UtBtpEventIndList_template& operator=(null_type other_value);
UtBtpEventIndList_template& operator=(const UtBtpEventIndList& other_value);
UtBtpEventIndList_template& operator=(const OPTIONAL<UtBtpEventIndList>& other_value);
UtBtpEventIndList_template& operator=(const UtBtpEventIndList_template& other_value);

UtBtpEventInd_template& operator[](int index_value);
UtBtpEventInd_template& operator[](const INTEGER& index_value);
const UtBtpEventInd_template& operator[](int index_value) const;
const UtBtpEventInd_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const UtBtpEventIndList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
UtBtpEventIndList valueof() const;
UtBtpEventIndList substr(int index, int returncount) const;

UtBtpEventIndList replace(int index, int len, const UtBtpEventIndList_template& repl) const;

UtBtpEventIndList replace(int index, int len, const UtBtpEventIndList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
UtBtpEventIndList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const UtBtpEventIndList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const UtBtpEventIndList& other_value);
inline boolean operator!=(null_type null_value, const UtBtpEventIndList& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_RAWdescriptor_t BtpHeader_raw_;
extern const TTCN_JSONdescriptor_t BtpHeader_json_;
extern const TTCN_Typedescriptor_t BtpHeader_descr_;
extern const TTCN_RAWdescriptor_t BtpPortId_raw_;
extern const XERdescriptor_t BtpPortId_xer_;
extern const TTCN_Typedescriptor_t BtpPortId_descr_;
extern const XERdescriptor_t BtpAHeader_destinationPort_xer_;
extern const TTCN_Typedescriptor_t BtpAHeader_destinationPort_descr_;
extern const XERdescriptor_t BtpAHeader_sourcePort_xer_;
extern const TTCN_Typedescriptor_t BtpAHeader_sourcePort_descr_;
extern const TTCN_RAWdescriptor_t BtpAHeader_raw_;
extern const TTCN_JSONdescriptor_t BtpAHeader_json_;
extern const TTCN_Typedescriptor_t BtpAHeader_descr_;
extern const XERdescriptor_t BtpBHeader_destinationPort_xer_;
extern const TTCN_Typedescriptor_t BtpBHeader_destinationPort_descr_;
extern const TTCN_RAWdescriptor_t BtpPortInfo_raw_;
extern const XERdescriptor_t BtpPortInfo_xer_;
extern const TTCN_Typedescriptor_t BtpPortInfo_descr_;
extern const XERdescriptor_t BtpBHeader_destinationPortInfo_xer_;
extern const TTCN_Typedescriptor_t BtpBHeader_destinationPortInfo_descr_;
extern const TTCN_RAWdescriptor_t BtpBHeader_raw_;
extern const TTCN_JSONdescriptor_t BtpBHeader_json_;
extern const TTCN_Typedescriptor_t BtpBHeader_descr_;
extern const TTCN_RAWdescriptor_t BtpPacket_raw_;
extern const TTCN_JSONdescriptor_t BtpPacket_json_;
extern const TTCN_Typedescriptor_t BtpPacket_descr_;
extern const TTCN_RAWdescriptor_t BtpRawPayload_raw_;
extern const XERdescriptor_t BtpRawPayload_xer_;
extern const TTCN_Typedescriptor_t BtpRawPayload_descr_;
extern const XERdescriptor_t BtpPayload_rawPayload_xer_;
extern const TTCN_Typedescriptor_t BtpPayload_rawPayload_descr_;
extern const TTCN_RAWdescriptor_t BtpPayload_raw_;
extern const TTCN_JSONdescriptor_t BtpPayload_json_;
extern const TTCN_Typedescriptor_t BtpPayload_descr_;
extern const TTCN_RAWdescriptor_t DecodedBtpPayload_raw_;
extern const TTCN_JSONdescriptor_t DecodedBtpPayload_json_;
extern const TTCN_Typedescriptor_t DecodedBtpPayload_descr_;
extern const TTCN_RAWdescriptor_t UtBtpTrigger_raw_;
extern const TTCN_JSONdescriptor_t UtBtpTrigger_json_;
extern const TTCN_Typedescriptor_t UtBtpTrigger_descr_;
extern const TTCN_RAWdescriptor_t GenerateBtpA_raw_;
extern const TTCN_JSONdescriptor_t GenerateBtpA_json_;
extern const TTCN_Typedescriptor_t GenerateBtpA_descr_;
extern const TTCN_RAWdescriptor_t GenerateBtpB_raw_;
extern const TTCN_JSONdescriptor_t GenerateBtpB_json_;
extern const TTCN_Typedescriptor_t GenerateBtpB_descr_;
extern const TTCN_RAWdescriptor_t UtBtpTriggerResult_utBtpTriggerResult_raw_;
extern const XERdescriptor_t UtBtpTriggerResult_utBtpTriggerResult_xer_;
extern const TTCN_Typedescriptor_t UtBtpTriggerResult_utBtpTriggerResult_descr_;
extern const TTCN_RAWdescriptor_t UtBtpTriggerResult_raw_;
extern const TTCN_JSONdescriptor_t UtBtpTriggerResult_json_;
extern const TTCN_Typedescriptor_t UtBtpTriggerResult_descr_;
extern const XERdescriptor_t UtBtpEventInd_rawPayload_xer_;
extern const TTCN_Typedescriptor_t UtBtpEventInd_rawPayload_descr_;
extern const TTCN_RAWdescriptor_t UtBtpEventInd_raw_;
extern const TTCN_JSONdescriptor_t UtBtpEventInd_json_;
extern const TTCN_Typedescriptor_t UtBtpEventInd_descr_;
extern const TTCN_RAWdescriptor_t UtBtpEventIndList_raw_;
extern const TTCN_Typedescriptor_t UtBtpEventIndList_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
