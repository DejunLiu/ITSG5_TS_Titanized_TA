// This C++ header file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef CAM__PDU__Descriptions_HH
#define CAM__PDU__Descriptions_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "ITS_Container.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the ASN.1 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef CAM__PDU__Descriptions_HH
#endif

namespace CAM__PDU__Descriptions {

/* Forward declarations of classes */

class BasicContainer;
class BasicContainer_template;
class HighFrequencyContainer;
class HighFrequencyContainer_template;
class BasicVehicleContainerHighFrequency;
class BasicVehicleContainerHighFrequency_template;
class RSUContainerHighFrequency;
class RSUContainerHighFrequency_template;
class CamParameters;
class CamParameters_template;
class LowFrequencyContainer;
class LowFrequencyContainer_template;
class BasicVehicleContainerLowFrequency;
class BasicVehicleContainerLowFrequency_template;
class SpecialVehicleContainer;
class SpecialVehicleContainer_template;
class PublicTransportContainer;
class PublicTransportContainer_template;
class SpecialTransportContainer;
class SpecialTransportContainer_template;
class DangerousGoodsContainer;
class DangerousGoodsContainer_template;
class RoadWorksContainerBasic;
class RoadWorksContainerBasic_template;
class RescueContainer;
class RescueContainer_template;
class EmergencyContainer;
class EmergencyContainer_template;
class SafetyCarContainer;
class SafetyCarContainer_template;
class CoopAwareness;
class CoopAwareness_template;
class CAM;
class CAM_template;

} /* end of namespace */

#ifndef CAM__PDU__Descriptions_HH
#define CAM__PDU__Descriptions_HH

namespace CAM__PDU__Descriptions {

/* Type definitions */

typedef INTEGER GenerationDeltaTime;
typedef INTEGER_template GenerationDeltaTime_template;

/* Class definitions */

class BasicContainer : public Base_Type {
  INTEGER field_stationType;
  ITS__Container::ReferencePosition field_referencePosition;
  boolean bound_flag;
public:
  BasicContainer();
  BasicContainer(const INTEGER& par_stationType,
    const ITS__Container::ReferencePosition& par_referencePosition);
  BasicContainer(const BasicContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BasicContainer& operator=(const BasicContainer& other_value);
  boolean operator==(const BasicContainer& other_value) const;
  inline boolean operator!=(const BasicContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& stationType()
    {return field_stationType;}
  inline const INTEGER& stationType() const
    {return field_stationType;}
  inline ITS__Container::ReferencePosition& referencePosition()
    {return field_referencePosition;}
  inline const ITS__Container::ReferencePosition& referencePosition() const
    {return field_referencePosition;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BasicContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BasicContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BasicContainer& other_value);
void copy_template(const BasicContainer_template& other_value);

public:
BasicContainer_template();
BasicContainer_template(template_sel other_value);
BasicContainer_template(const BasicContainer& other_value);
BasicContainer_template(const OPTIONAL<BasicContainer>& other_value);
BasicContainer_template(const BasicContainer_template& other_value);
~BasicContainer_template();
BasicContainer_template& operator=(template_sel other_value);
BasicContainer_template& operator=(const BasicContainer& other_value);
BasicContainer_template& operator=(const OPTIONAL<BasicContainer>& other_value);
BasicContainer_template& operator=(const BasicContainer_template& other_value);
boolean match(const BasicContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BasicContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BasicContainer_template& list_item(unsigned int list_index) const;
INTEGER_template& stationType();
const INTEGER_template& stationType() const;
ITS__Container::ReferencePosition_template& referencePosition();
const ITS__Container::ReferencePosition_template& referencePosition() const;
int size_of() const;
void log() const;
void log_match(const BasicContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HighFrequencyContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_basicVehicleContainerHighFrequency = 1, ALT_rsuContainerHighFrequency = 2 };
private:
union_selection_type union_selection;
union {
BasicVehicleContainerHighFrequency *field_basicVehicleContainerHighFrequency;
RSUContainerHighFrequency *field_rsuContainerHighFrequency;
};
void copy_value(const HighFrequencyContainer& other_value);

public:
HighFrequencyContainer();
HighFrequencyContainer(const HighFrequencyContainer& other_value);
~HighFrequencyContainer();
HighFrequencyContainer& operator=(const HighFrequencyContainer& other_value);
boolean operator==(const HighFrequencyContainer& other_value) const;
inline boolean operator!=(const HighFrequencyContainer& other_value) const { return !(*this == other_value); }
BasicVehicleContainerHighFrequency& basicVehicleContainerHighFrequency();
const BasicVehicleContainerHighFrequency& basicVehicleContainerHighFrequency() const;
RSUContainerHighFrequency& rsuContainerHighFrequency();
const RSUContainerHighFrequency& rsuContainerHighFrequency() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class HighFrequencyContainer_template : public Base_Template {
union {
struct {
HighFrequencyContainer::union_selection_type union_selection;
union {
BasicVehicleContainerHighFrequency_template *field_basicVehicleContainerHighFrequency;
RSUContainerHighFrequency_template *field_rsuContainerHighFrequency;
};
} single_value;
struct {
unsigned int n_values;
HighFrequencyContainer_template *list_value;
} value_list;
};
void copy_value(const HighFrequencyContainer& other_value);

void copy_template(const HighFrequencyContainer_template& other_value);

public:
HighFrequencyContainer_template();
HighFrequencyContainer_template(template_sel other_value);
HighFrequencyContainer_template(const HighFrequencyContainer& other_value);
HighFrequencyContainer_template(const OPTIONAL<HighFrequencyContainer>& other_value);
HighFrequencyContainer_template(const HighFrequencyContainer_template& other_value);
~HighFrequencyContainer_template();
void clean_up();
HighFrequencyContainer_template& operator=(template_sel other_value);
HighFrequencyContainer_template& operator=(const HighFrequencyContainer& other_value);
HighFrequencyContainer_template& operator=(const OPTIONAL<HighFrequencyContainer>& other_value);
HighFrequencyContainer_template& operator=(const HighFrequencyContainer_template& other_value);
boolean match(const HighFrequencyContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;HighFrequencyContainer valueof() const;
HighFrequencyContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
BasicVehicleContainerHighFrequency_template& basicVehicleContainerHighFrequency();
const BasicVehicleContainerHighFrequency_template& basicVehicleContainerHighFrequency() const;
RSUContainerHighFrequency_template& rsuContainerHighFrequency();
const RSUContainerHighFrequency_template& rsuContainerHighFrequency() const;
boolean ischosen(HighFrequencyContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const HighFrequencyContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class BasicVehicleContainerHighFrequency : public Base_Type {
  ITS__Container::Heading field_heading;
  ITS__Container::Speed field_speed;
  ITS__Container::DriveDirection field_driveDirection;
  ITS__Container::VehicleLength field_vehicleLength;
  INTEGER field_vehicleWidth;
  ITS__Container::LongitudinalAcceleration field_longitudinalAcceleration;
  ITS__Container::Curvature field_curvature;
  ITS__Container::CurvatureCalculationMode field_curvatureCalculationMode;
  ITS__Container::YawRate field_yawRate;
  OPTIONAL<BITSTRING> field_accelerationControl;
  OPTIONAL<INTEGER> field_lanePosition;
  OPTIONAL<ITS__Container::SteeringWheelAngle> field_steeringWheelAngle;
  OPTIONAL<ITS__Container::LateralAcceleration> field_lateralAcceleration;
  OPTIONAL<ITS__Container::VerticalAcceleration> field_verticalAcceleration;
  OPTIONAL<INTEGER> field_performanceClass;
  OPTIONAL<ITS__Container::CenDsrcTollingZone> field_cenDsrcTollingZone;
  boolean bound_flag;
public:
  BasicVehicleContainerHighFrequency();
  BasicVehicleContainerHighFrequency(const ITS__Container::Heading& par_heading,
    const ITS__Container::Speed& par_speed,
    const ITS__Container::DriveDirection& par_driveDirection,
    const ITS__Container::VehicleLength& par_vehicleLength,
    const INTEGER& par_vehicleWidth,
    const ITS__Container::LongitudinalAcceleration& par_longitudinalAcceleration,
    const ITS__Container::Curvature& par_curvature,
    const ITS__Container::CurvatureCalculationMode& par_curvatureCalculationMode,
    const ITS__Container::YawRate& par_yawRate,
    const OPTIONAL<BITSTRING>& par_accelerationControl,
    const OPTIONAL<INTEGER>& par_lanePosition,
    const OPTIONAL<ITS__Container::SteeringWheelAngle>& par_steeringWheelAngle,
    const OPTIONAL<ITS__Container::LateralAcceleration>& par_lateralAcceleration,
    const OPTIONAL<ITS__Container::VerticalAcceleration>& par_verticalAcceleration,
    const OPTIONAL<INTEGER>& par_performanceClass,
    const OPTIONAL<ITS__Container::CenDsrcTollingZone>& par_cenDsrcTollingZone);
  BasicVehicleContainerHighFrequency(const BasicVehicleContainerHighFrequency& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BasicVehicleContainerHighFrequency& operator=(const BasicVehicleContainerHighFrequency& other_value);
  boolean operator==(const BasicVehicleContainerHighFrequency& other_value) const;
  inline boolean operator!=(const BasicVehicleContainerHighFrequency& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ITS__Container::Heading& heading()
    {return field_heading;}
  inline const ITS__Container::Heading& heading() const
    {return field_heading;}
  inline ITS__Container::Speed& speed()
    {return field_speed;}
  inline const ITS__Container::Speed& speed() const
    {return field_speed;}
  inline ITS__Container::DriveDirection& driveDirection()
    {return field_driveDirection;}
  inline const ITS__Container::DriveDirection& driveDirection() const
    {return field_driveDirection;}
  inline ITS__Container::VehicleLength& vehicleLength()
    {return field_vehicleLength;}
  inline const ITS__Container::VehicleLength& vehicleLength() const
    {return field_vehicleLength;}
  inline INTEGER& vehicleWidth()
    {return field_vehicleWidth;}
  inline const INTEGER& vehicleWidth() const
    {return field_vehicleWidth;}
  inline ITS__Container::LongitudinalAcceleration& longitudinalAcceleration()
    {return field_longitudinalAcceleration;}
  inline const ITS__Container::LongitudinalAcceleration& longitudinalAcceleration() const
    {return field_longitudinalAcceleration;}
  inline ITS__Container::Curvature& curvature()
    {return field_curvature;}
  inline const ITS__Container::Curvature& curvature() const
    {return field_curvature;}
  inline ITS__Container::CurvatureCalculationMode& curvatureCalculationMode()
    {return field_curvatureCalculationMode;}
  inline const ITS__Container::CurvatureCalculationMode& curvatureCalculationMode() const
    {return field_curvatureCalculationMode;}
  inline ITS__Container::YawRate& yawRate()
    {return field_yawRate;}
  inline const ITS__Container::YawRate& yawRate() const
    {return field_yawRate;}
  inline OPTIONAL<BITSTRING>& accelerationControl()
    {return field_accelerationControl;}
  inline const OPTIONAL<BITSTRING>& accelerationControl() const
    {return field_accelerationControl;}
  inline OPTIONAL<INTEGER>& lanePosition()
    {return field_lanePosition;}
  inline const OPTIONAL<INTEGER>& lanePosition() const
    {return field_lanePosition;}
  inline OPTIONAL<ITS__Container::SteeringWheelAngle>& steeringWheelAngle()
    {return field_steeringWheelAngle;}
  inline const OPTIONAL<ITS__Container::SteeringWheelAngle>& steeringWheelAngle() const
    {return field_steeringWheelAngle;}
  inline OPTIONAL<ITS__Container::LateralAcceleration>& lateralAcceleration()
    {return field_lateralAcceleration;}
  inline const OPTIONAL<ITS__Container::LateralAcceleration>& lateralAcceleration() const
    {return field_lateralAcceleration;}
  inline OPTIONAL<ITS__Container::VerticalAcceleration>& verticalAcceleration()
    {return field_verticalAcceleration;}
  inline const OPTIONAL<ITS__Container::VerticalAcceleration>& verticalAcceleration() const
    {return field_verticalAcceleration;}
  inline OPTIONAL<INTEGER>& performanceClass()
    {return field_performanceClass;}
  inline const OPTIONAL<INTEGER>& performanceClass() const
    {return field_performanceClass;}
  inline OPTIONAL<ITS__Container::CenDsrcTollingZone>& cenDsrcTollingZone()
    {return field_cenDsrcTollingZone;}
  inline const OPTIONAL<ITS__Container::CenDsrcTollingZone>& cenDsrcTollingZone() const
    {return field_cenDsrcTollingZone;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BasicVehicleContainerHighFrequency_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BasicVehicleContainerHighFrequency_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BasicVehicleContainerHighFrequency& other_value);
void copy_template(const BasicVehicleContainerHighFrequency_template& other_value);

public:
BasicVehicleContainerHighFrequency_template();
BasicVehicleContainerHighFrequency_template(template_sel other_value);
BasicVehicleContainerHighFrequency_template(const BasicVehicleContainerHighFrequency& other_value);
BasicVehicleContainerHighFrequency_template(const OPTIONAL<BasicVehicleContainerHighFrequency>& other_value);
BasicVehicleContainerHighFrequency_template(const BasicVehicleContainerHighFrequency_template& other_value);
~BasicVehicleContainerHighFrequency_template();
BasicVehicleContainerHighFrequency_template& operator=(template_sel other_value);
BasicVehicleContainerHighFrequency_template& operator=(const BasicVehicleContainerHighFrequency& other_value);
BasicVehicleContainerHighFrequency_template& operator=(const OPTIONAL<BasicVehicleContainerHighFrequency>& other_value);
BasicVehicleContainerHighFrequency_template& operator=(const BasicVehicleContainerHighFrequency_template& other_value);
boolean match(const BasicVehicleContainerHighFrequency& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BasicVehicleContainerHighFrequency valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BasicVehicleContainerHighFrequency_template& list_item(unsigned int list_index) const;
ITS__Container::Heading_template& heading();
const ITS__Container::Heading_template& heading() const;
ITS__Container::Speed_template& speed();
const ITS__Container::Speed_template& speed() const;
ITS__Container::DriveDirection_template& driveDirection();
const ITS__Container::DriveDirection_template& driveDirection() const;
ITS__Container::VehicleLength_template& vehicleLength();
const ITS__Container::VehicleLength_template& vehicleLength() const;
INTEGER_template& vehicleWidth();
const INTEGER_template& vehicleWidth() const;
ITS__Container::LongitudinalAcceleration_template& longitudinalAcceleration();
const ITS__Container::LongitudinalAcceleration_template& longitudinalAcceleration() const;
ITS__Container::Curvature_template& curvature();
const ITS__Container::Curvature_template& curvature() const;
ITS__Container::CurvatureCalculationMode_template& curvatureCalculationMode();
const ITS__Container::CurvatureCalculationMode_template& curvatureCalculationMode() const;
ITS__Container::YawRate_template& yawRate();
const ITS__Container::YawRate_template& yawRate() const;
BITSTRING_template& accelerationControl();
const BITSTRING_template& accelerationControl() const;
INTEGER_template& lanePosition();
const INTEGER_template& lanePosition() const;
ITS__Container::SteeringWheelAngle_template& steeringWheelAngle();
const ITS__Container::SteeringWheelAngle_template& steeringWheelAngle() const;
ITS__Container::LateralAcceleration_template& lateralAcceleration();
const ITS__Container::LateralAcceleration_template& lateralAcceleration() const;
ITS__Container::VerticalAcceleration_template& verticalAcceleration();
const ITS__Container::VerticalAcceleration_template& verticalAcceleration() const;
INTEGER_template& performanceClass();
const INTEGER_template& performanceClass() const;
ITS__Container::CenDsrcTollingZone_template& cenDsrcTollingZone();
const ITS__Container::CenDsrcTollingZone_template& cenDsrcTollingZone() const;
int size_of() const;
void log() const;
void log_match(const BasicVehicleContainerHighFrequency& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RSUContainerHighFrequency : public Base_Type {
  OPTIONAL<ITS__Container::ProtectedCommunicationZonesRSU> field_protectedCommunicationZonesRSU;
  boolean bound_flag;
public:
  RSUContainerHighFrequency();
  RSUContainerHighFrequency(const OPTIONAL<ITS__Container::ProtectedCommunicationZonesRSU>& par_protectedCommunicationZonesRSU);
  RSUContainerHighFrequency(const RSUContainerHighFrequency& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RSUContainerHighFrequency& operator=(const RSUContainerHighFrequency& other_value);
  boolean operator==(const RSUContainerHighFrequency& other_value) const;
  inline boolean operator!=(const RSUContainerHighFrequency& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<ITS__Container::ProtectedCommunicationZonesRSU>& protectedCommunicationZonesRSU()
    {return field_protectedCommunicationZonesRSU;}
  inline const OPTIONAL<ITS__Container::ProtectedCommunicationZonesRSU>& protectedCommunicationZonesRSU() const
    {return field_protectedCommunicationZonesRSU;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RSUContainerHighFrequency_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RSUContainerHighFrequency_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RSUContainerHighFrequency& other_value);
void copy_template(const RSUContainerHighFrequency_template& other_value);

public:
RSUContainerHighFrequency_template();
RSUContainerHighFrequency_template(template_sel other_value);
RSUContainerHighFrequency_template(const RSUContainerHighFrequency& other_value);
RSUContainerHighFrequency_template(const OPTIONAL<RSUContainerHighFrequency>& other_value);
RSUContainerHighFrequency_template(const RSUContainerHighFrequency_template& other_value);
~RSUContainerHighFrequency_template();
RSUContainerHighFrequency_template& operator=(template_sel other_value);
RSUContainerHighFrequency_template& operator=(const RSUContainerHighFrequency& other_value);
RSUContainerHighFrequency_template& operator=(const OPTIONAL<RSUContainerHighFrequency>& other_value);
RSUContainerHighFrequency_template& operator=(const RSUContainerHighFrequency_template& other_value);
boolean match(const RSUContainerHighFrequency& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RSUContainerHighFrequency valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RSUContainerHighFrequency_template& list_item(unsigned int list_index) const;
ITS__Container::ProtectedCommunicationZonesRSU_template& protectedCommunicationZonesRSU();
const ITS__Container::ProtectedCommunicationZonesRSU_template& protectedCommunicationZonesRSU() const;
int size_of() const;
void log() const;
void log_match(const RSUContainerHighFrequency& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CamParameters : public Base_Type {
  BasicContainer field_basicContainer;
  HighFrequencyContainer field_highFrequencyContainer;
  OPTIONAL<LowFrequencyContainer> field_lowFrequencyContainer;
  OPTIONAL<SpecialVehicleContainer> field_specialVehicleContainer;
  boolean bound_flag;
public:
  CamParameters();
  CamParameters(const BasicContainer& par_basicContainer,
    const HighFrequencyContainer& par_highFrequencyContainer,
    const OPTIONAL<LowFrequencyContainer>& par_lowFrequencyContainer,
    const OPTIONAL<SpecialVehicleContainer>& par_specialVehicleContainer);
  CamParameters(const CamParameters& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CamParameters& operator=(const CamParameters& other_value);
  boolean operator==(const CamParameters& other_value) const;
  inline boolean operator!=(const CamParameters& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BasicContainer& basicContainer()
    {return field_basicContainer;}
  inline const BasicContainer& basicContainer() const
    {return field_basicContainer;}
  inline HighFrequencyContainer& highFrequencyContainer()
    {return field_highFrequencyContainer;}
  inline const HighFrequencyContainer& highFrequencyContainer() const
    {return field_highFrequencyContainer;}
  inline OPTIONAL<LowFrequencyContainer>& lowFrequencyContainer()
    {return field_lowFrequencyContainer;}
  inline const OPTIONAL<LowFrequencyContainer>& lowFrequencyContainer() const
    {return field_lowFrequencyContainer;}
  inline OPTIONAL<SpecialVehicleContainer>& specialVehicleContainer()
    {return field_specialVehicleContainer;}
  inline const OPTIONAL<SpecialVehicleContainer>& specialVehicleContainer() const
    {return field_specialVehicleContainer;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CamParameters_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CamParameters_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CamParameters& other_value);
void copy_template(const CamParameters_template& other_value);

public:
CamParameters_template();
CamParameters_template(template_sel other_value);
CamParameters_template(const CamParameters& other_value);
CamParameters_template(const OPTIONAL<CamParameters>& other_value);
CamParameters_template(const CamParameters_template& other_value);
~CamParameters_template();
CamParameters_template& operator=(template_sel other_value);
CamParameters_template& operator=(const CamParameters& other_value);
CamParameters_template& operator=(const OPTIONAL<CamParameters>& other_value);
CamParameters_template& operator=(const CamParameters_template& other_value);
boolean match(const CamParameters& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CamParameters valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CamParameters_template& list_item(unsigned int list_index) const;
BasicContainer_template& basicContainer();
const BasicContainer_template& basicContainer() const;
HighFrequencyContainer_template& highFrequencyContainer();
const HighFrequencyContainer_template& highFrequencyContainer() const;
LowFrequencyContainer_template& lowFrequencyContainer();
const LowFrequencyContainer_template& lowFrequencyContainer() const;
SpecialVehicleContainer_template& specialVehicleContainer();
const SpecialVehicleContainer_template& specialVehicleContainer() const;
int size_of() const;
void log() const;
void log_match(const CamParameters& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LowFrequencyContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_basicVehicleContainerLowFrequency = 1 };
private:
union_selection_type union_selection;
union {
BasicVehicleContainerLowFrequency *field_basicVehicleContainerLowFrequency;
};
void copy_value(const LowFrequencyContainer& other_value);

public:
LowFrequencyContainer();
LowFrequencyContainer(const LowFrequencyContainer& other_value);
~LowFrequencyContainer();
LowFrequencyContainer& operator=(const LowFrequencyContainer& other_value);
boolean operator==(const LowFrequencyContainer& other_value) const;
inline boolean operator!=(const LowFrequencyContainer& other_value) const { return !(*this == other_value); }
BasicVehicleContainerLowFrequency& basicVehicleContainerLowFrequency();
const BasicVehicleContainerLowFrequency& basicVehicleContainerLowFrequency() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class LowFrequencyContainer_template : public Base_Template {
union {
struct {
LowFrequencyContainer::union_selection_type union_selection;
union {
BasicVehicleContainerLowFrequency_template *field_basicVehicleContainerLowFrequency;
};
} single_value;
struct {
unsigned int n_values;
LowFrequencyContainer_template *list_value;
} value_list;
};
void copy_value(const LowFrequencyContainer& other_value);

void copy_template(const LowFrequencyContainer_template& other_value);

public:
LowFrequencyContainer_template();
LowFrequencyContainer_template(template_sel other_value);
LowFrequencyContainer_template(const LowFrequencyContainer& other_value);
LowFrequencyContainer_template(const OPTIONAL<LowFrequencyContainer>& other_value);
LowFrequencyContainer_template(const LowFrequencyContainer_template& other_value);
~LowFrequencyContainer_template();
void clean_up();
LowFrequencyContainer_template& operator=(template_sel other_value);
LowFrequencyContainer_template& operator=(const LowFrequencyContainer& other_value);
LowFrequencyContainer_template& operator=(const OPTIONAL<LowFrequencyContainer>& other_value);
LowFrequencyContainer_template& operator=(const LowFrequencyContainer_template& other_value);
boolean match(const LowFrequencyContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;LowFrequencyContainer valueof() const;
LowFrequencyContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
BasicVehicleContainerLowFrequency_template& basicVehicleContainerLowFrequency();
const BasicVehicleContainerLowFrequency_template& basicVehicleContainerLowFrequency() const;
boolean ischosen(LowFrequencyContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const LowFrequencyContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class BasicVehicleContainerLowFrequency : public Base_Type {
  ITS__Container::VehicleRole field_vehicleRole;
  BITSTRING field_exteriorLights;
  ITS__Container::PathHistory field_pathHistory;
  boolean bound_flag;
public:
  BasicVehicleContainerLowFrequency();
  BasicVehicleContainerLowFrequency(const ITS__Container::VehicleRole& par_vehicleRole,
    const BITSTRING& par_exteriorLights,
    const ITS__Container::PathHistory& par_pathHistory);
  BasicVehicleContainerLowFrequency(const BasicVehicleContainerLowFrequency& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BasicVehicleContainerLowFrequency& operator=(const BasicVehicleContainerLowFrequency& other_value);
  boolean operator==(const BasicVehicleContainerLowFrequency& other_value) const;
  inline boolean operator!=(const BasicVehicleContainerLowFrequency& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ITS__Container::VehicleRole& vehicleRole()
    {return field_vehicleRole;}
  inline const ITS__Container::VehicleRole& vehicleRole() const
    {return field_vehicleRole;}
  inline BITSTRING& exteriorLights()
    {return field_exteriorLights;}
  inline const BITSTRING& exteriorLights() const
    {return field_exteriorLights;}
  inline ITS__Container::PathHistory& pathHistory()
    {return field_pathHistory;}
  inline const ITS__Container::PathHistory& pathHistory() const
    {return field_pathHistory;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BasicVehicleContainerLowFrequency_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BasicVehicleContainerLowFrequency_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BasicVehicleContainerLowFrequency& other_value);
void copy_template(const BasicVehicleContainerLowFrequency_template& other_value);

public:
BasicVehicleContainerLowFrequency_template();
BasicVehicleContainerLowFrequency_template(template_sel other_value);
BasicVehicleContainerLowFrequency_template(const BasicVehicleContainerLowFrequency& other_value);
BasicVehicleContainerLowFrequency_template(const OPTIONAL<BasicVehicleContainerLowFrequency>& other_value);
BasicVehicleContainerLowFrequency_template(const BasicVehicleContainerLowFrequency_template& other_value);
~BasicVehicleContainerLowFrequency_template();
BasicVehicleContainerLowFrequency_template& operator=(template_sel other_value);
BasicVehicleContainerLowFrequency_template& operator=(const BasicVehicleContainerLowFrequency& other_value);
BasicVehicleContainerLowFrequency_template& operator=(const OPTIONAL<BasicVehicleContainerLowFrequency>& other_value);
BasicVehicleContainerLowFrequency_template& operator=(const BasicVehicleContainerLowFrequency_template& other_value);
boolean match(const BasicVehicleContainerLowFrequency& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BasicVehicleContainerLowFrequency valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BasicVehicleContainerLowFrequency_template& list_item(unsigned int list_index) const;
ITS__Container::VehicleRole_template& vehicleRole();
const ITS__Container::VehicleRole_template& vehicleRole() const;
BITSTRING_template& exteriorLights();
const BITSTRING_template& exteriorLights() const;
ITS__Container::PathHistory_template& pathHistory();
const ITS__Container::PathHistory_template& pathHistory() const;
int size_of() const;
void log() const;
void log_match(const BasicVehicleContainerLowFrequency& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SpecialVehicleContainer : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_publicTransportContainer = 1, ALT_specialTransportContainer = 2, ALT_dangerousGoodsContainer = 3, ALT_roadWorksContainerBasic = 4, ALT_rescueContainer = 5, ALT_emergencyContainer = 6, ALT_safetyCarContainer = 7 };
private:
union_selection_type union_selection;
union {
PublicTransportContainer *field_publicTransportContainer;
SpecialTransportContainer *field_specialTransportContainer;
DangerousGoodsContainer *field_dangerousGoodsContainer;
RoadWorksContainerBasic *field_roadWorksContainerBasic;
RescueContainer *field_rescueContainer;
EmergencyContainer *field_emergencyContainer;
SafetyCarContainer *field_safetyCarContainer;
};
void copy_value(const SpecialVehicleContainer& other_value);

public:
SpecialVehicleContainer();
SpecialVehicleContainer(const SpecialVehicleContainer& other_value);
~SpecialVehicleContainer();
SpecialVehicleContainer& operator=(const SpecialVehicleContainer& other_value);
boolean operator==(const SpecialVehicleContainer& other_value) const;
inline boolean operator!=(const SpecialVehicleContainer& other_value) const { return !(*this == other_value); }
PublicTransportContainer& publicTransportContainer();
const PublicTransportContainer& publicTransportContainer() const;
SpecialTransportContainer& specialTransportContainer();
const SpecialTransportContainer& specialTransportContainer() const;
DangerousGoodsContainer& dangerousGoodsContainer();
const DangerousGoodsContainer& dangerousGoodsContainer() const;
RoadWorksContainerBasic& roadWorksContainerBasic();
const RoadWorksContainerBasic& roadWorksContainerBasic() const;
RescueContainer& rescueContainer();
const RescueContainer& rescueContainer() const;
EmergencyContainer& emergencyContainer();
const EmergencyContainer& emergencyContainer() const;
SafetyCarContainer& safetyCarContainer();
const SafetyCarContainer& safetyCarContainer() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class SpecialVehicleContainer_template : public Base_Template {
union {
struct {
SpecialVehicleContainer::union_selection_type union_selection;
union {
PublicTransportContainer_template *field_publicTransportContainer;
SpecialTransportContainer_template *field_specialTransportContainer;
DangerousGoodsContainer_template *field_dangerousGoodsContainer;
RoadWorksContainerBasic_template *field_roadWorksContainerBasic;
RescueContainer_template *field_rescueContainer;
EmergencyContainer_template *field_emergencyContainer;
SafetyCarContainer_template *field_safetyCarContainer;
};
} single_value;
struct {
unsigned int n_values;
SpecialVehicleContainer_template *list_value;
} value_list;
};
void copy_value(const SpecialVehicleContainer& other_value);

void copy_template(const SpecialVehicleContainer_template& other_value);

public:
SpecialVehicleContainer_template();
SpecialVehicleContainer_template(template_sel other_value);
SpecialVehicleContainer_template(const SpecialVehicleContainer& other_value);
SpecialVehicleContainer_template(const OPTIONAL<SpecialVehicleContainer>& other_value);
SpecialVehicleContainer_template(const SpecialVehicleContainer_template& other_value);
~SpecialVehicleContainer_template();
void clean_up();
SpecialVehicleContainer_template& operator=(template_sel other_value);
SpecialVehicleContainer_template& operator=(const SpecialVehicleContainer& other_value);
SpecialVehicleContainer_template& operator=(const OPTIONAL<SpecialVehicleContainer>& other_value);
SpecialVehicleContainer_template& operator=(const SpecialVehicleContainer_template& other_value);
boolean match(const SpecialVehicleContainer& other_value, boolean legacy = FALSE) const;
boolean is_value() const;SpecialVehicleContainer valueof() const;
SpecialVehicleContainer_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
PublicTransportContainer_template& publicTransportContainer();
const PublicTransportContainer_template& publicTransportContainer() const;
SpecialTransportContainer_template& specialTransportContainer();
const SpecialTransportContainer_template& specialTransportContainer() const;
DangerousGoodsContainer_template& dangerousGoodsContainer();
const DangerousGoodsContainer_template& dangerousGoodsContainer() const;
RoadWorksContainerBasic_template& roadWorksContainerBasic();
const RoadWorksContainerBasic_template& roadWorksContainerBasic() const;
RescueContainer_template& rescueContainer();
const RescueContainer_template& rescueContainer() const;
EmergencyContainer_template& emergencyContainer();
const EmergencyContainer_template& emergencyContainer() const;
SafetyCarContainer_template& safetyCarContainer();
const SafetyCarContainer_template& safetyCarContainer() const;
boolean ischosen(SpecialVehicleContainer::union_selection_type checked_selection) const;
void log() const;
void log_match(const SpecialVehicleContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class PublicTransportContainer : public Base_Type {
  BOOLEAN field_embarkationStatus;
  OPTIONAL<ITS__Container::PtActivation> field_ptActivation;
  boolean bound_flag;
public:
  PublicTransportContainer();
  PublicTransportContainer(const BOOLEAN& par_embarkationStatus,
    const OPTIONAL<ITS__Container::PtActivation>& par_ptActivation);
  PublicTransportContainer(const PublicTransportContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PublicTransportContainer& operator=(const PublicTransportContainer& other_value);
  boolean operator==(const PublicTransportContainer& other_value) const;
  inline boolean operator!=(const PublicTransportContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& embarkationStatus()
    {return field_embarkationStatus;}
  inline const BOOLEAN& embarkationStatus() const
    {return field_embarkationStatus;}
  inline OPTIONAL<ITS__Container::PtActivation>& ptActivation()
    {return field_ptActivation;}
  inline const OPTIONAL<ITS__Container::PtActivation>& ptActivation() const
    {return field_ptActivation;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PublicTransportContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PublicTransportContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PublicTransportContainer& other_value);
void copy_template(const PublicTransportContainer_template& other_value);

public:
PublicTransportContainer_template();
PublicTransportContainer_template(template_sel other_value);
PublicTransportContainer_template(const PublicTransportContainer& other_value);
PublicTransportContainer_template(const OPTIONAL<PublicTransportContainer>& other_value);
PublicTransportContainer_template(const PublicTransportContainer_template& other_value);
~PublicTransportContainer_template();
PublicTransportContainer_template& operator=(template_sel other_value);
PublicTransportContainer_template& operator=(const PublicTransportContainer& other_value);
PublicTransportContainer_template& operator=(const OPTIONAL<PublicTransportContainer>& other_value);
PublicTransportContainer_template& operator=(const PublicTransportContainer_template& other_value);
boolean match(const PublicTransportContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PublicTransportContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PublicTransportContainer_template& list_item(unsigned int list_index) const;
BOOLEAN_template& embarkationStatus();
const BOOLEAN_template& embarkationStatus() const;
ITS__Container::PtActivation_template& ptActivation();
const ITS__Container::PtActivation_template& ptActivation() const;
int size_of() const;
void log() const;
void log_match(const PublicTransportContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SpecialTransportContainer : public Base_Type {
  BITSTRING field_specialTransportType;
  BITSTRING field_lightBarSirenInUse;
  boolean bound_flag;
public:
  SpecialTransportContainer();
  SpecialTransportContainer(const BITSTRING& par_specialTransportType,
    const BITSTRING& par_lightBarSirenInUse);
  SpecialTransportContainer(const SpecialTransportContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SpecialTransportContainer& operator=(const SpecialTransportContainer& other_value);
  boolean operator==(const SpecialTransportContainer& other_value) const;
  inline boolean operator!=(const SpecialTransportContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& specialTransportType()
    {return field_specialTransportType;}
  inline const BITSTRING& specialTransportType() const
    {return field_specialTransportType;}
  inline BITSTRING& lightBarSirenInUse()
    {return field_lightBarSirenInUse;}
  inline const BITSTRING& lightBarSirenInUse() const
    {return field_lightBarSirenInUse;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SpecialTransportContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SpecialTransportContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SpecialTransportContainer& other_value);
void copy_template(const SpecialTransportContainer_template& other_value);

public:
SpecialTransportContainer_template();
SpecialTransportContainer_template(template_sel other_value);
SpecialTransportContainer_template(const SpecialTransportContainer& other_value);
SpecialTransportContainer_template(const OPTIONAL<SpecialTransportContainer>& other_value);
SpecialTransportContainer_template(const SpecialTransportContainer_template& other_value);
~SpecialTransportContainer_template();
SpecialTransportContainer_template& operator=(template_sel other_value);
SpecialTransportContainer_template& operator=(const SpecialTransportContainer& other_value);
SpecialTransportContainer_template& operator=(const OPTIONAL<SpecialTransportContainer>& other_value);
SpecialTransportContainer_template& operator=(const SpecialTransportContainer_template& other_value);
boolean match(const SpecialTransportContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SpecialTransportContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SpecialTransportContainer_template& list_item(unsigned int list_index) const;
BITSTRING_template& specialTransportType();
const BITSTRING_template& specialTransportType() const;
BITSTRING_template& lightBarSirenInUse();
const BITSTRING_template& lightBarSirenInUse() const;
int size_of() const;
void log() const;
void log_match(const SpecialTransportContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DangerousGoodsContainer : public Base_Type {
  ITS__Container::DangerousGoodsBasic field_dangerousGoodsBasic;
  boolean bound_flag;
public:
  DangerousGoodsContainer();
  DangerousGoodsContainer(const ITS__Container::DangerousGoodsBasic& par_dangerousGoodsBasic);
  DangerousGoodsContainer(const DangerousGoodsContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DangerousGoodsContainer& operator=(const DangerousGoodsContainer& other_value);
  boolean operator==(const DangerousGoodsContainer& other_value) const;
  inline boolean operator!=(const DangerousGoodsContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ITS__Container::DangerousGoodsBasic& dangerousGoodsBasic()
    {return field_dangerousGoodsBasic;}
  inline const ITS__Container::DangerousGoodsBasic& dangerousGoodsBasic() const
    {return field_dangerousGoodsBasic;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DangerousGoodsContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DangerousGoodsContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DangerousGoodsContainer& other_value);
void copy_template(const DangerousGoodsContainer_template& other_value);

public:
DangerousGoodsContainer_template();
DangerousGoodsContainer_template(template_sel other_value);
DangerousGoodsContainer_template(const DangerousGoodsContainer& other_value);
DangerousGoodsContainer_template(const OPTIONAL<DangerousGoodsContainer>& other_value);
DangerousGoodsContainer_template(const DangerousGoodsContainer_template& other_value);
~DangerousGoodsContainer_template();
DangerousGoodsContainer_template& operator=(template_sel other_value);
DangerousGoodsContainer_template& operator=(const DangerousGoodsContainer& other_value);
DangerousGoodsContainer_template& operator=(const OPTIONAL<DangerousGoodsContainer>& other_value);
DangerousGoodsContainer_template& operator=(const DangerousGoodsContainer_template& other_value);
boolean match(const DangerousGoodsContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DangerousGoodsContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DangerousGoodsContainer_template& list_item(unsigned int list_index) const;
ITS__Container::DangerousGoodsBasic_template& dangerousGoodsBasic();
const ITS__Container::DangerousGoodsBasic_template& dangerousGoodsBasic() const;
int size_of() const;
void log() const;
void log_match(const DangerousGoodsContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RoadWorksContainerBasic : public Base_Type {
  OPTIONAL<INTEGER> field_roadworksSubCauseCode;
  BITSTRING field_lightBarSirenInUse;
  OPTIONAL<ITS__Container::ClosedLanes> field_closedLanes;
  boolean bound_flag;
public:
  RoadWorksContainerBasic();
  RoadWorksContainerBasic(const OPTIONAL<INTEGER>& par_roadworksSubCauseCode,
    const BITSTRING& par_lightBarSirenInUse,
    const OPTIONAL<ITS__Container::ClosedLanes>& par_closedLanes);
  RoadWorksContainerBasic(const RoadWorksContainerBasic& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RoadWorksContainerBasic& operator=(const RoadWorksContainerBasic& other_value);
  boolean operator==(const RoadWorksContainerBasic& other_value) const;
  inline boolean operator!=(const RoadWorksContainerBasic& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& roadworksSubCauseCode()
    {return field_roadworksSubCauseCode;}
  inline const OPTIONAL<INTEGER>& roadworksSubCauseCode() const
    {return field_roadworksSubCauseCode;}
  inline BITSTRING& lightBarSirenInUse()
    {return field_lightBarSirenInUse;}
  inline const BITSTRING& lightBarSirenInUse() const
    {return field_lightBarSirenInUse;}
  inline OPTIONAL<ITS__Container::ClosedLanes>& closedLanes()
    {return field_closedLanes;}
  inline const OPTIONAL<ITS__Container::ClosedLanes>& closedLanes() const
    {return field_closedLanes;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RoadWorksContainerBasic_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RoadWorksContainerBasic_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RoadWorksContainerBasic& other_value);
void copy_template(const RoadWorksContainerBasic_template& other_value);

public:
RoadWorksContainerBasic_template();
RoadWorksContainerBasic_template(template_sel other_value);
RoadWorksContainerBasic_template(const RoadWorksContainerBasic& other_value);
RoadWorksContainerBasic_template(const OPTIONAL<RoadWorksContainerBasic>& other_value);
RoadWorksContainerBasic_template(const RoadWorksContainerBasic_template& other_value);
~RoadWorksContainerBasic_template();
RoadWorksContainerBasic_template& operator=(template_sel other_value);
RoadWorksContainerBasic_template& operator=(const RoadWorksContainerBasic& other_value);
RoadWorksContainerBasic_template& operator=(const OPTIONAL<RoadWorksContainerBasic>& other_value);
RoadWorksContainerBasic_template& operator=(const RoadWorksContainerBasic_template& other_value);
boolean match(const RoadWorksContainerBasic& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RoadWorksContainerBasic valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RoadWorksContainerBasic_template& list_item(unsigned int list_index) const;
INTEGER_template& roadworksSubCauseCode();
const INTEGER_template& roadworksSubCauseCode() const;
BITSTRING_template& lightBarSirenInUse();
const BITSTRING_template& lightBarSirenInUse() const;
ITS__Container::ClosedLanes_template& closedLanes();
const ITS__Container::ClosedLanes_template& closedLanes() const;
int size_of() const;
void log() const;
void log_match(const RoadWorksContainerBasic& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RescueContainer : public Base_Type {
  BITSTRING field_lightBarSirenInUse;
  boolean bound_flag;
public:
  RescueContainer();
  RescueContainer(const BITSTRING& par_lightBarSirenInUse);
  RescueContainer(const RescueContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RescueContainer& operator=(const RescueContainer& other_value);
  boolean operator==(const RescueContainer& other_value) const;
  inline boolean operator!=(const RescueContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& lightBarSirenInUse()
    {return field_lightBarSirenInUse;}
  inline const BITSTRING& lightBarSirenInUse() const
    {return field_lightBarSirenInUse;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RescueContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RescueContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RescueContainer& other_value);
void copy_template(const RescueContainer_template& other_value);

public:
RescueContainer_template();
RescueContainer_template(template_sel other_value);
RescueContainer_template(const RescueContainer& other_value);
RescueContainer_template(const OPTIONAL<RescueContainer>& other_value);
RescueContainer_template(const RescueContainer_template& other_value);
~RescueContainer_template();
RescueContainer_template& operator=(template_sel other_value);
RescueContainer_template& operator=(const RescueContainer& other_value);
RescueContainer_template& operator=(const OPTIONAL<RescueContainer>& other_value);
RescueContainer_template& operator=(const RescueContainer_template& other_value);
boolean match(const RescueContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RescueContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RescueContainer_template& list_item(unsigned int list_index) const;
BITSTRING_template& lightBarSirenInUse();
const BITSTRING_template& lightBarSirenInUse() const;
int size_of() const;
void log() const;
void log_match(const RescueContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EmergencyContainer : public Base_Type {
  BITSTRING field_lightBarSirenInUse;
  OPTIONAL<ITS__Container::CauseCode> field_incidentIndication;
  OPTIONAL<BITSTRING> field_emergencyPriority;
  boolean bound_flag;
public:
  EmergencyContainer();
  EmergencyContainer(const BITSTRING& par_lightBarSirenInUse,
    const OPTIONAL<ITS__Container::CauseCode>& par_incidentIndication,
    const OPTIONAL<BITSTRING>& par_emergencyPriority);
  EmergencyContainer(const EmergencyContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EmergencyContainer& operator=(const EmergencyContainer& other_value);
  boolean operator==(const EmergencyContainer& other_value) const;
  inline boolean operator!=(const EmergencyContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& lightBarSirenInUse()
    {return field_lightBarSirenInUse;}
  inline const BITSTRING& lightBarSirenInUse() const
    {return field_lightBarSirenInUse;}
  inline OPTIONAL<ITS__Container::CauseCode>& incidentIndication()
    {return field_incidentIndication;}
  inline const OPTIONAL<ITS__Container::CauseCode>& incidentIndication() const
    {return field_incidentIndication;}
  inline OPTIONAL<BITSTRING>& emergencyPriority()
    {return field_emergencyPriority;}
  inline const OPTIONAL<BITSTRING>& emergencyPriority() const
    {return field_emergencyPriority;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EmergencyContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EmergencyContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EmergencyContainer& other_value);
void copy_template(const EmergencyContainer_template& other_value);

public:
EmergencyContainer_template();
EmergencyContainer_template(template_sel other_value);
EmergencyContainer_template(const EmergencyContainer& other_value);
EmergencyContainer_template(const OPTIONAL<EmergencyContainer>& other_value);
EmergencyContainer_template(const EmergencyContainer_template& other_value);
~EmergencyContainer_template();
EmergencyContainer_template& operator=(template_sel other_value);
EmergencyContainer_template& operator=(const EmergencyContainer& other_value);
EmergencyContainer_template& operator=(const OPTIONAL<EmergencyContainer>& other_value);
EmergencyContainer_template& operator=(const EmergencyContainer_template& other_value);
boolean match(const EmergencyContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EmergencyContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EmergencyContainer_template& list_item(unsigned int list_index) const;
BITSTRING_template& lightBarSirenInUse();
const BITSTRING_template& lightBarSirenInUse() const;
ITS__Container::CauseCode_template& incidentIndication();
const ITS__Container::CauseCode_template& incidentIndication() const;
BITSTRING_template& emergencyPriority();
const BITSTRING_template& emergencyPriority() const;
int size_of() const;
void log() const;
void log_match(const EmergencyContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SafetyCarContainer : public Base_Type {
  BITSTRING field_lightBarSirenInUse;
  OPTIONAL<ITS__Container::CauseCode> field_incidentIndication;
  OPTIONAL<ITS__Container::TrafficRule> field_trafficRule;
  OPTIONAL<INTEGER> field_speedLimit;
  boolean bound_flag;
public:
  SafetyCarContainer();
  SafetyCarContainer(const BITSTRING& par_lightBarSirenInUse,
    const OPTIONAL<ITS__Container::CauseCode>& par_incidentIndication,
    const OPTIONAL<ITS__Container::TrafficRule>& par_trafficRule,
    const OPTIONAL<INTEGER>& par_speedLimit);
  SafetyCarContainer(const SafetyCarContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SafetyCarContainer& operator=(const SafetyCarContainer& other_value);
  boolean operator==(const SafetyCarContainer& other_value) const;
  inline boolean operator!=(const SafetyCarContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& lightBarSirenInUse()
    {return field_lightBarSirenInUse;}
  inline const BITSTRING& lightBarSirenInUse() const
    {return field_lightBarSirenInUse;}
  inline OPTIONAL<ITS__Container::CauseCode>& incidentIndication()
    {return field_incidentIndication;}
  inline const OPTIONAL<ITS__Container::CauseCode>& incidentIndication() const
    {return field_incidentIndication;}
  inline OPTIONAL<ITS__Container::TrafficRule>& trafficRule()
    {return field_trafficRule;}
  inline const OPTIONAL<ITS__Container::TrafficRule>& trafficRule() const
    {return field_trafficRule;}
  inline OPTIONAL<INTEGER>& speedLimit()
    {return field_speedLimit;}
  inline const OPTIONAL<INTEGER>& speedLimit() const
    {return field_speedLimit;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SafetyCarContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SafetyCarContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SafetyCarContainer& other_value);
void copy_template(const SafetyCarContainer_template& other_value);

public:
SafetyCarContainer_template();
SafetyCarContainer_template(template_sel other_value);
SafetyCarContainer_template(const SafetyCarContainer& other_value);
SafetyCarContainer_template(const OPTIONAL<SafetyCarContainer>& other_value);
SafetyCarContainer_template(const SafetyCarContainer_template& other_value);
~SafetyCarContainer_template();
SafetyCarContainer_template& operator=(template_sel other_value);
SafetyCarContainer_template& operator=(const SafetyCarContainer& other_value);
SafetyCarContainer_template& operator=(const OPTIONAL<SafetyCarContainer>& other_value);
SafetyCarContainer_template& operator=(const SafetyCarContainer_template& other_value);
boolean match(const SafetyCarContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SafetyCarContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SafetyCarContainer_template& list_item(unsigned int list_index) const;
BITSTRING_template& lightBarSirenInUse();
const BITSTRING_template& lightBarSirenInUse() const;
ITS__Container::CauseCode_template& incidentIndication();
const ITS__Container::CauseCode_template& incidentIndication() const;
ITS__Container::TrafficRule_template& trafficRule();
const ITS__Container::TrafficRule_template& trafficRule() const;
INTEGER_template& speedLimit();
const INTEGER_template& speedLimit() const;
int size_of() const;
void log() const;
void log_match(const SafetyCarContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CoopAwareness : public Base_Type {
  INTEGER field_generationDeltaTime;
  CamParameters field_camParameters;
  boolean bound_flag;
public:
  CoopAwareness();
  CoopAwareness(const INTEGER& par_generationDeltaTime,
    const CamParameters& par_camParameters);
  CoopAwareness(const CoopAwareness& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CoopAwareness& operator=(const CoopAwareness& other_value);
  boolean operator==(const CoopAwareness& other_value) const;
  inline boolean operator!=(const CoopAwareness& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& generationDeltaTime()
    {return field_generationDeltaTime;}
  inline const INTEGER& generationDeltaTime() const
    {return field_generationDeltaTime;}
  inline CamParameters& camParameters()
    {return field_camParameters;}
  inline const CamParameters& camParameters() const
    {return field_camParameters;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CoopAwareness_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CoopAwareness_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CoopAwareness& other_value);
void copy_template(const CoopAwareness_template& other_value);

public:
CoopAwareness_template();
CoopAwareness_template(template_sel other_value);
CoopAwareness_template(const CoopAwareness& other_value);
CoopAwareness_template(const OPTIONAL<CoopAwareness>& other_value);
CoopAwareness_template(const CoopAwareness_template& other_value);
~CoopAwareness_template();
CoopAwareness_template& operator=(template_sel other_value);
CoopAwareness_template& operator=(const CoopAwareness& other_value);
CoopAwareness_template& operator=(const OPTIONAL<CoopAwareness>& other_value);
CoopAwareness_template& operator=(const CoopAwareness_template& other_value);
boolean match(const CoopAwareness& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CoopAwareness valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CoopAwareness_template& list_item(unsigned int list_index) const;
INTEGER_template& generationDeltaTime();
const INTEGER_template& generationDeltaTime() const;
CamParameters_template& camParameters();
const CamParameters_template& camParameters() const;
int size_of() const;
void log() const;
void log_match(const CoopAwareness& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CAM : public Base_Type {
  ITS__Container::ItsPduHeader field_header;
  CoopAwareness field_cam;
  boolean bound_flag;
public:
  CAM();
  CAM(const ITS__Container::ItsPduHeader& par_header,
    const CoopAwareness& par_cam);
  CAM(const CAM& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CAM& operator=(const CAM& other_value);
  boolean operator==(const CAM& other_value) const;
  inline boolean operator!=(const CAM& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ITS__Container::ItsPduHeader& header()
    {return field_header;}
  inline const ITS__Container::ItsPduHeader& header() const
    {return field_header;}
  inline CoopAwareness& cam()
    {return field_cam;}
  inline const CoopAwareness& cam() const
    {return field_cam;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CAM_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CAM_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CAM& other_value);
void copy_template(const CAM_template& other_value);

public:
CAM_template();
CAM_template(template_sel other_value);
CAM_template(const CAM& other_value);
CAM_template(const OPTIONAL<CAM>& other_value);
CAM_template(const CAM_template& other_value);
~CAM_template();
CAM_template& operator=(template_sel other_value);
CAM_template& operator=(const CAM& other_value);
CAM_template& operator=(const OPTIONAL<CAM>& other_value);
CAM_template& operator=(const CAM_template& other_value);
boolean match(const CAM& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CAM valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CAM_template& list_item(unsigned int list_index) const;
ITS__Container::ItsPduHeader_template& header();
const ITS__Container::ItsPduHeader_template& header() const;
CoopAwareness_template& cam();
const CoopAwareness_template& cam() const;
int size_of() const;
void log() const;
void log_match(const CAM& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Global variable declarations */

extern const ASN_BERdescriptor_t CAM_header_ber_;
extern const TTCN_Typedescriptor_t CAM_header_descr_;
extern const TTCN_Typedescriptor_t& GenerationDeltaTime_descr_;
extern const ASN_BERdescriptor_t CoopAwareness_generationDeltaTime_ber_;
extern const TTCN_Typedescriptor_t CoopAwareness_generationDeltaTime_descr_;
extern const ASN_BERdescriptor_t BasicContainer_stationType_ber_;
extern const TTCN_Typedescriptor_t BasicContainer_stationType_descr_;
extern const ASN_BERdescriptor_t BasicContainer_referencePosition_ber_;
extern const TTCN_Typedescriptor_t BasicContainer_referencePosition_descr_;
extern const TTCN_JSONdescriptor_t BasicContainer_json_;
extern const TTCN_Typedescriptor_t BasicContainer_descr_;
extern const ASN_BERdescriptor_t CamParameters_basicContainer_ber_;
extern const TTCN_Typedescriptor_t CamParameters_basicContainer_descr_;
extern const TTCN_JSONdescriptor_t HighFrequencyContainer_json_;
extern const TTCN_Typedescriptor_t HighFrequencyContainer_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_heading_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_heading_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_speed_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_speed_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_driveDirection_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_driveDirection_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_vehicleLength_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_vehicleLength_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_vehicleWidth_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_vehicleWidth_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_longitudinalAcceleration_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_longitudinalAcceleration_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_curvature_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_curvature_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_curvatureCalculationMode_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_curvatureCalculationMode_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_yawRate_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_yawRate_descr_;
extern const TTCN_JSONdescriptor_t BasicVehicleContainerHighFrequency_json_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_accelerationControl_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_accelerationControl_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_lanePosition_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_lanePosition_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_steeringWheelAngle_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_steeringWheelAngle_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_lateralAcceleration_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_lateralAcceleration_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_verticalAcceleration_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_verticalAcceleration_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_performanceClass_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_performanceClass_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerHighFrequency_cenDsrcTollingZone_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerHighFrequency_cenDsrcTollingZone_descr_;
extern const ASN_BERdescriptor_t HighFrequencyContainer_basicVehicleContainerHighFrequency_ber_;
extern const TTCN_Typedescriptor_t HighFrequencyContainer_basicVehicleContainerHighFrequency_descr_;
extern const TTCN_JSONdescriptor_t RSUContainerHighFrequency_json_;
extern const TTCN_Typedescriptor_t RSUContainerHighFrequency_descr_;
extern const ASN_BERdescriptor_t RSUContainerHighFrequency_protectedCommunicationZonesRSU_ber_;
extern const TTCN_Typedescriptor_t RSUContainerHighFrequency_protectedCommunicationZonesRSU_descr_;
extern const ASN_BERdescriptor_t HighFrequencyContainer_rsuContainerHighFrequency_ber_;
extern const TTCN_Typedescriptor_t HighFrequencyContainer_rsuContainerHighFrequency_descr_;
extern const ASN_BERdescriptor_t CamParameters_highFrequencyContainer_ber_;
extern const TTCN_Typedescriptor_t CamParameters_highFrequencyContainer_descr_;
extern const TTCN_JSONdescriptor_t CamParameters_json_;
extern const TTCN_Typedescriptor_t CamParameters_descr_;
extern const TTCN_JSONdescriptor_t LowFrequencyContainer_json_;
extern const TTCN_Typedescriptor_t LowFrequencyContainer_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerLowFrequency_vehicleRole_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerLowFrequency_vehicleRole_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerLowFrequency_exteriorLights_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerLowFrequency_exteriorLights_descr_;
extern const ASN_BERdescriptor_t BasicVehicleContainerLowFrequency_pathHistory_ber_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerLowFrequency_pathHistory_descr_;
extern const TTCN_JSONdescriptor_t BasicVehicleContainerLowFrequency_json_;
extern const TTCN_Typedescriptor_t BasicVehicleContainerLowFrequency_descr_;
extern const ASN_BERdescriptor_t LowFrequencyContainer_basicVehicleContainerLowFrequency_ber_;
extern const TTCN_Typedescriptor_t LowFrequencyContainer_basicVehicleContainerLowFrequency_descr_;
extern const ASN_BERdescriptor_t CamParameters_lowFrequencyContainer_ber_;
extern const TTCN_Typedescriptor_t CamParameters_lowFrequencyContainer_descr_;
extern const TTCN_JSONdescriptor_t SpecialVehicleContainer_json_;
extern const TTCN_Typedescriptor_t SpecialVehicleContainer_descr_;
extern const ASN_BERdescriptor_t PublicTransportContainer_embarkationStatus_ber_;
extern const TTCN_Typedescriptor_t PublicTransportContainer_embarkationStatus_descr_;
extern const TTCN_JSONdescriptor_t PublicTransportContainer_json_;
extern const TTCN_Typedescriptor_t PublicTransportContainer_descr_;
extern const ASN_BERdescriptor_t PublicTransportContainer_ptActivation_ber_;
extern const TTCN_Typedescriptor_t PublicTransportContainer_ptActivation_descr_;
extern const ASN_BERdescriptor_t SpecialVehicleContainer_publicTransportContainer_ber_;
extern const TTCN_Typedescriptor_t SpecialVehicleContainer_publicTransportContainer_descr_;
extern const ASN_BERdescriptor_t SpecialTransportContainer_specialTransportType_ber_;
extern const TTCN_Typedescriptor_t SpecialTransportContainer_specialTransportType_descr_;
extern const ASN_BERdescriptor_t SpecialTransportContainer_lightBarSirenInUse_ber_;
extern const TTCN_Typedescriptor_t SpecialTransportContainer_lightBarSirenInUse_descr_;
extern const TTCN_JSONdescriptor_t SpecialTransportContainer_json_;
extern const TTCN_Typedescriptor_t SpecialTransportContainer_descr_;
extern const ASN_BERdescriptor_t SpecialVehicleContainer_specialTransportContainer_ber_;
extern const TTCN_Typedescriptor_t SpecialVehicleContainer_specialTransportContainer_descr_;
extern const ASN_BERdescriptor_t DangerousGoodsContainer_dangerousGoodsBasic_ber_;
extern const TTCN_Typedescriptor_t DangerousGoodsContainer_dangerousGoodsBasic_descr_;
extern const TTCN_JSONdescriptor_t DangerousGoodsContainer_json_;
extern const TTCN_Typedescriptor_t DangerousGoodsContainer_descr_;
extern const ASN_BERdescriptor_t SpecialVehicleContainer_dangerousGoodsContainer_ber_;
extern const TTCN_Typedescriptor_t SpecialVehicleContainer_dangerousGoodsContainer_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerBasic_lightBarSirenInUse_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerBasic_lightBarSirenInUse_descr_;
extern const TTCN_JSONdescriptor_t RoadWorksContainerBasic_json_;
extern const TTCN_Typedescriptor_t RoadWorksContainerBasic_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerBasic_roadworksSubCauseCode_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerBasic_roadworksSubCauseCode_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerBasic_closedLanes_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerBasic_closedLanes_descr_;
extern const ASN_BERdescriptor_t SpecialVehicleContainer_roadWorksContainerBasic_ber_;
extern const TTCN_Typedescriptor_t SpecialVehicleContainer_roadWorksContainerBasic_descr_;
extern const ASN_BERdescriptor_t RescueContainer_lightBarSirenInUse_ber_;
extern const TTCN_Typedescriptor_t RescueContainer_lightBarSirenInUse_descr_;
extern const TTCN_JSONdescriptor_t RescueContainer_json_;
extern const TTCN_Typedescriptor_t RescueContainer_descr_;
extern const ASN_BERdescriptor_t SpecialVehicleContainer_rescueContainer_ber_;
extern const TTCN_Typedescriptor_t SpecialVehicleContainer_rescueContainer_descr_;
extern const ASN_BERdescriptor_t EmergencyContainer_lightBarSirenInUse_ber_;
extern const TTCN_Typedescriptor_t EmergencyContainer_lightBarSirenInUse_descr_;
extern const TTCN_JSONdescriptor_t EmergencyContainer_json_;
extern const TTCN_Typedescriptor_t EmergencyContainer_descr_;
extern const ASN_BERdescriptor_t EmergencyContainer_incidentIndication_ber_;
extern const TTCN_Typedescriptor_t EmergencyContainer_incidentIndication_descr_;
extern const ASN_BERdescriptor_t EmergencyContainer_emergencyPriority_ber_;
extern const TTCN_Typedescriptor_t EmergencyContainer_emergencyPriority_descr_;
extern const ASN_BERdescriptor_t SpecialVehicleContainer_emergencyContainer_ber_;
extern const TTCN_Typedescriptor_t SpecialVehicleContainer_emergencyContainer_descr_;
extern const ASN_BERdescriptor_t SafetyCarContainer_lightBarSirenInUse_ber_;
extern const TTCN_Typedescriptor_t SafetyCarContainer_lightBarSirenInUse_descr_;
extern const TTCN_JSONdescriptor_t SafetyCarContainer_json_;
extern const TTCN_Typedescriptor_t SafetyCarContainer_descr_;
extern const ASN_BERdescriptor_t SafetyCarContainer_incidentIndication_ber_;
extern const TTCN_Typedescriptor_t SafetyCarContainer_incidentIndication_descr_;
extern const ASN_BERdescriptor_t SafetyCarContainer_trafficRule_ber_;
extern const TTCN_Typedescriptor_t SafetyCarContainer_trafficRule_descr_;
extern const ASN_BERdescriptor_t SafetyCarContainer_speedLimit_ber_;
extern const TTCN_Typedescriptor_t SafetyCarContainer_speedLimit_descr_;
extern const ASN_BERdescriptor_t SpecialVehicleContainer_safetyCarContainer_ber_;
extern const TTCN_Typedescriptor_t SpecialVehicleContainer_safetyCarContainer_descr_;
extern const ASN_BERdescriptor_t CamParameters_specialVehicleContainer_ber_;
extern const TTCN_Typedescriptor_t CamParameters_specialVehicleContainer_descr_;
extern const ASN_BERdescriptor_t CoopAwareness_camParameters_ber_;
extern const TTCN_Typedescriptor_t CoopAwareness_camParameters_descr_;
extern const TTCN_JSONdescriptor_t CoopAwareness_json_;
extern const TTCN_Typedescriptor_t CoopAwareness_descr_;
extern const ASN_BERdescriptor_t CAM_cam_ber_;
extern const TTCN_Typedescriptor_t CAM_cam_descr_;
extern const TTCN_JSONdescriptor_t CAM_json_;
extern const TTCN_Typedescriptor_t CAM_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
