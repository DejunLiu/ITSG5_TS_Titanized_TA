// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "TTCN_EncDec.hh"

namespace TTCN__EncDec {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const unsigned char bs_0_bits[] = { 1 };
static const BITSTRING bs_0(1, bs_0_bits);
static const unsigned char os_7_octets[] = { 0 },
os_0_octets[] = { 1 },
os_1_octets[] = { 2 },
os_2_octets[] = { 80 },
os_3_octets[] = { 81 },
os_4_octets[] = { 82 },
os_5_octets[] = { 83 },
os_6_octets[] = { 84 };
static const OCTETSTRING os_7(1, os_7_octets),
os_0(1, os_0_octets),
os_1(1, os_1_octets),
os_2(1, os_2_octets),
os_3(1, os_3_octets),
os_4(1, os_4_octets),
os_5(1, os_5_octets),
os_6(1, os_6_octets);
static const unsigned char module_checksum[] = { 0x4c, 0xde, 0xeb, 0x63, 0x22, 0x34, 0x7d, 0xde, 0xc4, 0x39, 0x4a, 0x43, 0x6c, 0x66, 0x69, 0xcf };

/* Global variable definitions */

const TTCN_RAWdescriptor_t BIT1_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,1};
const XERdescriptor_t       BIT1_xer_ = { {"BIT1>\n", "BIT1>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BIT1_descr_ = { "@TTCN_EncDec.BIT1", &BITSTRING_ber_, &BIT1_raw_, NULL, &BIT1_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BIT6_raw_ = {6,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,6};
const XERdescriptor_t       BIT6_xer_ = { {"BIT6>\n", "BIT6>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BIT6_descr_ = { "@TTCN_EncDec.BIT6", &BITSTRING_ber_, &BIT6_raw_, NULL, &BIT6_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtTrafficClass_scf_xer_ = { {"scf>\n", "scf>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtTrafficClass_scf_descr_ = { "@TTCN_EncDec.ExtTrafficClass.scf", &BITSTRING_ber_, &BIT1_raw_, NULL, &ExtTrafficClass_scf_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtTrafficClass_channelOffload_xer_ = { {"channelOffload>\n", "channelOffload>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtTrafficClass_channelOffload_descr_ = { "@TTCN_EncDec.ExtTrafficClass.channelOffload", &BITSTRING_ber_, &BIT1_raw_, NULL, &ExtTrafficClass_channelOffload_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtTrafficClass_tcId_xer_ = { {"tcId>\n", "tcId>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtTrafficClass_tcId_descr_ = { "@TTCN_EncDec.ExtTrafficClass.tcId", &BITSTRING_ber_, &BIT6_raw_, NULL, &ExtTrafficClass_tcId_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtTrafficClass_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtTrafficClass
const TTCN_JSONdescriptor_t ExtTrafficClass_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtTrafficClass_descr_ = { "@TTCN_EncDec.ExtTrafficClass", NULL, &ExtTrafficClass_raw_, NULL, NULL, &ExtTrafficClass_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtGnPayload_rawPayload_xer_ = { {"rawPayload>\n", "rawPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGnPayload_rawPayload_descr_ = { "@TTCN_EncDec.ExtGnPayload.rawPayload", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ExtGnPayload_rawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGnPayload
const TTCN_JSONdescriptor_t ExtGnPayload_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtGnPayload_descr_ = { "@TTCN_EncDec.ExtGnPayload", NULL, &ExtGnPayload_raw_, NULL, NULL, &ExtGnPayload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtGenerateGeoBroadcastMessage_shape_xer_ = { {"shape>\n", "shape>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_shape_descr_ = { "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage.shape", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtGenerateGeoBroadcastMessage_shape_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtGenerateGeoBroadcastMessage_lifetime_xer_ = { {"lifetime>\n", "lifetime>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_lifetime_descr_ = { "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage.lifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &ExtGenerateGeoBroadcastMessage_lifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtGenerateGeoBroadcastMessage_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_reserved_descr_ = { "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt24_raw_, &INTEGER_text_, &ExtGenerateGeoBroadcastMessage_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGenerateGeoBroadcastMessage_payloadLength_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGenerateGeoBroadcastMessage_payloadLength_xer_ = { {"payloadLength>\n", "payloadLength>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_payloadLength_descr_ = { "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage.payloadLength", &INTEGER_ber_, &ExtGenerateGeoBroadcastMessage_payloadLength_raw_, &INTEGER_text_, &ExtGenerateGeoBroadcastMessage_payloadLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGenerateGeoBroadcastMessage_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGenerateGeoBroadcastMessage
const TTCN_JSONdescriptor_t ExtGenerateGeoBroadcastMessage_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_descr_ = { "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage", NULL, &ExtGenerateGeoBroadcastMessage_raw_, NULL, NULL, &ExtGenerateGeoBroadcastMessage_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BIT8_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,8};
const XERdescriptor_t       BIT8_xer_ = { {"BIT8>\n", "BIT8>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BIT8_descr_ = { "@TTCN_EncDec.BIT8", &BITSTRING_ber_, &BIT8_raw_, NULL, &BIT8_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtPtActivation_ptActivationType_xer_ = { {"ptActivationType>\n", "ptActivationType>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtPtActivation_ptActivationType_descr_ = { "@TTCN_EncDec.ExtPtActivation.ptActivationType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtPtActivation_ptActivationType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtPtActivation_ptActivationDataLength_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtPtActivation_ptActivationDataLength_xer_ = { {"ptActivationDataLength>\n", "ptActivationDataLength>\n"}, {24, 24}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtPtActivation_ptActivationDataLength_descr_ = { "@TTCN_EncDec.ExtPtActivation.ptActivationDataLength", &INTEGER_ber_, &ExtPtActivation_ptActivationDataLength_raw_, &INTEGER_text_, &ExtPtActivation_ptActivationDataLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtPtActivation_ptActivationData_xer_ = { {"ptActivationData>\n", "ptActivationData>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtPtActivation_ptActivationData_descr_ = { "@TTCN_EncDec.ExtPtActivation.ptActivationData", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ExtPtActivation_ptActivationData_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtPtActivation_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtPtActivation
const TTCN_JSONdescriptor_t ExtPtActivation_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtPtActivation_descr_ = { "@TTCN_EncDec.ExtPtActivation", NULL, &ExtPtActivation_raw_, NULL, NULL, &ExtPtActivation_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtCamTrigger_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtUtCamTrigger
const TTCN_JSONdescriptor_t ExtUtCamTrigger_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtUtCamTrigger_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger", NULL, &ExtUtCamTrigger_raw_, NULL, NULL, &ExtUtCamTrigger_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_changeCurvature_xer_ = { {"changeCurvature>\n", "changeCurvature>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_changeCurvature_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.changeCurvature", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int16_raw_, &INTEGER_text_, &ExtUtCamTrigger_changeCurvature_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_changeSpeed_xer_ = { {"changeSpeed>\n", "changeSpeed>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_changeSpeed_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.changeSpeed", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int16_raw_, &INTEGER_text_, &ExtUtCamTrigger_changeSpeed_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_setAccelerationControlStatus_xer_ = { {"setAccelerationControlStatus>\n", "setAccelerationControlStatus>\n"}, {30, 30}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_setAccelerationControlStatus_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.setAccelerationControlStatus", &BITSTRING_ber_, &BIT8_raw_, NULL, &ExtUtCamTrigger_setAccelerationControlStatus_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_setExteriorLightsStatus_xer_ = { {"setExteriorLightsStatus>\n", "setExteriorLightsStatus>\n"}, {25, 25}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_setExteriorLightsStatus_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.setExteriorLightsStatus", &BITSTRING_ber_, &BIT8_raw_, NULL, &ExtUtCamTrigger_setExteriorLightsStatus_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_changeHeading_xer_ = { {"changeHeading>\n", "changeHeading>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_changeHeading_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.changeHeading", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &ExtUtCamTrigger_changeHeading_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_setDriveDirection_xer_ = { {"setDriveDirection>\n", "setDriveDirection>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_setDriveDirection_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.setDriveDirection", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtUtCamTrigger_setDriveDirection_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_changeYawRate_xer_ = { {"changeYawRate>\n", "changeYawRate>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_changeYawRate_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.changeYawRate", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int16_raw_, &INTEGER_text_, &ExtUtCamTrigger_changeYawRate_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_setStationType_xer_ = { {"setStationType>\n", "setStationType>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_setStationType_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.setStationType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtUtCamTrigger_setStationType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_setVehicleRole_xer_ = { {"setVehicleRole>\n", "setVehicleRole>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_setVehicleRole_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.setVehicleRole", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtUtCamTrigger_setVehicleRole_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_setEmbarkationStatus_xer_ = { {"setEmbarkationStatus>\n", "setEmbarkationStatus>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_setEmbarkationStatus_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.setEmbarkationStatus", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtUtCamTrigger_setEmbarkationStatus_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_setDangerousGoods_xer_ = { {"setDangerousGoods>\n", "setDangerousGoods>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_setDangerousGoods_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.setDangerousGoods", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtUtCamTrigger_setDangerousGoods_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamTrigger_setLightBarSirene_xer_ = { {"setLightBarSirene>\n", "setLightBarSirene>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamTrigger_setLightBarSirene_descr_ = { "@TTCN_EncDec.ExtUtCamTrigger.setLightBarSirene", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtUtCamTrigger_setLightBarSirene_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtCamEventInd_camPduLength_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtCamEventInd_camPduLength_xer_ = { {"camPduLength>\n", "camPduLength>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamEventInd_camPduLength_descr_ = { "@TTCN_EncDec.ExtUtCamEventInd.camPduLength", &INTEGER_ber_, &ExtUtCamEventInd_camPduLength_raw_, &INTEGER_text_, &ExtUtCamEventInd_camPduLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtCamEventInd_camMsg_xer_ = { {"camMsg>\n", "camMsg>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtCamEventInd_camMsg_descr_ = { "@TTCN_EncDec.ExtUtCamEventInd.camMsg", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ExtUtCamEventInd_camMsg_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtCamEventInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtUtCamEventInd
const TTCN_JSONdescriptor_t ExtUtCamEventInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtUtCamEventInd_descr_ = { "@TTCN_EncDec.ExtUtCamEventInd", NULL, &ExtUtCamEventInd_raw_, NULL, NULL, &ExtUtCamEventInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtSituationContainer_informationQuality_xer_ = { {"informationQuality>\n", "informationQuality>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtSituationContainer_informationQuality_descr_ = { "@TTCN_EncDec.ExtSituationContainer.informationQuality", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtSituationContainer_informationQuality_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtSituationContainer_causeCode_xer_ = { {"causeCode>\n", "causeCode>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtSituationContainer_causeCode_descr_ = { "@TTCN_EncDec.ExtSituationContainer.causeCode", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtSituationContainer_causeCode_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtSituationContainer_subCauseCode_xer_ = { {"subCauseCode>\n", "subCauseCode>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtSituationContainer_subCauseCode_descr_ = { "@TTCN_EncDec.ExtSituationContainer.subCauseCode", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtSituationContainer_subCauseCode_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtSituationContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtSituationContainer
const TTCN_JSONdescriptor_t ExtSituationContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtSituationContainer_descr_ = { "@TTCN_EncDec.ExtSituationContainer", NULL, &ExtSituationContainer_raw_, NULL, NULL, &ExtSituationContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtAlacarteContainer_TODO_xer_ = { {"TODO>\n", "TODO>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtAlacarteContainer_TODO_descr_ = { "@TTCN_EncDec.ExtAlacarteContainer.TODO", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtAlacarteContainer_TODO_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtAlacarteContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtAlacarteContainer
const TTCN_JSONdescriptor_t ExtAlacarteContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtAlacarteContainer_descr_ = { "@TTCN_EncDec.ExtAlacarteContainer", NULL, &ExtAlacarteContainer_raw_, NULL, NULL, &ExtAlacarteContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_bitmask_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmTrigger_bitmask_xer_ = { {"bitmask>\n", "bitmask>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_bitmask_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger.bitmask", &INTEGER_ber_, &ExtUtDenmTrigger_bitmask_raw_, &INTEGER_text_, &ExtUtDenmTrigger_bitmask_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_detectionTime_raw_ = {48,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmTrigger_detectionTime_xer_ = { {"detectionTime>\n", "detectionTime>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_detectionTime_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger.detectionTime", &INTEGER_ber_, &ExtUtDenmTrigger_detectionTime_raw_, &INTEGER_text_, &ExtUtDenmTrigger_detectionTime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_relevanceDistance_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmTrigger_relevanceDistance_xer_ = { {"relevanceDistance>\n", "relevanceDistance>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_relevanceDistance_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger.relevanceDistance", &INTEGER_ber_, &ExtUtDenmTrigger_relevanceDistance_raw_, &INTEGER_text_, &ExtUtDenmTrigger_relevanceDistance_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_relevanceTrafficDirection_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmTrigger_relevanceTrafficDirection_xer_ = { {"relevanceTrafficDirection>\n", "relevanceTrafficDirection>\n"}, {27, 27}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_relevanceTrafficDirection_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger.relevanceTrafficDirection", &INTEGER_ber_, &ExtUtDenmTrigger_relevanceTrafficDirection_raw_, &INTEGER_text_, &ExtUtDenmTrigger_relevanceTrafficDirection_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtUtDenmTrigger
const TTCN_JSONdescriptor_t ExtUtDenmTrigger_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger", NULL, &ExtUtDenmTrigger_raw_, NULL, NULL, &ExtUtDenmTrigger_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_validityDuration_raw_ = {24,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmTrigger_validityDuration_xer_ = { {"validityDuration>\n", "validityDuration>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_validityDuration_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger.validityDuration", &INTEGER_ber_, &ExtUtDenmTrigger_validityDuration_raw_, &INTEGER_text_, &ExtUtDenmTrigger_validityDuration_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_repetitionDuration_raw_ = {24,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmTrigger_repetitionDuration_xer_ = { {"repetitionDuration>\n", "repetitionDuration>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_repetitionDuration_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger.repetitionDuration", &INTEGER_ber_, &ExtUtDenmTrigger_repetitionDuration_raw_, &INTEGER_text_, &ExtUtDenmTrigger_repetitionDuration_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_transmissionInterval_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmTrigger_transmissionInterval_xer_ = { {"transmissionInterval>\n", "transmissionInterval>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_transmissionInterval_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger.transmissionInterval", &INTEGER_ber_, &ExtUtDenmTrigger_transmissionInterval_raw_, &INTEGER_text_, &ExtUtDenmTrigger_transmissionInterval_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_repetitionInterval_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmTrigger_repetitionInterval_xer_ = { {"repetitionInterval>\n", "repetitionInterval>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_repetitionInterval_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger.repetitionInterval", &INTEGER_ber_, &ExtUtDenmTrigger_repetitionInterval_raw_, &INTEGER_text_, &ExtUtDenmTrigger_repetitionInterval_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmTrigger_alacarteLength_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmTrigger_alacarteLength_xer_ = { {"alacarteLength>\n", "alacarteLength>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmTrigger_alacarteLength_descr_ = { "@TTCN_EncDec.ExtUtDenmTrigger.alacarteLength", &INTEGER_ber_, &ExtUtDenmTrigger_alacarteLength_raw_, &INTEGER_text_, &ExtUtDenmTrigger_alacarteLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtActionID_originatingStationID_xer_ = { {"originatingStationID>\n", "originatingStationID>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtActionID_originatingStationID_descr_ = { "@TTCN_EncDec.ExtActionID.originatingStationID", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &ExtActionID_originatingStationID_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtActionID_sequenceNumber_xer_ = { {"sequenceNumber>\n", "sequenceNumber>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtActionID_sequenceNumber_descr_ = { "@TTCN_EncDec.ExtActionID.sequenceNumber", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &ExtActionID_sequenceNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtActionID_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtActionID
const TTCN_JSONdescriptor_t ExtActionID_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtActionID_descr_ = { "@TTCN_EncDec.ExtActionID", NULL, &ExtActionID_raw_, NULL, NULL, &ExtActionID_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmUpdate_bitmask_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmUpdate_bitmask_xer_ = { {"bitmask>\n", "bitmask>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmUpdate_bitmask_descr_ = { "@TTCN_EncDec.ExtUtDenmUpdate.bitmask", &INTEGER_ber_, &ExtUtDenmUpdate_bitmask_raw_, &INTEGER_text_, &ExtUtDenmUpdate_bitmask_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmUpdate_detectionTime_raw_ = {48,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmUpdate_detectionTime_xer_ = { {"detectionTime>\n", "detectionTime>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmUpdate_detectionTime_descr_ = { "@TTCN_EncDec.ExtUtDenmUpdate.detectionTime", &INTEGER_ber_, &ExtUtDenmUpdate_detectionTime_raw_, &INTEGER_text_, &ExtUtDenmUpdate_detectionTime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmUpdate_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtUtDenmUpdate
const TTCN_JSONdescriptor_t ExtUtDenmUpdate_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtUtDenmUpdate_descr_ = { "@TTCN_EncDec.ExtUtDenmUpdate", NULL, &ExtUtDenmUpdate_raw_, NULL, NULL, &ExtUtDenmUpdate_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmUpdate_validityDuration_raw_ = {24,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmUpdate_validityDuration_xer_ = { {"validityDuration>\n", "validityDuration>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmUpdate_validityDuration_descr_ = { "@TTCN_EncDec.ExtUtDenmUpdate.validityDuration", &INTEGER_ber_, &ExtUtDenmUpdate_validityDuration_raw_, &INTEGER_text_, &ExtUtDenmUpdate_validityDuration_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmUpdate_relevanceDistance_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmUpdate_relevanceDistance_xer_ = { {"relevanceDistance>\n", "relevanceDistance>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmUpdate_relevanceDistance_descr_ = { "@TTCN_EncDec.ExtUtDenmUpdate.relevanceDistance", &INTEGER_ber_, &ExtUtDenmUpdate_relevanceDistance_raw_, &INTEGER_text_, &ExtUtDenmUpdate_relevanceDistance_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmUpdate_relevanceTrafficDirection_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmUpdate_relevanceTrafficDirection_xer_ = { {"relevanceTrafficDirection>\n", "relevanceTrafficDirection>\n"}, {27, 27}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmUpdate_relevanceTrafficDirection_descr_ = { "@TTCN_EncDec.ExtUtDenmUpdate.relevanceTrafficDirection", &INTEGER_ber_, &ExtUtDenmUpdate_relevanceTrafficDirection_raw_, &INTEGER_text_, &ExtUtDenmUpdate_relevanceTrafficDirection_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmUpdate_transmissionInterval_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmUpdate_transmissionInterval_xer_ = { {"transmissionInterval>\n", "transmissionInterval>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmUpdate_transmissionInterval_descr_ = { "@TTCN_EncDec.ExtUtDenmUpdate.transmissionInterval", &INTEGER_ber_, &ExtUtDenmUpdate_transmissionInterval_raw_, &INTEGER_text_, &ExtUtDenmUpdate_transmissionInterval_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmUpdate_repetitionInterval_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmUpdate_repetitionInterval_xer_ = { {"repetitionInterval>\n", "repetitionInterval>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmUpdate_repetitionInterval_descr_ = { "@TTCN_EncDec.ExtUtDenmUpdate.repetitionInterval", &INTEGER_ber_, &ExtUtDenmUpdate_repetitionInterval_raw_, &INTEGER_text_, &ExtUtDenmUpdate_repetitionInterval_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmUpdate_alacarteLength_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmUpdate_alacarteLength_xer_ = { {"alacarteLength>\n", "alacarteLength>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmUpdate_alacarteLength_descr_ = { "@TTCN_EncDec.ExtUtDenmUpdate.alacarteLength", &INTEGER_ber_, &ExtUtDenmUpdate_alacarteLength_raw_, &INTEGER_text_, &ExtUtDenmUpdate_alacarteLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtDenmInd_gnNextHeader_xer_ = { {"gnNextHeader>\n", "gnNextHeader>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtDenmInd_gnNextHeader_descr_ = { "@TTCN_EncDec.ExtDenmInd.gnNextHeader", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtDenmInd_gnNextHeader_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtDenmInd_gnHeaderType_xer_ = { {"gnHeaderType>\n", "gnHeaderType>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtDenmInd_gnHeaderType_descr_ = { "@TTCN_EncDec.ExtDenmInd.gnHeaderType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtDenmInd_gnHeaderType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtDenmInd_gnHeaderSubtype_xer_ = { {"gnHeaderSubtype>\n", "gnHeaderSubtype>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtDenmInd_gnHeaderSubtype_descr_ = { "@TTCN_EncDec.ExtDenmInd.gnHeaderSubtype", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtDenmInd_gnHeaderSubtype_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtDenmInd_gnLifetime_xer_ = { {"gnLifetime>\n", "gnLifetime>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtDenmInd_gnLifetime_descr_ = { "@TTCN_EncDec.ExtDenmInd.gnLifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &ExtDenmInd_gnLifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtDenmInd_gnTrafficClass_xer_ = { {"gnTrafficClass>\n", "gnTrafficClass>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtDenmInd_gnTrafficClass_descr_ = { "@TTCN_EncDec.ExtDenmInd.gnTrafficClass", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtDenmInd_gnTrafficClass_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtDenmInd_btpDestinationPort_xer_ = { {"btpDestinationPort>\n", "btpDestinationPort>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtDenmInd_btpDestinationPort_descr_ = { "@TTCN_EncDec.ExtDenmInd.btpDestinationPort", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &ExtDenmInd_btpDestinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtDenmInd_btpInfo_xer_ = { {"btpInfo>\n", "btpInfo>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtDenmInd_btpInfo_descr_ = { "@TTCN_EncDec.ExtDenmInd.btpInfo", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &ExtDenmInd_btpInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtDenmInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtDenmInd
const TTCN_JSONdescriptor_t ExtDenmInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtDenmInd_descr_ = { "@TTCN_EncDec.ExtDenmInd", NULL, &ExtDenmInd_raw_, NULL, NULL, &ExtDenmInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmEventInd_denmPduLength_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtDenmEventInd_denmPduLength_xer_ = { {"denmPduLength>\n", "denmPduLength>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmEventInd_denmPduLength_descr_ = { "@TTCN_EncDec.ExtUtDenmEventInd.denmPduLength", &INTEGER_ber_, &ExtUtDenmEventInd_denmPduLength_raw_, &INTEGER_text_, &ExtUtDenmEventInd_denmPduLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtDenmEventInd_denMsg_xer_ = { {"denMsg>\n", "denMsg>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtDenmEventInd_denMsg_descr_ = { "@TTCN_EncDec.ExtUtDenmEventInd.denMsg", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ExtUtDenmEventInd_denMsg_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtDenmEventInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtUtDenmEventInd
const TTCN_JSONdescriptor_t ExtUtDenmEventInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtUtDenmEventInd_descr_ = { "@TTCN_EncDec.ExtUtDenmEventInd", NULL, &ExtUtDenmEventInd_raw_, NULL, NULL, &ExtUtDenmEventInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtMapEventInd_mapPduLength_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtMapEventInd_mapPduLength_xer_ = { {"mapPduLength>\n", "mapPduLength>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtMapEventInd_mapPduLength_descr_ = { "@TTCN_EncDec.ExtUtMapEventInd.mapPduLength", &INTEGER_ber_, &ExtUtMapEventInd_mapPduLength_raw_, &INTEGER_text_, &ExtUtMapEventInd_mapPduLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtMapEventInd_mapMsg_xer_ = { {"mapMsg>\n", "mapMsg>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtMapEventInd_mapMsg_descr_ = { "@TTCN_EncDec.ExtUtMapEventInd.mapMsg", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ExtUtMapEventInd_mapMsg_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtMapEventInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtUtMapEventInd
const TTCN_JSONdescriptor_t ExtUtMapEventInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtUtMapEventInd_descr_ = { "@TTCN_EncDec.ExtUtMapEventInd", NULL, &ExtUtMapEventInd_raw_, NULL, NULL, &ExtUtMapEventInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtSpatEventInd_spatPduLength_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtUtSpatEventInd_spatPduLength_xer_ = { {"spatPduLength>\n", "spatPduLength>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtSpatEventInd_spatPduLength_descr_ = { "@TTCN_EncDec.ExtUtSpatEventInd.spatPduLength", &INTEGER_ber_, &ExtUtSpatEventInd_spatPduLength_raw_, &INTEGER_text_, &ExtUtSpatEventInd_spatPduLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtUtSpatEventInd_spatMsg_xer_ = { {"spatMsg>\n", "spatMsg>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtUtSpatEventInd_spatMsg_descr_ = { "@TTCN_EncDec.ExtUtSpatEventInd.spatMsg", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ExtUtSpatEventInd_spatMsg_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtUtSpatEventInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtUtSpatEventInd
const TTCN_JSONdescriptor_t ExtUtSpatEventInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtUtSpatEventInd_descr_ = { "@TTCN_EncDec.ExtUtSpatEventInd", NULL, &ExtUtSpatEventInd_raw_, NULL, NULL, &ExtUtSpatEventInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtBtpPayload_rawPayload_xer_ = { {"rawPayload>\n", "rawPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtBtpPayload_rawPayload_descr_ = { "@TTCN_EncDec.ExtBtpPayload.rawPayload", &OCTETSTRING_ber_, &LibItsBtp__TypesAndValues::BtpRawPayload_raw_, &OCTETSTRING_text_, &ExtBtpPayload_rawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtBtpPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtBtpPayload
const TTCN_JSONdescriptor_t ExtBtpPayload_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtBtpPayload_descr_ = { "@TTCN_EncDec.ExtBtpPayload", NULL, &ExtBtpPayload_raw_, NULL, NULL, &ExtBtpPayload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtBtpReq_nextheader_xer_ = { {"nextheader>\n", "nextheader>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtBtpReq_nextheader_descr_ = { "@TTCN_EncDec.ExtBtpReq.nextheader", &OCTETSTRING_ber_, &General__Types::OCT1_raw_, &OCTETSTRING_text_, &ExtBtpReq_nextheader_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtBtpReq_header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtBtpReq_header
const TTCN_Typedescriptor_t ExtBtpReq_header_descr_ = { "@TTCN_EncDec.ExtBtpReq.header", NULL, &ExtBtpReq_header_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtBtpReq_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtBtpReq
const TTCN_JSONdescriptor_t ExtBtpReq_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtBtpReq_descr_ = { "@TTCN_EncDec.ExtBtpReq", NULL, &ExtBtpReq_raw_, NULL, NULL, &ExtBtpReq_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtBtpInd_nextheader_xer_ = { {"nextheader>\n", "nextheader>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtBtpInd_nextheader_descr_ = { "@TTCN_EncDec.ExtBtpInd.nextheader", &OCTETSTRING_ber_, &General__Types::OCT1_raw_, &OCTETSTRING_text_, &ExtBtpInd_nextheader_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtBtpInd_header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtBtpInd_header
const TTCN_Typedescriptor_t ExtBtpInd_header_descr_ = { "@TTCN_EncDec.ExtBtpInd.header", NULL, &ExtBtpInd_header_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtBtpInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtBtpInd
const TTCN_JSONdescriptor_t ExtBtpInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtBtpInd_descr_ = { "@TTCN_EncDec.ExtBtpInd", NULL, &ExtBtpInd_raw_, NULL, NULL, &ExtBtpInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtBtpInd_rawPayload_xer_ = { {"rawPayload>\n", "rawPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtBtpInd_rawPayload_descr_ = { "@TTCN_EncDec.ExtBtpInd.rawPayload", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ExtBtpInd_rawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtCamInd_gnNextHeader_xer_ = { {"gnNextHeader>\n", "gnNextHeader>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtCamInd_gnNextHeader_descr_ = { "@TTCN_EncDec.ExtCamInd.gnNextHeader", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtCamInd_gnNextHeader_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtCamInd_gnHeaderType_xer_ = { {"gnHeaderType>\n", "gnHeaderType>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtCamInd_gnHeaderType_descr_ = { "@TTCN_EncDec.ExtCamInd.gnHeaderType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtCamInd_gnHeaderType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtCamInd_gnHeaderSubtype_xer_ = { {"gnHeaderSubtype>\n", "gnHeaderSubtype>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtCamInd_gnHeaderSubtype_descr_ = { "@TTCN_EncDec.ExtCamInd.gnHeaderSubtype", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtCamInd_gnHeaderSubtype_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtCamInd_gnLifetime_xer_ = { {"gnLifetime>\n", "gnLifetime>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtCamInd_gnLifetime_descr_ = { "@TTCN_EncDec.ExtCamInd.gnLifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &ExtCamInd_gnLifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtCamInd_gnTrafficClass_xer_ = { {"gnTrafficClass>\n", "gnTrafficClass>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtCamInd_gnTrafficClass_descr_ = { "@TTCN_EncDec.ExtCamInd.gnTrafficClass", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtCamInd_gnTrafficClass_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtCamInd_btpDestinationPort_xer_ = { {"btpDestinationPort>\n", "btpDestinationPort>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtCamInd_btpDestinationPort_descr_ = { "@TTCN_EncDec.ExtCamInd.btpDestinationPort", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &ExtCamInd_btpDestinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtCamInd_btpInfo_xer_ = { {"btpInfo>\n", "btpInfo>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtCamInd_btpInfo_descr_ = { "@TTCN_EncDec.ExtCamInd.btpInfo", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &ExtCamInd_btpInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtCamInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtCamInd
const TTCN_JSONdescriptor_t ExtCamInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtCamInd_descr_ = { "@TTCN_EncDec.ExtCamInd", NULL, &ExtCamInd_raw_, NULL, NULL, &ExtCamInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MapSpatInd
const TTCN_Typedescriptor_t MapSpatInd_descr_ = { "@TTCN_EncDec.MapSpatInd", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtMapSpatInd_gnNextHeader_xer_ = { {"gnNextHeader>\n", "gnNextHeader>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtMapSpatInd_gnNextHeader_descr_ = { "@TTCN_EncDec.ExtMapSpatInd.gnNextHeader", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtMapSpatInd_gnNextHeader_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtMapSpatInd_gnHeaderType_xer_ = { {"gnHeaderType>\n", "gnHeaderType>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtMapSpatInd_gnHeaderType_descr_ = { "@TTCN_EncDec.ExtMapSpatInd.gnHeaderType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtMapSpatInd_gnHeaderType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtMapSpatInd_gnHeaderSubtype_xer_ = { {"gnHeaderSubtype>\n", "gnHeaderSubtype>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtMapSpatInd_gnHeaderSubtype_descr_ = { "@TTCN_EncDec.ExtMapSpatInd.gnHeaderSubtype", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtMapSpatInd_gnHeaderSubtype_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtMapSpatInd_gnLifetime_xer_ = { {"gnLifetime>\n", "gnLifetime>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtMapSpatInd_gnLifetime_descr_ = { "@TTCN_EncDec.ExtMapSpatInd.gnLifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &ExtMapSpatInd_gnLifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtMapSpatInd_gnTrafficClass_xer_ = { {"gnTrafficClass>\n", "gnTrafficClass>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtMapSpatInd_gnTrafficClass_descr_ = { "@TTCN_EncDec.ExtMapSpatInd.gnTrafficClass", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ExtMapSpatInd_gnTrafficClass_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtMapSpatInd_btpDestinationPort_xer_ = { {"btpDestinationPort>\n", "btpDestinationPort>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtMapSpatInd_btpDestinationPort_descr_ = { "@TTCN_EncDec.ExtMapSpatInd.btpDestinationPort", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &ExtMapSpatInd_btpDestinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtMapSpatInd_btpInfo_xer_ = { {"btpInfo>\n", "btpInfo>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtMapSpatInd_btpInfo_descr_ = { "@TTCN_EncDec.ExtMapSpatInd.btpInfo", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &ExtMapSpatInd_btpInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtMapSpatInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtMapSpatInd
const TTCN_JSONdescriptor_t ExtMapSpatInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtMapSpatInd_descr_ = { "@TTCN_EncDec.ExtMapSpatInd", NULL, &ExtMapSpatInd_raw_, NULL, NULL, &ExtMapSpatInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_nextHeader_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGnNonSecuredPacket_nextHeader
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_nextHeader_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.nextHeader", NULL, &ExtGnNonSecuredPacket_nextHeader_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_reserved_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGnNonSecuredPacket_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_reserved_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.reserved", &INTEGER_ber_, &ExtGnNonSecuredPacket_reserved_raw_, &INTEGER_text_, &ExtGnNonSecuredPacket_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_headerTST_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGnNonSecuredPacket_headerTST_xer_ = { {"headerTST>\n", "headerTST>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_headerTST_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.headerTST", &INTEGER_ber_, &ExtGnNonSecuredPacket_headerTST_raw_, &INTEGER_text_, &ExtGnNonSecuredPacket_headerTST_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_trafficClass_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGnNonSecuredPacket_trafficClass
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_trafficClass_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.trafficClass", NULL, &ExtGnNonSecuredPacket_trafficClass_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_flags_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,8};
const XERdescriptor_t       ExtGnNonSecuredPacket_flags_xer_ = { {"flags>\n", "flags>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_flags_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.flags", &BITSTRING_ber_, &ExtGnNonSecuredPacket_flags_raw_, NULL, &ExtGnNonSecuredPacket_flags_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_plLength_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGnNonSecuredPacket_plLength_xer_ = { {"plLength>\n", "plLength>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_plLength_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.plLength", &INTEGER_ber_, &ExtGnNonSecuredPacket_plLength_raw_, &INTEGER_text_, &ExtGnNonSecuredPacket_plLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_maxHopLimit_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGnNonSecuredPacket_maxHopLimit_xer_ = { {"maxHopLimit>\n", "maxHopLimit>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_maxHopLimit_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.maxHopLimit", &INTEGER_ber_, &ExtGnNonSecuredPacket_maxHopLimit_raw_, &INTEGER_text_, &ExtGnNonSecuredPacket_maxHopLimit_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_reserved2_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGnNonSecuredPacket_reserved2_xer_ = { {"reserved2>\n", "reserved2>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_reserved2_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.reserved2", &INTEGER_ber_, &ExtGnNonSecuredPacket_reserved2_raw_, &INTEGER_text_, &ExtGnNonSecuredPacket_reserved2_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_extendedHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGnNonSecuredPacket_extendedHeader
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_extendedHeader_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.extendedHeader", NULL, &ExtGnNonSecuredPacket_extendedHeader_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_rawPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGnNonSecuredPacket_rawPayload_xer_ = { {"rawPayload>\n", "rawPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_rawPayload_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.rawPayload", &OCTETSTRING_ber_, &ExtGnNonSecuredPacket_rawPayload_raw_, &OCTETSTRING_text_, &ExtGnNonSecuredPacket_rawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGnNonSecuredPacket
const TTCN_JSONdescriptor_t ExtGnNonSecuredPacket_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket", NULL, &ExtGnNonSecuredPacket_raw_, NULL, NULL, &ExtGnNonSecuredPacket_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_ipv6Packet_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGnNonSecuredPacket_ipv6Packet
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_ipv6Packet_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.ipv6Packet", NULL, &ExtGnNonSecuredPacket_ipv6Packet_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_btpHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGnNonSecuredPacket_btpHeader
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_btpHeader_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.btpHeader", NULL, &ExtGnNonSecuredPacket_btpHeader_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_btpPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGnNonSecuredPacket_btpPayload_xer_ = { {"btpPayload>\n", "btpPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_btpPayload_descr_ = { "@TTCN_EncDec.ExtGnNonSecuredPacket.btpPayload", &OCTETSTRING_ber_, &ExtGnNonSecuredPacket_btpPayload_raw_, &OCTETSTRING_text_, &ExtGnNonSecuredPacket_btpPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_version_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGeoNetworkingPdu_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_version_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingPdu.version", &INTEGER_ber_, &ExtGeoNetworkingPdu_version_raw_, &INTEGER_text_, &ExtGeoNetworkingPdu_version_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_nextHeader_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGeoNetworkingPdu_nextHeader
const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_nextHeader_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingPdu.nextHeader", NULL, &ExtGeoNetworkingPdu_nextHeader_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_reserved_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGeoNetworkingPdu_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_reserved_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingPdu.reserved", &INTEGER_ber_, &ExtGeoNetworkingPdu_reserved_raw_, &INTEGER_text_, &ExtGeoNetworkingPdu_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_lifeTime_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGeoNetworkingPdu_lifeTime
const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_lifeTime_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingPdu.lifeTime", NULL, &ExtGeoNetworkingPdu_lifeTime_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_routerHopLimit_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtGeoNetworkingPdu_routerHopLimit_xer_ = { {"routerHopLimit>\n", "routerHopLimit>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_routerHopLimit_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingPdu.routerHopLimit", &INTEGER_ber_, &ExtGeoNetworkingPdu_routerHopLimit_raw_, &INTEGER_text_, &ExtGeoNetworkingPdu_routerHopLimit_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGeoNetworkingPdu
const TTCN_JSONdescriptor_t ExtGeoNetworkingPdu_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingPdu", NULL, &ExtGeoNetworkingPdu_raw_, NULL, NULL, &ExtGeoNetworkingPdu_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_packet_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGeoNetworkingPdu_packet
const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_packet_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingPdu.packet", NULL, &ExtGeoNetworkingPdu_packet_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_securedMsg_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGeoNetworkingPdu_securedMsg
const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_securedMsg_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingPdu.securedMsg", NULL, &ExtGeoNetworkingPdu_securedMsg_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingInd_msgIn_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGeoNetworkingInd_msgIn
const TTCN_Typedescriptor_t ExtGeoNetworkingInd_msgIn_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingInd.msgIn", NULL, &ExtGeoNetworkingInd_msgIn_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ExtGeoNetworkingInd_macDestinationAddress_xer_ = { {"macDestinationAddress>\n", "macDestinationAddress>\n"}, {23, 23}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtGeoNetworkingInd_macDestinationAddress_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingInd.macDestinationAddress", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct6_raw_, &OCTETSTRING_text_, &ExtGeoNetworkingInd_macDestinationAddress_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtGeoNetworkingInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtGeoNetworkingInd
const TTCN_JSONdescriptor_t ExtGeoNetworkingInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtGeoNetworkingInd_descr_ = { "@TTCN_EncDec.ExtGeoNetworkingInd", NULL, &ExtGeoNetworkingInd_raw_, NULL, NULL, &ExtGeoNetworkingInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 0;
TTCN_Module module_object("TTCN_EncDec", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

ExtTrafficClass::ExtTrafficClass()
{
  bound_flag = FALSE;
}

ExtTrafficClass::ExtTrafficClass(const BITSTRING& par_scf,
    const BITSTRING& par_channelOffload,
    const BITSTRING& par_tcId)
  :   field_scf(par_scf),
  field_channelOffload(par_channelOffload),
  field_tcId(par_tcId)
{
  bound_flag = TRUE;
}

ExtTrafficClass::ExtTrafficClass(const ExtTrafficClass& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtTrafficClass.");
bound_flag = TRUE;
if (other_value.scf().is_bound()) field_scf = other_value.scf();
else field_scf.clean_up();
if (other_value.channelOffload().is_bound()) field_channelOffload = other_value.channelOffload();
else field_channelOffload.clean_up();
if (other_value.tcId().is_bound()) field_tcId = other_value.tcId();
else field_tcId.clean_up();
}

void ExtTrafficClass::clean_up()
{
field_scf.clean_up();
field_channelOffload.clean_up();
field_tcId.clean_up();
bound_flag = FALSE;
}

ExtTrafficClass& ExtTrafficClass::operator=(const ExtTrafficClass& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtTrafficClass.");
  bound_flag = TRUE;
  if (other_value.scf().is_bound()) field_scf = other_value.scf();
  else field_scf.clean_up();
  if (other_value.channelOffload().is_bound()) field_channelOffload = other_value.channelOffload();
  else field_channelOffload.clean_up();
  if (other_value.tcId().is_bound()) field_tcId = other_value.tcId();
  else field_tcId.clean_up();
}
return *this;
}

boolean ExtTrafficClass::operator==(const ExtTrafficClass& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_scf==other_value.field_scf
  && field_channelOffload==other_value.field_channelOffload
  && field_tcId==other_value.field_tcId;
}

boolean ExtTrafficClass::is_bound() const
{
if (bound_flag) return TRUE;
if(field_scf.is_bound()) return TRUE;
if(field_channelOffload.is_bound()) return TRUE;
if(field_tcId.is_bound()) return TRUE;
return FALSE;
}
boolean ExtTrafficClass::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_scf.is_value()) return FALSE;
if(!field_channelOffload.is_value()) return FALSE;
if(!field_tcId.is_value()) return FALSE;
return TRUE;
}
int ExtTrafficClass::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtTrafficClass");
  return 3;
}

void ExtTrafficClass::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ scf := ");
field_scf.log();
TTCN_Logger::log_event_str(", channelOffload := ");
field_channelOffload.log();
TTCN_Logger::log_event_str(", tcId := ");
field_tcId.log();
TTCN_Logger::log_event_str(" }");
}

void ExtTrafficClass::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtTrafficClass'");
    }
    if (strcmp("scf", param_field) == 0) {
      scf().set_param(param);
      return;
    } else if (strcmp("channelOffload", param_field) == 0) {
      channelOffload().set_param(param);
      return;
    } else if (strcmp("tcId", param_field) == 0) {
      tcId().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtTrafficClass'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtTrafficClass has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) scf().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) channelOffload().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) tcId().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "scf")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          scf().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "channelOffload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          channelOffload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tcId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tcId().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtTrafficClass: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtTrafficClass");
  }
}

Module_Param* ExtTrafficClass::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtTrafficClass'");
    }
    if (strcmp("scf", param_field) == 0) {
      return scf().get_param(param_name);
    } else if (strcmp("channelOffload", param_field) == 0) {
      return channelOffload().get_param(param_name);
    } else if (strcmp("tcId", param_field) == 0) {
      return tcId().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtTrafficClass'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_scf = field_scf.get_param(param_name);
  mp_field_scf->set_id(new Module_Param_FieldName(mcopystr("scf")));
  mp->add_elem(mp_field_scf);
  Module_Param* mp_field_channelOffload = field_channelOffload.get_param(param_name);
  mp_field_channelOffload->set_id(new Module_Param_FieldName(mcopystr("channelOffload")));
  mp->add_elem(mp_field_channelOffload);
  Module_Param* mp_field_tcId = field_tcId.get_param(param_name);
  mp_field_tcId->set_id(new Module_Param_FieldName(mcopystr("tcId")));
  mp->add_elem(mp_field_tcId);
  return mp;
  }

void ExtTrafficClass::set_implicit_omit()
{
if (scf().is_bound()) scf().set_implicit_omit();
if (channelOffload().is_bound()) channelOffload().set_implicit_omit();
if (tcId().is_bound()) tcId().set_implicit_omit();
}

void ExtTrafficClass::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtTrafficClass.");
field_scf.encode_text(text_buf);
field_channelOffload.encode_text(text_buf);
field_tcId.encode_text(text_buf);
}

void ExtTrafficClass::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_scf.decode_text(text_buf);
field_channelOffload.decode_text(text_buf);
field_tcId.decode_text(text_buf);
}

void ExtTrafficClass::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtTrafficClass::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtTrafficClass::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_scf.RAW_decode(BIT1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_channelOffload.RAW_decode(BIT1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_tcId.RAW_decode(BIT6_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtTrafficClass::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BIT1_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, BIT1_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, BIT6_descr_.raw);
  encoded_length += field_scf.RAW_encode(BIT1_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_channelOffload.RAW_encode(BIT1_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_tcId.RAW_encode(BIT6_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int ExtTrafficClass::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtTrafficClass.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "scf");
    enc_len += field_scf.JSON_encode(BIT1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "channelOffload");
    enc_len += field_channelOffload.JSON_encode(BIT1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "tcId");
    enc_len += field_tcId.JSON_encode(BIT6_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtTrafficClass::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "scf", name_len)) {
         int ret_val = field_scf.JSON_decode(BIT1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "scf");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "channelOffload", name_len)) {
         int ret_val = field_channelOffload.JSON_decode(BIT1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "channelOffload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "tcId", name_len)) {
         int ret_val = field_tcId.JSON_decode(BIT6_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "tcId");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_scf.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "scf");
    return JSON_ERROR_FATAL;
  }
if (!field_channelOffload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "channelOffload");
    return JSON_ERROR_FATAL;
  }
if (!field_tcId.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "tcId");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtTrafficClass_template::single_value_struct {
BITSTRING_template field_scf;
BITSTRING_template field_channelOffload;
BITSTRING_template field_tcId;
};

void ExtTrafficClass_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_scf = ANY_VALUE;
single_value->field_channelOffload = ANY_VALUE;
single_value->field_tcId = ANY_VALUE;
}
}
}

void ExtTrafficClass_template::copy_value(const ExtTrafficClass& other_value)
{
single_value = new single_value_struct;
if (other_value.scf().is_bound()) {
  single_value->field_scf = other_value.scf();
} else {
  single_value->field_scf.clean_up();
}
if (other_value.channelOffload().is_bound()) {
  single_value->field_channelOffload = other_value.channelOffload();
} else {
  single_value->field_channelOffload.clean_up();
}
if (other_value.tcId().is_bound()) {
  single_value->field_tcId = other_value.tcId();
} else {
  single_value->field_tcId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtTrafficClass_template::copy_template(const ExtTrafficClass_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.scf().get_selection()) {
single_value->field_scf = other_value.scf();
} else {
single_value->field_scf.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.channelOffload().get_selection()) {
single_value->field_channelOffload = other_value.channelOffload();
} else {
single_value->field_channelOffload.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.tcId().get_selection()) {
single_value->field_tcId = other_value.tcId();
} else {
single_value->field_tcId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtTrafficClass_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtTrafficClass.");
break;
}
set_selection(other_value);
}

ExtTrafficClass_template::ExtTrafficClass_template()
{
}

ExtTrafficClass_template::ExtTrafficClass_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtTrafficClass_template::ExtTrafficClass_template(const ExtTrafficClass& other_value)
{
copy_value(other_value);
}

ExtTrafficClass_template::ExtTrafficClass_template(const OPTIONAL<ExtTrafficClass>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtTrafficClass&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtTrafficClass from an unbound optional field.");
}
}

ExtTrafficClass_template::ExtTrafficClass_template(const ExtTrafficClass_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtTrafficClass_template::~ExtTrafficClass_template()
{
clean_up();
}

ExtTrafficClass_template& ExtTrafficClass_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtTrafficClass_template& ExtTrafficClass_template::operator=(const ExtTrafficClass& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtTrafficClass_template& ExtTrafficClass_template::operator=(const OPTIONAL<ExtTrafficClass>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtTrafficClass&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtTrafficClass.");
}
return *this;
}

ExtTrafficClass_template& ExtTrafficClass_template::operator=(const ExtTrafficClass_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtTrafficClass_template::match(const ExtTrafficClass& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.scf().is_bound()) return FALSE;
if(!single_value->field_scf.match(other_value.scf(), legacy))return FALSE;
if(!other_value.channelOffload().is_bound()) return FALSE;
if(!single_value->field_channelOffload.match(other_value.channelOffload(), legacy))return FALSE;
if(!other_value.tcId().is_bound()) return FALSE;
if(!single_value->field_tcId.match(other_value.tcId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtTrafficClass.");
}
return FALSE;
}

boolean ExtTrafficClass_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_scf.is_bound()) return TRUE;
if (single_value->field_channelOffload.is_bound()) return TRUE;
if (single_value->field_tcId.is_bound()) return TRUE;
return FALSE;
}

boolean ExtTrafficClass_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_scf.is_value()) return FALSE;
if (!single_value->field_channelOffload.is_value()) return FALSE;
if (!single_value->field_tcId.is_value()) return FALSE;
return TRUE;
}

void ExtTrafficClass_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtTrafficClass ExtTrafficClass_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtTrafficClass.");
ExtTrafficClass ret_val;
if (single_value->field_scf.is_bound()) {
ret_val.scf() = single_value->field_scf.valueof();
}
if (single_value->field_channelOffload.is_bound()) {
ret_val.channelOffload() = single_value->field_channelOffload.valueof();
}
if (single_value->field_tcId.is_bound()) {
ret_val.tcId() = single_value->field_tcId.valueof();
}
return ret_val;
}

void ExtTrafficClass_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtTrafficClass.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtTrafficClass_template[list_length];
}

ExtTrafficClass_template& ExtTrafficClass_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtTrafficClass.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtTrafficClass.");
return value_list.list_value[list_index];
}

BITSTRING_template& ExtTrafficClass_template::scf()
{
set_specific();
return single_value->field_scf;
}

const BITSTRING_template& ExtTrafficClass_template::scf() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field scf of a non-specific template of type @TTCN_EncDec.ExtTrafficClass.");
return single_value->field_scf;
}

BITSTRING_template& ExtTrafficClass_template::channelOffload()
{
set_specific();
return single_value->field_channelOffload;
}

const BITSTRING_template& ExtTrafficClass_template::channelOffload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field channelOffload of a non-specific template of type @TTCN_EncDec.ExtTrafficClass.");
return single_value->field_channelOffload;
}

BITSTRING_template& ExtTrafficClass_template::tcId()
{
set_specific();
return single_value->field_tcId;
}

const BITSTRING_template& ExtTrafficClass_template::tcId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field tcId of a non-specific template of type @TTCN_EncDec.ExtTrafficClass.");
return single_value->field_tcId;
}

int ExtTrafficClass_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtTrafficClass which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtTrafficClass containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtTrafficClass containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtTrafficClass containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtTrafficClass containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtTrafficClass containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtTrafficClass.");
  }
  return 0;
}

void ExtTrafficClass_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ scf := ");
single_value->field_scf.log();
TTCN_Logger::log_event_str(", channelOffload := ");
single_value->field_channelOffload.log();
TTCN_Logger::log_event_str(", tcId := ");
single_value->field_tcId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtTrafficClass_template::log_match(const ExtTrafficClass& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_scf.match(match_value.scf(), legacy)){
TTCN_Logger::log_logmatch_info(".scf");
single_value->field_scf.log_match(match_value.scf(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_channelOffload.match(match_value.channelOffload(), legacy)){
TTCN_Logger::log_logmatch_info(".channelOffload");
single_value->field_channelOffload.log_match(match_value.channelOffload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_tcId.match(match_value.tcId(), legacy)){
TTCN_Logger::log_logmatch_info(".tcId");
single_value->field_tcId.log_match(match_value.tcId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ scf := ");
single_value->field_scf.log_match(match_value.scf(), legacy);
TTCN_Logger::log_event_str(", channelOffload := ");
single_value->field_channelOffload.log_match(match_value.channelOffload(), legacy);
TTCN_Logger::log_event_str(", tcId := ");
single_value->field_tcId.log_match(match_value.tcId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtTrafficClass_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_scf.encode_text(text_buf);
single_value->field_channelOffload.encode_text(text_buf);
single_value->field_tcId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtTrafficClass.");
}
}

void ExtTrafficClass_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_scf.decode_text(text_buf);
single_value->field_channelOffload.decode_text(text_buf);
single_value->field_tcId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtTrafficClass_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtTrafficClass.");
}
}

void ExtTrafficClass_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtTrafficClass'");
    }
    if (strcmp("scf", param_field) == 0) {
      scf().set_param(param);
      return;
    } else if (strcmp("channelOffload", param_field) == 0) {
      channelOffload().set_param(param);
      return;
    } else if (strcmp("tcId", param_field) == 0) {
      tcId().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtTrafficClass'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtTrafficClass_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtTrafficClass has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) scf().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) channelOffload().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) tcId().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "scf")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          scf().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "channelOffload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          channelOffload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tcId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tcId().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtTrafficClass: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtTrafficClass");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtTrafficClass_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtTrafficClass'");
    }
    if (strcmp("scf", param_field) == 0) {
      return scf().get_param(param_name);
    } else if (strcmp("channelOffload", param_field) == 0) {
      return channelOffload().get_param(param_name);
    } else if (strcmp("tcId", param_field) == 0) {
      return tcId().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtTrafficClass'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_scf = single_value->field_scf.get_param(param_name);
    mp_field_scf->set_id(new Module_Param_FieldName(mcopystr("scf")));
    mp->add_elem(mp_field_scf);
    Module_Param* mp_field_channelOffload = single_value->field_channelOffload.get_param(param_name);
    mp_field_channelOffload->set_id(new Module_Param_FieldName(mcopystr("channelOffload")));
    mp->add_elem(mp_field_channelOffload);
    Module_Param* mp_field_tcId = single_value->field_tcId.get_param(param_name);
    mp_field_tcId->set_id(new Module_Param_FieldName(mcopystr("tcId")));
    mp->add_elem(mp_field_tcId);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtTrafficClass_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_scf.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtTrafficClass");
single_value->field_channelOffload.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtTrafficClass");
single_value->field_tcId.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtTrafficClass");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtTrafficClass");
}

boolean ExtTrafficClass_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtTrafficClass_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtGnPayload::ExtGnPayload()
{
  bound_flag = FALSE;
}

ExtGnPayload::ExtGnPayload(const OCTETSTRING& par_rawPayload)
  :   field_rawPayload(par_rawPayload)
{
  bound_flag = TRUE;
}

ExtGnPayload::ExtGnPayload(const ExtGnPayload& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtGnPayload.");
bound_flag = TRUE;
if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
else field_rawPayload.clean_up();
}

void ExtGnPayload::clean_up()
{
field_rawPayload.clean_up();
bound_flag = FALSE;
}

ExtGnPayload& ExtGnPayload::operator=(const ExtGnPayload& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtGnPayload.");
  bound_flag = TRUE;
  if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
  else field_rawPayload.clean_up();
}
return *this;
}

boolean ExtGnPayload::operator==(const ExtGnPayload& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_rawPayload==other_value.field_rawPayload;
}

boolean ExtGnPayload::is_bound() const
{
if (bound_flag) return TRUE;
if(field_rawPayload.is_bound()) return TRUE;
return FALSE;
}
boolean ExtGnPayload::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_rawPayload.is_value()) return FALSE;
return TRUE;
}
int ExtGnPayload::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtGnPayload");
  return 1;
}

void ExtGnPayload::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ rawPayload := ");
field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
}

void ExtGnPayload::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtGnPayload'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtGnPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtGnPayload has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGnPayload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtGnPayload");
  }
}

Module_Param* ExtGnPayload::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtGnPayload'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGnPayload'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_rawPayload = field_rawPayload.get_param(param_name);
  mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
  mp->add_elem(mp_field_rawPayload);
  return mp;
  }

void ExtGnPayload::set_implicit_omit()
{
if (rawPayload().is_bound()) rawPayload().set_implicit_omit();
}

void ExtGnPayload::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtGnPayload.");
field_rawPayload.encode_text(text_buf);
}

void ExtGnPayload::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_rawPayload.decode_text(text_buf);
}

void ExtGnPayload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtGnPayload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtGnPayload::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_rawPayload.RAW_decode(OCTETSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtGnPayload::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, OCTETSTRING_descr_.raw);
  encoded_length += field_rawPayload.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int ExtGnPayload::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtGnPayload.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rawPayload");
    enc_len += field_rawPayload.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtGnPayload::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "rawPayload", name_len)) {
         int ret_val = field_rawPayload.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rawPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_rawPayload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rawPayload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtGnPayload_template::single_value_struct {
OCTETSTRING_template field_rawPayload;
};

void ExtGnPayload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_rawPayload = ANY_VALUE;
}
}
}

void ExtGnPayload_template::copy_value(const ExtGnPayload& other_value)
{
single_value = new single_value_struct;
if (other_value.rawPayload().is_bound()) {
  single_value->field_rawPayload = other_value.rawPayload();
} else {
  single_value->field_rawPayload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtGnPayload_template::copy_template(const ExtGnPayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.rawPayload().get_selection()) {
single_value->field_rawPayload = other_value.rawPayload();
} else {
single_value->field_rawPayload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtGnPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtGnPayload.");
break;
}
set_selection(other_value);
}

ExtGnPayload_template::ExtGnPayload_template()
{
}

ExtGnPayload_template::ExtGnPayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtGnPayload_template::ExtGnPayload_template(const ExtGnPayload& other_value)
{
copy_value(other_value);
}

ExtGnPayload_template::ExtGnPayload_template(const OPTIONAL<ExtGnPayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGnPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtGnPayload from an unbound optional field.");
}
}

ExtGnPayload_template::ExtGnPayload_template(const ExtGnPayload_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtGnPayload_template::~ExtGnPayload_template()
{
clean_up();
}

ExtGnPayload_template& ExtGnPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtGnPayload_template& ExtGnPayload_template::operator=(const ExtGnPayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtGnPayload_template& ExtGnPayload_template::operator=(const OPTIONAL<ExtGnPayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGnPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtGnPayload.");
}
return *this;
}

ExtGnPayload_template& ExtGnPayload_template::operator=(const ExtGnPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtGnPayload_template::match(const ExtGnPayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.rawPayload().is_bound()) return FALSE;
if(!single_value->field_rawPayload.match(other_value.rawPayload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtGnPayload.");
}
return FALSE;
}

boolean ExtGnPayload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_rawPayload.is_bound()) return TRUE;
return FALSE;
}

boolean ExtGnPayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_rawPayload.is_value()) return FALSE;
return TRUE;
}

void ExtGnPayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtGnPayload ExtGnPayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtGnPayload.");
ExtGnPayload ret_val;
if (single_value->field_rawPayload.is_bound()) {
ret_val.rawPayload() = single_value->field_rawPayload.valueof();
}
return ret_val;
}

void ExtGnPayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtGnPayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtGnPayload_template[list_length];
}

ExtGnPayload_template& ExtGnPayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtGnPayload.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtGnPayload.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& ExtGnPayload_template::rawPayload()
{
set_specific();
return single_value->field_rawPayload;
}

const OCTETSTRING_template& ExtGnPayload_template::rawPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawPayload of a non-specific template of type @TTCN_EncDec.ExtGnPayload.");
return single_value->field_rawPayload;
}

int ExtGnPayload_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnPayload which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnPayload containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnPayload containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnPayload containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnPayload containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnPayload containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtGnPayload.");
  }
  return 0;
}

void ExtGnPayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ rawPayload := ");
single_value->field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtGnPayload_template::log_match(const ExtGnPayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_rawPayload.match(match_value.rawPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".rawPayload");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ rawPayload := ");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtGnPayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_rawPayload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtGnPayload.");
}
}

void ExtGnPayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_rawPayload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtGnPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtGnPayload.");
}
}

void ExtGnPayload_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtGnPayload'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtGnPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtGnPayload_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtGnPayload has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGnPayload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtGnPayload");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtGnPayload_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtGnPayload'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGnPayload'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_rawPayload = single_value->field_rawPayload.get_param(param_name);
    mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
    mp->add_elem(mp_field_rawPayload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtGnPayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_rawPayload.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnPayload");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtGnPayload");
}

boolean ExtGnPayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtGnPayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtGenerateGeoBroadcastMessage::ExtGenerateGeoBroadcastMessage()
{
  bound_flag = FALSE;
}

ExtGenerateGeoBroadcastMessage::ExtGenerateGeoBroadcastMessage(const INTEGER& par_shape,
    const INTEGER& par_lifetime,
    const ExtTrafficClass& par_trafficClass,
    const INTEGER& par_reserved,
    const LibItsGeoNetworking__TypesAndValues::Area& par_area,
    const INTEGER& par_payloadLength,
    const ExtGnPayload& par_payload)
  :   field_shape(par_shape),
  field_lifetime(par_lifetime),
  field_trafficClass(par_trafficClass),
  field_reserved(par_reserved),
  field_area(par_area),
  field_payloadLength(par_payloadLength),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

ExtGenerateGeoBroadcastMessage::ExtGenerateGeoBroadcastMessage(const ExtGenerateGeoBroadcastMessage& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
bound_flag = TRUE;
if (other_value.shape().is_bound()) field_shape = other_value.shape();
else field_shape.clean_up();
if (other_value.lifetime().is_bound()) field_lifetime = other_value.lifetime();
else field_lifetime.clean_up();
if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
else field_trafficClass.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.area().is_bound()) field_area = other_value.area();
else field_area.clean_up();
if (other_value.payloadLength().is_bound()) field_payloadLength = other_value.payloadLength();
else field_payloadLength.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void ExtGenerateGeoBroadcastMessage::clean_up()
{
field_shape.clean_up();
field_lifetime.clean_up();
field_trafficClass.clean_up();
field_reserved.clean_up();
field_area.clean_up();
field_payloadLength.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

ExtGenerateGeoBroadcastMessage& ExtGenerateGeoBroadcastMessage::operator=(const ExtGenerateGeoBroadcastMessage& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
  bound_flag = TRUE;
  if (other_value.shape().is_bound()) field_shape = other_value.shape();
  else field_shape.clean_up();
  if (other_value.lifetime().is_bound()) field_lifetime = other_value.lifetime();
  else field_lifetime.clean_up();
  if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
  else field_trafficClass.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.area().is_bound()) field_area = other_value.area();
  else field_area.clean_up();
  if (other_value.payloadLength().is_bound()) field_payloadLength = other_value.payloadLength();
  else field_payloadLength.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean ExtGenerateGeoBroadcastMessage::operator==(const ExtGenerateGeoBroadcastMessage& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_shape==other_value.field_shape
  && field_lifetime==other_value.field_lifetime
  && field_trafficClass==other_value.field_trafficClass
  && field_reserved==other_value.field_reserved
  && field_area==other_value.field_area
  && field_payloadLength==other_value.field_payloadLength
  && field_payload==other_value.field_payload;
}

boolean ExtGenerateGeoBroadcastMessage::is_bound() const
{
if (bound_flag) return TRUE;
if(field_shape.is_bound()) return TRUE;
if(field_lifetime.is_bound()) return TRUE;
if(field_trafficClass.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_area.is_bound()) return TRUE;
if(field_payloadLength.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean ExtGenerateGeoBroadcastMessage::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_shape.is_value()) return FALSE;
if(!field_lifetime.is_value()) return FALSE;
if(!field_trafficClass.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_area.is_value()) return FALSE;
if(!field_payloadLength.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
int ExtGenerateGeoBroadcastMessage::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
  return 7;
}

void ExtGenerateGeoBroadcastMessage::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ shape := ");
field_shape.log();
TTCN_Logger::log_event_str(", lifetime := ");
field_lifetime.log();
TTCN_Logger::log_event_str(", trafficClass := ");
field_trafficClass.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", area := ");
field_area.log();
TTCN_Logger::log_event_str(", payloadLength := ");
field_payloadLength.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void ExtGenerateGeoBroadcastMessage::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtGenerateGeoBroadcastMessage'");
    }
    if (strcmp("shape", param_field) == 0) {
      shape().set_param(param);
      return;
    } else if (strcmp("lifetime", param_field) == 0) {
      lifetime().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("area", param_field) == 0) {
      area().set_param(param);
      return;
    } else if (strcmp("payloadLength", param_field) == 0) {
      payloadLength().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtGenerateGeoBroadcastMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) shape().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lifetime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) area().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) payloadLength().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "shape")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          shape().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "area")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          area().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payloadLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payloadLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
  }
}

Module_Param* ExtGenerateGeoBroadcastMessage::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtGenerateGeoBroadcastMessage'");
    }
    if (strcmp("shape", param_field) == 0) {
      return shape().get_param(param_name);
    } else if (strcmp("lifetime", param_field) == 0) {
      return lifetime().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("area", param_field) == 0) {
      return area().get_param(param_name);
    } else if (strcmp("payloadLength", param_field) == 0) {
      return payloadLength().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGenerateGeoBroadcastMessage'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_shape = field_shape.get_param(param_name);
  mp_field_shape->set_id(new Module_Param_FieldName(mcopystr("shape")));
  mp->add_elem(mp_field_shape);
  Module_Param* mp_field_lifetime = field_lifetime.get_param(param_name);
  mp_field_lifetime->set_id(new Module_Param_FieldName(mcopystr("lifetime")));
  mp->add_elem(mp_field_lifetime);
  Module_Param* mp_field_trafficClass = field_trafficClass.get_param(param_name);
  mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
  mp->add_elem(mp_field_trafficClass);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_area = field_area.get_param(param_name);
  mp_field_area->set_id(new Module_Param_FieldName(mcopystr("area")));
  mp->add_elem(mp_field_area);
  Module_Param* mp_field_payloadLength = field_payloadLength.get_param(param_name);
  mp_field_payloadLength->set_id(new Module_Param_FieldName(mcopystr("payloadLength")));
  mp->add_elem(mp_field_payloadLength);
  Module_Param* mp_field_payload = field_payload.get_param(param_name);
  mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
  mp->add_elem(mp_field_payload);
  return mp;
  }

void ExtGenerateGeoBroadcastMessage::set_implicit_omit()
{
if (shape().is_bound()) shape().set_implicit_omit();
if (lifetime().is_bound()) lifetime().set_implicit_omit();
if (trafficClass().is_bound()) trafficClass().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (area().is_bound()) area().set_implicit_omit();
if (payloadLength().is_bound()) payloadLength().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void ExtGenerateGeoBroadcastMessage::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
field_shape.encode_text(text_buf);
field_lifetime.encode_text(text_buf);
field_trafficClass.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_area.encode_text(text_buf);
field_payloadLength.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void ExtGenerateGeoBroadcastMessage::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_shape.decode_text(text_buf);
field_lifetime.decode_text(text_buf);
field_trafficClass.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_area.decode_text(text_buf);
field_payloadLength.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void ExtGenerateGeoBroadcastMessage::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtGenerateGeoBroadcastMessage::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtGenerateGeoBroadcastMessage::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  int value_of_length_field5 = 0;
  decoded_field_length = field_shape.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_lifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trafficClass.RAW_decode(ExtTrafficClass_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt24_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_area.RAW_decode(LibItsGeoNetworking__TypesAndValues::Area_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_payloadLength.RAW_decode(ExtGenerateGeoBroadcastMessage_payloadLength_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field5+=(int)field_payloadLength*8;
  decoded_field_length = field_payload.RAW_decode(ExtGnPayload_descr_, p_buf, min_of_ints(2, limit, value_of_length_field5), local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field5 -= decoded_field_length;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtGenerateGeoBroadcastMessage::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, ExtTrafficClass_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt24_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibItsGeoNetworking__TypesAndValues::Area_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, ExtGenerateGeoBroadcastMessage_payloadLength_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, ExtGnPayload_descr_.raw);
  encoded_length += field_shape.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_lifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_trafficClass.RAW_encode(ExtTrafficClass_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt24_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_area.RAW_encode(LibItsGeoNetworking__TypesAndValues::Area_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += 16;
  myleaf.body.node.nodes[5]->calc = CALC_LENGTH;
  myleaf.body.node.nodes[5]->coding_descr = &ExtGenerateGeoBroadcastMessage_payloadLength_descr_;
  myleaf.body.node.nodes[5]->calcof.lengthto.num_of_fields = 1;
  myleaf.body.node.nodes[5]->calcof.lengthto.unit = 8;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields = init_lengthto_fields_list(1);
  myleaf.body.node.nodes[5]->length = 16;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[0].level = myleaf.body.node.nodes[6]->curr_pos.level;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[0].pos = myleaf.body.node.nodes[6]->curr_pos.pos;
  encoded_length += field_payload.RAW_encode(ExtGnPayload_descr_, *myleaf.body.node.nodes[6]);
  return myleaf.length = encoded_length;
}

int ExtGenerateGeoBroadcastMessage::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "shape");
    enc_len += field_shape.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lifetime");
    enc_len += field_lifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficClass");
    enc_len += field_trafficClass.JSON_encode(ExtTrafficClass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt24_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "area");
    enc_len += field_area.JSON_encode(LibItsGeoNetworking__TypesAndValues::Area_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payloadLength");
    enc_len += field_payloadLength.JSON_encode(ExtGenerateGeoBroadcastMessage_payloadLength_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(ExtGnPayload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtGenerateGeoBroadcastMessage::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "shape", name_len)) {
         int ret_val = field_shape.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "shape");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "lifetime", name_len)) {
         int ret_val = field_lifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "trafficClass", name_len)) {
         int ret_val = field_trafficClass.JSON_decode(ExtTrafficClass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt24_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "area", name_len)) {
         int ret_val = field_area.JSON_decode(LibItsGeoNetworking__TypesAndValues::Area_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "area");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "payloadLength", name_len)) {
         int ret_val = field_payloadLength.JSON_decode(ExtGenerateGeoBroadcastMessage_payloadLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payloadLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
         int ret_val = field_payload.JSON_decode(ExtGnPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_shape.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "shape");
    return JSON_ERROR_FATAL;
  }
if (!field_lifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_trafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_area.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "area");
    return JSON_ERROR_FATAL;
  }
if (!field_payloadLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payloadLength");
    return JSON_ERROR_FATAL;
  }
if (!field_payload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtGenerateGeoBroadcastMessage_template::single_value_struct {
INTEGER_template field_shape;
INTEGER_template field_lifetime;
ExtTrafficClass_template field_trafficClass;
INTEGER_template field_reserved;
LibItsGeoNetworking__TypesAndValues::Area_template field_area;
INTEGER_template field_payloadLength;
ExtGnPayload_template field_payload;
};

void ExtGenerateGeoBroadcastMessage_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_shape = ANY_VALUE;
single_value->field_lifetime = ANY_VALUE;
single_value->field_trafficClass = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_area = ANY_VALUE;
single_value->field_payloadLength = ANY_VALUE;
single_value->field_payload = ANY_VALUE;
}
}
}

void ExtGenerateGeoBroadcastMessage_template::copy_value(const ExtGenerateGeoBroadcastMessage& other_value)
{
single_value = new single_value_struct;
if (other_value.shape().is_bound()) {
  single_value->field_shape = other_value.shape();
} else {
  single_value->field_shape.clean_up();
}
if (other_value.lifetime().is_bound()) {
  single_value->field_lifetime = other_value.lifetime();
} else {
  single_value->field_lifetime.clean_up();
}
if (other_value.trafficClass().is_bound()) {
  single_value->field_trafficClass = other_value.trafficClass();
} else {
  single_value->field_trafficClass.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.area().is_bound()) {
  single_value->field_area = other_value.area();
} else {
  single_value->field_area.clean_up();
}
if (other_value.payloadLength().is_bound()) {
  single_value->field_payloadLength = other_value.payloadLength();
} else {
  single_value->field_payloadLength.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtGenerateGeoBroadcastMessage_template::copy_template(const ExtGenerateGeoBroadcastMessage_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.shape().get_selection()) {
single_value->field_shape = other_value.shape();
} else {
single_value->field_shape.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lifetime().get_selection()) {
single_value->field_lifetime = other_value.lifetime();
} else {
single_value->field_lifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trafficClass().get_selection()) {
single_value->field_trafficClass = other_value.trafficClass();
} else {
single_value->field_trafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.area().get_selection()) {
single_value->field_area = other_value.area();
} else {
single_value->field_area.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payloadLength().get_selection()) {
single_value->field_payloadLength = other_value.payloadLength();
} else {
single_value->field_payloadLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtGenerateGeoBroadcastMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
break;
}
set_selection(other_value);
}

ExtGenerateGeoBroadcastMessage_template::ExtGenerateGeoBroadcastMessage_template()
{
}

ExtGenerateGeoBroadcastMessage_template::ExtGenerateGeoBroadcastMessage_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtGenerateGeoBroadcastMessage_template::ExtGenerateGeoBroadcastMessage_template(const ExtGenerateGeoBroadcastMessage& other_value)
{
copy_value(other_value);
}

ExtGenerateGeoBroadcastMessage_template::ExtGenerateGeoBroadcastMessage_template(const OPTIONAL<ExtGenerateGeoBroadcastMessage>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGenerateGeoBroadcastMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage from an unbound optional field.");
}
}

ExtGenerateGeoBroadcastMessage_template::ExtGenerateGeoBroadcastMessage_template(const ExtGenerateGeoBroadcastMessage_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtGenerateGeoBroadcastMessage_template::~ExtGenerateGeoBroadcastMessage_template()
{
clean_up();
}

ExtGenerateGeoBroadcastMessage_template& ExtGenerateGeoBroadcastMessage_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtGenerateGeoBroadcastMessage_template& ExtGenerateGeoBroadcastMessage_template::operator=(const ExtGenerateGeoBroadcastMessage& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtGenerateGeoBroadcastMessage_template& ExtGenerateGeoBroadcastMessage_template::operator=(const OPTIONAL<ExtGenerateGeoBroadcastMessage>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGenerateGeoBroadcastMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
}
return *this;
}

ExtGenerateGeoBroadcastMessage_template& ExtGenerateGeoBroadcastMessage_template::operator=(const ExtGenerateGeoBroadcastMessage_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtGenerateGeoBroadcastMessage_template::match(const ExtGenerateGeoBroadcastMessage& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.shape().is_bound()) return FALSE;
if(!single_value->field_shape.match(other_value.shape(), legacy))return FALSE;
if(!other_value.lifetime().is_bound()) return FALSE;
if(!single_value->field_lifetime.match(other_value.lifetime(), legacy))return FALSE;
if(!other_value.trafficClass().is_bound()) return FALSE;
if(!single_value->field_trafficClass.match(other_value.trafficClass(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.area().is_bound()) return FALSE;
if(!single_value->field_area.match(other_value.area(), legacy))return FALSE;
if(!other_value.payloadLength().is_bound()) return FALSE;
if(!single_value->field_payloadLength.match(other_value.payloadLength(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
}
return FALSE;
}

boolean ExtGenerateGeoBroadcastMessage_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_shape.is_bound()) return TRUE;
if (single_value->field_lifetime.is_bound()) return TRUE;
if (single_value->field_trafficClass.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_area.is_bound()) return TRUE;
if (single_value->field_payloadLength.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean ExtGenerateGeoBroadcastMessage_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_shape.is_value()) return FALSE;
if (!single_value->field_lifetime.is_value()) return FALSE;
if (!single_value->field_trafficClass.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_area.is_value()) return FALSE;
if (!single_value->field_payloadLength.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void ExtGenerateGeoBroadcastMessage_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtGenerateGeoBroadcastMessage ExtGenerateGeoBroadcastMessage_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
ExtGenerateGeoBroadcastMessage ret_val;
if (single_value->field_shape.is_bound()) {
ret_val.shape() = single_value->field_shape.valueof();
}
if (single_value->field_lifetime.is_bound()) {
ret_val.lifetime() = single_value->field_lifetime.valueof();
}
if (single_value->field_trafficClass.is_bound()) {
ret_val.trafficClass() = single_value->field_trafficClass.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_area.is_bound()) {
ret_val.area() = single_value->field_area.valueof();
}
if (single_value->field_payloadLength.is_bound()) {
ret_val.payloadLength() = single_value->field_payloadLength.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void ExtGenerateGeoBroadcastMessage_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtGenerateGeoBroadcastMessage_template[list_length];
}

ExtGenerateGeoBroadcastMessage_template& ExtGenerateGeoBroadcastMessage_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtGenerateGeoBroadcastMessage_template::shape()
{
set_specific();
return single_value->field_shape;
}

const INTEGER_template& ExtGenerateGeoBroadcastMessage_template::shape() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field shape of a non-specific template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
return single_value->field_shape;
}

INTEGER_template& ExtGenerateGeoBroadcastMessage_template::lifetime()
{
set_specific();
return single_value->field_lifetime;
}

const INTEGER_template& ExtGenerateGeoBroadcastMessage_template::lifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lifetime of a non-specific template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
return single_value->field_lifetime;
}

ExtTrafficClass_template& ExtGenerateGeoBroadcastMessage_template::trafficClass()
{
set_specific();
return single_value->field_trafficClass;
}

const ExtTrafficClass_template& ExtGenerateGeoBroadcastMessage_template::trafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficClass of a non-specific template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
return single_value->field_trafficClass;
}

INTEGER_template& ExtGenerateGeoBroadcastMessage_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& ExtGenerateGeoBroadcastMessage_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
return single_value->field_reserved;
}

LibItsGeoNetworking__TypesAndValues::Area_template& ExtGenerateGeoBroadcastMessage_template::area()
{
set_specific();
return single_value->field_area;
}

const LibItsGeoNetworking__TypesAndValues::Area_template& ExtGenerateGeoBroadcastMessage_template::area() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field area of a non-specific template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
return single_value->field_area;
}

INTEGER_template& ExtGenerateGeoBroadcastMessage_template::payloadLength()
{
set_specific();
return single_value->field_payloadLength;
}

const INTEGER_template& ExtGenerateGeoBroadcastMessage_template::payloadLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payloadLength of a non-specific template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
return single_value->field_payloadLength;
}

ExtGnPayload_template& ExtGenerateGeoBroadcastMessage_template::payload()
{
set_specific();
return single_value->field_payload;
}

const ExtGnPayload_template& ExtGenerateGeoBroadcastMessage_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
return single_value->field_payload;
}

int ExtGenerateGeoBroadcastMessage_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 7;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
  }
  return 0;
}

void ExtGenerateGeoBroadcastMessage_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ shape := ");
single_value->field_shape.log();
TTCN_Logger::log_event_str(", lifetime := ");
single_value->field_lifetime.log();
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", area := ");
single_value->field_area.log();
TTCN_Logger::log_event_str(", payloadLength := ");
single_value->field_payloadLength.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtGenerateGeoBroadcastMessage_template::log_match(const ExtGenerateGeoBroadcastMessage& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_shape.match(match_value.shape(), legacy)){
TTCN_Logger::log_logmatch_info(".shape");
single_value->field_shape.log_match(match_value.shape(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lifetime.match(match_value.lifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".lifetime");
single_value->field_lifetime.log_match(match_value.lifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trafficClass.match(match_value.trafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficClass");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_area.match(match_value.area(), legacy)){
TTCN_Logger::log_logmatch_info(".area");
single_value->field_area.log_match(match_value.area(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payloadLength.match(match_value.payloadLength(), legacy)){
TTCN_Logger::log_logmatch_info(".payloadLength");
single_value->field_payloadLength.log_match(match_value.payloadLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ shape := ");
single_value->field_shape.log_match(match_value.shape(), legacy);
TTCN_Logger::log_event_str(", lifetime := ");
single_value->field_lifetime.log_match(match_value.lifetime(), legacy);
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", area := ");
single_value->field_area.log_match(match_value.area(), legacy);
TTCN_Logger::log_event_str(", payloadLength := ");
single_value->field_payloadLength.log_match(match_value.payloadLength(), legacy);
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtGenerateGeoBroadcastMessage_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_shape.encode_text(text_buf);
single_value->field_lifetime.encode_text(text_buf);
single_value->field_trafficClass.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_area.encode_text(text_buf);
single_value->field_payloadLength.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
}
}

void ExtGenerateGeoBroadcastMessage_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_shape.decode_text(text_buf);
single_value->field_lifetime.decode_text(text_buf);
single_value->field_trafficClass.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_area.decode_text(text_buf);
single_value->field_payloadLength.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtGenerateGeoBroadcastMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage.");
}
}

void ExtGenerateGeoBroadcastMessage_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtGenerateGeoBroadcastMessage'");
    }
    if (strcmp("shape", param_field) == 0) {
      shape().set_param(param);
      return;
    } else if (strcmp("lifetime", param_field) == 0) {
      lifetime().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("area", param_field) == 0) {
      area().set_param(param);
      return;
    } else if (strcmp("payloadLength", param_field) == 0) {
      payloadLength().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtGenerateGeoBroadcastMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtGenerateGeoBroadcastMessage_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) shape().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lifetime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) area().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) payloadLength().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "shape")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          shape().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "area")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          area().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payloadLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payloadLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGenerateGeoBroadcastMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtGenerateGeoBroadcastMessage_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtGenerateGeoBroadcastMessage'");
    }
    if (strcmp("shape", param_field) == 0) {
      return shape().get_param(param_name);
    } else if (strcmp("lifetime", param_field) == 0) {
      return lifetime().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("area", param_field) == 0) {
      return area().get_param(param_name);
    } else if (strcmp("payloadLength", param_field) == 0) {
      return payloadLength().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGenerateGeoBroadcastMessage'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_shape = single_value->field_shape.get_param(param_name);
    mp_field_shape->set_id(new Module_Param_FieldName(mcopystr("shape")));
    mp->add_elem(mp_field_shape);
    Module_Param* mp_field_lifetime = single_value->field_lifetime.get_param(param_name);
    mp_field_lifetime->set_id(new Module_Param_FieldName(mcopystr("lifetime")));
    mp->add_elem(mp_field_lifetime);
    Module_Param* mp_field_trafficClass = single_value->field_trafficClass.get_param(param_name);
    mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
    mp->add_elem(mp_field_trafficClass);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_area = single_value->field_area.get_param(param_name);
    mp_field_area->set_id(new Module_Param_FieldName(mcopystr("area")));
    mp->add_elem(mp_field_area);
    Module_Param* mp_field_payloadLength = single_value->field_payloadLength.get_param(param_name);
    mp_field_payloadLength->set_id(new Module_Param_FieldName(mcopystr("payloadLength")));
    mp->add_elem(mp_field_payloadLength);
    Module_Param* mp_field_payload = single_value->field_payload.get_param(param_name);
    mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
    mp->add_elem(mp_field_payload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtGenerateGeoBroadcastMessage_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_shape.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
single_value->field_lifetime.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
single_value->field_trafficClass.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
single_value->field_area.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
single_value->field_payloadLength.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtGenerateGeoBroadcastMessage");
}

boolean ExtGenerateGeoBroadcastMessage_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtGenerateGeoBroadcastMessage_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtPtActivation::ExtPtActivation()
{
  bound_flag = FALSE;
}

ExtPtActivation::ExtPtActivation(const INTEGER& par_ptActivationType,
    const INTEGER& par_ptActivationDataLength,
    const OCTETSTRING& par_ptActivationData)
  :   field_ptActivationType(par_ptActivationType),
  field_ptActivationDataLength(par_ptActivationDataLength),
  field_ptActivationData(par_ptActivationData)
{
  bound_flag = TRUE;
}

ExtPtActivation::ExtPtActivation(const ExtPtActivation& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtPtActivation.");
bound_flag = TRUE;
if (other_value.ptActivationType().is_bound()) field_ptActivationType = other_value.ptActivationType();
else field_ptActivationType.clean_up();
if (other_value.ptActivationDataLength().is_bound()) field_ptActivationDataLength = other_value.ptActivationDataLength();
else field_ptActivationDataLength.clean_up();
if (other_value.ptActivationData().is_bound()) field_ptActivationData = other_value.ptActivationData();
else field_ptActivationData.clean_up();
}

void ExtPtActivation::clean_up()
{
field_ptActivationType.clean_up();
field_ptActivationDataLength.clean_up();
field_ptActivationData.clean_up();
bound_flag = FALSE;
}

ExtPtActivation& ExtPtActivation::operator=(const ExtPtActivation& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtPtActivation.");
  bound_flag = TRUE;
  if (other_value.ptActivationType().is_bound()) field_ptActivationType = other_value.ptActivationType();
  else field_ptActivationType.clean_up();
  if (other_value.ptActivationDataLength().is_bound()) field_ptActivationDataLength = other_value.ptActivationDataLength();
  else field_ptActivationDataLength.clean_up();
  if (other_value.ptActivationData().is_bound()) field_ptActivationData = other_value.ptActivationData();
  else field_ptActivationData.clean_up();
}
return *this;
}

boolean ExtPtActivation::operator==(const ExtPtActivation& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_ptActivationType==other_value.field_ptActivationType
  && field_ptActivationDataLength==other_value.field_ptActivationDataLength
  && field_ptActivationData==other_value.field_ptActivationData;
}

boolean ExtPtActivation::is_bound() const
{
if (bound_flag) return TRUE;
if(field_ptActivationType.is_bound()) return TRUE;
if(field_ptActivationDataLength.is_bound()) return TRUE;
if(field_ptActivationData.is_bound()) return TRUE;
return FALSE;
}
boolean ExtPtActivation::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_ptActivationType.is_value()) return FALSE;
if(!field_ptActivationDataLength.is_value()) return FALSE;
if(!field_ptActivationData.is_value()) return FALSE;
return TRUE;
}
int ExtPtActivation::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtPtActivation");
  return 3;
}

void ExtPtActivation::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ ptActivationType := ");
field_ptActivationType.log();
TTCN_Logger::log_event_str(", ptActivationDataLength := ");
field_ptActivationDataLength.log();
TTCN_Logger::log_event_str(", ptActivationData := ");
field_ptActivationData.log();
TTCN_Logger::log_event_str(" }");
}

void ExtPtActivation::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtPtActivation'");
    }
    if (strcmp("ptActivationType", param_field) == 0) {
      ptActivationType().set_param(param);
      return;
    } else if (strcmp("ptActivationDataLength", param_field) == 0) {
      ptActivationDataLength().set_param(param);
      return;
    } else if (strcmp("ptActivationData", param_field) == 0) {
      ptActivationData().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtPtActivation'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtPtActivation has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ptActivationType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ptActivationDataLength().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ptActivationData().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationDataLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationDataLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtPtActivation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtPtActivation");
  }
}

Module_Param* ExtPtActivation::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtPtActivation'");
    }
    if (strcmp("ptActivationType", param_field) == 0) {
      return ptActivationType().get_param(param_name);
    } else if (strcmp("ptActivationDataLength", param_field) == 0) {
      return ptActivationDataLength().get_param(param_name);
    } else if (strcmp("ptActivationData", param_field) == 0) {
      return ptActivationData().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtPtActivation'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_ptActivationType = field_ptActivationType.get_param(param_name);
  mp_field_ptActivationType->set_id(new Module_Param_FieldName(mcopystr("ptActivationType")));
  mp->add_elem(mp_field_ptActivationType);
  Module_Param* mp_field_ptActivationDataLength = field_ptActivationDataLength.get_param(param_name);
  mp_field_ptActivationDataLength->set_id(new Module_Param_FieldName(mcopystr("ptActivationDataLength")));
  mp->add_elem(mp_field_ptActivationDataLength);
  Module_Param* mp_field_ptActivationData = field_ptActivationData.get_param(param_name);
  mp_field_ptActivationData->set_id(new Module_Param_FieldName(mcopystr("ptActivationData")));
  mp->add_elem(mp_field_ptActivationData);
  return mp;
  }

void ExtPtActivation::set_implicit_omit()
{
if (ptActivationType().is_bound()) ptActivationType().set_implicit_omit();
if (ptActivationDataLength().is_bound()) ptActivationDataLength().set_implicit_omit();
if (ptActivationData().is_bound()) ptActivationData().set_implicit_omit();
}

void ExtPtActivation::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtPtActivation.");
field_ptActivationType.encode_text(text_buf);
field_ptActivationDataLength.encode_text(text_buf);
field_ptActivationData.encode_text(text_buf);
}

void ExtPtActivation::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_ptActivationType.decode_text(text_buf);
field_ptActivationDataLength.decode_text(text_buf);
field_ptActivationData.decode_text(text_buf);
}

void ExtPtActivation::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtPtActivation::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtPtActivation::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  int value_of_length_field1 = 0;
  decoded_field_length = field_ptActivationType.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_ptActivationDataLength.RAW_decode(ExtPtActivation_ptActivationDataLength_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field1+=(int)field_ptActivationDataLength*8;
  decoded_field_length = field_ptActivationData.RAW_decode(OCTETSTRING_descr_, p_buf, min_of_ints(2, limit, value_of_length_field1), local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field1 -= decoded_field_length;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtPtActivation::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ExtPtActivation_ptActivationDataLength_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, OCTETSTRING_descr_.raw);
  encoded_length += field_ptActivationType.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += 8;
  myleaf.body.node.nodes[1]->calc = CALC_LENGTH;
  myleaf.body.node.nodes[1]->coding_descr = &ExtPtActivation_ptActivationDataLength_descr_;
  myleaf.body.node.nodes[1]->calcof.lengthto.num_of_fields = 1;
  myleaf.body.node.nodes[1]->calcof.lengthto.unit = 8;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields = init_lengthto_fields_list(1);
  myleaf.body.node.nodes[1]->length = 8;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[0].level = myleaf.body.node.nodes[2]->curr_pos.level;
  myleaf.body.node.nodes[1]->calcof.lengthto.fields[0].pos = myleaf.body.node.nodes[2]->curr_pos.pos;
  encoded_length += field_ptActivationData.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int ExtPtActivation::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtPtActivation.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ptActivationType");
    enc_len += field_ptActivationType.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ptActivationDataLength");
    enc_len += field_ptActivationDataLength.JSON_encode(ExtPtActivation_ptActivationDataLength_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ptActivationData");
    enc_len += field_ptActivationData.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtPtActivation::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (16 == name_len && 0 == strncmp(fld_name, "ptActivationType", name_len)) {
         int ret_val = field_ptActivationType.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ptActivationType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (22 == name_len && 0 == strncmp(fld_name, "ptActivationDataLength", name_len)) {
         int ret_val = field_ptActivationDataLength.JSON_decode(ExtPtActivation_ptActivationDataLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ptActivationDataLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "ptActivationData", name_len)) {
         int ret_val = field_ptActivationData.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ptActivationData");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_ptActivationType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ptActivationType");
    return JSON_ERROR_FATAL;
  }
if (!field_ptActivationDataLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ptActivationDataLength");
    return JSON_ERROR_FATAL;
  }
if (!field_ptActivationData.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ptActivationData");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtPtActivation_template::single_value_struct {
INTEGER_template field_ptActivationType;
INTEGER_template field_ptActivationDataLength;
OCTETSTRING_template field_ptActivationData;
};

void ExtPtActivation_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_ptActivationType = ANY_VALUE;
single_value->field_ptActivationDataLength = ANY_VALUE;
single_value->field_ptActivationData = ANY_VALUE;
}
}
}

void ExtPtActivation_template::copy_value(const ExtPtActivation& other_value)
{
single_value = new single_value_struct;
if (other_value.ptActivationType().is_bound()) {
  single_value->field_ptActivationType = other_value.ptActivationType();
} else {
  single_value->field_ptActivationType.clean_up();
}
if (other_value.ptActivationDataLength().is_bound()) {
  single_value->field_ptActivationDataLength = other_value.ptActivationDataLength();
} else {
  single_value->field_ptActivationDataLength.clean_up();
}
if (other_value.ptActivationData().is_bound()) {
  single_value->field_ptActivationData = other_value.ptActivationData();
} else {
  single_value->field_ptActivationData.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtPtActivation_template::copy_template(const ExtPtActivation_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.ptActivationType().get_selection()) {
single_value->field_ptActivationType = other_value.ptActivationType();
} else {
single_value->field_ptActivationType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ptActivationDataLength().get_selection()) {
single_value->field_ptActivationDataLength = other_value.ptActivationDataLength();
} else {
single_value->field_ptActivationDataLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ptActivationData().get_selection()) {
single_value->field_ptActivationData = other_value.ptActivationData();
} else {
single_value->field_ptActivationData.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtPtActivation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtPtActivation.");
break;
}
set_selection(other_value);
}

ExtPtActivation_template::ExtPtActivation_template()
{
}

ExtPtActivation_template::ExtPtActivation_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtPtActivation_template::ExtPtActivation_template(const ExtPtActivation& other_value)
{
copy_value(other_value);
}

ExtPtActivation_template::ExtPtActivation_template(const OPTIONAL<ExtPtActivation>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtPtActivation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtPtActivation from an unbound optional field.");
}
}

ExtPtActivation_template::ExtPtActivation_template(const ExtPtActivation_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtPtActivation_template::~ExtPtActivation_template()
{
clean_up();
}

ExtPtActivation_template& ExtPtActivation_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtPtActivation_template& ExtPtActivation_template::operator=(const ExtPtActivation& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtPtActivation_template& ExtPtActivation_template::operator=(const OPTIONAL<ExtPtActivation>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtPtActivation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtPtActivation.");
}
return *this;
}

ExtPtActivation_template& ExtPtActivation_template::operator=(const ExtPtActivation_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtPtActivation_template::match(const ExtPtActivation& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.ptActivationType().is_bound()) return FALSE;
if(!single_value->field_ptActivationType.match(other_value.ptActivationType(), legacy))return FALSE;
if(!other_value.ptActivationDataLength().is_bound()) return FALSE;
if(!single_value->field_ptActivationDataLength.match(other_value.ptActivationDataLength(), legacy))return FALSE;
if(!other_value.ptActivationData().is_bound()) return FALSE;
if(!single_value->field_ptActivationData.match(other_value.ptActivationData(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtPtActivation.");
}
return FALSE;
}

boolean ExtPtActivation_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_ptActivationType.is_bound()) return TRUE;
if (single_value->field_ptActivationDataLength.is_bound()) return TRUE;
if (single_value->field_ptActivationData.is_bound()) return TRUE;
return FALSE;
}

boolean ExtPtActivation_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_ptActivationType.is_value()) return FALSE;
if (!single_value->field_ptActivationDataLength.is_value()) return FALSE;
if (!single_value->field_ptActivationData.is_value()) return FALSE;
return TRUE;
}

void ExtPtActivation_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtPtActivation ExtPtActivation_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtPtActivation.");
ExtPtActivation ret_val;
if (single_value->field_ptActivationType.is_bound()) {
ret_val.ptActivationType() = single_value->field_ptActivationType.valueof();
}
if (single_value->field_ptActivationDataLength.is_bound()) {
ret_val.ptActivationDataLength() = single_value->field_ptActivationDataLength.valueof();
}
if (single_value->field_ptActivationData.is_bound()) {
ret_val.ptActivationData() = single_value->field_ptActivationData.valueof();
}
return ret_val;
}

void ExtPtActivation_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtPtActivation.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtPtActivation_template[list_length];
}

ExtPtActivation_template& ExtPtActivation_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtPtActivation.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtPtActivation.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtPtActivation_template::ptActivationType()
{
set_specific();
return single_value->field_ptActivationType;
}

const INTEGER_template& ExtPtActivation_template::ptActivationType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ptActivationType of a non-specific template of type @TTCN_EncDec.ExtPtActivation.");
return single_value->field_ptActivationType;
}

INTEGER_template& ExtPtActivation_template::ptActivationDataLength()
{
set_specific();
return single_value->field_ptActivationDataLength;
}

const INTEGER_template& ExtPtActivation_template::ptActivationDataLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ptActivationDataLength of a non-specific template of type @TTCN_EncDec.ExtPtActivation.");
return single_value->field_ptActivationDataLength;
}

OCTETSTRING_template& ExtPtActivation_template::ptActivationData()
{
set_specific();
return single_value->field_ptActivationData;
}

const OCTETSTRING_template& ExtPtActivation_template::ptActivationData() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ptActivationData of a non-specific template of type @TTCN_EncDec.ExtPtActivation.");
return single_value->field_ptActivationData;
}

int ExtPtActivation_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtPtActivation which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtPtActivation containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtPtActivation containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtPtActivation containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtPtActivation containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtPtActivation containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtPtActivation.");
  }
  return 0;
}

void ExtPtActivation_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ ptActivationType := ");
single_value->field_ptActivationType.log();
TTCN_Logger::log_event_str(", ptActivationDataLength := ");
single_value->field_ptActivationDataLength.log();
TTCN_Logger::log_event_str(", ptActivationData := ");
single_value->field_ptActivationData.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtPtActivation_template::log_match(const ExtPtActivation& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_ptActivationType.match(match_value.ptActivationType(), legacy)){
TTCN_Logger::log_logmatch_info(".ptActivationType");
single_value->field_ptActivationType.log_match(match_value.ptActivationType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ptActivationDataLength.match(match_value.ptActivationDataLength(), legacy)){
TTCN_Logger::log_logmatch_info(".ptActivationDataLength");
single_value->field_ptActivationDataLength.log_match(match_value.ptActivationDataLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ptActivationData.match(match_value.ptActivationData(), legacy)){
TTCN_Logger::log_logmatch_info(".ptActivationData");
single_value->field_ptActivationData.log_match(match_value.ptActivationData(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ ptActivationType := ");
single_value->field_ptActivationType.log_match(match_value.ptActivationType(), legacy);
TTCN_Logger::log_event_str(", ptActivationDataLength := ");
single_value->field_ptActivationDataLength.log_match(match_value.ptActivationDataLength(), legacy);
TTCN_Logger::log_event_str(", ptActivationData := ");
single_value->field_ptActivationData.log_match(match_value.ptActivationData(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtPtActivation_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_ptActivationType.encode_text(text_buf);
single_value->field_ptActivationDataLength.encode_text(text_buf);
single_value->field_ptActivationData.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtPtActivation.");
}
}

void ExtPtActivation_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_ptActivationType.decode_text(text_buf);
single_value->field_ptActivationDataLength.decode_text(text_buf);
single_value->field_ptActivationData.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtPtActivation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtPtActivation.");
}
}

void ExtPtActivation_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtPtActivation'");
    }
    if (strcmp("ptActivationType", param_field) == 0) {
      ptActivationType().set_param(param);
      return;
    } else if (strcmp("ptActivationDataLength", param_field) == 0) {
      ptActivationDataLength().set_param(param);
      return;
    } else if (strcmp("ptActivationData", param_field) == 0) {
      ptActivationData().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtPtActivation'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtPtActivation_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtPtActivation has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ptActivationType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ptActivationDataLength().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ptActivationData().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationDataLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationDataLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtPtActivation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtPtActivation");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtPtActivation_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtPtActivation'");
    }
    if (strcmp("ptActivationType", param_field) == 0) {
      return ptActivationType().get_param(param_name);
    } else if (strcmp("ptActivationDataLength", param_field) == 0) {
      return ptActivationDataLength().get_param(param_name);
    } else if (strcmp("ptActivationData", param_field) == 0) {
      return ptActivationData().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtPtActivation'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_ptActivationType = single_value->field_ptActivationType.get_param(param_name);
    mp_field_ptActivationType->set_id(new Module_Param_FieldName(mcopystr("ptActivationType")));
    mp->add_elem(mp_field_ptActivationType);
    Module_Param* mp_field_ptActivationDataLength = single_value->field_ptActivationDataLength.get_param(param_name);
    mp_field_ptActivationDataLength->set_id(new Module_Param_FieldName(mcopystr("ptActivationDataLength")));
    mp->add_elem(mp_field_ptActivationDataLength);
    Module_Param* mp_field_ptActivationData = single_value->field_ptActivationData.get_param(param_name);
    mp_field_ptActivationData->set_id(new Module_Param_FieldName(mcopystr("ptActivationData")));
    mp->add_elem(mp_field_ptActivationData);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtPtActivation_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_ptActivationType.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtPtActivation");
single_value->field_ptActivationDataLength.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtPtActivation");
single_value->field_ptActivationData.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtPtActivation");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtPtActivation");
}

boolean ExtPtActivation_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtPtActivation_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ExtUtCamTrigger::copy_value(const ExtUtCamTrigger& other_value)
{
switch (other_value.union_selection) {
case ALT_changeCurvature:
field_changeCurvature = new INTEGER(*other_value.field_changeCurvature);
break;
case ALT_changeSpeed:
field_changeSpeed = new INTEGER(*other_value.field_changeSpeed);
break;
case ALT_setAccelerationControlStatus:
field_setAccelerationControlStatus = new BITSTRING(*other_value.field_setAccelerationControlStatus);
break;
case ALT_setExteriorLightsStatus:
field_setExteriorLightsStatus = new BITSTRING(*other_value.field_setExteriorLightsStatus);
break;
case ALT_changeHeading:
field_changeHeading = new INTEGER(*other_value.field_changeHeading);
break;
case ALT_setDriveDirection:
field_setDriveDirection = new INTEGER(*other_value.field_setDriveDirection);
break;
case ALT_changeYawRate:
field_changeYawRate = new INTEGER(*other_value.field_changeYawRate);
break;
case ALT_setStationType:
field_setStationType = new INTEGER(*other_value.field_setStationType);
break;
case ALT_setVehicleRole:
field_setVehicleRole = new INTEGER(*other_value.field_setVehicleRole);
break;
case ALT_setEmbarkationStatus:
field_setEmbarkationStatus = new INTEGER(*other_value.field_setEmbarkationStatus);
break;
case ALT_setPtActivation:
field_setPtActivation = new ExtPtActivation(*other_value.field_setPtActivation);
break;
case ALT_setDangerousGoods:
field_setDangerousGoods = new INTEGER(*other_value.field_setDangerousGoods);
break;
case ALT_setLightBarSirene:
field_setLightBarSirene = new INTEGER(*other_value.field_setLightBarSirene);
break;
default:
TTCN_error("Assignment of an unbound union value of type @TTCN_EncDec.ExtUtCamTrigger.");
}
union_selection = other_value.union_selection;
}

ExtUtCamTrigger::ExtUtCamTrigger()
{
union_selection = UNBOUND_VALUE;
}

ExtUtCamTrigger::ExtUtCamTrigger(const ExtUtCamTrigger& other_value)
: Base_Type(){
copy_value(other_value);
}

ExtUtCamTrigger::~ExtUtCamTrigger()
{
clean_up();
}

ExtUtCamTrigger& ExtUtCamTrigger::operator=(const ExtUtCamTrigger& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean ExtUtCamTrigger::operator==(const ExtUtCamTrigger& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_changeCurvature:
return *field_changeCurvature == *other_value.field_changeCurvature;
case ALT_changeSpeed:
return *field_changeSpeed == *other_value.field_changeSpeed;
case ALT_setAccelerationControlStatus:
return *field_setAccelerationControlStatus == *other_value.field_setAccelerationControlStatus;
case ALT_setExteriorLightsStatus:
return *field_setExteriorLightsStatus == *other_value.field_setExteriorLightsStatus;
case ALT_changeHeading:
return *field_changeHeading == *other_value.field_changeHeading;
case ALT_setDriveDirection:
return *field_setDriveDirection == *other_value.field_setDriveDirection;
case ALT_changeYawRate:
return *field_changeYawRate == *other_value.field_changeYawRate;
case ALT_setStationType:
return *field_setStationType == *other_value.field_setStationType;
case ALT_setVehicleRole:
return *field_setVehicleRole == *other_value.field_setVehicleRole;
case ALT_setEmbarkationStatus:
return *field_setEmbarkationStatus == *other_value.field_setEmbarkationStatus;
case ALT_setPtActivation:
return *field_setPtActivation == *other_value.field_setPtActivation;
case ALT_setDangerousGoods:
return *field_setDangerousGoods == *other_value.field_setDangerousGoods;
case ALT_setLightBarSirene:
return *field_setLightBarSirene == *other_value.field_setLightBarSirene;
default:
return FALSE;
}
}

INTEGER& ExtUtCamTrigger::changeCurvature()
{
if (union_selection != ALT_changeCurvature) {
clean_up();
field_changeCurvature = new INTEGER;
union_selection = ALT_changeCurvature;
}
return *field_changeCurvature;
}

const INTEGER& ExtUtCamTrigger::changeCurvature() const
{
if (union_selection != ALT_changeCurvature) TTCN_error("Using non-selected field changeCurvature in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_changeCurvature;
}

INTEGER& ExtUtCamTrigger::changeSpeed()
{
if (union_selection != ALT_changeSpeed) {
clean_up();
field_changeSpeed = new INTEGER;
union_selection = ALT_changeSpeed;
}
return *field_changeSpeed;
}

const INTEGER& ExtUtCamTrigger::changeSpeed() const
{
if (union_selection != ALT_changeSpeed) TTCN_error("Using non-selected field changeSpeed in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_changeSpeed;
}

BITSTRING& ExtUtCamTrigger::setAccelerationControlStatus()
{
if (union_selection != ALT_setAccelerationControlStatus) {
clean_up();
field_setAccelerationControlStatus = new BITSTRING;
union_selection = ALT_setAccelerationControlStatus;
}
return *field_setAccelerationControlStatus;
}

const BITSTRING& ExtUtCamTrigger::setAccelerationControlStatus() const
{
if (union_selection != ALT_setAccelerationControlStatus) TTCN_error("Using non-selected field setAccelerationControlStatus in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_setAccelerationControlStatus;
}

BITSTRING& ExtUtCamTrigger::setExteriorLightsStatus()
{
if (union_selection != ALT_setExteriorLightsStatus) {
clean_up();
field_setExteriorLightsStatus = new BITSTRING;
union_selection = ALT_setExteriorLightsStatus;
}
return *field_setExteriorLightsStatus;
}

const BITSTRING& ExtUtCamTrigger::setExteriorLightsStatus() const
{
if (union_selection != ALT_setExteriorLightsStatus) TTCN_error("Using non-selected field setExteriorLightsStatus in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_setExteriorLightsStatus;
}

INTEGER& ExtUtCamTrigger::changeHeading()
{
if (union_selection != ALT_changeHeading) {
clean_up();
field_changeHeading = new INTEGER;
union_selection = ALT_changeHeading;
}
return *field_changeHeading;
}

const INTEGER& ExtUtCamTrigger::changeHeading() const
{
if (union_selection != ALT_changeHeading) TTCN_error("Using non-selected field changeHeading in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_changeHeading;
}

INTEGER& ExtUtCamTrigger::setDriveDirection()
{
if (union_selection != ALT_setDriveDirection) {
clean_up();
field_setDriveDirection = new INTEGER;
union_selection = ALT_setDriveDirection;
}
return *field_setDriveDirection;
}

const INTEGER& ExtUtCamTrigger::setDriveDirection() const
{
if (union_selection != ALT_setDriveDirection) TTCN_error("Using non-selected field setDriveDirection in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_setDriveDirection;
}

INTEGER& ExtUtCamTrigger::changeYawRate()
{
if (union_selection != ALT_changeYawRate) {
clean_up();
field_changeYawRate = new INTEGER;
union_selection = ALT_changeYawRate;
}
return *field_changeYawRate;
}

const INTEGER& ExtUtCamTrigger::changeYawRate() const
{
if (union_selection != ALT_changeYawRate) TTCN_error("Using non-selected field changeYawRate in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_changeYawRate;
}

INTEGER& ExtUtCamTrigger::setStationType()
{
if (union_selection != ALT_setStationType) {
clean_up();
field_setStationType = new INTEGER;
union_selection = ALT_setStationType;
}
return *field_setStationType;
}

const INTEGER& ExtUtCamTrigger::setStationType() const
{
if (union_selection != ALT_setStationType) TTCN_error("Using non-selected field setStationType in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_setStationType;
}

INTEGER& ExtUtCamTrigger::setVehicleRole()
{
if (union_selection != ALT_setVehicleRole) {
clean_up();
field_setVehicleRole = new INTEGER;
union_selection = ALT_setVehicleRole;
}
return *field_setVehicleRole;
}

const INTEGER& ExtUtCamTrigger::setVehicleRole() const
{
if (union_selection != ALT_setVehicleRole) TTCN_error("Using non-selected field setVehicleRole in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_setVehicleRole;
}

INTEGER& ExtUtCamTrigger::setEmbarkationStatus()
{
if (union_selection != ALT_setEmbarkationStatus) {
clean_up();
field_setEmbarkationStatus = new INTEGER;
union_selection = ALT_setEmbarkationStatus;
}
return *field_setEmbarkationStatus;
}

const INTEGER& ExtUtCamTrigger::setEmbarkationStatus() const
{
if (union_selection != ALT_setEmbarkationStatus) TTCN_error("Using non-selected field setEmbarkationStatus in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_setEmbarkationStatus;
}

ExtPtActivation& ExtUtCamTrigger::setPtActivation()
{
if (union_selection != ALT_setPtActivation) {
clean_up();
field_setPtActivation = new ExtPtActivation;
union_selection = ALT_setPtActivation;
}
return *field_setPtActivation;
}

const ExtPtActivation& ExtUtCamTrigger::setPtActivation() const
{
if (union_selection != ALT_setPtActivation) TTCN_error("Using non-selected field setPtActivation in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_setPtActivation;
}

INTEGER& ExtUtCamTrigger::setDangerousGoods()
{
if (union_selection != ALT_setDangerousGoods) {
clean_up();
field_setDangerousGoods = new INTEGER;
union_selection = ALT_setDangerousGoods;
}
return *field_setDangerousGoods;
}

const INTEGER& ExtUtCamTrigger::setDangerousGoods() const
{
if (union_selection != ALT_setDangerousGoods) TTCN_error("Using non-selected field setDangerousGoods in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_setDangerousGoods;
}

INTEGER& ExtUtCamTrigger::setLightBarSirene()
{
if (union_selection != ALT_setLightBarSirene) {
clean_up();
field_setLightBarSirene = new INTEGER;
union_selection = ALT_setLightBarSirene;
}
return *field_setLightBarSirene;
}

const INTEGER& ExtUtCamTrigger::setLightBarSirene() const
{
if (union_selection != ALT_setLightBarSirene) TTCN_error("Using non-selected field setLightBarSirene in a value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *field_setLightBarSirene;
}

boolean ExtUtCamTrigger::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @TTCN_EncDec.ExtUtCamTrigger.");
return union_selection == checked_selection;
}

boolean ExtUtCamTrigger::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean ExtUtCamTrigger::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_changeCurvature: return field_changeCurvature->is_value();
case ALT_changeSpeed: return field_changeSpeed->is_value();
case ALT_setAccelerationControlStatus: return field_setAccelerationControlStatus->is_value();
case ALT_setExteriorLightsStatus: return field_setExteriorLightsStatus->is_value();
case ALT_changeHeading: return field_changeHeading->is_value();
case ALT_setDriveDirection: return field_setDriveDirection->is_value();
case ALT_changeYawRate: return field_changeYawRate->is_value();
case ALT_setStationType: return field_setStationType->is_value();
case ALT_setVehicleRole: return field_setVehicleRole->is_value();
case ALT_setEmbarkationStatus: return field_setEmbarkationStatus->is_value();
case ALT_setPtActivation: return field_setPtActivation->is_value();
case ALT_setDangerousGoods: return field_setDangerousGoods->is_value();
case ALT_setLightBarSirene: return field_setLightBarSirene->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void ExtUtCamTrigger::clean_up()
{
switch (union_selection) {
case ALT_changeCurvature:
  delete field_changeCurvature;
  break;
case ALT_changeSpeed:
  delete field_changeSpeed;
  break;
case ALT_setAccelerationControlStatus:
  delete field_setAccelerationControlStatus;
  break;
case ALT_setExteriorLightsStatus:
  delete field_setExteriorLightsStatus;
  break;
case ALT_changeHeading:
  delete field_changeHeading;
  break;
case ALT_setDriveDirection:
  delete field_setDriveDirection;
  break;
case ALT_changeYawRate:
  delete field_changeYawRate;
  break;
case ALT_setStationType:
  delete field_setStationType;
  break;
case ALT_setVehicleRole:
  delete field_setVehicleRole;
  break;
case ALT_setEmbarkationStatus:
  delete field_setEmbarkationStatus;
  break;
case ALT_setPtActivation:
  delete field_setPtActivation;
  break;
case ALT_setDangerousGoods:
  delete field_setDangerousGoods;
  break;
case ALT_setLightBarSirene:
  delete field_setLightBarSirene;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void ExtUtCamTrigger::log() const
{
switch (union_selection) {
case ALT_changeCurvature:
TTCN_Logger::log_event_str("{ changeCurvature := ");
field_changeCurvature->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_changeSpeed:
TTCN_Logger::log_event_str("{ changeSpeed := ");
field_changeSpeed->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setAccelerationControlStatus:
TTCN_Logger::log_event_str("{ setAccelerationControlStatus := ");
field_setAccelerationControlStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setExteriorLightsStatus:
TTCN_Logger::log_event_str("{ setExteriorLightsStatus := ");
field_setExteriorLightsStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_changeHeading:
TTCN_Logger::log_event_str("{ changeHeading := ");
field_changeHeading->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setDriveDirection:
TTCN_Logger::log_event_str("{ setDriveDirection := ");
field_setDriveDirection->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_changeYawRate:
TTCN_Logger::log_event_str("{ changeYawRate := ");
field_changeYawRate->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setStationType:
TTCN_Logger::log_event_str("{ setStationType := ");
field_setStationType->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setVehicleRole:
TTCN_Logger::log_event_str("{ setVehicleRole := ");
field_setVehicleRole->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setEmbarkationStatus:
TTCN_Logger::log_event_str("{ setEmbarkationStatus := ");
field_setEmbarkationStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setPtActivation:
TTCN_Logger::log_event_str("{ setPtActivation := ");
field_setPtActivation->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setDangerousGoods:
TTCN_Logger::log_event_str("{ setDangerousGoods := ");
field_setDangerousGoods->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_setLightBarSirene:
TTCN_Logger::log_event_str("{ setLightBarSirene := ");
field_setLightBarSirene->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void ExtUtCamTrigger::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@TTCN_EncDec.ExtUtCamTrigger'");
    }
    if (strcmp("changeCurvature", param_field) == 0) {
      changeCurvature().set_param(param);
      return;
    } else if (strcmp("changeSpeed", param_field) == 0) {
      changeSpeed().set_param(param);
      return;
    } else if (strcmp("setAccelerationControlStatus", param_field) == 0) {
      setAccelerationControlStatus().set_param(param);
      return;
    } else if (strcmp("setExteriorLightsStatus", param_field) == 0) {
      setExteriorLightsStatus().set_param(param);
      return;
    } else if (strcmp("changeHeading", param_field) == 0) {
      changeHeading().set_param(param);
      return;
    } else if (strcmp("setDriveDirection", param_field) == 0) {
      setDriveDirection().set_param(param);
      return;
    } else if (strcmp("changeYawRate", param_field) == 0) {
      changeYawRate().set_param(param);
      return;
    } else if (strcmp("setStationType", param_field) == 0) {
      setStationType().set_param(param);
      return;
    } else if (strcmp("setVehicleRole", param_field) == 0) {
      setVehicleRole().set_param(param);
      return;
    } else if (strcmp("setEmbarkationStatus", param_field) == 0) {
      setEmbarkationStatus().set_param(param);
      return;
    } else if (strcmp("setPtActivation", param_field) == 0) {
      setPtActivation().set_param(param);
      return;
    } else if (strcmp("setDangerousGoods", param_field) == 0) {
      setDangerousGoods().set_param(param);
      return;
    } else if (strcmp("setLightBarSirene", param_field) == 0) {
      setLightBarSirene().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@TTCN_EncDec.ExtUtCamTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "changeCurvature")) {
    changeCurvature().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "changeSpeed")) {
    changeSpeed().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setAccelerationControlStatus")) {
    setAccelerationControlStatus().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setExteriorLightsStatus")) {
    setExteriorLightsStatus().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "changeHeading")) {
    changeHeading().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setDriveDirection")) {
    setDriveDirection().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "changeYawRate")) {
    changeYawRate().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setStationType")) {
    setStationType().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setVehicleRole")) {
    setVehicleRole().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setEmbarkationStatus")) {
    setEmbarkationStatus().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setPtActivation")) {
    setPtActivation().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setDangerousGoods")) {
    setDangerousGoods().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "setLightBarSirene")) {
    setLightBarSirene().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @TTCN_EncDec.ExtUtCamTrigger.", mp_last->get_id()->get_name());
}

Module_Param* ExtUtCamTrigger::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@TTCN_EncDec.ExtUtCamTrigger'");
    }
    if (strcmp("changeCurvature", param_field) == 0) {
      return changeCurvature().get_param(param_name);
    } else if (strcmp("changeSpeed", param_field) == 0) {
      return changeSpeed().get_param(param_name);
    } else if (strcmp("setAccelerationControlStatus", param_field) == 0) {
      return setAccelerationControlStatus().get_param(param_name);
    } else if (strcmp("setExteriorLightsStatus", param_field) == 0) {
      return setExteriorLightsStatus().get_param(param_name);
    } else if (strcmp("changeHeading", param_field) == 0) {
      return changeHeading().get_param(param_name);
    } else if (strcmp("setDriveDirection", param_field) == 0) {
      return setDriveDirection().get_param(param_name);
    } else if (strcmp("changeYawRate", param_field) == 0) {
      return changeYawRate().get_param(param_name);
    } else if (strcmp("setStationType", param_field) == 0) {
      return setStationType().get_param(param_name);
    } else if (strcmp("setVehicleRole", param_field) == 0) {
      return setVehicleRole().get_param(param_name);
    } else if (strcmp("setEmbarkationStatus", param_field) == 0) {
      return setEmbarkationStatus().get_param(param_name);
    } else if (strcmp("setPtActivation", param_field) == 0) {
      return setPtActivation().get_param(param_name);
    } else if (strcmp("setDangerousGoods", param_field) == 0) {
      return setDangerousGoods().get_param(param_name);
    } else if (strcmp("setLightBarSirene", param_field) == 0) {
      return setLightBarSirene().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ExtUtCamTrigger'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_changeCurvature:
    mp_field = field_changeCurvature->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("changeCurvature")));
    break;
  case ALT_changeSpeed:
    mp_field = field_changeSpeed->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("changeSpeed")));
    break;
  case ALT_setAccelerationControlStatus:
    mp_field = field_setAccelerationControlStatus->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setAccelerationControlStatus")));
    break;
  case ALT_setExteriorLightsStatus:
    mp_field = field_setExteriorLightsStatus->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setExteriorLightsStatus")));
    break;
  case ALT_changeHeading:
    mp_field = field_changeHeading->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("changeHeading")));
    break;
  case ALT_setDriveDirection:
    mp_field = field_setDriveDirection->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setDriveDirection")));
    break;
  case ALT_changeYawRate:
    mp_field = field_changeYawRate->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("changeYawRate")));
    break;
  case ALT_setStationType:
    mp_field = field_setStationType->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setStationType")));
    break;
  case ALT_setVehicleRole:
    mp_field = field_setVehicleRole->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setVehicleRole")));
    break;
  case ALT_setEmbarkationStatus:
    mp_field = field_setEmbarkationStatus->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setEmbarkationStatus")));
    break;
  case ALT_setPtActivation:
    mp_field = field_setPtActivation->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setPtActivation")));
    break;
  case ALT_setDangerousGoods:
    mp_field = field_setDangerousGoods->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setDangerousGoods")));
    break;
  case ALT_setLightBarSirene:
    mp_field = field_setLightBarSirene->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("setLightBarSirene")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void ExtUtCamTrigger::set_implicit_omit()
{
switch (union_selection) {
case ALT_changeCurvature:
field_changeCurvature->set_implicit_omit(); break;
case ALT_changeSpeed:
field_changeSpeed->set_implicit_omit(); break;
case ALT_setAccelerationControlStatus:
field_setAccelerationControlStatus->set_implicit_omit(); break;
case ALT_setExteriorLightsStatus:
field_setExteriorLightsStatus->set_implicit_omit(); break;
case ALT_changeHeading:
field_changeHeading->set_implicit_omit(); break;
case ALT_setDriveDirection:
field_setDriveDirection->set_implicit_omit(); break;
case ALT_changeYawRate:
field_changeYawRate->set_implicit_omit(); break;
case ALT_setStationType:
field_setStationType->set_implicit_omit(); break;
case ALT_setVehicleRole:
field_setVehicleRole->set_implicit_omit(); break;
case ALT_setEmbarkationStatus:
field_setEmbarkationStatus->set_implicit_omit(); break;
case ALT_setPtActivation:
field_setPtActivation->set_implicit_omit(); break;
case ALT_setDangerousGoods:
field_setDangerousGoods->set_implicit_omit(); break;
case ALT_setLightBarSirene:
field_setLightBarSirene->set_implicit_omit(); break;
default: break;
}
}

void ExtUtCamTrigger::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_changeCurvature:
field_changeCurvature->encode_text(text_buf);
break;
case ALT_changeSpeed:
field_changeSpeed->encode_text(text_buf);
break;
case ALT_setAccelerationControlStatus:
field_setAccelerationControlStatus->encode_text(text_buf);
break;
case ALT_setExteriorLightsStatus:
field_setExteriorLightsStatus->encode_text(text_buf);
break;
case ALT_changeHeading:
field_changeHeading->encode_text(text_buf);
break;
case ALT_setDriveDirection:
field_setDriveDirection->encode_text(text_buf);
break;
case ALT_changeYawRate:
field_changeYawRate->encode_text(text_buf);
break;
case ALT_setStationType:
field_setStationType->encode_text(text_buf);
break;
case ALT_setVehicleRole:
field_setVehicleRole->encode_text(text_buf);
break;
case ALT_setEmbarkationStatus:
field_setEmbarkationStatus->encode_text(text_buf);
break;
case ALT_setPtActivation:
field_setPtActivation->encode_text(text_buf);
break;
case ALT_setDangerousGoods:
field_setDangerousGoods->encode_text(text_buf);
break;
case ALT_setLightBarSirene:
field_setLightBarSirene->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @TTCN_EncDec.ExtUtCamTrigger.");
}
}

void ExtUtCamTrigger::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_changeCurvature:
changeCurvature().decode_text(text_buf);
break;
case ALT_changeSpeed:
changeSpeed().decode_text(text_buf);
break;
case ALT_setAccelerationControlStatus:
setAccelerationControlStatus().decode_text(text_buf);
break;
case ALT_setExteriorLightsStatus:
setExteriorLightsStatus().decode_text(text_buf);
break;
case ALT_changeHeading:
changeHeading().decode_text(text_buf);
break;
case ALT_setDriveDirection:
setDriveDirection().decode_text(text_buf);
break;
case ALT_changeYawRate:
changeYawRate().decode_text(text_buf);
break;
case ALT_setStationType:
setStationType().decode_text(text_buf);
break;
case ALT_setVehicleRole:
setVehicleRole().decode_text(text_buf);
break;
case ALT_setEmbarkationStatus:
setEmbarkationStatus().decode_text(text_buf);
break;
case ALT_setPtActivation:
setPtActivation().decode_text(text_buf);
break;
case ALT_setDangerousGoods:
setDangerousGoods().decode_text(text_buf);
break;
case ALT_setLightBarSirene:
setLightBarSirene().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @TTCN_EncDec.ExtUtCamTrigger.");
}
}

void ExtUtCamTrigger::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtUtCamTrigger::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtUtCamTrigger::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = changeCurvature().RAW_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = changeSpeed().RAW_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = setAccelerationControlStatus().RAW_decode(BIT8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = setExteriorLightsStatus().RAW_decode(BIT8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = changeHeading().RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 5:
      decoded_length = setDriveDirection().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 6:
      decoded_length = changeYawRate().RAW_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 7:
      decoded_length = setStationType().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 8:
      decoded_length = setVehicleRole().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 9:
      decoded_length = setEmbarkationStatus().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 10:
      decoded_length = setPtActivation().RAW_decode(ExtPtActivation_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 11:
      decoded_length = setDangerousGoods().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 12:
      decoded_length = setLightBarSirene().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = changeCurvature().RAW_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = changeSpeed().RAW_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setAccelerationControlStatus().RAW_decode(BIT8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setExteriorLightsStatus().RAW_decode(BIT8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = changeHeading().RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setDriveDirection().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = changeYawRate().RAW_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setStationType().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setVehicleRole().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setEmbarkationStatus().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setPtActivation().RAW_decode(ExtPtActivation_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setDangerousGoods().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = setLightBarSirene().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int ExtUtCamTrigger::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 13;  myleaf.body.node.nodes = init_nodes_of_enc_tree(13);
  memset(myleaf.body.node.nodes, 0, 13 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_changeCurvature:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, LibCommon__BasicTypesAndValues::Int16_descr_.raw);
    encoded_length = field_changeCurvature->RAW_encode(LibCommon__BasicTypesAndValues::Int16_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &LibCommon__BasicTypesAndValues::Int16_descr_;
    break;
  case ALT_changeSpeed:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, LibCommon__BasicTypesAndValues::Int16_descr_.raw);
    encoded_length = field_changeSpeed->RAW_encode(LibCommon__BasicTypesAndValues::Int16_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &LibCommon__BasicTypesAndValues::Int16_descr_;
    break;
  case ALT_setAccelerationControlStatus:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, BIT8_descr_.raw);
    encoded_length = field_setAccelerationControlStatus->RAW_encode(BIT8_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &BIT8_descr_;
    break;
  case ALT_setExteriorLightsStatus:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, BIT8_descr_.raw);
    encoded_length = field_setExteriorLightsStatus->RAW_encode(BIT8_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &BIT8_descr_;
    break;
  case ALT_changeHeading:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
    encoded_length = field_changeHeading->RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &LibCommon__BasicTypesAndValues::UInt16_descr_;
    break;
  case ALT_setDriveDirection:
    myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 5, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
    encoded_length = field_setDriveDirection->RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[5]);
    myleaf.body.node.nodes[5]->coding_descr = &LibCommon__BasicTypesAndValues::UInt8_descr_;
    break;
  case ALT_changeYawRate:
    myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 6, LibCommon__BasicTypesAndValues::Int16_descr_.raw);
    encoded_length = field_changeYawRate->RAW_encode(LibCommon__BasicTypesAndValues::Int16_descr_, *myleaf.body.node.nodes[6]);
    myleaf.body.node.nodes[6]->coding_descr = &LibCommon__BasicTypesAndValues::Int16_descr_;
    break;
  case ALT_setStationType:
    myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 7, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
    encoded_length = field_setStationType->RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[7]);
    myleaf.body.node.nodes[7]->coding_descr = &LibCommon__BasicTypesAndValues::UInt8_descr_;
    break;
  case ALT_setVehicleRole:
    myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 8, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
    encoded_length = field_setVehicleRole->RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[8]);
    myleaf.body.node.nodes[8]->coding_descr = &LibCommon__BasicTypesAndValues::UInt8_descr_;
    break;
  case ALT_setEmbarkationStatus:
    myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 9, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
    encoded_length = field_setEmbarkationStatus->RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[9]);
    myleaf.body.node.nodes[9]->coding_descr = &LibCommon__BasicTypesAndValues::UInt8_descr_;
    break;
  case ALT_setPtActivation:
    myleaf.body.node.nodes[10] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 10, ExtPtActivation_descr_.raw);
    encoded_length = field_setPtActivation->RAW_encode(ExtPtActivation_descr_, *myleaf.body.node.nodes[10]);
    myleaf.body.node.nodes[10]->coding_descr = &ExtPtActivation_descr_;
    break;
  case ALT_setDangerousGoods:
    myleaf.body.node.nodes[11] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 11, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
    encoded_length = field_setDangerousGoods->RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[11]);
    myleaf.body.node.nodes[11]->coding_descr = &LibCommon__BasicTypesAndValues::UInt8_descr_;
    break;
  case ALT_setLightBarSirene:
    myleaf.body.node.nodes[12] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 12, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
    encoded_length = field_setLightBarSirene->RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[12]);
    myleaf.body.node.nodes[12]->coding_descr = &LibCommon__BasicTypesAndValues::UInt8_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int ExtUtCamTrigger::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_changeCurvature:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "changeCurvature");
    enc_len += field_changeCurvature->JSON_encode(LibCommon__BasicTypesAndValues::Int16_descr_, p_tok);
    break;
  case ALT_changeSpeed:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "changeSpeed");
    enc_len += field_changeSpeed->JSON_encode(LibCommon__BasicTypesAndValues::Int16_descr_, p_tok);
    break;
  case ALT_setAccelerationControlStatus:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setAccelerationControlStatus");
    enc_len += field_setAccelerationControlStatus->JSON_encode(BIT8_descr_, p_tok);
    break;
  case ALT_setExteriorLightsStatus:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setExteriorLightsStatus");
    enc_len += field_setExteriorLightsStatus->JSON_encode(BIT8_descr_, p_tok);
    break;
  case ALT_changeHeading:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "changeHeading");
    enc_len += field_changeHeading->JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
    break;
  case ALT_setDriveDirection:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setDriveDirection");
    enc_len += field_setDriveDirection->JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
    break;
  case ALT_changeYawRate:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "changeYawRate");
    enc_len += field_changeYawRate->JSON_encode(LibCommon__BasicTypesAndValues::Int16_descr_, p_tok);
    break;
  case ALT_setStationType:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setStationType");
    enc_len += field_setStationType->JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
    break;
  case ALT_setVehicleRole:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setVehicleRole");
    enc_len += field_setVehicleRole->JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
    break;
  case ALT_setEmbarkationStatus:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setEmbarkationStatus");
    enc_len += field_setEmbarkationStatus->JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
    break;
  case ALT_setPtActivation:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setPtActivation");
    enc_len += field_setPtActivation->JSON_encode(ExtPtActivation_descr_, p_tok);
    break;
  case ALT_setDangerousGoods:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setDangerousGoods");
    enc_len += field_setDangerousGoods->JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
    break;
  case ALT_setLightBarSirene:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "setLightBarSirene");
    enc_len += field_setLightBarSirene->JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @TTCN_EncDec.ExtUtCamTrigger.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtUtCamTrigger::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "changeCurvature", name_len)) {
      int ret_val = changeCurvature().JSON_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "changeCurvature");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "changeSpeed", name_len)) {
      int ret_val = changeSpeed().JSON_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "changeSpeed");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setAccelerationControlStatus", name_len)) {
      int ret_val = setAccelerationControlStatus().JSON_decode(BIT8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setAccelerationControlStatus");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setExteriorLightsStatus", name_len)) {
      int ret_val = setExteriorLightsStatus().JSON_decode(BIT8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setExteriorLightsStatus");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "changeHeading", name_len)) {
      int ret_val = changeHeading().JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "changeHeading");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setDriveDirection", name_len)) {
      int ret_val = setDriveDirection().JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setDriveDirection");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "changeYawRate", name_len)) {
      int ret_val = changeYawRate().JSON_decode(LibCommon__BasicTypesAndValues::Int16_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "changeYawRate");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setStationType", name_len)) {
      int ret_val = setStationType().JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setStationType");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setVehicleRole", name_len)) {
      int ret_val = setVehicleRole().JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setVehicleRole");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setEmbarkationStatus", name_len)) {
      int ret_val = setEmbarkationStatus().JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setEmbarkationStatus");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setPtActivation", name_len)) {
      int ret_val = setPtActivation().JSON_decode(ExtPtActivation_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setPtActivation");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setDangerousGoods", name_len)) {
      int ret_val = setDangerousGoods().JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setDangerousGoods");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "setLightBarSirene", name_len)) {
      int ret_val = setLightBarSirene().JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "setLightBarSirene");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ExtUtCamTrigger_template::copy_value(const ExtUtCamTrigger& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature = new INTEGER_template(other_value.changeCurvature());
break;
case ExtUtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed = new INTEGER_template(other_value.changeSpeed());
break;
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus = new BITSTRING_template(other_value.setAccelerationControlStatus());
break;
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus = new BITSTRING_template(other_value.setExteriorLightsStatus());
break;
case ExtUtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading = new INTEGER_template(other_value.changeHeading());
break;
case ExtUtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection = new INTEGER_template(other_value.setDriveDirection());
break;
case ExtUtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate = new INTEGER_template(other_value.changeYawRate());
break;
case ExtUtCamTrigger::ALT_setStationType:
single_value.field_setStationType = new INTEGER_template(other_value.setStationType());
break;
case ExtUtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole = new INTEGER_template(other_value.setVehicleRole());
break;
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus = new INTEGER_template(other_value.setEmbarkationStatus());
break;
case ExtUtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation = new ExtPtActivation_template(other_value.setPtActivation());
break;
case ExtUtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods = new INTEGER_template(other_value.setDangerousGoods());
break;
case ExtUtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene = new INTEGER_template(other_value.setLightBarSirene());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @TTCN_EncDec.ExtUtCamTrigger.");
}
set_selection(SPECIFIC_VALUE);
}

void ExtUtCamTrigger_template::copy_template(const ExtUtCamTrigger_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature = new INTEGER_template(*other_value.single_value.field_changeCurvature);
break;
case ExtUtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed = new INTEGER_template(*other_value.single_value.field_changeSpeed);
break;
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus = new BITSTRING_template(*other_value.single_value.field_setAccelerationControlStatus);
break;
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus = new BITSTRING_template(*other_value.single_value.field_setExteriorLightsStatus);
break;
case ExtUtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading = new INTEGER_template(*other_value.single_value.field_changeHeading);
break;
case ExtUtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection = new INTEGER_template(*other_value.single_value.field_setDriveDirection);
break;
case ExtUtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate = new INTEGER_template(*other_value.single_value.field_changeYawRate);
break;
case ExtUtCamTrigger::ALT_setStationType:
single_value.field_setStationType = new INTEGER_template(*other_value.single_value.field_setStationType);
break;
case ExtUtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole = new INTEGER_template(*other_value.single_value.field_setVehicleRole);
break;
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus = new INTEGER_template(*other_value.single_value.field_setEmbarkationStatus);
break;
case ExtUtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation = new ExtPtActivation_template(*other_value.single_value.field_setPtActivation);
break;
case ExtUtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods = new INTEGER_template(*other_value.single_value.field_setDangerousGoods);
break;
case ExtUtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene = new INTEGER_template(*other_value.single_value.field_setLightBarSirene);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @TTCN_EncDec.ExtUtCamTrigger.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtUtCamTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @TTCN_EncDec.ExtUtCamTrigger.");
}
set_selection(other_value);
}

ExtUtCamTrigger_template::ExtUtCamTrigger_template()
{
}

ExtUtCamTrigger_template::ExtUtCamTrigger_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtUtCamTrigger_template::ExtUtCamTrigger_template(const ExtUtCamTrigger& other_value)
{
copy_value(other_value);
}

ExtUtCamTrigger_template::ExtUtCamTrigger_template(const OPTIONAL<ExtUtCamTrigger>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtCamTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @TTCN_EncDec.ExtUtCamTrigger from an unbound optional field.");
}
}

ExtUtCamTrigger_template::ExtUtCamTrigger_template(const ExtUtCamTrigger_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ExtUtCamTrigger_template::~ExtUtCamTrigger_template()
{
clean_up();
}

void ExtUtCamTrigger_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
delete single_value.field_changeCurvature;
break;
case ExtUtCamTrigger::ALT_changeSpeed:
delete single_value.field_changeSpeed;
break;
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
delete single_value.field_setAccelerationControlStatus;
break;
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
delete single_value.field_setExteriorLightsStatus;
break;
case ExtUtCamTrigger::ALT_changeHeading:
delete single_value.field_changeHeading;
break;
case ExtUtCamTrigger::ALT_setDriveDirection:
delete single_value.field_setDriveDirection;
break;
case ExtUtCamTrigger::ALT_changeYawRate:
delete single_value.field_changeYawRate;
break;
case ExtUtCamTrigger::ALT_setStationType:
delete single_value.field_setStationType;
break;
case ExtUtCamTrigger::ALT_setVehicleRole:
delete single_value.field_setVehicleRole;
break;
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
delete single_value.field_setEmbarkationStatus;
break;
case ExtUtCamTrigger::ALT_setPtActivation:
delete single_value.field_setPtActivation;
break;
case ExtUtCamTrigger::ALT_setDangerousGoods:
delete single_value.field_setDangerousGoods;
break;
case ExtUtCamTrigger::ALT_setLightBarSirene:
delete single_value.field_setLightBarSirene;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtUtCamTrigger_template& ExtUtCamTrigger_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtUtCamTrigger_template& ExtUtCamTrigger_template::operator=(const ExtUtCamTrigger& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtUtCamTrigger_template& ExtUtCamTrigger_template::operator=(const OPTIONAL<ExtUtCamTrigger>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtCamTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
}
return *this;
}

ExtUtCamTrigger_template& ExtUtCamTrigger_template::operator=(const ExtUtCamTrigger_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtUtCamTrigger_template::match(const ExtUtCamTrigger& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
ExtUtCamTrigger::union_selection_type value_selection = other_value.get_selection();
if (value_selection == ExtUtCamTrigger::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
return single_value.field_changeCurvature->match(other_value.changeCurvature(), legacy);
case ExtUtCamTrigger::ALT_changeSpeed:
return single_value.field_changeSpeed->match(other_value.changeSpeed(), legacy);
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
return single_value.field_setAccelerationControlStatus->match(other_value.setAccelerationControlStatus(), legacy);
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
return single_value.field_setExteriorLightsStatus->match(other_value.setExteriorLightsStatus(), legacy);
case ExtUtCamTrigger::ALT_changeHeading:
return single_value.field_changeHeading->match(other_value.changeHeading(), legacy);
case ExtUtCamTrigger::ALT_setDriveDirection:
return single_value.field_setDriveDirection->match(other_value.setDriveDirection(), legacy);
case ExtUtCamTrigger::ALT_changeYawRate:
return single_value.field_changeYawRate->match(other_value.changeYawRate(), legacy);
case ExtUtCamTrigger::ALT_setStationType:
return single_value.field_setStationType->match(other_value.setStationType(), legacy);
case ExtUtCamTrigger::ALT_setVehicleRole:
return single_value.field_setVehicleRole->match(other_value.setVehicleRole(), legacy);
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
return single_value.field_setEmbarkationStatus->match(other_value.setEmbarkationStatus(), legacy);
case ExtUtCamTrigger::ALT_setPtActivation:
return single_value.field_setPtActivation->match(other_value.setPtActivation(), legacy);
case ExtUtCamTrigger::ALT_setDangerousGoods:
return single_value.field_setDangerousGoods->match(other_value.setDangerousGoods(), legacy);
case ExtUtCamTrigger::ALT_setLightBarSirene:
return single_value.field_setLightBarSirene->match(other_value.setLightBarSirene(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @TTCN_EncDec.ExtUtCamTrigger.");
}
return FALSE;
}

boolean ExtUtCamTrigger_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
return single_value.field_changeCurvature->is_value();
case ExtUtCamTrigger::ALT_changeSpeed:
return single_value.field_changeSpeed->is_value();
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
return single_value.field_setAccelerationControlStatus->is_value();
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
return single_value.field_setExteriorLightsStatus->is_value();
case ExtUtCamTrigger::ALT_changeHeading:
return single_value.field_changeHeading->is_value();
case ExtUtCamTrigger::ALT_setDriveDirection:
return single_value.field_setDriveDirection->is_value();
case ExtUtCamTrigger::ALT_changeYawRate:
return single_value.field_changeYawRate->is_value();
case ExtUtCamTrigger::ALT_setStationType:
return single_value.field_setStationType->is_value();
case ExtUtCamTrigger::ALT_setVehicleRole:
return single_value.field_setVehicleRole->is_value();
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
return single_value.field_setEmbarkationStatus->is_value();
case ExtUtCamTrigger::ALT_setPtActivation:
return single_value.field_setPtActivation->is_value();
case ExtUtCamTrigger::ALT_setDangerousGoods:
return single_value.field_setDangerousGoods->is_value();
case ExtUtCamTrigger::ALT_setLightBarSirene:
return single_value.field_setLightBarSirene->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
}
}

ExtUtCamTrigger ExtUtCamTrigger_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
ExtUtCamTrigger ret_val;
switch (single_value.union_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
ret_val.changeCurvature() = single_value.field_changeCurvature->valueof();
break;
case ExtUtCamTrigger::ALT_changeSpeed:
ret_val.changeSpeed() = single_value.field_changeSpeed->valueof();
break;
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
ret_val.setAccelerationControlStatus() = single_value.field_setAccelerationControlStatus->valueof();
break;
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
ret_val.setExteriorLightsStatus() = single_value.field_setExteriorLightsStatus->valueof();
break;
case ExtUtCamTrigger::ALT_changeHeading:
ret_val.changeHeading() = single_value.field_changeHeading->valueof();
break;
case ExtUtCamTrigger::ALT_setDriveDirection:
ret_val.setDriveDirection() = single_value.field_setDriveDirection->valueof();
break;
case ExtUtCamTrigger::ALT_changeYawRate:
ret_val.changeYawRate() = single_value.field_changeYawRate->valueof();
break;
case ExtUtCamTrigger::ALT_setStationType:
ret_val.setStationType() = single_value.field_setStationType->valueof();
break;
case ExtUtCamTrigger::ALT_setVehicleRole:
ret_val.setVehicleRole() = single_value.field_setVehicleRole->valueof();
break;
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
ret_val.setEmbarkationStatus() = single_value.field_setEmbarkationStatus->valueof();
break;
case ExtUtCamTrigger::ALT_setPtActivation:
ret_val.setPtActivation() = single_value.field_setPtActivation->valueof();
break;
case ExtUtCamTrigger::ALT_setDangerousGoods:
ret_val.setDangerousGoods() = single_value.field_setDangerousGoods->valueof();
break;
case ExtUtCamTrigger::ALT_setLightBarSirene:
ret_val.setLightBarSirene() = single_value.field_setLightBarSirene->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
}
return ret_val;
}

ExtUtCamTrigger_template& ExtUtCamTrigger_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return value_list.list_value[list_index];
}
void ExtUtCamTrigger_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtUtCamTrigger_template[list_length];
}

INTEGER_template& ExtUtCamTrigger_template::changeCurvature()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_changeCurvature) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_changeCurvature = new INTEGER_template(ANY_VALUE);
else single_value.field_changeCurvature = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_changeCurvature;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_changeCurvature;
}

const INTEGER_template& ExtUtCamTrigger_template::changeCurvature() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field changeCurvature in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_changeCurvature) TTCN_error("Accessing non-selected field changeCurvature in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_changeCurvature;
}

INTEGER_template& ExtUtCamTrigger_template::changeSpeed()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_changeSpeed) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_changeSpeed = new INTEGER_template(ANY_VALUE);
else single_value.field_changeSpeed = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_changeSpeed;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_changeSpeed;
}

const INTEGER_template& ExtUtCamTrigger_template::changeSpeed() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field changeSpeed in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_changeSpeed) TTCN_error("Accessing non-selected field changeSpeed in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_changeSpeed;
}

BITSTRING_template& ExtUtCamTrigger_template::setAccelerationControlStatus()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_setAccelerationControlStatus) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setAccelerationControlStatus = new BITSTRING_template(ANY_VALUE);
else single_value.field_setAccelerationControlStatus = new BITSTRING_template;
single_value.union_selection = ExtUtCamTrigger::ALT_setAccelerationControlStatus;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setAccelerationControlStatus;
}

const BITSTRING_template& ExtUtCamTrigger_template::setAccelerationControlStatus() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setAccelerationControlStatus in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_setAccelerationControlStatus) TTCN_error("Accessing non-selected field setAccelerationControlStatus in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_setAccelerationControlStatus;
}

BITSTRING_template& ExtUtCamTrigger_template::setExteriorLightsStatus()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_setExteriorLightsStatus) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setExteriorLightsStatus = new BITSTRING_template(ANY_VALUE);
else single_value.field_setExteriorLightsStatus = new BITSTRING_template;
single_value.union_selection = ExtUtCamTrigger::ALT_setExteriorLightsStatus;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setExteriorLightsStatus;
}

const BITSTRING_template& ExtUtCamTrigger_template::setExteriorLightsStatus() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setExteriorLightsStatus in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_setExteriorLightsStatus) TTCN_error("Accessing non-selected field setExteriorLightsStatus in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_setExteriorLightsStatus;
}

INTEGER_template& ExtUtCamTrigger_template::changeHeading()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_changeHeading) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_changeHeading = new INTEGER_template(ANY_VALUE);
else single_value.field_changeHeading = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_changeHeading;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_changeHeading;
}

const INTEGER_template& ExtUtCamTrigger_template::changeHeading() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field changeHeading in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_changeHeading) TTCN_error("Accessing non-selected field changeHeading in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_changeHeading;
}

INTEGER_template& ExtUtCamTrigger_template::setDriveDirection()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_setDriveDirection) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setDriveDirection = new INTEGER_template(ANY_VALUE);
else single_value.field_setDriveDirection = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_setDriveDirection;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setDriveDirection;
}

const INTEGER_template& ExtUtCamTrigger_template::setDriveDirection() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setDriveDirection in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_setDriveDirection) TTCN_error("Accessing non-selected field setDriveDirection in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_setDriveDirection;
}

INTEGER_template& ExtUtCamTrigger_template::changeYawRate()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_changeYawRate) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_changeYawRate = new INTEGER_template(ANY_VALUE);
else single_value.field_changeYawRate = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_changeYawRate;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_changeYawRate;
}

const INTEGER_template& ExtUtCamTrigger_template::changeYawRate() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field changeYawRate in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_changeYawRate) TTCN_error("Accessing non-selected field changeYawRate in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_changeYawRate;
}

INTEGER_template& ExtUtCamTrigger_template::setStationType()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_setStationType) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setStationType = new INTEGER_template(ANY_VALUE);
else single_value.field_setStationType = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_setStationType;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setStationType;
}

const INTEGER_template& ExtUtCamTrigger_template::setStationType() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setStationType in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_setStationType) TTCN_error("Accessing non-selected field setStationType in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_setStationType;
}

INTEGER_template& ExtUtCamTrigger_template::setVehicleRole()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_setVehicleRole) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setVehicleRole = new INTEGER_template(ANY_VALUE);
else single_value.field_setVehicleRole = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_setVehicleRole;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setVehicleRole;
}

const INTEGER_template& ExtUtCamTrigger_template::setVehicleRole() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setVehicleRole in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_setVehicleRole) TTCN_error("Accessing non-selected field setVehicleRole in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_setVehicleRole;
}

INTEGER_template& ExtUtCamTrigger_template::setEmbarkationStatus()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_setEmbarkationStatus) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setEmbarkationStatus = new INTEGER_template(ANY_VALUE);
else single_value.field_setEmbarkationStatus = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_setEmbarkationStatus;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setEmbarkationStatus;
}

const INTEGER_template& ExtUtCamTrigger_template::setEmbarkationStatus() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setEmbarkationStatus in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_setEmbarkationStatus) TTCN_error("Accessing non-selected field setEmbarkationStatus in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_setEmbarkationStatus;
}

ExtPtActivation_template& ExtUtCamTrigger_template::setPtActivation()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_setPtActivation) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setPtActivation = new ExtPtActivation_template(ANY_VALUE);
else single_value.field_setPtActivation = new ExtPtActivation_template;
single_value.union_selection = ExtUtCamTrigger::ALT_setPtActivation;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setPtActivation;
}

const ExtPtActivation_template& ExtUtCamTrigger_template::setPtActivation() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setPtActivation in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_setPtActivation) TTCN_error("Accessing non-selected field setPtActivation in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_setPtActivation;
}

INTEGER_template& ExtUtCamTrigger_template::setDangerousGoods()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_setDangerousGoods) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setDangerousGoods = new INTEGER_template(ANY_VALUE);
else single_value.field_setDangerousGoods = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_setDangerousGoods;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setDangerousGoods;
}

const INTEGER_template& ExtUtCamTrigger_template::setDangerousGoods() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setDangerousGoods in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_setDangerousGoods) TTCN_error("Accessing non-selected field setDangerousGoods in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_setDangerousGoods;
}

INTEGER_template& ExtUtCamTrigger_template::setLightBarSirene()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtUtCamTrigger::ALT_setLightBarSirene) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_setLightBarSirene = new INTEGER_template(ANY_VALUE);
else single_value.field_setLightBarSirene = new INTEGER_template;
single_value.union_selection = ExtUtCamTrigger::ALT_setLightBarSirene;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_setLightBarSirene;
}

const INTEGER_template& ExtUtCamTrigger_template::setLightBarSirene() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field setLightBarSirene in a non-specific template of union type @TTCN_EncDec.ExtUtCamTrigger.");
if (single_value.union_selection != ExtUtCamTrigger::ALT_setLightBarSirene) TTCN_error("Accessing non-selected field setLightBarSirene in a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return *single_value.field_setLightBarSirene;
}

boolean ExtUtCamTrigger_template::ischosen(ExtUtCamTrigger::union_selection_type checked_selection) const
{
if (checked_selection == ExtUtCamTrigger::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @TTCN_EncDec.ExtUtCamTrigger.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == ExtUtCamTrigger::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @TTCN_EncDec.ExtUtCamTrigger containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @TTCN_EncDec.ExtUtCamTrigger, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @TTCN_EncDec.ExtUtCamTrigger");
}
return FALSE;
}

void ExtUtCamTrigger_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
TTCN_Logger::log_event_str("{ changeCurvature := ");
single_value.field_changeCurvature->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_changeSpeed:
TTCN_Logger::log_event_str("{ changeSpeed := ");
single_value.field_changeSpeed->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
TTCN_Logger::log_event_str("{ setAccelerationControlStatus := ");
single_value.field_setAccelerationControlStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
TTCN_Logger::log_event_str("{ setExteriorLightsStatus := ");
single_value.field_setExteriorLightsStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_changeHeading:
TTCN_Logger::log_event_str("{ changeHeading := ");
single_value.field_changeHeading->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_setDriveDirection:
TTCN_Logger::log_event_str("{ setDriveDirection := ");
single_value.field_setDriveDirection->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_changeYawRate:
TTCN_Logger::log_event_str("{ changeYawRate := ");
single_value.field_changeYawRate->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_setStationType:
TTCN_Logger::log_event_str("{ setStationType := ");
single_value.field_setStationType->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_setVehicleRole:
TTCN_Logger::log_event_str("{ setVehicleRole := ");
single_value.field_setVehicleRole->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
TTCN_Logger::log_event_str("{ setEmbarkationStatus := ");
single_value.field_setEmbarkationStatus->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_setPtActivation:
TTCN_Logger::log_event_str("{ setPtActivation := ");
single_value.field_setPtActivation->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_setDangerousGoods:
TTCN_Logger::log_event_str("{ setDangerousGoods := ");
single_value.field_setDangerousGoods->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtUtCamTrigger::ALT_setLightBarSirene:
TTCN_Logger::log_event_str("{ setLightBarSirene := ");
single_value.field_setLightBarSirene->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtUtCamTrigger_template::log_match(const ExtUtCamTrigger& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".changeCurvature");
single_value.field_changeCurvature->log_match(match_value.changeCurvature(), legacy);
} else {
TTCN_Logger::log_event_str("{ changeCurvature := ");
single_value.field_changeCurvature->log_match(match_value.changeCurvature(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_changeSpeed:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".changeSpeed");
single_value.field_changeSpeed->log_match(match_value.changeSpeed(), legacy);
} else {
TTCN_Logger::log_event_str("{ changeSpeed := ");
single_value.field_changeSpeed->log_match(match_value.changeSpeed(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setAccelerationControlStatus");
single_value.field_setAccelerationControlStatus->log_match(match_value.setAccelerationControlStatus(), legacy);
} else {
TTCN_Logger::log_event_str("{ setAccelerationControlStatus := ");
single_value.field_setAccelerationControlStatus->log_match(match_value.setAccelerationControlStatus(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setExteriorLightsStatus");
single_value.field_setExteriorLightsStatus->log_match(match_value.setExteriorLightsStatus(), legacy);
} else {
TTCN_Logger::log_event_str("{ setExteriorLightsStatus := ");
single_value.field_setExteriorLightsStatus->log_match(match_value.setExteriorLightsStatus(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_changeHeading:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".changeHeading");
single_value.field_changeHeading->log_match(match_value.changeHeading(), legacy);
} else {
TTCN_Logger::log_event_str("{ changeHeading := ");
single_value.field_changeHeading->log_match(match_value.changeHeading(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_setDriveDirection:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setDriveDirection");
single_value.field_setDriveDirection->log_match(match_value.setDriveDirection(), legacy);
} else {
TTCN_Logger::log_event_str("{ setDriveDirection := ");
single_value.field_setDriveDirection->log_match(match_value.setDriveDirection(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_changeYawRate:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".changeYawRate");
single_value.field_changeYawRate->log_match(match_value.changeYawRate(), legacy);
} else {
TTCN_Logger::log_event_str("{ changeYawRate := ");
single_value.field_changeYawRate->log_match(match_value.changeYawRate(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_setStationType:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setStationType");
single_value.field_setStationType->log_match(match_value.setStationType(), legacy);
} else {
TTCN_Logger::log_event_str("{ setStationType := ");
single_value.field_setStationType->log_match(match_value.setStationType(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_setVehicleRole:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setVehicleRole");
single_value.field_setVehicleRole->log_match(match_value.setVehicleRole(), legacy);
} else {
TTCN_Logger::log_event_str("{ setVehicleRole := ");
single_value.field_setVehicleRole->log_match(match_value.setVehicleRole(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setEmbarkationStatus");
single_value.field_setEmbarkationStatus->log_match(match_value.setEmbarkationStatus(), legacy);
} else {
TTCN_Logger::log_event_str("{ setEmbarkationStatus := ");
single_value.field_setEmbarkationStatus->log_match(match_value.setEmbarkationStatus(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_setPtActivation:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setPtActivation");
single_value.field_setPtActivation->log_match(match_value.setPtActivation(), legacy);
} else {
TTCN_Logger::log_event_str("{ setPtActivation := ");
single_value.field_setPtActivation->log_match(match_value.setPtActivation(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_setDangerousGoods:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setDangerousGoods");
single_value.field_setDangerousGoods->log_match(match_value.setDangerousGoods(), legacy);
} else {
TTCN_Logger::log_event_str("{ setDangerousGoods := ");
single_value.field_setDangerousGoods->log_match(match_value.setDangerousGoods(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtUtCamTrigger::ALT_setLightBarSirene:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".setLightBarSirene");
single_value.field_setLightBarSirene->log_match(match_value.setLightBarSirene(), legacy);
} else {
TTCN_Logger::log_event_str("{ setLightBarSirene := ");
single_value.field_setLightBarSirene->log_match(match_value.setLightBarSirene(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtUtCamTrigger_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setStationType:
single_value.field_setStationType->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods->encode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @TTCN_EncDec.ExtUtCamTrigger.");
}
}

void ExtUtCamTrigger_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = ExtUtCamTrigger::UNBOUND_VALUE;
ExtUtCamTrigger::union_selection_type new_selection = (ExtUtCamTrigger::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature = new INTEGER_template;
single_value.field_changeCurvature->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed = new INTEGER_template;
single_value.field_changeSpeed->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus = new BITSTRING_template;
single_value.field_setAccelerationControlStatus->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus = new BITSTRING_template;
single_value.field_setExteriorLightsStatus->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading = new INTEGER_template;
single_value.field_changeHeading->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection = new INTEGER_template;
single_value.field_setDriveDirection->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate = new INTEGER_template;
single_value.field_changeYawRate->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setStationType:
single_value.field_setStationType = new INTEGER_template;
single_value.field_setStationType->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole = new INTEGER_template;
single_value.field_setVehicleRole->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus = new INTEGER_template;
single_value.field_setEmbarkationStatus->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation = new ExtPtActivation_template;
single_value.field_setPtActivation->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods = new INTEGER_template;
single_value.field_setDangerousGoods->decode_text(text_buf);
break;
case ExtUtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene = new INTEGER_template;
single_value.field_setLightBarSirene->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @TTCN_EncDec.ExtUtCamTrigger.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtUtCamTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @TTCN_EncDec.ExtUtCamTrigger.");
}
}

boolean ExtUtCamTrigger_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtUtCamTrigger_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ExtUtCamTrigger_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@TTCN_EncDec.ExtUtCamTrigger'");
    }
    if (strcmp("changeCurvature", param_field) == 0) {
      changeCurvature().set_param(param);
      return;
    } else if (strcmp("changeSpeed", param_field) == 0) {
      changeSpeed().set_param(param);
      return;
    } else if (strcmp("setAccelerationControlStatus", param_field) == 0) {
      setAccelerationControlStatus().set_param(param);
      return;
    } else if (strcmp("setExteriorLightsStatus", param_field) == 0) {
      setExteriorLightsStatus().set_param(param);
      return;
    } else if (strcmp("changeHeading", param_field) == 0) {
      changeHeading().set_param(param);
      return;
    } else if (strcmp("setDriveDirection", param_field) == 0) {
      setDriveDirection().set_param(param);
      return;
    } else if (strcmp("changeYawRate", param_field) == 0) {
      changeYawRate().set_param(param);
      return;
    } else if (strcmp("setStationType", param_field) == 0) {
      setStationType().set_param(param);
      return;
    } else if (strcmp("setVehicleRole", param_field) == 0) {
      setVehicleRole().set_param(param);
      return;
    } else if (strcmp("setEmbarkationStatus", param_field) == 0) {
      setEmbarkationStatus().set_param(param);
      return;
    } else if (strcmp("setPtActivation", param_field) == 0) {
      setPtActivation().set_param(param);
      return;
    } else if (strcmp("setDangerousGoods", param_field) == 0) {
      setDangerousGoods().set_param(param);
      return;
    } else if (strcmp("setLightBarSirene", param_field) == 0) {
      setLightBarSirene().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@TTCN_EncDec.ExtUtCamTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtUtCamTrigger_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@TTCN_EncDec.ExtUtCamTrigger");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "changeCurvature")) {
      changeCurvature().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "changeSpeed")) {
      changeSpeed().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setAccelerationControlStatus")) {
      setAccelerationControlStatus().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setExteriorLightsStatus")) {
      setExteriorLightsStatus().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "changeHeading")) {
      changeHeading().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setDriveDirection")) {
      setDriveDirection().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "changeYawRate")) {
      changeYawRate().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setStationType")) {
      setStationType().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setVehicleRole")) {
      setVehicleRole().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setEmbarkationStatus")) {
      setEmbarkationStatus().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setPtActivation")) {
      setPtActivation().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setDangerousGoods")) {
      setDangerousGoods().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "setLightBarSirene")) {
      setLightBarSirene().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @TTCN_EncDec.ExtUtCamTrigger.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@TTCN_EncDec.ExtUtCamTrigger");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtUtCamTrigger_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@TTCN_EncDec.ExtUtCamTrigger'");
    }
    if (strcmp("changeCurvature", param_field) == 0) {
      return changeCurvature().get_param(param_name);
    } else if (strcmp("changeSpeed", param_field) == 0) {
      return changeSpeed().get_param(param_name);
    } else if (strcmp("setAccelerationControlStatus", param_field) == 0) {
      return setAccelerationControlStatus().get_param(param_name);
    } else if (strcmp("setExteriorLightsStatus", param_field) == 0) {
      return setExteriorLightsStatus().get_param(param_name);
    } else if (strcmp("changeHeading", param_field) == 0) {
      return changeHeading().get_param(param_name);
    } else if (strcmp("setDriveDirection", param_field) == 0) {
      return setDriveDirection().get_param(param_name);
    } else if (strcmp("changeYawRate", param_field) == 0) {
      return changeYawRate().get_param(param_name);
    } else if (strcmp("setStationType", param_field) == 0) {
      return setStationType().get_param(param_name);
    } else if (strcmp("setVehicleRole", param_field) == 0) {
      return setVehicleRole().get_param(param_name);
    } else if (strcmp("setEmbarkationStatus", param_field) == 0) {
      return setEmbarkationStatus().get_param(param_name);
    } else if (strcmp("setPtActivation", param_field) == 0) {
      return setPtActivation().get_param(param_name);
    } else if (strcmp("setDangerousGoods", param_field) == 0) {
      return setDangerousGoods().get_param(param_name);
    } else if (strcmp("setLightBarSirene", param_field) == 0) {
      return setLightBarSirene().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ExtUtCamTrigger'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case ExtUtCamTrigger::ALT_changeCurvature:
      mp_field = single_value.field_changeCurvature->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("changeCurvature")));
      break;
    case ExtUtCamTrigger::ALT_changeSpeed:
      mp_field = single_value.field_changeSpeed->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("changeSpeed")));
      break;
    case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
      mp_field = single_value.field_setAccelerationControlStatus->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setAccelerationControlStatus")));
      break;
    case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
      mp_field = single_value.field_setExteriorLightsStatus->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setExteriorLightsStatus")));
      break;
    case ExtUtCamTrigger::ALT_changeHeading:
      mp_field = single_value.field_changeHeading->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("changeHeading")));
      break;
    case ExtUtCamTrigger::ALT_setDriveDirection:
      mp_field = single_value.field_setDriveDirection->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setDriveDirection")));
      break;
    case ExtUtCamTrigger::ALT_changeYawRate:
      mp_field = single_value.field_changeYawRate->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("changeYawRate")));
      break;
    case ExtUtCamTrigger::ALT_setStationType:
      mp_field = single_value.field_setStationType->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setStationType")));
      break;
    case ExtUtCamTrigger::ALT_setVehicleRole:
      mp_field = single_value.field_setVehicleRole->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setVehicleRole")));
      break;
    case ExtUtCamTrigger::ALT_setEmbarkationStatus:
      mp_field = single_value.field_setEmbarkationStatus->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setEmbarkationStatus")));
      break;
    case ExtUtCamTrigger::ALT_setPtActivation:
      mp_field = single_value.field_setPtActivation->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setPtActivation")));
      break;
    case ExtUtCamTrigger::ALT_setDangerousGoods:
      mp_field = single_value.field_setDangerousGoods->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setDangerousGoods")));
      break;
    case ExtUtCamTrigger::ALT_setLightBarSirene:
      mp_field = single_value.field_setLightBarSirene->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("setLightBarSirene")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtUtCamTrigger_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case ExtUtCamTrigger::ALT_changeCurvature:
single_value.field_changeCurvature->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_changeSpeed:
single_value.field_changeSpeed->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_setAccelerationControlStatus:
single_value.field_setAccelerationControlStatus->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_setExteriorLightsStatus:
single_value.field_setExteriorLightsStatus->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_changeHeading:
single_value.field_changeHeading->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_setDriveDirection:
single_value.field_setDriveDirection->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_changeYawRate:
single_value.field_changeYawRate->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_setStationType:
single_value.field_setStationType->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_setVehicleRole:
single_value.field_setVehicleRole->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_setEmbarkationStatus:
single_value.field_setEmbarkationStatus->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_setPtActivation:
single_value.field_setPtActivation->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_setDangerousGoods:
single_value.field_setDangerousGoods->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
case ExtUtCamTrigger::ALT_setLightBarSirene:
single_value.field_setLightBarSirene->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TTCN_EncDec.ExtUtCamTrigger.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtUtCamTrigger");
}

ExtUtCamEventInd::ExtUtCamEventInd()
{
  bound_flag = FALSE;
}

ExtUtCamEventInd::ExtUtCamEventInd(const INTEGER& par_camPduLength,
    const OCTETSTRING& par_camMsg)
  :   field_camPduLength(par_camPduLength),
  field_camMsg(par_camMsg)
{
  bound_flag = TRUE;
}

ExtUtCamEventInd::ExtUtCamEventInd(const ExtUtCamEventInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtUtCamEventInd.");
bound_flag = TRUE;
if (other_value.camPduLength().is_bound()) field_camPduLength = other_value.camPduLength();
else field_camPduLength.clean_up();
if (other_value.camMsg().is_bound()) field_camMsg = other_value.camMsg();
else field_camMsg.clean_up();
}

void ExtUtCamEventInd::clean_up()
{
field_camPduLength.clean_up();
field_camMsg.clean_up();
bound_flag = FALSE;
}

ExtUtCamEventInd& ExtUtCamEventInd::operator=(const ExtUtCamEventInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtUtCamEventInd.");
  bound_flag = TRUE;
  if (other_value.camPduLength().is_bound()) field_camPduLength = other_value.camPduLength();
  else field_camPduLength.clean_up();
  if (other_value.camMsg().is_bound()) field_camMsg = other_value.camMsg();
  else field_camMsg.clean_up();
}
return *this;
}

boolean ExtUtCamEventInd::operator==(const ExtUtCamEventInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_camPduLength==other_value.field_camPduLength
  && field_camMsg==other_value.field_camMsg;
}

boolean ExtUtCamEventInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_camPduLength.is_bound()) return TRUE;
if(field_camMsg.is_bound()) return TRUE;
return FALSE;
}
boolean ExtUtCamEventInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_camPduLength.is_value()) return FALSE;
if(!field_camMsg.is_value()) return FALSE;
return TRUE;
}
int ExtUtCamEventInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtUtCamEventInd");
  return 2;
}

void ExtUtCamEventInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ camPduLength := ");
field_camPduLength.log();
TTCN_Logger::log_event_str(", camMsg := ");
field_camMsg.log();
TTCN_Logger::log_event_str(" }");
}

void ExtUtCamEventInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtUtCamEventInd'");
    }
    if (strcmp("camPduLength", param_field) == 0) {
      camPduLength().set_param(param);
      return;
    } else if (strcmp("camMsg", param_field) == 0) {
      camMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtCamEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtUtCamEventInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) camPduLength().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) camMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "camPduLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          camPduLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "camMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          camMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtCamEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtUtCamEventInd");
  }
}

Module_Param* ExtUtCamEventInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtUtCamEventInd'");
    }
    if (strcmp("camPduLength", param_field) == 0) {
      return camPduLength().get_param(param_name);
    } else if (strcmp("camMsg", param_field) == 0) {
      return camMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtCamEventInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_camPduLength = field_camPduLength.get_param(param_name);
  mp_field_camPduLength->set_id(new Module_Param_FieldName(mcopystr("camPduLength")));
  mp->add_elem(mp_field_camPduLength);
  Module_Param* mp_field_camMsg = field_camMsg.get_param(param_name);
  mp_field_camMsg->set_id(new Module_Param_FieldName(mcopystr("camMsg")));
  mp->add_elem(mp_field_camMsg);
  return mp;
  }

void ExtUtCamEventInd::set_implicit_omit()
{
if (camPduLength().is_bound()) camPduLength().set_implicit_omit();
if (camMsg().is_bound()) camMsg().set_implicit_omit();
}

void ExtUtCamEventInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtUtCamEventInd.");
field_camPduLength.encode_text(text_buf);
field_camMsg.encode_text(text_buf);
}

void ExtUtCamEventInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_camPduLength.decode_text(text_buf);
field_camMsg.decode_text(text_buf);
}

void ExtUtCamEventInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtUtCamEventInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtUtCamEventInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  int value_of_length_field0 = 0;
  decoded_field_length = field_camPduLength.RAW_decode(ExtUtCamEventInd_camPduLength_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field0+=(int)field_camPduLength*8;
  decoded_field_length = field_camMsg.RAW_decode(OCTETSTRING_descr_, p_buf, min_of_ints(2, limit, value_of_length_field0), local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field0 -= decoded_field_length;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtUtCamEventInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ExtUtCamEventInd_camPduLength_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, OCTETSTRING_descr_.raw);
  encoded_length += 16;
  myleaf.body.node.nodes[0]->calc = CALC_LENGTH;
  myleaf.body.node.nodes[0]->coding_descr = &ExtUtCamEventInd_camPduLength_descr_;
  myleaf.body.node.nodes[0]->calcof.lengthto.num_of_fields = 1;
  myleaf.body.node.nodes[0]->calcof.lengthto.unit = 8;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields = init_lengthto_fields_list(1);
  myleaf.body.node.nodes[0]->length = 16;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields[0].level = myleaf.body.node.nodes[1]->curr_pos.level;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields[0].pos = myleaf.body.node.nodes[1]->curr_pos.pos;
  encoded_length += field_camMsg.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int ExtUtCamEventInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtUtCamEventInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "camPduLength");
    enc_len += field_camPduLength.JSON_encode(ExtUtCamEventInd_camPduLength_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "camMsg");
    enc_len += field_camMsg.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtUtCamEventInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "camPduLength", name_len)) {
         int ret_val = field_camPduLength.JSON_decode(ExtUtCamEventInd_camPduLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "camPduLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "camMsg", name_len)) {
         int ret_val = field_camMsg.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "camMsg");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_camPduLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "camPduLength");
    return JSON_ERROR_FATAL;
  }
if (!field_camMsg.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "camMsg");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtUtCamEventInd_template::single_value_struct {
INTEGER_template field_camPduLength;
OCTETSTRING_template field_camMsg;
};

void ExtUtCamEventInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_camPduLength = ANY_VALUE;
single_value->field_camMsg = ANY_VALUE;
}
}
}

void ExtUtCamEventInd_template::copy_value(const ExtUtCamEventInd& other_value)
{
single_value = new single_value_struct;
if (other_value.camPduLength().is_bound()) {
  single_value->field_camPduLength = other_value.camPduLength();
} else {
  single_value->field_camPduLength.clean_up();
}
if (other_value.camMsg().is_bound()) {
  single_value->field_camMsg = other_value.camMsg();
} else {
  single_value->field_camMsg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtUtCamEventInd_template::copy_template(const ExtUtCamEventInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.camPduLength().get_selection()) {
single_value->field_camPduLength = other_value.camPduLength();
} else {
single_value->field_camPduLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.camMsg().get_selection()) {
single_value->field_camMsg = other_value.camMsg();
} else {
single_value->field_camMsg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtUtCamEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtCamEventInd.");
break;
}
set_selection(other_value);
}

ExtUtCamEventInd_template::ExtUtCamEventInd_template()
{
}

ExtUtCamEventInd_template::ExtUtCamEventInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtUtCamEventInd_template::ExtUtCamEventInd_template(const ExtUtCamEventInd& other_value)
{
copy_value(other_value);
}

ExtUtCamEventInd_template::ExtUtCamEventInd_template(const OPTIONAL<ExtUtCamEventInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtCamEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtUtCamEventInd from an unbound optional field.");
}
}

ExtUtCamEventInd_template::ExtUtCamEventInd_template(const ExtUtCamEventInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtUtCamEventInd_template::~ExtUtCamEventInd_template()
{
clean_up();
}

ExtUtCamEventInd_template& ExtUtCamEventInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtUtCamEventInd_template& ExtUtCamEventInd_template::operator=(const ExtUtCamEventInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtUtCamEventInd_template& ExtUtCamEventInd_template::operator=(const OPTIONAL<ExtUtCamEventInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtCamEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtUtCamEventInd.");
}
return *this;
}

ExtUtCamEventInd_template& ExtUtCamEventInd_template::operator=(const ExtUtCamEventInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtUtCamEventInd_template::match(const ExtUtCamEventInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.camPduLength().is_bound()) return FALSE;
if(!single_value->field_camPduLength.match(other_value.camPduLength(), legacy))return FALSE;
if(!other_value.camMsg().is_bound()) return FALSE;
if(!single_value->field_camMsg.match(other_value.camMsg(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtCamEventInd.");
}
return FALSE;
}

boolean ExtUtCamEventInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_camPduLength.is_bound()) return TRUE;
if (single_value->field_camMsg.is_bound()) return TRUE;
return FALSE;
}

boolean ExtUtCamEventInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_camPduLength.is_value()) return FALSE;
if (!single_value->field_camMsg.is_value()) return FALSE;
return TRUE;
}

void ExtUtCamEventInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtUtCamEventInd ExtUtCamEventInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtUtCamEventInd.");
ExtUtCamEventInd ret_val;
if (single_value->field_camPduLength.is_bound()) {
ret_val.camPduLength() = single_value->field_camPduLength.valueof();
}
if (single_value->field_camMsg.is_bound()) {
ret_val.camMsg() = single_value->field_camMsg.valueof();
}
return ret_val;
}

void ExtUtCamEventInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtUtCamEventInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtUtCamEventInd_template[list_length];
}

ExtUtCamEventInd_template& ExtUtCamEventInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtUtCamEventInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtUtCamEventInd.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtUtCamEventInd_template::camPduLength()
{
set_specific();
return single_value->field_camPduLength;
}

const INTEGER_template& ExtUtCamEventInd_template::camPduLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field camPduLength of a non-specific template of type @TTCN_EncDec.ExtUtCamEventInd.");
return single_value->field_camPduLength;
}

OCTETSTRING_template& ExtUtCamEventInd_template::camMsg()
{
set_specific();
return single_value->field_camMsg;
}

const OCTETSTRING_template& ExtUtCamEventInd_template::camMsg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field camMsg of a non-specific template of type @TTCN_EncDec.ExtUtCamEventInd.");
return single_value->field_camMsg;
}

int ExtUtCamEventInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtCamEventInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtCamEventInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtCamEventInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtCamEventInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtCamEventInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtCamEventInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtCamEventInd.");
  }
  return 0;
}

void ExtUtCamEventInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ camPduLength := ");
single_value->field_camPduLength.log();
TTCN_Logger::log_event_str(", camMsg := ");
single_value->field_camMsg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtUtCamEventInd_template::log_match(const ExtUtCamEventInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_camPduLength.match(match_value.camPduLength(), legacy)){
TTCN_Logger::log_logmatch_info(".camPduLength");
single_value->field_camPduLength.log_match(match_value.camPduLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_camMsg.match(match_value.camMsg(), legacy)){
TTCN_Logger::log_logmatch_info(".camMsg");
single_value->field_camMsg.log_match(match_value.camMsg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ camPduLength := ");
single_value->field_camPduLength.log_match(match_value.camPduLength(), legacy);
TTCN_Logger::log_event_str(", camMsg := ");
single_value->field_camMsg.log_match(match_value.camMsg(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtUtCamEventInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_camPduLength.encode_text(text_buf);
single_value->field_camMsg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtCamEventInd.");
}
}

void ExtUtCamEventInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_camPduLength.decode_text(text_buf);
single_value->field_camMsg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtUtCamEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtUtCamEventInd.");
}
}

void ExtUtCamEventInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtUtCamEventInd'");
    }
    if (strcmp("camPduLength", param_field) == 0) {
      camPduLength().set_param(param);
      return;
    } else if (strcmp("camMsg", param_field) == 0) {
      camMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtUtCamEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtUtCamEventInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtUtCamEventInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) camPduLength().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) camMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "camPduLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          camPduLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "camMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          camMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtCamEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtUtCamEventInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtUtCamEventInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtUtCamEventInd'");
    }
    if (strcmp("camPduLength", param_field) == 0) {
      return camPduLength().get_param(param_name);
    } else if (strcmp("camMsg", param_field) == 0) {
      return camMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtCamEventInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_camPduLength = single_value->field_camPduLength.get_param(param_name);
    mp_field_camPduLength->set_id(new Module_Param_FieldName(mcopystr("camPduLength")));
    mp->add_elem(mp_field_camPduLength);
    Module_Param* mp_field_camMsg = single_value->field_camMsg.get_param(param_name);
    mp_field_camMsg->set_id(new Module_Param_FieldName(mcopystr("camMsg")));
    mp->add_elem(mp_field_camMsg);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtUtCamEventInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_camPduLength.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamEventInd");
single_value->field_camMsg.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtCamEventInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtUtCamEventInd");
}

boolean ExtUtCamEventInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtUtCamEventInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtSituationContainer::ExtSituationContainer()
{
  bound_flag = FALSE;
}

ExtSituationContainer::ExtSituationContainer(const INTEGER& par_informationQuality,
    const INTEGER& par_causeCode,
    const INTEGER& par_subCauseCode)
  :   field_informationQuality(par_informationQuality),
  field_causeCode(par_causeCode),
  field_subCauseCode(par_subCauseCode)
{
  bound_flag = TRUE;
}

ExtSituationContainer::ExtSituationContainer(const ExtSituationContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtSituationContainer.");
bound_flag = TRUE;
if (other_value.informationQuality().is_bound()) field_informationQuality = other_value.informationQuality();
else field_informationQuality.clean_up();
if (other_value.causeCode().is_bound()) field_causeCode = other_value.causeCode();
else field_causeCode.clean_up();
if (other_value.subCauseCode().is_bound()) field_subCauseCode = other_value.subCauseCode();
else field_subCauseCode.clean_up();
}

void ExtSituationContainer::clean_up()
{
field_informationQuality.clean_up();
field_causeCode.clean_up();
field_subCauseCode.clean_up();
bound_flag = FALSE;
}

ExtSituationContainer& ExtSituationContainer::operator=(const ExtSituationContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtSituationContainer.");
  bound_flag = TRUE;
  if (other_value.informationQuality().is_bound()) field_informationQuality = other_value.informationQuality();
  else field_informationQuality.clean_up();
  if (other_value.causeCode().is_bound()) field_causeCode = other_value.causeCode();
  else field_causeCode.clean_up();
  if (other_value.subCauseCode().is_bound()) field_subCauseCode = other_value.subCauseCode();
  else field_subCauseCode.clean_up();
}
return *this;
}

boolean ExtSituationContainer::operator==(const ExtSituationContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_informationQuality==other_value.field_informationQuality
  && field_causeCode==other_value.field_causeCode
  && field_subCauseCode==other_value.field_subCauseCode;
}

boolean ExtSituationContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_informationQuality.is_bound()) return TRUE;
if(field_causeCode.is_bound()) return TRUE;
if(field_subCauseCode.is_bound()) return TRUE;
return FALSE;
}
boolean ExtSituationContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_informationQuality.is_value()) return FALSE;
if(!field_causeCode.is_value()) return FALSE;
if(!field_subCauseCode.is_value()) return FALSE;
return TRUE;
}
int ExtSituationContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtSituationContainer");
  return 3;
}

void ExtSituationContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ informationQuality := ");
field_informationQuality.log();
TTCN_Logger::log_event_str(", causeCode := ");
field_causeCode.log();
TTCN_Logger::log_event_str(", subCauseCode := ");
field_subCauseCode.log();
TTCN_Logger::log_event_str(" }");
}

void ExtSituationContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtSituationContainer'");
    }
    if (strcmp("informationQuality", param_field) == 0) {
      informationQuality().set_param(param);
      return;
    } else if (strcmp("causeCode", param_field) == 0) {
      causeCode().set_param(param);
      return;
    } else if (strcmp("subCauseCode", param_field) == 0) {
      subCauseCode().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtSituationContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtSituationContainer has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) informationQuality().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) causeCode().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) subCauseCode().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "informationQuality")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          informationQuality().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "causeCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          causeCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subCauseCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subCauseCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtSituationContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtSituationContainer");
  }
}

Module_Param* ExtSituationContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtSituationContainer'");
    }
    if (strcmp("informationQuality", param_field) == 0) {
      return informationQuality().get_param(param_name);
    } else if (strcmp("causeCode", param_field) == 0) {
      return causeCode().get_param(param_name);
    } else if (strcmp("subCauseCode", param_field) == 0) {
      return subCauseCode().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtSituationContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_informationQuality = field_informationQuality.get_param(param_name);
  mp_field_informationQuality->set_id(new Module_Param_FieldName(mcopystr("informationQuality")));
  mp->add_elem(mp_field_informationQuality);
  Module_Param* mp_field_causeCode = field_causeCode.get_param(param_name);
  mp_field_causeCode->set_id(new Module_Param_FieldName(mcopystr("causeCode")));
  mp->add_elem(mp_field_causeCode);
  Module_Param* mp_field_subCauseCode = field_subCauseCode.get_param(param_name);
  mp_field_subCauseCode->set_id(new Module_Param_FieldName(mcopystr("subCauseCode")));
  mp->add_elem(mp_field_subCauseCode);
  return mp;
  }

void ExtSituationContainer::set_implicit_omit()
{
if (informationQuality().is_bound()) informationQuality().set_implicit_omit();
if (causeCode().is_bound()) causeCode().set_implicit_omit();
if (subCauseCode().is_bound()) subCauseCode().set_implicit_omit();
}

void ExtSituationContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtSituationContainer.");
field_informationQuality.encode_text(text_buf);
field_causeCode.encode_text(text_buf);
field_subCauseCode.encode_text(text_buf);
}

void ExtSituationContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_informationQuality.decode_text(text_buf);
field_causeCode.decode_text(text_buf);
field_subCauseCode.decode_text(text_buf);
}

void ExtSituationContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtSituationContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtSituationContainer::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_informationQuality.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_causeCode.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_subCauseCode.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtSituationContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  encoded_length += field_informationQuality.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_causeCode.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_subCauseCode.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int ExtSituationContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtSituationContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "informationQuality");
    enc_len += field_informationQuality.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "causeCode");
    enc_len += field_causeCode.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "subCauseCode");
    enc_len += field_subCauseCode.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtSituationContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "informationQuality", name_len)) {
         int ret_val = field_informationQuality.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "informationQuality");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "causeCode", name_len)) {
         int ret_val = field_causeCode.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "causeCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "subCauseCode", name_len)) {
         int ret_val = field_subCauseCode.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "subCauseCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_informationQuality.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "informationQuality");
    return JSON_ERROR_FATAL;
  }
if (!field_causeCode.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "causeCode");
    return JSON_ERROR_FATAL;
  }
if (!field_subCauseCode.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "subCauseCode");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtSituationContainer_template::single_value_struct {
INTEGER_template field_informationQuality;
INTEGER_template field_causeCode;
INTEGER_template field_subCauseCode;
};

void ExtSituationContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_informationQuality = ANY_VALUE;
single_value->field_causeCode = ANY_VALUE;
single_value->field_subCauseCode = ANY_VALUE;
}
}
}

void ExtSituationContainer_template::copy_value(const ExtSituationContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.informationQuality().is_bound()) {
  single_value->field_informationQuality = other_value.informationQuality();
} else {
  single_value->field_informationQuality.clean_up();
}
if (other_value.causeCode().is_bound()) {
  single_value->field_causeCode = other_value.causeCode();
} else {
  single_value->field_causeCode.clean_up();
}
if (other_value.subCauseCode().is_bound()) {
  single_value->field_subCauseCode = other_value.subCauseCode();
} else {
  single_value->field_subCauseCode.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtSituationContainer_template::copy_template(const ExtSituationContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.informationQuality().get_selection()) {
single_value->field_informationQuality = other_value.informationQuality();
} else {
single_value->field_informationQuality.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.causeCode().get_selection()) {
single_value->field_causeCode = other_value.causeCode();
} else {
single_value->field_causeCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.subCauseCode().get_selection()) {
single_value->field_subCauseCode = other_value.subCauseCode();
} else {
single_value->field_subCauseCode.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtSituationContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtSituationContainer.");
break;
}
set_selection(other_value);
}

ExtSituationContainer_template::ExtSituationContainer_template()
{
}

ExtSituationContainer_template::ExtSituationContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtSituationContainer_template::ExtSituationContainer_template(const ExtSituationContainer& other_value)
{
copy_value(other_value);
}

ExtSituationContainer_template::ExtSituationContainer_template(const OPTIONAL<ExtSituationContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtSituationContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtSituationContainer from an unbound optional field.");
}
}

ExtSituationContainer_template::ExtSituationContainer_template(const ExtSituationContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtSituationContainer_template::~ExtSituationContainer_template()
{
clean_up();
}

ExtSituationContainer_template& ExtSituationContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtSituationContainer_template& ExtSituationContainer_template::operator=(const ExtSituationContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtSituationContainer_template& ExtSituationContainer_template::operator=(const OPTIONAL<ExtSituationContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtSituationContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtSituationContainer.");
}
return *this;
}

ExtSituationContainer_template& ExtSituationContainer_template::operator=(const ExtSituationContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtSituationContainer_template::match(const ExtSituationContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.informationQuality().is_bound()) return FALSE;
if(!single_value->field_informationQuality.match(other_value.informationQuality(), legacy))return FALSE;
if(!other_value.causeCode().is_bound()) return FALSE;
if(!single_value->field_causeCode.match(other_value.causeCode(), legacy))return FALSE;
if(!other_value.subCauseCode().is_bound()) return FALSE;
if(!single_value->field_subCauseCode.match(other_value.subCauseCode(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtSituationContainer.");
}
return FALSE;
}

boolean ExtSituationContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_informationQuality.is_bound()) return TRUE;
if (single_value->field_causeCode.is_bound()) return TRUE;
if (single_value->field_subCauseCode.is_bound()) return TRUE;
return FALSE;
}

boolean ExtSituationContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_informationQuality.is_value()) return FALSE;
if (!single_value->field_causeCode.is_value()) return FALSE;
if (!single_value->field_subCauseCode.is_value()) return FALSE;
return TRUE;
}

void ExtSituationContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtSituationContainer ExtSituationContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtSituationContainer.");
ExtSituationContainer ret_val;
if (single_value->field_informationQuality.is_bound()) {
ret_val.informationQuality() = single_value->field_informationQuality.valueof();
}
if (single_value->field_causeCode.is_bound()) {
ret_val.causeCode() = single_value->field_causeCode.valueof();
}
if (single_value->field_subCauseCode.is_bound()) {
ret_val.subCauseCode() = single_value->field_subCauseCode.valueof();
}
return ret_val;
}

void ExtSituationContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtSituationContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtSituationContainer_template[list_length];
}

ExtSituationContainer_template& ExtSituationContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtSituationContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtSituationContainer.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtSituationContainer_template::informationQuality()
{
set_specific();
return single_value->field_informationQuality;
}

const INTEGER_template& ExtSituationContainer_template::informationQuality() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field informationQuality of a non-specific template of type @TTCN_EncDec.ExtSituationContainer.");
return single_value->field_informationQuality;
}

INTEGER_template& ExtSituationContainer_template::causeCode()
{
set_specific();
return single_value->field_causeCode;
}

const INTEGER_template& ExtSituationContainer_template::causeCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field causeCode of a non-specific template of type @TTCN_EncDec.ExtSituationContainer.");
return single_value->field_causeCode;
}

INTEGER_template& ExtSituationContainer_template::subCauseCode()
{
set_specific();
return single_value->field_subCauseCode;
}

const INTEGER_template& ExtSituationContainer_template::subCauseCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field subCauseCode of a non-specific template of type @TTCN_EncDec.ExtSituationContainer.");
return single_value->field_subCauseCode;
}

int ExtSituationContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtSituationContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtSituationContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtSituationContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtSituationContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtSituationContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtSituationContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtSituationContainer.");
  }
  return 0;
}

void ExtSituationContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ informationQuality := ");
single_value->field_informationQuality.log();
TTCN_Logger::log_event_str(", causeCode := ");
single_value->field_causeCode.log();
TTCN_Logger::log_event_str(", subCauseCode := ");
single_value->field_subCauseCode.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtSituationContainer_template::log_match(const ExtSituationContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_informationQuality.match(match_value.informationQuality(), legacy)){
TTCN_Logger::log_logmatch_info(".informationQuality");
single_value->field_informationQuality.log_match(match_value.informationQuality(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_causeCode.match(match_value.causeCode(), legacy)){
TTCN_Logger::log_logmatch_info(".causeCode");
single_value->field_causeCode.log_match(match_value.causeCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_subCauseCode.match(match_value.subCauseCode(), legacy)){
TTCN_Logger::log_logmatch_info(".subCauseCode");
single_value->field_subCauseCode.log_match(match_value.subCauseCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ informationQuality := ");
single_value->field_informationQuality.log_match(match_value.informationQuality(), legacy);
TTCN_Logger::log_event_str(", causeCode := ");
single_value->field_causeCode.log_match(match_value.causeCode(), legacy);
TTCN_Logger::log_event_str(", subCauseCode := ");
single_value->field_subCauseCode.log_match(match_value.subCauseCode(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtSituationContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_informationQuality.encode_text(text_buf);
single_value->field_causeCode.encode_text(text_buf);
single_value->field_subCauseCode.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtSituationContainer.");
}
}

void ExtSituationContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_informationQuality.decode_text(text_buf);
single_value->field_causeCode.decode_text(text_buf);
single_value->field_subCauseCode.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtSituationContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtSituationContainer.");
}
}

void ExtSituationContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtSituationContainer'");
    }
    if (strcmp("informationQuality", param_field) == 0) {
      informationQuality().set_param(param);
      return;
    } else if (strcmp("causeCode", param_field) == 0) {
      causeCode().set_param(param);
      return;
    } else if (strcmp("subCauseCode", param_field) == 0) {
      subCauseCode().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtSituationContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtSituationContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtSituationContainer has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) informationQuality().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) causeCode().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) subCauseCode().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "informationQuality")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          informationQuality().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "causeCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          causeCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subCauseCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subCauseCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtSituationContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtSituationContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtSituationContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtSituationContainer'");
    }
    if (strcmp("informationQuality", param_field) == 0) {
      return informationQuality().get_param(param_name);
    } else if (strcmp("causeCode", param_field) == 0) {
      return causeCode().get_param(param_name);
    } else if (strcmp("subCauseCode", param_field) == 0) {
      return subCauseCode().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtSituationContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_informationQuality = single_value->field_informationQuality.get_param(param_name);
    mp_field_informationQuality->set_id(new Module_Param_FieldName(mcopystr("informationQuality")));
    mp->add_elem(mp_field_informationQuality);
    Module_Param* mp_field_causeCode = single_value->field_causeCode.get_param(param_name);
    mp_field_causeCode->set_id(new Module_Param_FieldName(mcopystr("causeCode")));
    mp->add_elem(mp_field_causeCode);
    Module_Param* mp_field_subCauseCode = single_value->field_subCauseCode.get_param(param_name);
    mp_field_subCauseCode->set_id(new Module_Param_FieldName(mcopystr("subCauseCode")));
    mp->add_elem(mp_field_subCauseCode);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtSituationContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_informationQuality.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtSituationContainer");
single_value->field_causeCode.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtSituationContainer");
single_value->field_subCauseCode.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtSituationContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtSituationContainer");
}

boolean ExtSituationContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtSituationContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtAlacarteContainer::ExtAlacarteContainer()
{
  bound_flag = FALSE;
}

ExtAlacarteContainer::ExtAlacarteContainer(const INTEGER& par_TODO)
  :   field_TODO(par_TODO)
{
  bound_flag = TRUE;
}

ExtAlacarteContainer::ExtAlacarteContainer(const ExtAlacarteContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtAlacarteContainer.");
bound_flag = TRUE;
if (other_value.TODO().is_bound()) field_TODO = other_value.TODO();
else field_TODO.clean_up();
}

void ExtAlacarteContainer::clean_up()
{
field_TODO.clean_up();
bound_flag = FALSE;
}

ExtAlacarteContainer& ExtAlacarteContainer::operator=(const ExtAlacarteContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtAlacarteContainer.");
  bound_flag = TRUE;
  if (other_value.TODO().is_bound()) field_TODO = other_value.TODO();
  else field_TODO.clean_up();
}
return *this;
}

boolean ExtAlacarteContainer::operator==(const ExtAlacarteContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_TODO==other_value.field_TODO;
}

boolean ExtAlacarteContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_TODO.is_bound()) return TRUE;
return FALSE;
}
boolean ExtAlacarteContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_TODO.is_value()) return FALSE;
return TRUE;
}
int ExtAlacarteContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtAlacarteContainer");
  return 1;
}

void ExtAlacarteContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ TODO := ");
field_TODO.log();
TTCN_Logger::log_event_str(" }");
}

void ExtAlacarteContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtAlacarteContainer'");
    }
    if (strcmp("TODO", param_field) == 0) {
      TODO().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtAlacarteContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtAlacarteContainer has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) TODO().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "TODO")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          TODO().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtAlacarteContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtAlacarteContainer");
  }
}

Module_Param* ExtAlacarteContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtAlacarteContainer'");
    }
    if (strcmp("TODO", param_field) == 0) {
      return TODO().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtAlacarteContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_TODO = field_TODO.get_param(param_name);
  mp_field_TODO->set_id(new Module_Param_FieldName(mcopystr("TODO")));
  mp->add_elem(mp_field_TODO);
  return mp;
  }

void ExtAlacarteContainer::set_implicit_omit()
{
if (TODO().is_bound()) TODO().set_implicit_omit();
}

void ExtAlacarteContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtAlacarteContainer.");
field_TODO.encode_text(text_buf);
}

void ExtAlacarteContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_TODO.decode_text(text_buf);
}

void ExtAlacarteContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtAlacarteContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtAlacarteContainer::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_TODO.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtAlacarteContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  encoded_length += field_TODO.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int ExtAlacarteContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtAlacarteContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "TODO");
    enc_len += field_TODO.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtAlacarteContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (4 == name_len && 0 == strncmp(fld_name, "TODO", name_len)) {
         int ret_val = field_TODO.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "TODO");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_TODO.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "TODO");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtAlacarteContainer_template::single_value_struct {
INTEGER_template field_TODO;
};

void ExtAlacarteContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_TODO = ANY_VALUE;
}
}
}

void ExtAlacarteContainer_template::copy_value(const ExtAlacarteContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.TODO().is_bound()) {
  single_value->field_TODO = other_value.TODO();
} else {
  single_value->field_TODO.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtAlacarteContainer_template::copy_template(const ExtAlacarteContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.TODO().get_selection()) {
single_value->field_TODO = other_value.TODO();
} else {
single_value->field_TODO.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtAlacarteContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtAlacarteContainer.");
break;
}
set_selection(other_value);
}

ExtAlacarteContainer_template::ExtAlacarteContainer_template()
{
}

ExtAlacarteContainer_template::ExtAlacarteContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtAlacarteContainer_template::ExtAlacarteContainer_template(const ExtAlacarteContainer& other_value)
{
copy_value(other_value);
}

ExtAlacarteContainer_template::ExtAlacarteContainer_template(const OPTIONAL<ExtAlacarteContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtAlacarteContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtAlacarteContainer from an unbound optional field.");
}
}

ExtAlacarteContainer_template::ExtAlacarteContainer_template(const ExtAlacarteContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtAlacarteContainer_template::~ExtAlacarteContainer_template()
{
clean_up();
}

ExtAlacarteContainer_template& ExtAlacarteContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtAlacarteContainer_template& ExtAlacarteContainer_template::operator=(const ExtAlacarteContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtAlacarteContainer_template& ExtAlacarteContainer_template::operator=(const OPTIONAL<ExtAlacarteContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtAlacarteContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtAlacarteContainer.");
}
return *this;
}

ExtAlacarteContainer_template& ExtAlacarteContainer_template::operator=(const ExtAlacarteContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtAlacarteContainer_template::match(const ExtAlacarteContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.TODO().is_bound()) return FALSE;
if(!single_value->field_TODO.match(other_value.TODO(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtAlacarteContainer.");
}
return FALSE;
}

boolean ExtAlacarteContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_TODO.is_bound()) return TRUE;
return FALSE;
}

boolean ExtAlacarteContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_TODO.is_value()) return FALSE;
return TRUE;
}

void ExtAlacarteContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtAlacarteContainer ExtAlacarteContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtAlacarteContainer.");
ExtAlacarteContainer ret_val;
if (single_value->field_TODO.is_bound()) {
ret_val.TODO() = single_value->field_TODO.valueof();
}
return ret_val;
}

void ExtAlacarteContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtAlacarteContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtAlacarteContainer_template[list_length];
}

ExtAlacarteContainer_template& ExtAlacarteContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtAlacarteContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtAlacarteContainer.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtAlacarteContainer_template::TODO()
{
set_specific();
return single_value->field_TODO;
}

const INTEGER_template& ExtAlacarteContainer_template::TODO() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field TODO of a non-specific template of type @TTCN_EncDec.ExtAlacarteContainer.");
return single_value->field_TODO;
}

int ExtAlacarteContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtAlacarteContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtAlacarteContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtAlacarteContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtAlacarteContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtAlacarteContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtAlacarteContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtAlacarteContainer.");
  }
  return 0;
}

void ExtAlacarteContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ TODO := ");
single_value->field_TODO.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtAlacarteContainer_template::log_match(const ExtAlacarteContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_TODO.match(match_value.TODO(), legacy)){
TTCN_Logger::log_logmatch_info(".TODO");
single_value->field_TODO.log_match(match_value.TODO(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ TODO := ");
single_value->field_TODO.log_match(match_value.TODO(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtAlacarteContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_TODO.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtAlacarteContainer.");
}
}

void ExtAlacarteContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_TODO.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtAlacarteContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtAlacarteContainer.");
}
}

void ExtAlacarteContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtAlacarteContainer'");
    }
    if (strcmp("TODO", param_field) == 0) {
      TODO().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtAlacarteContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtAlacarteContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtAlacarteContainer has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) TODO().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "TODO")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          TODO().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtAlacarteContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtAlacarteContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtAlacarteContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtAlacarteContainer'");
    }
    if (strcmp("TODO", param_field) == 0) {
      return TODO().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtAlacarteContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_TODO = single_value->field_TODO.get_param(param_name);
    mp_field_TODO->set_id(new Module_Param_FieldName(mcopystr("TODO")));
    mp->add_elem(mp_field_TODO);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtAlacarteContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_TODO.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtAlacarteContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtAlacarteContainer");
}

boolean ExtAlacarteContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtAlacarteContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtUtDenmTrigger::ExtUtDenmTrigger()
{
  bound_flag = FALSE;
}

ExtUtDenmTrigger::ExtUtDenmTrigger(const INTEGER& par_bitmask,
    const INTEGER& par_detectionTime,
    const OPTIONAL<INTEGER>& par_validityDuration,
    const OPTIONAL<INTEGER>& par_repetitionDuration,
    const ExtSituationContainer& par_situation,
    const INTEGER& par_relevanceDistance,
    const INTEGER& par_relevanceTrafficDirection,
    const OPTIONAL<INTEGER>& par_transmissionInterval,
    const OPTIONAL<INTEGER>& par_repetitionInterval,
    const OPTIONAL<INTEGER>& par_alacarteLength,
    const OPTIONAL<ExtAlacarteContainer>& par_alacarte)
  :   field_bitmask(par_bitmask),
  field_detectionTime(par_detectionTime),
  field_validityDuration(par_validityDuration),
  field_repetitionDuration(par_repetitionDuration),
  field_situation(par_situation),
  field_relevanceDistance(par_relevanceDistance),
  field_relevanceTrafficDirection(par_relevanceTrafficDirection),
  field_transmissionInterval(par_transmissionInterval),
  field_repetitionInterval(par_repetitionInterval),
  field_alacarteLength(par_alacarteLength),
  field_alacarte(par_alacarte)
{
  bound_flag = TRUE;
}

ExtUtDenmTrigger::ExtUtDenmTrigger(const ExtUtDenmTrigger& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtUtDenmTrigger.");
bound_flag = TRUE;
if (other_value.bitmask().is_bound()) field_bitmask = other_value.bitmask();
else field_bitmask.clean_up();
if (other_value.detectionTime().is_bound()) field_detectionTime = other_value.detectionTime();
else field_detectionTime.clean_up();
if (other_value.validityDuration().is_bound()) field_validityDuration = other_value.validityDuration();
else field_validityDuration.clean_up();
if (other_value.repetitionDuration().is_bound()) field_repetitionDuration = other_value.repetitionDuration();
else field_repetitionDuration.clean_up();
if (other_value.situation().is_bound()) field_situation = other_value.situation();
else field_situation.clean_up();
if (other_value.relevanceDistance().is_bound()) field_relevanceDistance = other_value.relevanceDistance();
else field_relevanceDistance.clean_up();
if (other_value.relevanceTrafficDirection().is_bound()) field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
else field_relevanceTrafficDirection.clean_up();
if (other_value.transmissionInterval().is_bound()) field_transmissionInterval = other_value.transmissionInterval();
else field_transmissionInterval.clean_up();
if (other_value.repetitionInterval().is_bound()) field_repetitionInterval = other_value.repetitionInterval();
else field_repetitionInterval.clean_up();
if (other_value.alacarteLength().is_bound()) field_alacarteLength = other_value.alacarteLength();
else field_alacarteLength.clean_up();
if (other_value.alacarte().is_bound()) field_alacarte = other_value.alacarte();
else field_alacarte.clean_up();
}

void ExtUtDenmTrigger::clean_up()
{
field_bitmask.clean_up();
field_detectionTime.clean_up();
field_validityDuration.clean_up();
field_repetitionDuration.clean_up();
field_situation.clean_up();
field_relevanceDistance.clean_up();
field_relevanceTrafficDirection.clean_up();
field_transmissionInterval.clean_up();
field_repetitionInterval.clean_up();
field_alacarteLength.clean_up();
field_alacarte.clean_up();
bound_flag = FALSE;
}

ExtUtDenmTrigger& ExtUtDenmTrigger::operator=(const ExtUtDenmTrigger& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtUtDenmTrigger.");
  bound_flag = TRUE;
  if (other_value.bitmask().is_bound()) field_bitmask = other_value.bitmask();
  else field_bitmask.clean_up();
  if (other_value.detectionTime().is_bound()) field_detectionTime = other_value.detectionTime();
  else field_detectionTime.clean_up();
  if (other_value.validityDuration().is_bound()) field_validityDuration = other_value.validityDuration();
  else field_validityDuration.clean_up();
  if (other_value.repetitionDuration().is_bound()) field_repetitionDuration = other_value.repetitionDuration();
  else field_repetitionDuration.clean_up();
  if (other_value.situation().is_bound()) field_situation = other_value.situation();
  else field_situation.clean_up();
  if (other_value.relevanceDistance().is_bound()) field_relevanceDistance = other_value.relevanceDistance();
  else field_relevanceDistance.clean_up();
  if (other_value.relevanceTrafficDirection().is_bound()) field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
  else field_relevanceTrafficDirection.clean_up();
  if (other_value.transmissionInterval().is_bound()) field_transmissionInterval = other_value.transmissionInterval();
  else field_transmissionInterval.clean_up();
  if (other_value.repetitionInterval().is_bound()) field_repetitionInterval = other_value.repetitionInterval();
  else field_repetitionInterval.clean_up();
  if (other_value.alacarteLength().is_bound()) field_alacarteLength = other_value.alacarteLength();
  else field_alacarteLength.clean_up();
  if (other_value.alacarte().is_bound()) field_alacarte = other_value.alacarte();
  else field_alacarte.clean_up();
}
return *this;
}

boolean ExtUtDenmTrigger::operator==(const ExtUtDenmTrigger& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_bitmask==other_value.field_bitmask
  && field_detectionTime==other_value.field_detectionTime
  && field_validityDuration==other_value.field_validityDuration
  && field_repetitionDuration==other_value.field_repetitionDuration
  && field_situation==other_value.field_situation
  && field_relevanceDistance==other_value.field_relevanceDistance
  && field_relevanceTrafficDirection==other_value.field_relevanceTrafficDirection
  && field_transmissionInterval==other_value.field_transmissionInterval
  && field_repetitionInterval==other_value.field_repetitionInterval
  && field_alacarteLength==other_value.field_alacarteLength
  && field_alacarte==other_value.field_alacarte;
}

boolean ExtUtDenmTrigger::is_bound() const
{
if (bound_flag) return TRUE;
if(field_bitmask.is_bound()) return TRUE;
if(field_detectionTime.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_validityDuration.get_selection() || field_validityDuration.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_repetitionDuration.get_selection() || field_repetitionDuration.is_bound()) return TRUE;
if(field_situation.is_bound()) return TRUE;
if(field_relevanceDistance.is_bound()) return TRUE;
if(field_relevanceTrafficDirection.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_transmissionInterval.get_selection() || field_transmissionInterval.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_repetitionInterval.get_selection() || field_repetitionInterval.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_alacarteLength.get_selection() || field_alacarteLength.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_alacarte.get_selection() || field_alacarte.is_bound()) return TRUE;
return FALSE;
}
boolean ExtUtDenmTrigger::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_bitmask.is_value()) return FALSE;
if(!field_detectionTime.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_validityDuration.get_selection() && !field_validityDuration.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_repetitionDuration.get_selection() && !field_repetitionDuration.is_value()) return FALSE;
if(!field_situation.is_value()) return FALSE;
if(!field_relevanceDistance.is_value()) return FALSE;
if(!field_relevanceTrafficDirection.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_transmissionInterval.get_selection() && !field_transmissionInterval.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_repetitionInterval.get_selection() && !field_repetitionInterval.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_alacarteLength.get_selection() && !field_alacarteLength.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_alacarte.get_selection() && !field_alacarte.is_value()) return FALSE;
return TRUE;
}
int ExtUtDenmTrigger::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtUtDenmTrigger");
  int ret_val = 5;
  if (field_validityDuration.ispresent()) ret_val++;
  if (field_repetitionDuration.ispresent()) ret_val++;
  if (field_transmissionInterval.ispresent()) ret_val++;
  if (field_repetitionInterval.ispresent()) ret_val++;
  if (field_alacarteLength.ispresent()) ret_val++;
  if (field_alacarte.ispresent()) ret_val++;
  return ret_val;
}

void ExtUtDenmTrigger::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ bitmask := ");
field_bitmask.log();
TTCN_Logger::log_event_str(", detectionTime := ");
field_detectionTime.log();
TTCN_Logger::log_event_str(", validityDuration := ");
field_validityDuration.log();
TTCN_Logger::log_event_str(", repetitionDuration := ");
field_repetitionDuration.log();
TTCN_Logger::log_event_str(", situation := ");
field_situation.log();
TTCN_Logger::log_event_str(", relevanceDistance := ");
field_relevanceDistance.log();
TTCN_Logger::log_event_str(", relevanceTrafficDirection := ");
field_relevanceTrafficDirection.log();
TTCN_Logger::log_event_str(", transmissionInterval := ");
field_transmissionInterval.log();
TTCN_Logger::log_event_str(", repetitionInterval := ");
field_repetitionInterval.log();
TTCN_Logger::log_event_str(", alacarteLength := ");
field_alacarteLength.log();
TTCN_Logger::log_event_str(", alacarte := ");
field_alacarte.log();
TTCN_Logger::log_event_str(" }");
}

void ExtUtDenmTrigger::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtUtDenmTrigger'");
    }
    if (strcmp("bitmask", param_field) == 0) {
      bitmask().set_param(param);
      return;
    } else if (strcmp("detectionTime", param_field) == 0) {
      detectionTime().set_param(param);
      return;
    } else if (strcmp("validityDuration", param_field) == 0) {
      validityDuration().set_param(param);
      return;
    } else if (strcmp("repetitionDuration", param_field) == 0) {
      repetitionDuration().set_param(param);
      return;
    } else if (strcmp("situation", param_field) == 0) {
      situation().set_param(param);
      return;
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      relevanceDistance().set_param(param);
      return;
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      relevanceTrafficDirection().set_param(param);
      return;
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      transmissionInterval().set_param(param);
      return;
    } else if (strcmp("repetitionInterval", param_field) == 0) {
      repetitionInterval().set_param(param);
      return;
    } else if (strcmp("alacarteLength", param_field) == 0) {
      alacarteLength().set_param(param);
      return;
    } else if (strcmp("alacarte", param_field) == 0) {
      alacarte().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtDenmTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (11<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtUtDenmTrigger has 11 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) bitmask().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) detectionTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) validityDuration().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) repetitionDuration().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) situation().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) relevanceDistance().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) relevanceTrafficDirection().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) transmissionInterval().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) repetitionInterval().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) alacarteLength().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) alacarte().set_param(*mp->get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bitmask")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bitmask().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "detectionTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          detectionTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validityDuration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validityDuration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repetitionDuration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repetitionDuration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "situation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          situation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceDistance")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceDistance().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceTrafficDirection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceTrafficDirection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transmissionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transmissionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repetitionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repetitionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarteLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarteLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarte")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarte().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtDenmTrigger: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtUtDenmTrigger");
  }
}

Module_Param* ExtUtDenmTrigger::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtUtDenmTrigger'");
    }
    if (strcmp("bitmask", param_field) == 0) {
      return bitmask().get_param(param_name);
    } else if (strcmp("detectionTime", param_field) == 0) {
      return detectionTime().get_param(param_name);
    } else if (strcmp("validityDuration", param_field) == 0) {
      return validityDuration().get_param(param_name);
    } else if (strcmp("repetitionDuration", param_field) == 0) {
      return repetitionDuration().get_param(param_name);
    } else if (strcmp("situation", param_field) == 0) {
      return situation().get_param(param_name);
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      return relevanceDistance().get_param(param_name);
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      return relevanceTrafficDirection().get_param(param_name);
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      return transmissionInterval().get_param(param_name);
    } else if (strcmp("repetitionInterval", param_field) == 0) {
      return repetitionInterval().get_param(param_name);
    } else if (strcmp("alacarteLength", param_field) == 0) {
      return alacarteLength().get_param(param_name);
    } else if (strcmp("alacarte", param_field) == 0) {
      return alacarte().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtDenmTrigger'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_bitmask = field_bitmask.get_param(param_name);
  mp_field_bitmask->set_id(new Module_Param_FieldName(mcopystr("bitmask")));
  mp->add_elem(mp_field_bitmask);
  Module_Param* mp_field_detectionTime = field_detectionTime.get_param(param_name);
  mp_field_detectionTime->set_id(new Module_Param_FieldName(mcopystr("detectionTime")));
  mp->add_elem(mp_field_detectionTime);
  Module_Param* mp_field_validityDuration = field_validityDuration.get_param(param_name);
  mp_field_validityDuration->set_id(new Module_Param_FieldName(mcopystr("validityDuration")));
  mp->add_elem(mp_field_validityDuration);
  Module_Param* mp_field_repetitionDuration = field_repetitionDuration.get_param(param_name);
  mp_field_repetitionDuration->set_id(new Module_Param_FieldName(mcopystr("repetitionDuration")));
  mp->add_elem(mp_field_repetitionDuration);
  Module_Param* mp_field_situation = field_situation.get_param(param_name);
  mp_field_situation->set_id(new Module_Param_FieldName(mcopystr("situation")));
  mp->add_elem(mp_field_situation);
  Module_Param* mp_field_relevanceDistance = field_relevanceDistance.get_param(param_name);
  mp_field_relevanceDistance->set_id(new Module_Param_FieldName(mcopystr("relevanceDistance")));
  mp->add_elem(mp_field_relevanceDistance);
  Module_Param* mp_field_relevanceTrafficDirection = field_relevanceTrafficDirection.get_param(param_name);
  mp_field_relevanceTrafficDirection->set_id(new Module_Param_FieldName(mcopystr("relevanceTrafficDirection")));
  mp->add_elem(mp_field_relevanceTrafficDirection);
  Module_Param* mp_field_transmissionInterval = field_transmissionInterval.get_param(param_name);
  mp_field_transmissionInterval->set_id(new Module_Param_FieldName(mcopystr("transmissionInterval")));
  mp->add_elem(mp_field_transmissionInterval);
  Module_Param* mp_field_repetitionInterval = field_repetitionInterval.get_param(param_name);
  mp_field_repetitionInterval->set_id(new Module_Param_FieldName(mcopystr("repetitionInterval")));
  mp->add_elem(mp_field_repetitionInterval);
  Module_Param* mp_field_alacarteLength = field_alacarteLength.get_param(param_name);
  mp_field_alacarteLength->set_id(new Module_Param_FieldName(mcopystr("alacarteLength")));
  mp->add_elem(mp_field_alacarteLength);
  Module_Param* mp_field_alacarte = field_alacarte.get_param(param_name);
  mp_field_alacarte->set_id(new Module_Param_FieldName(mcopystr("alacarte")));
  mp->add_elem(mp_field_alacarte);
  return mp;
  }

void ExtUtDenmTrigger::set_implicit_omit()
{
if (bitmask().is_bound()) bitmask().set_implicit_omit();
if (detectionTime().is_bound()) detectionTime().set_implicit_omit();
if (!validityDuration().is_bound()) validityDuration() = OMIT_VALUE;
else validityDuration().set_implicit_omit();
if (!repetitionDuration().is_bound()) repetitionDuration() = OMIT_VALUE;
else repetitionDuration().set_implicit_omit();
if (situation().is_bound()) situation().set_implicit_omit();
if (relevanceDistance().is_bound()) relevanceDistance().set_implicit_omit();
if (relevanceTrafficDirection().is_bound()) relevanceTrafficDirection().set_implicit_omit();
if (!transmissionInterval().is_bound()) transmissionInterval() = OMIT_VALUE;
else transmissionInterval().set_implicit_omit();
if (!repetitionInterval().is_bound()) repetitionInterval() = OMIT_VALUE;
else repetitionInterval().set_implicit_omit();
if (!alacarteLength().is_bound()) alacarteLength() = OMIT_VALUE;
else alacarteLength().set_implicit_omit();
if (!alacarte().is_bound()) alacarte() = OMIT_VALUE;
else alacarte().set_implicit_omit();
}

void ExtUtDenmTrigger::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtUtDenmTrigger.");
field_bitmask.encode_text(text_buf);
field_detectionTime.encode_text(text_buf);
field_validityDuration.encode_text(text_buf);
field_repetitionDuration.encode_text(text_buf);
field_situation.encode_text(text_buf);
field_relevanceDistance.encode_text(text_buf);
field_relevanceTrafficDirection.encode_text(text_buf);
field_transmissionInterval.encode_text(text_buf);
field_repetitionInterval.encode_text(text_buf);
field_alacarteLength.encode_text(text_buf);
field_alacarte.encode_text(text_buf);
}

void ExtUtDenmTrigger::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_bitmask.decode_text(text_buf);
field_detectionTime.decode_text(text_buf);
field_validityDuration.decode_text(text_buf);
field_repetitionDuration.decode_text(text_buf);
field_situation.decode_text(text_buf);
field_relevanceDistance.decode_text(text_buf);
field_relevanceTrafficDirection.decode_text(text_buf);
field_transmissionInterval.decode_text(text_buf);
field_repetitionInterval.decode_text(text_buf);
field_alacarteLength.decode_text(text_buf);
field_alacarte.decode_text(text_buf);
}

void ExtUtDenmTrigger::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtUtDenmTrigger::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtUtDenmTrigger::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_bitmask.RAW_decode(ExtUtDenmTrigger_bitmask_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_detectionTime.RAW_decode(ExtUtDenmTrigger_detectionTime_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_validityDuration().RAW_decode(ExtUtDenmTrigger_validityDuration_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_validityDuration = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_validityDuration=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_repetitionDuration().RAW_decode(ExtUtDenmTrigger_repetitionDuration_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_repetitionDuration = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_repetitionDuration=OMIT_VALUE;
  decoded_field_length = field_situation.RAW_decode(ExtSituationContainer_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_relevanceDistance.RAW_decode(ExtUtDenmTrigger_relevanceDistance_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_relevanceTrafficDirection.RAW_decode(ExtUtDenmTrigger_relevanceTrafficDirection_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_transmissionInterval().RAW_decode(ExtUtDenmTrigger_transmissionInterval_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_transmissionInterval = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_transmissionInterval=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_repetitionInterval().RAW_decode(ExtUtDenmTrigger_repetitionInterval_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_repetitionInterval = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_repetitionInterval=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_alacarteLength().RAW_decode(ExtUtDenmTrigger_alacarteLength_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_alacarteLength = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_alacarteLength=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_alacarte().RAW_decode(ExtAlacarteContainer_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_alacarte = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_alacarte=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtUtDenmTrigger::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 11;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(11);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ExtUtDenmTrigger_bitmask_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ExtUtDenmTrigger_detectionTime_descr_.raw);
  if (field_validityDuration.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, ExtUtDenmTrigger_validityDuration_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  if (field_repetitionDuration.ispresent()) {
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, ExtUtDenmTrigger_repetitionDuration_descr_.raw);
  }
  else myleaf.body.node.nodes[3] = NULL;
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, ExtSituationContainer_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, ExtUtDenmTrigger_relevanceDistance_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, ExtUtDenmTrigger_relevanceTrafficDirection_descr_.raw);
  if (field_transmissionInterval.ispresent()) {
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, ExtUtDenmTrigger_transmissionInterval_descr_.raw);
  }
  else myleaf.body.node.nodes[7] = NULL;
  if (field_repetitionInterval.ispresent()) {
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, ExtUtDenmTrigger_repetitionInterval_descr_.raw);
  }
  else myleaf.body.node.nodes[8] = NULL;
  if (field_alacarteLength.ispresent()) {
  myleaf.body.node.nodes[9] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 9, ExtUtDenmTrigger_alacarteLength_descr_.raw);
  }
  else myleaf.body.node.nodes[9] = NULL;
  if (field_alacarte.ispresent()) {
  myleaf.body.node.nodes[10] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 10, ExtAlacarteContainer_descr_.raw);
  }
  else myleaf.body.node.nodes[10] = NULL;
  encoded_length += field_bitmask.RAW_encode(ExtUtDenmTrigger_bitmask_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_detectionTime.RAW_encode(ExtUtDenmTrigger_detectionTime_descr_, *myleaf.body.node.nodes[1]);
  if (field_validityDuration.ispresent()) {
  encoded_length += field_validityDuration().RAW_encode(ExtUtDenmTrigger_validityDuration_descr_, *myleaf.body.node.nodes[2]);
  }
  if (field_repetitionDuration.ispresent()) {
  encoded_length += field_repetitionDuration().RAW_encode(ExtUtDenmTrigger_repetitionDuration_descr_, *myleaf.body.node.nodes[3]);
  }
  encoded_length += field_situation.RAW_encode(ExtSituationContainer_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_relevanceDistance.RAW_encode(ExtUtDenmTrigger_relevanceDistance_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_relevanceTrafficDirection.RAW_encode(ExtUtDenmTrigger_relevanceTrafficDirection_descr_, *myleaf.body.node.nodes[6]);
  if (field_transmissionInterval.ispresent()) {
  encoded_length += field_transmissionInterval().RAW_encode(ExtUtDenmTrigger_transmissionInterval_descr_, *myleaf.body.node.nodes[7]);
  }
  if (field_repetitionInterval.ispresent()) {
  encoded_length += field_repetitionInterval().RAW_encode(ExtUtDenmTrigger_repetitionInterval_descr_, *myleaf.body.node.nodes[8]);
  }
  if (field_alacarteLength.ispresent()) {
  encoded_length += field_alacarteLength().RAW_encode(ExtUtDenmTrigger_alacarteLength_descr_, *myleaf.body.node.nodes[9]);
  }
  if (field_alacarte.ispresent()) {
  encoded_length += field_alacarte().RAW_encode(ExtAlacarteContainer_descr_, *myleaf.body.node.nodes[10]);
  }
  return myleaf.length = encoded_length;
}

int ExtUtDenmTrigger::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtUtDenmTrigger.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "bitmask");
    enc_len += field_bitmask.JSON_encode(ExtUtDenmTrigger_bitmask_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "detectionTime");
    enc_len += field_detectionTime.JSON_encode(ExtUtDenmTrigger_detectionTime_descr_, p_tok);
  }

  if (field_validityDuration.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "validityDuration");
    enc_len += field_validityDuration.JSON_encode(ExtUtDenmTrigger_validityDuration_descr_, p_tok);
  }

  if (field_repetitionDuration.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "repetitionDuration");
    enc_len += field_repetitionDuration.JSON_encode(ExtUtDenmTrigger_repetitionDuration_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "situation");
    enc_len += field_situation.JSON_encode(ExtSituationContainer_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "relevanceDistance");
    enc_len += field_relevanceDistance.JSON_encode(ExtUtDenmTrigger_relevanceDistance_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "relevanceTrafficDirection");
    enc_len += field_relevanceTrafficDirection.JSON_encode(ExtUtDenmTrigger_relevanceTrafficDirection_descr_, p_tok);
  }

  if (field_transmissionInterval.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "transmissionInterval");
    enc_len += field_transmissionInterval.JSON_encode(ExtUtDenmTrigger_transmissionInterval_descr_, p_tok);
  }

  if (field_repetitionInterval.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "repetitionInterval");
    enc_len += field_repetitionInterval.JSON_encode(ExtUtDenmTrigger_repetitionInterval_descr_, p_tok);
  }

  if (field_alacarteLength.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "alacarteLength");
    enc_len += field_alacarteLength.JSON_encode(ExtUtDenmTrigger_alacarteLength_descr_, p_tok);
  }

  if (field_alacarte.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "alacarte");
    enc_len += field_alacarte.JSON_encode(ExtAlacarteContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtUtDenmTrigger::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "bitmask", name_len)) {
         int ret_val = field_bitmask.JSON_decode(ExtUtDenmTrigger_bitmask_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "bitmask");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "detectionTime", name_len)) {
         int ret_val = field_detectionTime.JSON_decode(ExtUtDenmTrigger_detectionTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "detectionTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "validityDuration", name_len)) {
         int ret_val = field_validityDuration.JSON_decode(ExtUtDenmTrigger_validityDuration_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "validityDuration");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "repetitionDuration", name_len)) {
         int ret_val = field_repetitionDuration.JSON_decode(ExtUtDenmTrigger_repetitionDuration_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "repetitionDuration");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "situation", name_len)) {
         int ret_val = field_situation.JSON_decode(ExtSituationContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "situation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "relevanceDistance", name_len)) {
         int ret_val = field_relevanceDistance.JSON_decode(ExtUtDenmTrigger_relevanceDistance_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "relevanceDistance");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (25 == name_len && 0 == strncmp(fld_name, "relevanceTrafficDirection", name_len)) {
         int ret_val = field_relevanceTrafficDirection.JSON_decode(ExtUtDenmTrigger_relevanceTrafficDirection_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "relevanceTrafficDirection");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "transmissionInterval", name_len)) {
         int ret_val = field_transmissionInterval.JSON_decode(ExtUtDenmTrigger_transmissionInterval_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "transmissionInterval");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "repetitionInterval", name_len)) {
         int ret_val = field_repetitionInterval.JSON_decode(ExtUtDenmTrigger_repetitionInterval_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "repetitionInterval");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "alacarteLength", name_len)) {
         int ret_val = field_alacarteLength.JSON_decode(ExtUtDenmTrigger_alacarteLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "alacarteLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "alacarte", name_len)) {
         int ret_val = field_alacarte.JSON_decode(ExtAlacarteContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "alacarte");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_bitmask.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "bitmask");
    return JSON_ERROR_FATAL;
  }
if (!field_detectionTime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "detectionTime");
    return JSON_ERROR_FATAL;
  }
if (!field_validityDuration.is_bound()) {
    field_validityDuration = OMIT_VALUE;
  }
if (!field_repetitionDuration.is_bound()) {
    field_repetitionDuration = OMIT_VALUE;
  }
if (!field_situation.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "situation");
    return JSON_ERROR_FATAL;
  }
if (!field_relevanceDistance.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "relevanceDistance");
    return JSON_ERROR_FATAL;
  }
if (!field_relevanceTrafficDirection.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "relevanceTrafficDirection");
    return JSON_ERROR_FATAL;
  }
if (!field_transmissionInterval.is_bound()) {
    field_transmissionInterval = OMIT_VALUE;
  }
if (!field_repetitionInterval.is_bound()) {
    field_repetitionInterval = OMIT_VALUE;
  }
if (!field_alacarteLength.is_bound()) {
    field_alacarteLength = OMIT_VALUE;
  }
if (!field_alacarte.is_bound()) {
    field_alacarte = OMIT_VALUE;
  }

  return dec_len;
}

struct ExtUtDenmTrigger_template::single_value_struct {
INTEGER_template field_bitmask;
INTEGER_template field_detectionTime;
INTEGER_template field_validityDuration;
INTEGER_template field_repetitionDuration;
ExtSituationContainer_template field_situation;
INTEGER_template field_relevanceDistance;
INTEGER_template field_relevanceTrafficDirection;
INTEGER_template field_transmissionInterval;
INTEGER_template field_repetitionInterval;
INTEGER_template field_alacarteLength;
ExtAlacarteContainer_template field_alacarte;
};

void ExtUtDenmTrigger_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_bitmask = ANY_VALUE;
single_value->field_detectionTime = ANY_VALUE;
single_value->field_validityDuration = ANY_OR_OMIT;
single_value->field_repetitionDuration = ANY_OR_OMIT;
single_value->field_situation = ANY_VALUE;
single_value->field_relevanceDistance = ANY_VALUE;
single_value->field_relevanceTrafficDirection = ANY_VALUE;
single_value->field_transmissionInterval = ANY_OR_OMIT;
single_value->field_repetitionInterval = ANY_OR_OMIT;
single_value->field_alacarteLength = ANY_OR_OMIT;
single_value->field_alacarte = ANY_OR_OMIT;
}
}
}

void ExtUtDenmTrigger_template::copy_value(const ExtUtDenmTrigger& other_value)
{
single_value = new single_value_struct;
if (other_value.bitmask().is_bound()) {
  single_value->field_bitmask = other_value.bitmask();
} else {
  single_value->field_bitmask.clean_up();
}
if (other_value.detectionTime().is_bound()) {
  single_value->field_detectionTime = other_value.detectionTime();
} else {
  single_value->field_detectionTime.clean_up();
}
if (other_value.validityDuration().is_bound()) {
  if (other_value.validityDuration().ispresent()) single_value->field_validityDuration = other_value.validityDuration()();
  else single_value->field_validityDuration = OMIT_VALUE;
} else {
  single_value->field_validityDuration.clean_up();
}
if (other_value.repetitionDuration().is_bound()) {
  if (other_value.repetitionDuration().ispresent()) single_value->field_repetitionDuration = other_value.repetitionDuration()();
  else single_value->field_repetitionDuration = OMIT_VALUE;
} else {
  single_value->field_repetitionDuration.clean_up();
}
if (other_value.situation().is_bound()) {
  single_value->field_situation = other_value.situation();
} else {
  single_value->field_situation.clean_up();
}
if (other_value.relevanceDistance().is_bound()) {
  single_value->field_relevanceDistance = other_value.relevanceDistance();
} else {
  single_value->field_relevanceDistance.clean_up();
}
if (other_value.relevanceTrafficDirection().is_bound()) {
  single_value->field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
} else {
  single_value->field_relevanceTrafficDirection.clean_up();
}
if (other_value.transmissionInterval().is_bound()) {
  if (other_value.transmissionInterval().ispresent()) single_value->field_transmissionInterval = other_value.transmissionInterval()();
  else single_value->field_transmissionInterval = OMIT_VALUE;
} else {
  single_value->field_transmissionInterval.clean_up();
}
if (other_value.repetitionInterval().is_bound()) {
  if (other_value.repetitionInterval().ispresent()) single_value->field_repetitionInterval = other_value.repetitionInterval()();
  else single_value->field_repetitionInterval = OMIT_VALUE;
} else {
  single_value->field_repetitionInterval.clean_up();
}
if (other_value.alacarteLength().is_bound()) {
  if (other_value.alacarteLength().ispresent()) single_value->field_alacarteLength = other_value.alacarteLength()();
  else single_value->field_alacarteLength = OMIT_VALUE;
} else {
  single_value->field_alacarteLength.clean_up();
}
if (other_value.alacarte().is_bound()) {
  if (other_value.alacarte().ispresent()) single_value->field_alacarte = other_value.alacarte()();
  else single_value->field_alacarte = OMIT_VALUE;
} else {
  single_value->field_alacarte.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtUtDenmTrigger_template::copy_template(const ExtUtDenmTrigger_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.bitmask().get_selection()) {
single_value->field_bitmask = other_value.bitmask();
} else {
single_value->field_bitmask.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.detectionTime().get_selection()) {
single_value->field_detectionTime = other_value.detectionTime();
} else {
single_value->field_detectionTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.validityDuration().get_selection()) {
single_value->field_validityDuration = other_value.validityDuration();
} else {
single_value->field_validityDuration.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.repetitionDuration().get_selection()) {
single_value->field_repetitionDuration = other_value.repetitionDuration();
} else {
single_value->field_repetitionDuration.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.situation().get_selection()) {
single_value->field_situation = other_value.situation();
} else {
single_value->field_situation.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.relevanceDistance().get_selection()) {
single_value->field_relevanceDistance = other_value.relevanceDistance();
} else {
single_value->field_relevanceDistance.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.relevanceTrafficDirection().get_selection()) {
single_value->field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
} else {
single_value->field_relevanceTrafficDirection.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.transmissionInterval().get_selection()) {
single_value->field_transmissionInterval = other_value.transmissionInterval();
} else {
single_value->field_transmissionInterval.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.repetitionInterval().get_selection()) {
single_value->field_repetitionInterval = other_value.repetitionInterval();
} else {
single_value->field_repetitionInterval.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.alacarteLength().get_selection()) {
single_value->field_alacarteLength = other_value.alacarteLength();
} else {
single_value->field_alacarteLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.alacarte().get_selection()) {
single_value->field_alacarte = other_value.alacarte();
} else {
single_value->field_alacarte.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtUtDenmTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmTrigger.");
break;
}
set_selection(other_value);
}

ExtUtDenmTrigger_template::ExtUtDenmTrigger_template()
{
}

ExtUtDenmTrigger_template::ExtUtDenmTrigger_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtUtDenmTrigger_template::ExtUtDenmTrigger_template(const ExtUtDenmTrigger& other_value)
{
copy_value(other_value);
}

ExtUtDenmTrigger_template::ExtUtDenmTrigger_template(const OPTIONAL<ExtUtDenmTrigger>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtDenmTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtUtDenmTrigger from an unbound optional field.");
}
}

ExtUtDenmTrigger_template::ExtUtDenmTrigger_template(const ExtUtDenmTrigger_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtUtDenmTrigger_template::~ExtUtDenmTrigger_template()
{
clean_up();
}

ExtUtDenmTrigger_template& ExtUtDenmTrigger_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtUtDenmTrigger_template& ExtUtDenmTrigger_template::operator=(const ExtUtDenmTrigger& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtUtDenmTrigger_template& ExtUtDenmTrigger_template::operator=(const OPTIONAL<ExtUtDenmTrigger>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtDenmTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtUtDenmTrigger.");
}
return *this;
}

ExtUtDenmTrigger_template& ExtUtDenmTrigger_template::operator=(const ExtUtDenmTrigger_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtUtDenmTrigger_template::match(const ExtUtDenmTrigger& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.bitmask().is_bound()) return FALSE;
if(!single_value->field_bitmask.match(other_value.bitmask(), legacy))return FALSE;
if(!other_value.detectionTime().is_bound()) return FALSE;
if(!single_value->field_detectionTime.match(other_value.detectionTime(), legacy))return FALSE;
if(!other_value.validityDuration().is_bound()) return FALSE;
if((other_value.validityDuration().ispresent() ? !single_value->field_validityDuration.match((const INTEGER&)other_value.validityDuration(), legacy) : !single_value->field_validityDuration.match_omit(legacy)))return FALSE;
if(!other_value.repetitionDuration().is_bound()) return FALSE;
if((other_value.repetitionDuration().ispresent() ? !single_value->field_repetitionDuration.match((const INTEGER&)other_value.repetitionDuration(), legacy) : !single_value->field_repetitionDuration.match_omit(legacy)))return FALSE;
if(!other_value.situation().is_bound()) return FALSE;
if(!single_value->field_situation.match(other_value.situation(), legacy))return FALSE;
if(!other_value.relevanceDistance().is_bound()) return FALSE;
if(!single_value->field_relevanceDistance.match(other_value.relevanceDistance(), legacy))return FALSE;
if(!other_value.relevanceTrafficDirection().is_bound()) return FALSE;
if(!single_value->field_relevanceTrafficDirection.match(other_value.relevanceTrafficDirection(), legacy))return FALSE;
if(!other_value.transmissionInterval().is_bound()) return FALSE;
if((other_value.transmissionInterval().ispresent() ? !single_value->field_transmissionInterval.match((const INTEGER&)other_value.transmissionInterval(), legacy) : !single_value->field_transmissionInterval.match_omit(legacy)))return FALSE;
if(!other_value.repetitionInterval().is_bound()) return FALSE;
if((other_value.repetitionInterval().ispresent() ? !single_value->field_repetitionInterval.match((const INTEGER&)other_value.repetitionInterval(), legacy) : !single_value->field_repetitionInterval.match_omit(legacy)))return FALSE;
if(!other_value.alacarteLength().is_bound()) return FALSE;
if((other_value.alacarteLength().ispresent() ? !single_value->field_alacarteLength.match((const INTEGER&)other_value.alacarteLength(), legacy) : !single_value->field_alacarteLength.match_omit(legacy)))return FALSE;
if(!other_value.alacarte().is_bound()) return FALSE;
if((other_value.alacarte().ispresent() ? !single_value->field_alacarte.match((const ExtAlacarteContainer&)other_value.alacarte(), legacy) : !single_value->field_alacarte.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmTrigger.");
}
return FALSE;
}

boolean ExtUtDenmTrigger_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_bitmask.is_bound()) return TRUE;
if (single_value->field_detectionTime.is_bound()) return TRUE;
if (single_value->field_validityDuration.is_omit() || single_value->field_validityDuration.is_bound()) return TRUE;
if (single_value->field_repetitionDuration.is_omit() || single_value->field_repetitionDuration.is_bound()) return TRUE;
if (single_value->field_situation.is_bound()) return TRUE;
if (single_value->field_relevanceDistance.is_bound()) return TRUE;
if (single_value->field_relevanceTrafficDirection.is_bound()) return TRUE;
if (single_value->field_transmissionInterval.is_omit() || single_value->field_transmissionInterval.is_bound()) return TRUE;
if (single_value->field_repetitionInterval.is_omit() || single_value->field_repetitionInterval.is_bound()) return TRUE;
if (single_value->field_alacarteLength.is_omit() || single_value->field_alacarteLength.is_bound()) return TRUE;
if (single_value->field_alacarte.is_omit() || single_value->field_alacarte.is_bound()) return TRUE;
return FALSE;
}

boolean ExtUtDenmTrigger_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_bitmask.is_value()) return FALSE;
if (!single_value->field_detectionTime.is_value()) return FALSE;
if (!single_value->field_validityDuration.is_omit() && !single_value->field_validityDuration.is_value()) return FALSE;
if (!single_value->field_repetitionDuration.is_omit() && !single_value->field_repetitionDuration.is_value()) return FALSE;
if (!single_value->field_situation.is_value()) return FALSE;
if (!single_value->field_relevanceDistance.is_value()) return FALSE;
if (!single_value->field_relevanceTrafficDirection.is_value()) return FALSE;
if (!single_value->field_transmissionInterval.is_omit() && !single_value->field_transmissionInterval.is_value()) return FALSE;
if (!single_value->field_repetitionInterval.is_omit() && !single_value->field_repetitionInterval.is_value()) return FALSE;
if (!single_value->field_alacarteLength.is_omit() && !single_value->field_alacarteLength.is_value()) return FALSE;
if (!single_value->field_alacarte.is_omit() && !single_value->field_alacarte.is_value()) return FALSE;
return TRUE;
}

void ExtUtDenmTrigger_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtUtDenmTrigger ExtUtDenmTrigger_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
ExtUtDenmTrigger ret_val;
if (single_value->field_bitmask.is_bound()) {
ret_val.bitmask() = single_value->field_bitmask.valueof();
}
if (single_value->field_detectionTime.is_bound()) {
ret_val.detectionTime() = single_value->field_detectionTime.valueof();
}
if (single_value->field_validityDuration.is_omit()) ret_val.validityDuration() = OMIT_VALUE;
else if (single_value->field_validityDuration.is_bound()) {
ret_val.validityDuration() = single_value->field_validityDuration.valueof();
}
if (single_value->field_repetitionDuration.is_omit()) ret_val.repetitionDuration() = OMIT_VALUE;
else if (single_value->field_repetitionDuration.is_bound()) {
ret_val.repetitionDuration() = single_value->field_repetitionDuration.valueof();
}
if (single_value->field_situation.is_bound()) {
ret_val.situation() = single_value->field_situation.valueof();
}
if (single_value->field_relevanceDistance.is_bound()) {
ret_val.relevanceDistance() = single_value->field_relevanceDistance.valueof();
}
if (single_value->field_relevanceTrafficDirection.is_bound()) {
ret_val.relevanceTrafficDirection() = single_value->field_relevanceTrafficDirection.valueof();
}
if (single_value->field_transmissionInterval.is_omit()) ret_val.transmissionInterval() = OMIT_VALUE;
else if (single_value->field_transmissionInterval.is_bound()) {
ret_val.transmissionInterval() = single_value->field_transmissionInterval.valueof();
}
if (single_value->field_repetitionInterval.is_omit()) ret_val.repetitionInterval() = OMIT_VALUE;
else if (single_value->field_repetitionInterval.is_bound()) {
ret_val.repetitionInterval() = single_value->field_repetitionInterval.valueof();
}
if (single_value->field_alacarteLength.is_omit()) ret_val.alacarteLength() = OMIT_VALUE;
else if (single_value->field_alacarteLength.is_bound()) {
ret_val.alacarteLength() = single_value->field_alacarteLength.valueof();
}
if (single_value->field_alacarte.is_omit()) ret_val.alacarte() = OMIT_VALUE;
else if (single_value->field_alacarte.is_bound()) {
ret_val.alacarte() = single_value->field_alacarte.valueof();
}
return ret_val;
}

void ExtUtDenmTrigger_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtUtDenmTrigger.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtUtDenmTrigger_template[list_length];
}

ExtUtDenmTrigger_template& ExtUtDenmTrigger_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtUtDenmTrigger.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtUtDenmTrigger_template::bitmask()
{
set_specific();
return single_value->field_bitmask;
}

const INTEGER_template& ExtUtDenmTrigger_template::bitmask() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field bitmask of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_bitmask;
}

INTEGER_template& ExtUtDenmTrigger_template::detectionTime()
{
set_specific();
return single_value->field_detectionTime;
}

const INTEGER_template& ExtUtDenmTrigger_template::detectionTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field detectionTime of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_detectionTime;
}

INTEGER_template& ExtUtDenmTrigger_template::validityDuration()
{
set_specific();
return single_value->field_validityDuration;
}

const INTEGER_template& ExtUtDenmTrigger_template::validityDuration() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field validityDuration of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_validityDuration;
}

INTEGER_template& ExtUtDenmTrigger_template::repetitionDuration()
{
set_specific();
return single_value->field_repetitionDuration;
}

const INTEGER_template& ExtUtDenmTrigger_template::repetitionDuration() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field repetitionDuration of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_repetitionDuration;
}

ExtSituationContainer_template& ExtUtDenmTrigger_template::situation()
{
set_specific();
return single_value->field_situation;
}

const ExtSituationContainer_template& ExtUtDenmTrigger_template::situation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field situation of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_situation;
}

INTEGER_template& ExtUtDenmTrigger_template::relevanceDistance()
{
set_specific();
return single_value->field_relevanceDistance;
}

const INTEGER_template& ExtUtDenmTrigger_template::relevanceDistance() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field relevanceDistance of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_relevanceDistance;
}

INTEGER_template& ExtUtDenmTrigger_template::relevanceTrafficDirection()
{
set_specific();
return single_value->field_relevanceTrafficDirection;
}

const INTEGER_template& ExtUtDenmTrigger_template::relevanceTrafficDirection() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field relevanceTrafficDirection of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_relevanceTrafficDirection;
}

INTEGER_template& ExtUtDenmTrigger_template::transmissionInterval()
{
set_specific();
return single_value->field_transmissionInterval;
}

const INTEGER_template& ExtUtDenmTrigger_template::transmissionInterval() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field transmissionInterval of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_transmissionInterval;
}

INTEGER_template& ExtUtDenmTrigger_template::repetitionInterval()
{
set_specific();
return single_value->field_repetitionInterval;
}

const INTEGER_template& ExtUtDenmTrigger_template::repetitionInterval() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field repetitionInterval of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_repetitionInterval;
}

INTEGER_template& ExtUtDenmTrigger_template::alacarteLength()
{
set_specific();
return single_value->field_alacarteLength;
}

const INTEGER_template& ExtUtDenmTrigger_template::alacarteLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field alacarteLength of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_alacarteLength;
}

ExtAlacarteContainer_template& ExtUtDenmTrigger_template::alacarte()
{
set_specific();
return single_value->field_alacarte;
}

const ExtAlacarteContainer_template& ExtUtDenmTrigger_template::alacarte() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field alacarte of a non-specific template of type @TTCN_EncDec.ExtUtDenmTrigger.");
return single_value->field_alacarte;
}

int ExtUtDenmTrigger_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmTrigger which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 5;
      if (single_value->field_validityDuration.is_present()) ret_val++;
      if (single_value->field_repetitionDuration.is_present()) ret_val++;
      if (single_value->field_transmissionInterval.is_present()) ret_val++;
      if (single_value->field_repetitionInterval.is_present()) ret_val++;
      if (single_value->field_alacarteLength.is_present()) ret_val++;
      if (single_value->field_alacarte.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmTrigger containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmTrigger containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmTrigger containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmTrigger containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmTrigger containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmTrigger.");
  }
  return 0;
}

void ExtUtDenmTrigger_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ bitmask := ");
single_value->field_bitmask.log();
TTCN_Logger::log_event_str(", detectionTime := ");
single_value->field_detectionTime.log();
TTCN_Logger::log_event_str(", validityDuration := ");
single_value->field_validityDuration.log();
TTCN_Logger::log_event_str(", repetitionDuration := ");
single_value->field_repetitionDuration.log();
TTCN_Logger::log_event_str(", situation := ");
single_value->field_situation.log();
TTCN_Logger::log_event_str(", relevanceDistance := ");
single_value->field_relevanceDistance.log();
TTCN_Logger::log_event_str(", relevanceTrafficDirection := ");
single_value->field_relevanceTrafficDirection.log();
TTCN_Logger::log_event_str(", transmissionInterval := ");
single_value->field_transmissionInterval.log();
TTCN_Logger::log_event_str(", repetitionInterval := ");
single_value->field_repetitionInterval.log();
TTCN_Logger::log_event_str(", alacarteLength := ");
single_value->field_alacarteLength.log();
TTCN_Logger::log_event_str(", alacarte := ");
single_value->field_alacarte.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtUtDenmTrigger_template::log_match(const ExtUtDenmTrigger& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_bitmask.match(match_value.bitmask(), legacy)){
TTCN_Logger::log_logmatch_info(".bitmask");
single_value->field_bitmask.log_match(match_value.bitmask(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_detectionTime.match(match_value.detectionTime(), legacy)){
TTCN_Logger::log_logmatch_info(".detectionTime");
single_value->field_detectionTime.log_match(match_value.detectionTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.validityDuration().ispresent()){
if(!single_value->field_validityDuration.match(match_value.validityDuration(), legacy)){
TTCN_Logger::log_logmatch_info(".validityDuration");
single_value->field_validityDuration.log_match(match_value.validityDuration(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_validityDuration.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".validityDuration := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_validityDuration.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.repetitionDuration().ispresent()){
if(!single_value->field_repetitionDuration.match(match_value.repetitionDuration(), legacy)){
TTCN_Logger::log_logmatch_info(".repetitionDuration");
single_value->field_repetitionDuration.log_match(match_value.repetitionDuration(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_repetitionDuration.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".repetitionDuration := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_repetitionDuration.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_situation.match(match_value.situation(), legacy)){
TTCN_Logger::log_logmatch_info(".situation");
single_value->field_situation.log_match(match_value.situation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_relevanceDistance.match(match_value.relevanceDistance(), legacy)){
TTCN_Logger::log_logmatch_info(".relevanceDistance");
single_value->field_relevanceDistance.log_match(match_value.relevanceDistance(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_relevanceTrafficDirection.match(match_value.relevanceTrafficDirection(), legacy)){
TTCN_Logger::log_logmatch_info(".relevanceTrafficDirection");
single_value->field_relevanceTrafficDirection.log_match(match_value.relevanceTrafficDirection(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.transmissionInterval().ispresent()){
if(!single_value->field_transmissionInterval.match(match_value.transmissionInterval(), legacy)){
TTCN_Logger::log_logmatch_info(".transmissionInterval");
single_value->field_transmissionInterval.log_match(match_value.transmissionInterval(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_transmissionInterval.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".transmissionInterval := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_transmissionInterval.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.repetitionInterval().ispresent()){
if(!single_value->field_repetitionInterval.match(match_value.repetitionInterval(), legacy)){
TTCN_Logger::log_logmatch_info(".repetitionInterval");
single_value->field_repetitionInterval.log_match(match_value.repetitionInterval(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_repetitionInterval.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".repetitionInterval := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_repetitionInterval.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.alacarteLength().ispresent()){
if(!single_value->field_alacarteLength.match(match_value.alacarteLength(), legacy)){
TTCN_Logger::log_logmatch_info(".alacarteLength");
single_value->field_alacarteLength.log_match(match_value.alacarteLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_alacarteLength.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".alacarteLength := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_alacarteLength.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.alacarte().ispresent()){
if(!single_value->field_alacarte.match(match_value.alacarte(), legacy)){
TTCN_Logger::log_logmatch_info(".alacarte");
single_value->field_alacarte.log_match(match_value.alacarte(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_alacarte.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".alacarte := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_alacarte.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ bitmask := ");
single_value->field_bitmask.log_match(match_value.bitmask(), legacy);
TTCN_Logger::log_event_str(", detectionTime := ");
single_value->field_detectionTime.log_match(match_value.detectionTime(), legacy);
TTCN_Logger::log_event_str(", validityDuration := ");
if (match_value.validityDuration().ispresent()) single_value->field_validityDuration.log_match(match_value.validityDuration(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_validityDuration.log();
if (single_value->field_validityDuration.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", repetitionDuration := ");
if (match_value.repetitionDuration().ispresent()) single_value->field_repetitionDuration.log_match(match_value.repetitionDuration(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_repetitionDuration.log();
if (single_value->field_repetitionDuration.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", situation := ");
single_value->field_situation.log_match(match_value.situation(), legacy);
TTCN_Logger::log_event_str(", relevanceDistance := ");
single_value->field_relevanceDistance.log_match(match_value.relevanceDistance(), legacy);
TTCN_Logger::log_event_str(", relevanceTrafficDirection := ");
single_value->field_relevanceTrafficDirection.log_match(match_value.relevanceTrafficDirection(), legacy);
TTCN_Logger::log_event_str(", transmissionInterval := ");
if (match_value.transmissionInterval().ispresent()) single_value->field_transmissionInterval.log_match(match_value.transmissionInterval(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_transmissionInterval.log();
if (single_value->field_transmissionInterval.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", repetitionInterval := ");
if (match_value.repetitionInterval().ispresent()) single_value->field_repetitionInterval.log_match(match_value.repetitionInterval(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_repetitionInterval.log();
if (single_value->field_repetitionInterval.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", alacarteLength := ");
if (match_value.alacarteLength().ispresent()) single_value->field_alacarteLength.log_match(match_value.alacarteLength(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_alacarteLength.log();
if (single_value->field_alacarteLength.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", alacarte := ");
if (match_value.alacarte().ispresent()) single_value->field_alacarte.log_match(match_value.alacarte(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_alacarte.log();
if (single_value->field_alacarte.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtUtDenmTrigger_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_bitmask.encode_text(text_buf);
single_value->field_detectionTime.encode_text(text_buf);
single_value->field_validityDuration.encode_text(text_buf);
single_value->field_repetitionDuration.encode_text(text_buf);
single_value->field_situation.encode_text(text_buf);
single_value->field_relevanceDistance.encode_text(text_buf);
single_value->field_relevanceTrafficDirection.encode_text(text_buf);
single_value->field_transmissionInterval.encode_text(text_buf);
single_value->field_repetitionInterval.encode_text(text_buf);
single_value->field_alacarteLength.encode_text(text_buf);
single_value->field_alacarte.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmTrigger.");
}
}

void ExtUtDenmTrigger_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_bitmask.decode_text(text_buf);
single_value->field_detectionTime.decode_text(text_buf);
single_value->field_validityDuration.decode_text(text_buf);
single_value->field_repetitionDuration.decode_text(text_buf);
single_value->field_situation.decode_text(text_buf);
single_value->field_relevanceDistance.decode_text(text_buf);
single_value->field_relevanceTrafficDirection.decode_text(text_buf);
single_value->field_transmissionInterval.decode_text(text_buf);
single_value->field_repetitionInterval.decode_text(text_buf);
single_value->field_alacarteLength.decode_text(text_buf);
single_value->field_alacarte.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtUtDenmTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtUtDenmTrigger.");
}
}

void ExtUtDenmTrigger_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtUtDenmTrigger'");
    }
    if (strcmp("bitmask", param_field) == 0) {
      bitmask().set_param(param);
      return;
    } else if (strcmp("detectionTime", param_field) == 0) {
      detectionTime().set_param(param);
      return;
    } else if (strcmp("validityDuration", param_field) == 0) {
      validityDuration().set_param(param);
      return;
    } else if (strcmp("repetitionDuration", param_field) == 0) {
      repetitionDuration().set_param(param);
      return;
    } else if (strcmp("situation", param_field) == 0) {
      situation().set_param(param);
      return;
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      relevanceDistance().set_param(param);
      return;
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      relevanceTrafficDirection().set_param(param);
      return;
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      transmissionInterval().set_param(param);
      return;
    } else if (strcmp("repetitionInterval", param_field) == 0) {
      repetitionInterval().set_param(param);
      return;
    } else if (strcmp("alacarteLength", param_field) == 0) {
      alacarteLength().set_param(param);
      return;
    } else if (strcmp("alacarte", param_field) == 0) {
      alacarte().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtUtDenmTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtUtDenmTrigger_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (11<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtUtDenmTrigger has 11 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) bitmask().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) detectionTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) validityDuration().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) repetitionDuration().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) situation().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) relevanceDistance().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) relevanceTrafficDirection().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) transmissionInterval().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) repetitionInterval().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) alacarteLength().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) alacarte().set_param(*mp->get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bitmask")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bitmask().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "detectionTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          detectionTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validityDuration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validityDuration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repetitionDuration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repetitionDuration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "situation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          situation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceDistance")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceDistance().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceTrafficDirection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceTrafficDirection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transmissionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transmissionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repetitionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repetitionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarteLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarteLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarte")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarte().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtDenmTrigger: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtUtDenmTrigger");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtUtDenmTrigger_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtUtDenmTrigger'");
    }
    if (strcmp("bitmask", param_field) == 0) {
      return bitmask().get_param(param_name);
    } else if (strcmp("detectionTime", param_field) == 0) {
      return detectionTime().get_param(param_name);
    } else if (strcmp("validityDuration", param_field) == 0) {
      return validityDuration().get_param(param_name);
    } else if (strcmp("repetitionDuration", param_field) == 0) {
      return repetitionDuration().get_param(param_name);
    } else if (strcmp("situation", param_field) == 0) {
      return situation().get_param(param_name);
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      return relevanceDistance().get_param(param_name);
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      return relevanceTrafficDirection().get_param(param_name);
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      return transmissionInterval().get_param(param_name);
    } else if (strcmp("repetitionInterval", param_field) == 0) {
      return repetitionInterval().get_param(param_name);
    } else if (strcmp("alacarteLength", param_field) == 0) {
      return alacarteLength().get_param(param_name);
    } else if (strcmp("alacarte", param_field) == 0) {
      return alacarte().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtDenmTrigger'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_bitmask = single_value->field_bitmask.get_param(param_name);
    mp_field_bitmask->set_id(new Module_Param_FieldName(mcopystr("bitmask")));
    mp->add_elem(mp_field_bitmask);
    Module_Param* mp_field_detectionTime = single_value->field_detectionTime.get_param(param_name);
    mp_field_detectionTime->set_id(new Module_Param_FieldName(mcopystr("detectionTime")));
    mp->add_elem(mp_field_detectionTime);
    Module_Param* mp_field_validityDuration = single_value->field_validityDuration.get_param(param_name);
    mp_field_validityDuration->set_id(new Module_Param_FieldName(mcopystr("validityDuration")));
    mp->add_elem(mp_field_validityDuration);
    Module_Param* mp_field_repetitionDuration = single_value->field_repetitionDuration.get_param(param_name);
    mp_field_repetitionDuration->set_id(new Module_Param_FieldName(mcopystr("repetitionDuration")));
    mp->add_elem(mp_field_repetitionDuration);
    Module_Param* mp_field_situation = single_value->field_situation.get_param(param_name);
    mp_field_situation->set_id(new Module_Param_FieldName(mcopystr("situation")));
    mp->add_elem(mp_field_situation);
    Module_Param* mp_field_relevanceDistance = single_value->field_relevanceDistance.get_param(param_name);
    mp_field_relevanceDistance->set_id(new Module_Param_FieldName(mcopystr("relevanceDistance")));
    mp->add_elem(mp_field_relevanceDistance);
    Module_Param* mp_field_relevanceTrafficDirection = single_value->field_relevanceTrafficDirection.get_param(param_name);
    mp_field_relevanceTrafficDirection->set_id(new Module_Param_FieldName(mcopystr("relevanceTrafficDirection")));
    mp->add_elem(mp_field_relevanceTrafficDirection);
    Module_Param* mp_field_transmissionInterval = single_value->field_transmissionInterval.get_param(param_name);
    mp_field_transmissionInterval->set_id(new Module_Param_FieldName(mcopystr("transmissionInterval")));
    mp->add_elem(mp_field_transmissionInterval);
    Module_Param* mp_field_repetitionInterval = single_value->field_repetitionInterval.get_param(param_name);
    mp_field_repetitionInterval->set_id(new Module_Param_FieldName(mcopystr("repetitionInterval")));
    mp->add_elem(mp_field_repetitionInterval);
    Module_Param* mp_field_alacarteLength = single_value->field_alacarteLength.get_param(param_name);
    mp_field_alacarteLength->set_id(new Module_Param_FieldName(mcopystr("alacarteLength")));
    mp->add_elem(mp_field_alacarteLength);
    Module_Param* mp_field_alacarte = single_value->field_alacarte.get_param(param_name);
    mp_field_alacarte->set_id(new Module_Param_FieldName(mcopystr("alacarte")));
    mp->add_elem(mp_field_alacarte);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtUtDenmTrigger_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_bitmask.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_detectionTime.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_validityDuration.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_repetitionDuration.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_situation.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_relevanceDistance.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_relevanceTrafficDirection.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_transmissionInterval.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_repetitionInterval.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_alacarteLength.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
single_value->field_alacarte.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtUtDenmTrigger");
}

boolean ExtUtDenmTrigger_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtUtDenmTrigger_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtActionID::ExtActionID()
{
  bound_flag = FALSE;
}

ExtActionID::ExtActionID(const INTEGER& par_originatingStationID,
    const INTEGER& par_sequenceNumber)
  :   field_originatingStationID(par_originatingStationID),
  field_sequenceNumber(par_sequenceNumber)
{
  bound_flag = TRUE;
}

ExtActionID::ExtActionID(const ExtActionID& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtActionID.");
bound_flag = TRUE;
if (other_value.originatingStationID().is_bound()) field_originatingStationID = other_value.originatingStationID();
else field_originatingStationID.clean_up();
if (other_value.sequenceNumber().is_bound()) field_sequenceNumber = other_value.sequenceNumber();
else field_sequenceNumber.clean_up();
}

void ExtActionID::clean_up()
{
field_originatingStationID.clean_up();
field_sequenceNumber.clean_up();
bound_flag = FALSE;
}

ExtActionID& ExtActionID::operator=(const ExtActionID& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtActionID.");
  bound_flag = TRUE;
  if (other_value.originatingStationID().is_bound()) field_originatingStationID = other_value.originatingStationID();
  else field_originatingStationID.clean_up();
  if (other_value.sequenceNumber().is_bound()) field_sequenceNumber = other_value.sequenceNumber();
  else field_sequenceNumber.clean_up();
}
return *this;
}

boolean ExtActionID::operator==(const ExtActionID& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_originatingStationID==other_value.field_originatingStationID
  && field_sequenceNumber==other_value.field_sequenceNumber;
}

boolean ExtActionID::is_bound() const
{
if (bound_flag) return TRUE;
if(field_originatingStationID.is_bound()) return TRUE;
if(field_sequenceNumber.is_bound()) return TRUE;
return FALSE;
}
boolean ExtActionID::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_originatingStationID.is_value()) return FALSE;
if(!field_sequenceNumber.is_value()) return FALSE;
return TRUE;
}
int ExtActionID::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtActionID");
  return 2;
}

void ExtActionID::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ originatingStationID := ");
field_originatingStationID.log();
TTCN_Logger::log_event_str(", sequenceNumber := ");
field_sequenceNumber.log();
TTCN_Logger::log_event_str(" }");
}

void ExtActionID::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtActionID'");
    }
    if (strcmp("originatingStationID", param_field) == 0) {
      originatingStationID().set_param(param);
      return;
    } else if (strcmp("sequenceNumber", param_field) == 0) {
      sequenceNumber().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtActionID'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtActionID has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) originatingStationID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sequenceNumber().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "originatingStationID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          originatingStationID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sequenceNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sequenceNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtActionID: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtActionID");
  }
}

Module_Param* ExtActionID::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtActionID'");
    }
    if (strcmp("originatingStationID", param_field) == 0) {
      return originatingStationID().get_param(param_name);
    } else if (strcmp("sequenceNumber", param_field) == 0) {
      return sequenceNumber().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtActionID'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_originatingStationID = field_originatingStationID.get_param(param_name);
  mp_field_originatingStationID->set_id(new Module_Param_FieldName(mcopystr("originatingStationID")));
  mp->add_elem(mp_field_originatingStationID);
  Module_Param* mp_field_sequenceNumber = field_sequenceNumber.get_param(param_name);
  mp_field_sequenceNumber->set_id(new Module_Param_FieldName(mcopystr("sequenceNumber")));
  mp->add_elem(mp_field_sequenceNumber);
  return mp;
  }

void ExtActionID::set_implicit_omit()
{
if (originatingStationID().is_bound()) originatingStationID().set_implicit_omit();
if (sequenceNumber().is_bound()) sequenceNumber().set_implicit_omit();
}

void ExtActionID::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtActionID.");
field_originatingStationID.encode_text(text_buf);
field_sequenceNumber.encode_text(text_buf);
}

void ExtActionID::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_originatingStationID.decode_text(text_buf);
field_sequenceNumber.decode_text(text_buf);
}

void ExtActionID::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtActionID::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtActionID::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_originatingStationID.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_sequenceNumber.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtActionID::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_originatingStationID.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_sequenceNumber.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int ExtActionID::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtActionID.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "originatingStationID");
    enc_len += field_originatingStationID.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sequenceNumber");
    enc_len += field_sequenceNumber.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtActionID::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (20 == name_len && 0 == strncmp(fld_name, "originatingStationID", name_len)) {
         int ret_val = field_originatingStationID.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "originatingStationID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "sequenceNumber", name_len)) {
         int ret_val = field_sequenceNumber.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sequenceNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_originatingStationID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "originatingStationID");
    return JSON_ERROR_FATAL;
  }
if (!field_sequenceNumber.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "sequenceNumber");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtActionID_template::single_value_struct {
INTEGER_template field_originatingStationID;
INTEGER_template field_sequenceNumber;
};

void ExtActionID_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_originatingStationID = ANY_VALUE;
single_value->field_sequenceNumber = ANY_VALUE;
}
}
}

void ExtActionID_template::copy_value(const ExtActionID& other_value)
{
single_value = new single_value_struct;
if (other_value.originatingStationID().is_bound()) {
  single_value->field_originatingStationID = other_value.originatingStationID();
} else {
  single_value->field_originatingStationID.clean_up();
}
if (other_value.sequenceNumber().is_bound()) {
  single_value->field_sequenceNumber = other_value.sequenceNumber();
} else {
  single_value->field_sequenceNumber.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtActionID_template::copy_template(const ExtActionID_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.originatingStationID().get_selection()) {
single_value->field_originatingStationID = other_value.originatingStationID();
} else {
single_value->field_originatingStationID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sequenceNumber().get_selection()) {
single_value->field_sequenceNumber = other_value.sequenceNumber();
} else {
single_value->field_sequenceNumber.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtActionID_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtActionID.");
break;
}
set_selection(other_value);
}

ExtActionID_template::ExtActionID_template()
{
}

ExtActionID_template::ExtActionID_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtActionID_template::ExtActionID_template(const ExtActionID& other_value)
{
copy_value(other_value);
}

ExtActionID_template::ExtActionID_template(const OPTIONAL<ExtActionID>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtActionID&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtActionID from an unbound optional field.");
}
}

ExtActionID_template::ExtActionID_template(const ExtActionID_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtActionID_template::~ExtActionID_template()
{
clean_up();
}

ExtActionID_template& ExtActionID_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtActionID_template& ExtActionID_template::operator=(const ExtActionID& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtActionID_template& ExtActionID_template::operator=(const OPTIONAL<ExtActionID>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtActionID&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtActionID.");
}
return *this;
}

ExtActionID_template& ExtActionID_template::operator=(const ExtActionID_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtActionID_template::match(const ExtActionID& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.originatingStationID().is_bound()) return FALSE;
if(!single_value->field_originatingStationID.match(other_value.originatingStationID(), legacy))return FALSE;
if(!other_value.sequenceNumber().is_bound()) return FALSE;
if(!single_value->field_sequenceNumber.match(other_value.sequenceNumber(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtActionID.");
}
return FALSE;
}

boolean ExtActionID_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_originatingStationID.is_bound()) return TRUE;
if (single_value->field_sequenceNumber.is_bound()) return TRUE;
return FALSE;
}

boolean ExtActionID_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_originatingStationID.is_value()) return FALSE;
if (!single_value->field_sequenceNumber.is_value()) return FALSE;
return TRUE;
}

void ExtActionID_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtActionID ExtActionID_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtActionID.");
ExtActionID ret_val;
if (single_value->field_originatingStationID.is_bound()) {
ret_val.originatingStationID() = single_value->field_originatingStationID.valueof();
}
if (single_value->field_sequenceNumber.is_bound()) {
ret_val.sequenceNumber() = single_value->field_sequenceNumber.valueof();
}
return ret_val;
}

void ExtActionID_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtActionID.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtActionID_template[list_length];
}

ExtActionID_template& ExtActionID_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtActionID.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtActionID.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtActionID_template::originatingStationID()
{
set_specific();
return single_value->field_originatingStationID;
}

const INTEGER_template& ExtActionID_template::originatingStationID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field originatingStationID of a non-specific template of type @TTCN_EncDec.ExtActionID.");
return single_value->field_originatingStationID;
}

INTEGER_template& ExtActionID_template::sequenceNumber()
{
set_specific();
return single_value->field_sequenceNumber;
}

const INTEGER_template& ExtActionID_template::sequenceNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sequenceNumber of a non-specific template of type @TTCN_EncDec.ExtActionID.");
return single_value->field_sequenceNumber;
}

int ExtActionID_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtActionID which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtActionID containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtActionID containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtActionID containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtActionID containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtActionID containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtActionID.");
  }
  return 0;
}

void ExtActionID_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ originatingStationID := ");
single_value->field_originatingStationID.log();
TTCN_Logger::log_event_str(", sequenceNumber := ");
single_value->field_sequenceNumber.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtActionID_template::log_match(const ExtActionID& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_originatingStationID.match(match_value.originatingStationID(), legacy)){
TTCN_Logger::log_logmatch_info(".originatingStationID");
single_value->field_originatingStationID.log_match(match_value.originatingStationID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sequenceNumber.match(match_value.sequenceNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".sequenceNumber");
single_value->field_sequenceNumber.log_match(match_value.sequenceNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ originatingStationID := ");
single_value->field_originatingStationID.log_match(match_value.originatingStationID(), legacy);
TTCN_Logger::log_event_str(", sequenceNumber := ");
single_value->field_sequenceNumber.log_match(match_value.sequenceNumber(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtActionID_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_originatingStationID.encode_text(text_buf);
single_value->field_sequenceNumber.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtActionID.");
}
}

void ExtActionID_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_originatingStationID.decode_text(text_buf);
single_value->field_sequenceNumber.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtActionID_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtActionID.");
}
}

void ExtActionID_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtActionID'");
    }
    if (strcmp("originatingStationID", param_field) == 0) {
      originatingStationID().set_param(param);
      return;
    } else if (strcmp("sequenceNumber", param_field) == 0) {
      sequenceNumber().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtActionID'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtActionID_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtActionID has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) originatingStationID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sequenceNumber().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "originatingStationID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          originatingStationID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sequenceNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sequenceNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtActionID: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtActionID");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtActionID_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtActionID'");
    }
    if (strcmp("originatingStationID", param_field) == 0) {
      return originatingStationID().get_param(param_name);
    } else if (strcmp("sequenceNumber", param_field) == 0) {
      return sequenceNumber().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtActionID'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_originatingStationID = single_value->field_originatingStationID.get_param(param_name);
    mp_field_originatingStationID->set_id(new Module_Param_FieldName(mcopystr("originatingStationID")));
    mp->add_elem(mp_field_originatingStationID);
    Module_Param* mp_field_sequenceNumber = single_value->field_sequenceNumber.get_param(param_name);
    mp_field_sequenceNumber->set_id(new Module_Param_FieldName(mcopystr("sequenceNumber")));
    mp->add_elem(mp_field_sequenceNumber);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtActionID_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_originatingStationID.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtActionID");
single_value->field_sequenceNumber.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtActionID");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtActionID");
}

boolean ExtActionID_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtActionID_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtUtDenmUpdate::ExtUtDenmUpdate()
{
  bound_flag = FALSE;
}

ExtUtDenmUpdate::ExtUtDenmUpdate(const INTEGER& par_bitmask,
    const ExtActionID& par_actionID,
    const INTEGER& par_detectionTime,
    const OPTIONAL<INTEGER>& par_validityDuration,
    const OPTIONAL<ExtSituationContainer>& par_situation,
    const OPTIONAL<INTEGER>& par_relevanceDistance,
    const OPTIONAL<INTEGER>& par_relevanceTrafficDirection,
    const OPTIONAL<INTEGER>& par_transmissionInterval,
    const OPTIONAL<INTEGER>& par_repetitionInterval,
    const OPTIONAL<INTEGER>& par_alacarteLength,
    const OPTIONAL<ExtAlacarteContainer>& par_alacarte)
  :   field_bitmask(par_bitmask),
  field_actionID(par_actionID),
  field_detectionTime(par_detectionTime),
  field_validityDuration(par_validityDuration),
  field_situation(par_situation),
  field_relevanceDistance(par_relevanceDistance),
  field_relevanceTrafficDirection(par_relevanceTrafficDirection),
  field_transmissionInterval(par_transmissionInterval),
  field_repetitionInterval(par_repetitionInterval),
  field_alacarteLength(par_alacarteLength),
  field_alacarte(par_alacarte)
{
  bound_flag = TRUE;
}

ExtUtDenmUpdate::ExtUtDenmUpdate(const ExtUtDenmUpdate& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtUtDenmUpdate.");
bound_flag = TRUE;
if (other_value.bitmask().is_bound()) field_bitmask = other_value.bitmask();
else field_bitmask.clean_up();
if (other_value.actionID().is_bound()) field_actionID = other_value.actionID();
else field_actionID.clean_up();
if (other_value.detectionTime().is_bound()) field_detectionTime = other_value.detectionTime();
else field_detectionTime.clean_up();
if (other_value.validityDuration().is_bound()) field_validityDuration = other_value.validityDuration();
else field_validityDuration.clean_up();
if (other_value.situation().is_bound()) field_situation = other_value.situation();
else field_situation.clean_up();
if (other_value.relevanceDistance().is_bound()) field_relevanceDistance = other_value.relevanceDistance();
else field_relevanceDistance.clean_up();
if (other_value.relevanceTrafficDirection().is_bound()) field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
else field_relevanceTrafficDirection.clean_up();
if (other_value.transmissionInterval().is_bound()) field_transmissionInterval = other_value.transmissionInterval();
else field_transmissionInterval.clean_up();
if (other_value.repetitionInterval().is_bound()) field_repetitionInterval = other_value.repetitionInterval();
else field_repetitionInterval.clean_up();
if (other_value.alacarteLength().is_bound()) field_alacarteLength = other_value.alacarteLength();
else field_alacarteLength.clean_up();
if (other_value.alacarte().is_bound()) field_alacarte = other_value.alacarte();
else field_alacarte.clean_up();
}

void ExtUtDenmUpdate::clean_up()
{
field_bitmask.clean_up();
field_actionID.clean_up();
field_detectionTime.clean_up();
field_validityDuration.clean_up();
field_situation.clean_up();
field_relevanceDistance.clean_up();
field_relevanceTrafficDirection.clean_up();
field_transmissionInterval.clean_up();
field_repetitionInterval.clean_up();
field_alacarteLength.clean_up();
field_alacarte.clean_up();
bound_flag = FALSE;
}

ExtUtDenmUpdate& ExtUtDenmUpdate::operator=(const ExtUtDenmUpdate& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtUtDenmUpdate.");
  bound_flag = TRUE;
  if (other_value.bitmask().is_bound()) field_bitmask = other_value.bitmask();
  else field_bitmask.clean_up();
  if (other_value.actionID().is_bound()) field_actionID = other_value.actionID();
  else field_actionID.clean_up();
  if (other_value.detectionTime().is_bound()) field_detectionTime = other_value.detectionTime();
  else field_detectionTime.clean_up();
  if (other_value.validityDuration().is_bound()) field_validityDuration = other_value.validityDuration();
  else field_validityDuration.clean_up();
  if (other_value.situation().is_bound()) field_situation = other_value.situation();
  else field_situation.clean_up();
  if (other_value.relevanceDistance().is_bound()) field_relevanceDistance = other_value.relevanceDistance();
  else field_relevanceDistance.clean_up();
  if (other_value.relevanceTrafficDirection().is_bound()) field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
  else field_relevanceTrafficDirection.clean_up();
  if (other_value.transmissionInterval().is_bound()) field_transmissionInterval = other_value.transmissionInterval();
  else field_transmissionInterval.clean_up();
  if (other_value.repetitionInterval().is_bound()) field_repetitionInterval = other_value.repetitionInterval();
  else field_repetitionInterval.clean_up();
  if (other_value.alacarteLength().is_bound()) field_alacarteLength = other_value.alacarteLength();
  else field_alacarteLength.clean_up();
  if (other_value.alacarte().is_bound()) field_alacarte = other_value.alacarte();
  else field_alacarte.clean_up();
}
return *this;
}

boolean ExtUtDenmUpdate::operator==(const ExtUtDenmUpdate& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_bitmask==other_value.field_bitmask
  && field_actionID==other_value.field_actionID
  && field_detectionTime==other_value.field_detectionTime
  && field_validityDuration==other_value.field_validityDuration
  && field_situation==other_value.field_situation
  && field_relevanceDistance==other_value.field_relevanceDistance
  && field_relevanceTrafficDirection==other_value.field_relevanceTrafficDirection
  && field_transmissionInterval==other_value.field_transmissionInterval
  && field_repetitionInterval==other_value.field_repetitionInterval
  && field_alacarteLength==other_value.field_alacarteLength
  && field_alacarte==other_value.field_alacarte;
}

boolean ExtUtDenmUpdate::is_bound() const
{
if (bound_flag) return TRUE;
if(field_bitmask.is_bound()) return TRUE;
if(field_actionID.is_bound()) return TRUE;
if(field_detectionTime.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_validityDuration.get_selection() || field_validityDuration.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_situation.get_selection() || field_situation.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_relevanceDistance.get_selection() || field_relevanceDistance.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_relevanceTrafficDirection.get_selection() || field_relevanceTrafficDirection.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_transmissionInterval.get_selection() || field_transmissionInterval.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_repetitionInterval.get_selection() || field_repetitionInterval.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_alacarteLength.get_selection() || field_alacarteLength.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_alacarte.get_selection() || field_alacarte.is_bound()) return TRUE;
return FALSE;
}
boolean ExtUtDenmUpdate::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_bitmask.is_value()) return FALSE;
if(!field_actionID.is_value()) return FALSE;
if(!field_detectionTime.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_validityDuration.get_selection() && !field_validityDuration.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_situation.get_selection() && !field_situation.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_relevanceDistance.get_selection() && !field_relevanceDistance.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_relevanceTrafficDirection.get_selection() && !field_relevanceTrafficDirection.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_transmissionInterval.get_selection() && !field_transmissionInterval.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_repetitionInterval.get_selection() && !field_repetitionInterval.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_alacarteLength.get_selection() && !field_alacarteLength.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_alacarte.get_selection() && !field_alacarte.is_value()) return FALSE;
return TRUE;
}
int ExtUtDenmUpdate::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtUtDenmUpdate");
  int ret_val = 3;
  if (field_validityDuration.ispresent()) ret_val++;
  if (field_situation.ispresent()) ret_val++;
  if (field_relevanceDistance.ispresent()) ret_val++;
  if (field_relevanceTrafficDirection.ispresent()) ret_val++;
  if (field_transmissionInterval.ispresent()) ret_val++;
  if (field_repetitionInterval.ispresent()) ret_val++;
  if (field_alacarteLength.ispresent()) ret_val++;
  if (field_alacarte.ispresent()) ret_val++;
  return ret_val;
}

void ExtUtDenmUpdate::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ bitmask := ");
field_bitmask.log();
TTCN_Logger::log_event_str(", actionID := ");
field_actionID.log();
TTCN_Logger::log_event_str(", detectionTime := ");
field_detectionTime.log();
TTCN_Logger::log_event_str(", validityDuration := ");
field_validityDuration.log();
TTCN_Logger::log_event_str(", situation := ");
field_situation.log();
TTCN_Logger::log_event_str(", relevanceDistance := ");
field_relevanceDistance.log();
TTCN_Logger::log_event_str(", relevanceTrafficDirection := ");
field_relevanceTrafficDirection.log();
TTCN_Logger::log_event_str(", transmissionInterval := ");
field_transmissionInterval.log();
TTCN_Logger::log_event_str(", repetitionInterval := ");
field_repetitionInterval.log();
TTCN_Logger::log_event_str(", alacarteLength := ");
field_alacarteLength.log();
TTCN_Logger::log_event_str(", alacarte := ");
field_alacarte.log();
TTCN_Logger::log_event_str(" }");
}

void ExtUtDenmUpdate::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtUtDenmUpdate'");
    }
    if (strcmp("bitmask", param_field) == 0) {
      bitmask().set_param(param);
      return;
    } else if (strcmp("actionID", param_field) == 0) {
      actionID().set_param(param);
      return;
    } else if (strcmp("detectionTime", param_field) == 0) {
      detectionTime().set_param(param);
      return;
    } else if (strcmp("validityDuration", param_field) == 0) {
      validityDuration().set_param(param);
      return;
    } else if (strcmp("situation", param_field) == 0) {
      situation().set_param(param);
      return;
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      relevanceDistance().set_param(param);
      return;
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      relevanceTrafficDirection().set_param(param);
      return;
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      transmissionInterval().set_param(param);
      return;
    } else if (strcmp("repetitionInterval", param_field) == 0) {
      repetitionInterval().set_param(param);
      return;
    } else if (strcmp("alacarteLength", param_field) == 0) {
      alacarteLength().set_param(param);
      return;
    } else if (strcmp("alacarte", param_field) == 0) {
      alacarte().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtDenmUpdate'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (11<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtUtDenmUpdate has 11 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) bitmask().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) actionID().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) detectionTime().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) validityDuration().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) situation().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) relevanceDistance().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) relevanceTrafficDirection().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) transmissionInterval().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) repetitionInterval().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) alacarteLength().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) alacarte().set_param(*mp->get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bitmask")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bitmask().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "actionID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          actionID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "detectionTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          detectionTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validityDuration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validityDuration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "situation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          situation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceDistance")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceDistance().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceTrafficDirection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceTrafficDirection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transmissionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transmissionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repetitionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repetitionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarteLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarteLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarte")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarte().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtDenmUpdate: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtUtDenmUpdate");
  }
}

Module_Param* ExtUtDenmUpdate::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtUtDenmUpdate'");
    }
    if (strcmp("bitmask", param_field) == 0) {
      return bitmask().get_param(param_name);
    } else if (strcmp("actionID", param_field) == 0) {
      return actionID().get_param(param_name);
    } else if (strcmp("detectionTime", param_field) == 0) {
      return detectionTime().get_param(param_name);
    } else if (strcmp("validityDuration", param_field) == 0) {
      return validityDuration().get_param(param_name);
    } else if (strcmp("situation", param_field) == 0) {
      return situation().get_param(param_name);
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      return relevanceDistance().get_param(param_name);
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      return relevanceTrafficDirection().get_param(param_name);
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      return transmissionInterval().get_param(param_name);
    } else if (strcmp("repetitionInterval", param_field) == 0) {
      return repetitionInterval().get_param(param_name);
    } else if (strcmp("alacarteLength", param_field) == 0) {
      return alacarteLength().get_param(param_name);
    } else if (strcmp("alacarte", param_field) == 0) {
      return alacarte().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtDenmUpdate'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_bitmask = field_bitmask.get_param(param_name);
  mp_field_bitmask->set_id(new Module_Param_FieldName(mcopystr("bitmask")));
  mp->add_elem(mp_field_bitmask);
  Module_Param* mp_field_actionID = field_actionID.get_param(param_name);
  mp_field_actionID->set_id(new Module_Param_FieldName(mcopystr("actionID")));
  mp->add_elem(mp_field_actionID);
  Module_Param* mp_field_detectionTime = field_detectionTime.get_param(param_name);
  mp_field_detectionTime->set_id(new Module_Param_FieldName(mcopystr("detectionTime")));
  mp->add_elem(mp_field_detectionTime);
  Module_Param* mp_field_validityDuration = field_validityDuration.get_param(param_name);
  mp_field_validityDuration->set_id(new Module_Param_FieldName(mcopystr("validityDuration")));
  mp->add_elem(mp_field_validityDuration);
  Module_Param* mp_field_situation = field_situation.get_param(param_name);
  mp_field_situation->set_id(new Module_Param_FieldName(mcopystr("situation")));
  mp->add_elem(mp_field_situation);
  Module_Param* mp_field_relevanceDistance = field_relevanceDistance.get_param(param_name);
  mp_field_relevanceDistance->set_id(new Module_Param_FieldName(mcopystr("relevanceDistance")));
  mp->add_elem(mp_field_relevanceDistance);
  Module_Param* mp_field_relevanceTrafficDirection = field_relevanceTrafficDirection.get_param(param_name);
  mp_field_relevanceTrafficDirection->set_id(new Module_Param_FieldName(mcopystr("relevanceTrafficDirection")));
  mp->add_elem(mp_field_relevanceTrafficDirection);
  Module_Param* mp_field_transmissionInterval = field_transmissionInterval.get_param(param_name);
  mp_field_transmissionInterval->set_id(new Module_Param_FieldName(mcopystr("transmissionInterval")));
  mp->add_elem(mp_field_transmissionInterval);
  Module_Param* mp_field_repetitionInterval = field_repetitionInterval.get_param(param_name);
  mp_field_repetitionInterval->set_id(new Module_Param_FieldName(mcopystr("repetitionInterval")));
  mp->add_elem(mp_field_repetitionInterval);
  Module_Param* mp_field_alacarteLength = field_alacarteLength.get_param(param_name);
  mp_field_alacarteLength->set_id(new Module_Param_FieldName(mcopystr("alacarteLength")));
  mp->add_elem(mp_field_alacarteLength);
  Module_Param* mp_field_alacarte = field_alacarte.get_param(param_name);
  mp_field_alacarte->set_id(new Module_Param_FieldName(mcopystr("alacarte")));
  mp->add_elem(mp_field_alacarte);
  return mp;
  }

void ExtUtDenmUpdate::set_implicit_omit()
{
if (bitmask().is_bound()) bitmask().set_implicit_omit();
if (actionID().is_bound()) actionID().set_implicit_omit();
if (detectionTime().is_bound()) detectionTime().set_implicit_omit();
if (!validityDuration().is_bound()) validityDuration() = OMIT_VALUE;
else validityDuration().set_implicit_omit();
if (!situation().is_bound()) situation() = OMIT_VALUE;
else situation().set_implicit_omit();
if (!relevanceDistance().is_bound()) relevanceDistance() = OMIT_VALUE;
else relevanceDistance().set_implicit_omit();
if (!relevanceTrafficDirection().is_bound()) relevanceTrafficDirection() = OMIT_VALUE;
else relevanceTrafficDirection().set_implicit_omit();
if (!transmissionInterval().is_bound()) transmissionInterval() = OMIT_VALUE;
else transmissionInterval().set_implicit_omit();
if (!repetitionInterval().is_bound()) repetitionInterval() = OMIT_VALUE;
else repetitionInterval().set_implicit_omit();
if (!alacarteLength().is_bound()) alacarteLength() = OMIT_VALUE;
else alacarteLength().set_implicit_omit();
if (!alacarte().is_bound()) alacarte() = OMIT_VALUE;
else alacarte().set_implicit_omit();
}

void ExtUtDenmUpdate::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtUtDenmUpdate.");
field_bitmask.encode_text(text_buf);
field_actionID.encode_text(text_buf);
field_detectionTime.encode_text(text_buf);
field_validityDuration.encode_text(text_buf);
field_situation.encode_text(text_buf);
field_relevanceDistance.encode_text(text_buf);
field_relevanceTrafficDirection.encode_text(text_buf);
field_transmissionInterval.encode_text(text_buf);
field_repetitionInterval.encode_text(text_buf);
field_alacarteLength.encode_text(text_buf);
field_alacarte.encode_text(text_buf);
}

void ExtUtDenmUpdate::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_bitmask.decode_text(text_buf);
field_actionID.decode_text(text_buf);
field_detectionTime.decode_text(text_buf);
field_validityDuration.decode_text(text_buf);
field_situation.decode_text(text_buf);
field_relevanceDistance.decode_text(text_buf);
field_relevanceTrafficDirection.decode_text(text_buf);
field_transmissionInterval.decode_text(text_buf);
field_repetitionInterval.decode_text(text_buf);
field_alacarteLength.decode_text(text_buf);
field_alacarte.decode_text(text_buf);
}

void ExtUtDenmUpdate::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtUtDenmUpdate::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtUtDenmUpdate::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_bitmask.RAW_decode(ExtUtDenmUpdate_bitmask_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_actionID.RAW_decode(ExtActionID_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_detectionTime.RAW_decode(ExtUtDenmUpdate_detectionTime_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_validityDuration().RAW_decode(ExtUtDenmUpdate_validityDuration_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_validityDuration = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_validityDuration=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_situation().RAW_decode(ExtSituationContainer_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_situation = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_situation=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_relevanceDistance().RAW_decode(ExtUtDenmUpdate_relevanceDistance_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_relevanceDistance = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_relevanceDistance=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_relevanceTrafficDirection().RAW_decode(ExtUtDenmUpdate_relevanceTrafficDirection_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_relevanceTrafficDirection = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_relevanceTrafficDirection=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_transmissionInterval().RAW_decode(ExtUtDenmUpdate_transmissionInterval_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_transmissionInterval = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_transmissionInterval=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_repetitionInterval().RAW_decode(ExtUtDenmUpdate_repetitionInterval_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_repetitionInterval = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_repetitionInterval=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_alacarteLength().RAW_decode(ExtUtDenmUpdate_alacarteLength_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_alacarteLength = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_alacarteLength=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_alacarte().RAW_decode(ExtAlacarteContainer_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_alacarte = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_alacarte=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtUtDenmUpdate::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 11;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(11);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ExtUtDenmUpdate_bitmask_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ExtActionID_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, ExtUtDenmUpdate_detectionTime_descr_.raw);
  if (field_validityDuration.ispresent()) {
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, ExtUtDenmUpdate_validityDuration_descr_.raw);
  }
  else myleaf.body.node.nodes[3] = NULL;
  if (field_situation.ispresent()) {
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, ExtSituationContainer_descr_.raw);
  }
  else myleaf.body.node.nodes[4] = NULL;
  if (field_relevanceDistance.ispresent()) {
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, ExtUtDenmUpdate_relevanceDistance_descr_.raw);
  }
  else myleaf.body.node.nodes[5] = NULL;
  if (field_relevanceTrafficDirection.ispresent()) {
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, ExtUtDenmUpdate_relevanceTrafficDirection_descr_.raw);
  }
  else myleaf.body.node.nodes[6] = NULL;
  if (field_transmissionInterval.ispresent()) {
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, ExtUtDenmUpdate_transmissionInterval_descr_.raw);
  }
  else myleaf.body.node.nodes[7] = NULL;
  if (field_repetitionInterval.ispresent()) {
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, ExtUtDenmUpdate_repetitionInterval_descr_.raw);
  }
  else myleaf.body.node.nodes[8] = NULL;
  if (field_alacarteLength.ispresent()) {
  myleaf.body.node.nodes[9] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 9, ExtUtDenmUpdate_alacarteLength_descr_.raw);
  }
  else myleaf.body.node.nodes[9] = NULL;
  if (field_alacarte.ispresent()) {
  myleaf.body.node.nodes[10] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 10, ExtAlacarteContainer_descr_.raw);
  }
  else myleaf.body.node.nodes[10] = NULL;
  encoded_length += field_bitmask.RAW_encode(ExtUtDenmUpdate_bitmask_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_actionID.RAW_encode(ExtActionID_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_detectionTime.RAW_encode(ExtUtDenmUpdate_detectionTime_descr_, *myleaf.body.node.nodes[2]);
  if (field_validityDuration.ispresent()) {
  encoded_length += field_validityDuration().RAW_encode(ExtUtDenmUpdate_validityDuration_descr_, *myleaf.body.node.nodes[3]);
  }
  if (field_situation.ispresent()) {
  encoded_length += field_situation().RAW_encode(ExtSituationContainer_descr_, *myleaf.body.node.nodes[4]);
  }
  if (field_relevanceDistance.ispresent()) {
  encoded_length += field_relevanceDistance().RAW_encode(ExtUtDenmUpdate_relevanceDistance_descr_, *myleaf.body.node.nodes[5]);
  }
  if (field_relevanceTrafficDirection.ispresent()) {
  encoded_length += field_relevanceTrafficDirection().RAW_encode(ExtUtDenmUpdate_relevanceTrafficDirection_descr_, *myleaf.body.node.nodes[6]);
  }
  if (field_transmissionInterval.ispresent()) {
  encoded_length += field_transmissionInterval().RAW_encode(ExtUtDenmUpdate_transmissionInterval_descr_, *myleaf.body.node.nodes[7]);
  }
  if (field_repetitionInterval.ispresent()) {
  encoded_length += field_repetitionInterval().RAW_encode(ExtUtDenmUpdate_repetitionInterval_descr_, *myleaf.body.node.nodes[8]);
  }
  if (field_alacarteLength.ispresent()) {
  encoded_length += field_alacarteLength().RAW_encode(ExtUtDenmUpdate_alacarteLength_descr_, *myleaf.body.node.nodes[9]);
  }
  if (field_alacarte.ispresent()) {
  encoded_length += field_alacarte().RAW_encode(ExtAlacarteContainer_descr_, *myleaf.body.node.nodes[10]);
  }
  return myleaf.length = encoded_length;
}

int ExtUtDenmUpdate::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtUtDenmUpdate.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "bitmask");
    enc_len += field_bitmask.JSON_encode(ExtUtDenmUpdate_bitmask_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "actionID");
    enc_len += field_actionID.JSON_encode(ExtActionID_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "detectionTime");
    enc_len += field_detectionTime.JSON_encode(ExtUtDenmUpdate_detectionTime_descr_, p_tok);
  }

  if (field_validityDuration.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "validityDuration");
    enc_len += field_validityDuration.JSON_encode(ExtUtDenmUpdate_validityDuration_descr_, p_tok);
  }

  if (field_situation.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "situation");
    enc_len += field_situation.JSON_encode(ExtSituationContainer_descr_, p_tok);
  }

  if (field_relevanceDistance.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "relevanceDistance");
    enc_len += field_relevanceDistance.JSON_encode(ExtUtDenmUpdate_relevanceDistance_descr_, p_tok);
  }

  if (field_relevanceTrafficDirection.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "relevanceTrafficDirection");
    enc_len += field_relevanceTrafficDirection.JSON_encode(ExtUtDenmUpdate_relevanceTrafficDirection_descr_, p_tok);
  }

  if (field_transmissionInterval.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "transmissionInterval");
    enc_len += field_transmissionInterval.JSON_encode(ExtUtDenmUpdate_transmissionInterval_descr_, p_tok);
  }

  if (field_repetitionInterval.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "repetitionInterval");
    enc_len += field_repetitionInterval.JSON_encode(ExtUtDenmUpdate_repetitionInterval_descr_, p_tok);
  }

  if (field_alacarteLength.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "alacarteLength");
    enc_len += field_alacarteLength.JSON_encode(ExtUtDenmUpdate_alacarteLength_descr_, p_tok);
  }

  if (field_alacarte.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "alacarte");
    enc_len += field_alacarte.JSON_encode(ExtAlacarteContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtUtDenmUpdate::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "bitmask", name_len)) {
         int ret_val = field_bitmask.JSON_decode(ExtUtDenmUpdate_bitmask_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "bitmask");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "actionID", name_len)) {
         int ret_val = field_actionID.JSON_decode(ExtActionID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "actionID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "detectionTime", name_len)) {
         int ret_val = field_detectionTime.JSON_decode(ExtUtDenmUpdate_detectionTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "detectionTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "validityDuration", name_len)) {
         int ret_val = field_validityDuration.JSON_decode(ExtUtDenmUpdate_validityDuration_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "validityDuration");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "situation", name_len)) {
         int ret_val = field_situation.JSON_decode(ExtSituationContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "situation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "relevanceDistance", name_len)) {
         int ret_val = field_relevanceDistance.JSON_decode(ExtUtDenmUpdate_relevanceDistance_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "relevanceDistance");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (25 == name_len && 0 == strncmp(fld_name, "relevanceTrafficDirection", name_len)) {
         int ret_val = field_relevanceTrafficDirection.JSON_decode(ExtUtDenmUpdate_relevanceTrafficDirection_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "relevanceTrafficDirection");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "transmissionInterval", name_len)) {
         int ret_val = field_transmissionInterval.JSON_decode(ExtUtDenmUpdate_transmissionInterval_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "transmissionInterval");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "repetitionInterval", name_len)) {
         int ret_val = field_repetitionInterval.JSON_decode(ExtUtDenmUpdate_repetitionInterval_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "repetitionInterval");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "alacarteLength", name_len)) {
         int ret_val = field_alacarteLength.JSON_decode(ExtUtDenmUpdate_alacarteLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "alacarteLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "alacarte", name_len)) {
         int ret_val = field_alacarte.JSON_decode(ExtAlacarteContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "alacarte");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_bitmask.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "bitmask");
    return JSON_ERROR_FATAL;
  }
if (!field_actionID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "actionID");
    return JSON_ERROR_FATAL;
  }
if (!field_detectionTime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "detectionTime");
    return JSON_ERROR_FATAL;
  }
if (!field_validityDuration.is_bound()) {
    field_validityDuration = OMIT_VALUE;
  }
if (!field_situation.is_bound()) {
    field_situation = OMIT_VALUE;
  }
if (!field_relevanceDistance.is_bound()) {
    field_relevanceDistance = OMIT_VALUE;
  }
if (!field_relevanceTrafficDirection.is_bound()) {
    field_relevanceTrafficDirection = OMIT_VALUE;
  }
if (!field_transmissionInterval.is_bound()) {
    field_transmissionInterval = OMIT_VALUE;
  }
if (!field_repetitionInterval.is_bound()) {
    field_repetitionInterval = OMIT_VALUE;
  }
if (!field_alacarteLength.is_bound()) {
    field_alacarteLength = OMIT_VALUE;
  }
if (!field_alacarte.is_bound()) {
    field_alacarte = OMIT_VALUE;
  }

  return dec_len;
}

struct ExtUtDenmUpdate_template::single_value_struct {
INTEGER_template field_bitmask;
ExtActionID_template field_actionID;
INTEGER_template field_detectionTime;
INTEGER_template field_validityDuration;
ExtSituationContainer_template field_situation;
INTEGER_template field_relevanceDistance;
INTEGER_template field_relevanceTrafficDirection;
INTEGER_template field_transmissionInterval;
INTEGER_template field_repetitionInterval;
INTEGER_template field_alacarteLength;
ExtAlacarteContainer_template field_alacarte;
};

void ExtUtDenmUpdate_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_bitmask = ANY_VALUE;
single_value->field_actionID = ANY_VALUE;
single_value->field_detectionTime = ANY_VALUE;
single_value->field_validityDuration = ANY_OR_OMIT;
single_value->field_situation = ANY_OR_OMIT;
single_value->field_relevanceDistance = ANY_OR_OMIT;
single_value->field_relevanceTrafficDirection = ANY_OR_OMIT;
single_value->field_transmissionInterval = ANY_OR_OMIT;
single_value->field_repetitionInterval = ANY_OR_OMIT;
single_value->field_alacarteLength = ANY_OR_OMIT;
single_value->field_alacarte = ANY_OR_OMIT;
}
}
}

void ExtUtDenmUpdate_template::copy_value(const ExtUtDenmUpdate& other_value)
{
single_value = new single_value_struct;
if (other_value.bitmask().is_bound()) {
  single_value->field_bitmask = other_value.bitmask();
} else {
  single_value->field_bitmask.clean_up();
}
if (other_value.actionID().is_bound()) {
  single_value->field_actionID = other_value.actionID();
} else {
  single_value->field_actionID.clean_up();
}
if (other_value.detectionTime().is_bound()) {
  single_value->field_detectionTime = other_value.detectionTime();
} else {
  single_value->field_detectionTime.clean_up();
}
if (other_value.validityDuration().is_bound()) {
  if (other_value.validityDuration().ispresent()) single_value->field_validityDuration = other_value.validityDuration()();
  else single_value->field_validityDuration = OMIT_VALUE;
} else {
  single_value->field_validityDuration.clean_up();
}
if (other_value.situation().is_bound()) {
  if (other_value.situation().ispresent()) single_value->field_situation = other_value.situation()();
  else single_value->field_situation = OMIT_VALUE;
} else {
  single_value->field_situation.clean_up();
}
if (other_value.relevanceDistance().is_bound()) {
  if (other_value.relevanceDistance().ispresent()) single_value->field_relevanceDistance = other_value.relevanceDistance()();
  else single_value->field_relevanceDistance = OMIT_VALUE;
} else {
  single_value->field_relevanceDistance.clean_up();
}
if (other_value.relevanceTrafficDirection().is_bound()) {
  if (other_value.relevanceTrafficDirection().ispresent()) single_value->field_relevanceTrafficDirection = other_value.relevanceTrafficDirection()();
  else single_value->field_relevanceTrafficDirection = OMIT_VALUE;
} else {
  single_value->field_relevanceTrafficDirection.clean_up();
}
if (other_value.transmissionInterval().is_bound()) {
  if (other_value.transmissionInterval().ispresent()) single_value->field_transmissionInterval = other_value.transmissionInterval()();
  else single_value->field_transmissionInterval = OMIT_VALUE;
} else {
  single_value->field_transmissionInterval.clean_up();
}
if (other_value.repetitionInterval().is_bound()) {
  if (other_value.repetitionInterval().ispresent()) single_value->field_repetitionInterval = other_value.repetitionInterval()();
  else single_value->field_repetitionInterval = OMIT_VALUE;
} else {
  single_value->field_repetitionInterval.clean_up();
}
if (other_value.alacarteLength().is_bound()) {
  if (other_value.alacarteLength().ispresent()) single_value->field_alacarteLength = other_value.alacarteLength()();
  else single_value->field_alacarteLength = OMIT_VALUE;
} else {
  single_value->field_alacarteLength.clean_up();
}
if (other_value.alacarte().is_bound()) {
  if (other_value.alacarte().ispresent()) single_value->field_alacarte = other_value.alacarte()();
  else single_value->field_alacarte = OMIT_VALUE;
} else {
  single_value->field_alacarte.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtUtDenmUpdate_template::copy_template(const ExtUtDenmUpdate_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.bitmask().get_selection()) {
single_value->field_bitmask = other_value.bitmask();
} else {
single_value->field_bitmask.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.actionID().get_selection()) {
single_value->field_actionID = other_value.actionID();
} else {
single_value->field_actionID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.detectionTime().get_selection()) {
single_value->field_detectionTime = other_value.detectionTime();
} else {
single_value->field_detectionTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.validityDuration().get_selection()) {
single_value->field_validityDuration = other_value.validityDuration();
} else {
single_value->field_validityDuration.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.situation().get_selection()) {
single_value->field_situation = other_value.situation();
} else {
single_value->field_situation.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.relevanceDistance().get_selection()) {
single_value->field_relevanceDistance = other_value.relevanceDistance();
} else {
single_value->field_relevanceDistance.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.relevanceTrafficDirection().get_selection()) {
single_value->field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
} else {
single_value->field_relevanceTrafficDirection.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.transmissionInterval().get_selection()) {
single_value->field_transmissionInterval = other_value.transmissionInterval();
} else {
single_value->field_transmissionInterval.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.repetitionInterval().get_selection()) {
single_value->field_repetitionInterval = other_value.repetitionInterval();
} else {
single_value->field_repetitionInterval.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.alacarteLength().get_selection()) {
single_value->field_alacarteLength = other_value.alacarteLength();
} else {
single_value->field_alacarteLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.alacarte().get_selection()) {
single_value->field_alacarte = other_value.alacarte();
} else {
single_value->field_alacarte.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtUtDenmUpdate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmUpdate.");
break;
}
set_selection(other_value);
}

ExtUtDenmUpdate_template::ExtUtDenmUpdate_template()
{
}

ExtUtDenmUpdate_template::ExtUtDenmUpdate_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtUtDenmUpdate_template::ExtUtDenmUpdate_template(const ExtUtDenmUpdate& other_value)
{
copy_value(other_value);
}

ExtUtDenmUpdate_template::ExtUtDenmUpdate_template(const OPTIONAL<ExtUtDenmUpdate>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtDenmUpdate&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtUtDenmUpdate from an unbound optional field.");
}
}

ExtUtDenmUpdate_template::ExtUtDenmUpdate_template(const ExtUtDenmUpdate_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtUtDenmUpdate_template::~ExtUtDenmUpdate_template()
{
clean_up();
}

ExtUtDenmUpdate_template& ExtUtDenmUpdate_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtUtDenmUpdate_template& ExtUtDenmUpdate_template::operator=(const ExtUtDenmUpdate& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtUtDenmUpdate_template& ExtUtDenmUpdate_template::operator=(const OPTIONAL<ExtUtDenmUpdate>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtDenmUpdate&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtUtDenmUpdate.");
}
return *this;
}

ExtUtDenmUpdate_template& ExtUtDenmUpdate_template::operator=(const ExtUtDenmUpdate_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtUtDenmUpdate_template::match(const ExtUtDenmUpdate& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.bitmask().is_bound()) return FALSE;
if(!single_value->field_bitmask.match(other_value.bitmask(), legacy))return FALSE;
if(!other_value.actionID().is_bound()) return FALSE;
if(!single_value->field_actionID.match(other_value.actionID(), legacy))return FALSE;
if(!other_value.detectionTime().is_bound()) return FALSE;
if(!single_value->field_detectionTime.match(other_value.detectionTime(), legacy))return FALSE;
if(!other_value.validityDuration().is_bound()) return FALSE;
if((other_value.validityDuration().ispresent() ? !single_value->field_validityDuration.match((const INTEGER&)other_value.validityDuration(), legacy) : !single_value->field_validityDuration.match_omit(legacy)))return FALSE;
if(!other_value.situation().is_bound()) return FALSE;
if((other_value.situation().ispresent() ? !single_value->field_situation.match((const ExtSituationContainer&)other_value.situation(), legacy) : !single_value->field_situation.match_omit(legacy)))return FALSE;
if(!other_value.relevanceDistance().is_bound()) return FALSE;
if((other_value.relevanceDistance().ispresent() ? !single_value->field_relevanceDistance.match((const INTEGER&)other_value.relevanceDistance(), legacy) : !single_value->field_relevanceDistance.match_omit(legacy)))return FALSE;
if(!other_value.relevanceTrafficDirection().is_bound()) return FALSE;
if((other_value.relevanceTrafficDirection().ispresent() ? !single_value->field_relevanceTrafficDirection.match((const INTEGER&)other_value.relevanceTrafficDirection(), legacy) : !single_value->field_relevanceTrafficDirection.match_omit(legacy)))return FALSE;
if(!other_value.transmissionInterval().is_bound()) return FALSE;
if((other_value.transmissionInterval().ispresent() ? !single_value->field_transmissionInterval.match((const INTEGER&)other_value.transmissionInterval(), legacy) : !single_value->field_transmissionInterval.match_omit(legacy)))return FALSE;
if(!other_value.repetitionInterval().is_bound()) return FALSE;
if((other_value.repetitionInterval().ispresent() ? !single_value->field_repetitionInterval.match((const INTEGER&)other_value.repetitionInterval(), legacy) : !single_value->field_repetitionInterval.match_omit(legacy)))return FALSE;
if(!other_value.alacarteLength().is_bound()) return FALSE;
if((other_value.alacarteLength().ispresent() ? !single_value->field_alacarteLength.match((const INTEGER&)other_value.alacarteLength(), legacy) : !single_value->field_alacarteLength.match_omit(legacy)))return FALSE;
if(!other_value.alacarte().is_bound()) return FALSE;
if((other_value.alacarte().ispresent() ? !single_value->field_alacarte.match((const ExtAlacarteContainer&)other_value.alacarte(), legacy) : !single_value->field_alacarte.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmUpdate.");
}
return FALSE;
}

boolean ExtUtDenmUpdate_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_bitmask.is_bound()) return TRUE;
if (single_value->field_actionID.is_bound()) return TRUE;
if (single_value->field_detectionTime.is_bound()) return TRUE;
if (single_value->field_validityDuration.is_omit() || single_value->field_validityDuration.is_bound()) return TRUE;
if (single_value->field_situation.is_omit() || single_value->field_situation.is_bound()) return TRUE;
if (single_value->field_relevanceDistance.is_omit() || single_value->field_relevanceDistance.is_bound()) return TRUE;
if (single_value->field_relevanceTrafficDirection.is_omit() || single_value->field_relevanceTrafficDirection.is_bound()) return TRUE;
if (single_value->field_transmissionInterval.is_omit() || single_value->field_transmissionInterval.is_bound()) return TRUE;
if (single_value->field_repetitionInterval.is_omit() || single_value->field_repetitionInterval.is_bound()) return TRUE;
if (single_value->field_alacarteLength.is_omit() || single_value->field_alacarteLength.is_bound()) return TRUE;
if (single_value->field_alacarte.is_omit() || single_value->field_alacarte.is_bound()) return TRUE;
return FALSE;
}

boolean ExtUtDenmUpdate_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_bitmask.is_value()) return FALSE;
if (!single_value->field_actionID.is_value()) return FALSE;
if (!single_value->field_detectionTime.is_value()) return FALSE;
if (!single_value->field_validityDuration.is_omit() && !single_value->field_validityDuration.is_value()) return FALSE;
if (!single_value->field_situation.is_omit() && !single_value->field_situation.is_value()) return FALSE;
if (!single_value->field_relevanceDistance.is_omit() && !single_value->field_relevanceDistance.is_value()) return FALSE;
if (!single_value->field_relevanceTrafficDirection.is_omit() && !single_value->field_relevanceTrafficDirection.is_value()) return FALSE;
if (!single_value->field_transmissionInterval.is_omit() && !single_value->field_transmissionInterval.is_value()) return FALSE;
if (!single_value->field_repetitionInterval.is_omit() && !single_value->field_repetitionInterval.is_value()) return FALSE;
if (!single_value->field_alacarteLength.is_omit() && !single_value->field_alacarteLength.is_value()) return FALSE;
if (!single_value->field_alacarte.is_omit() && !single_value->field_alacarte.is_value()) return FALSE;
return TRUE;
}

void ExtUtDenmUpdate_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtUtDenmUpdate ExtUtDenmUpdate_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
ExtUtDenmUpdate ret_val;
if (single_value->field_bitmask.is_bound()) {
ret_val.bitmask() = single_value->field_bitmask.valueof();
}
if (single_value->field_actionID.is_bound()) {
ret_val.actionID() = single_value->field_actionID.valueof();
}
if (single_value->field_detectionTime.is_bound()) {
ret_val.detectionTime() = single_value->field_detectionTime.valueof();
}
if (single_value->field_validityDuration.is_omit()) ret_val.validityDuration() = OMIT_VALUE;
else if (single_value->field_validityDuration.is_bound()) {
ret_val.validityDuration() = single_value->field_validityDuration.valueof();
}
if (single_value->field_situation.is_omit()) ret_val.situation() = OMIT_VALUE;
else if (single_value->field_situation.is_bound()) {
ret_val.situation() = single_value->field_situation.valueof();
}
if (single_value->field_relevanceDistance.is_omit()) ret_val.relevanceDistance() = OMIT_VALUE;
else if (single_value->field_relevanceDistance.is_bound()) {
ret_val.relevanceDistance() = single_value->field_relevanceDistance.valueof();
}
if (single_value->field_relevanceTrafficDirection.is_omit()) ret_val.relevanceTrafficDirection() = OMIT_VALUE;
else if (single_value->field_relevanceTrafficDirection.is_bound()) {
ret_val.relevanceTrafficDirection() = single_value->field_relevanceTrafficDirection.valueof();
}
if (single_value->field_transmissionInterval.is_omit()) ret_val.transmissionInterval() = OMIT_VALUE;
else if (single_value->field_transmissionInterval.is_bound()) {
ret_val.transmissionInterval() = single_value->field_transmissionInterval.valueof();
}
if (single_value->field_repetitionInterval.is_omit()) ret_val.repetitionInterval() = OMIT_VALUE;
else if (single_value->field_repetitionInterval.is_bound()) {
ret_val.repetitionInterval() = single_value->field_repetitionInterval.valueof();
}
if (single_value->field_alacarteLength.is_omit()) ret_val.alacarteLength() = OMIT_VALUE;
else if (single_value->field_alacarteLength.is_bound()) {
ret_val.alacarteLength() = single_value->field_alacarteLength.valueof();
}
if (single_value->field_alacarte.is_omit()) ret_val.alacarte() = OMIT_VALUE;
else if (single_value->field_alacarte.is_bound()) {
ret_val.alacarte() = single_value->field_alacarte.valueof();
}
return ret_val;
}

void ExtUtDenmUpdate_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtUtDenmUpdate.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtUtDenmUpdate_template[list_length];
}

ExtUtDenmUpdate_template& ExtUtDenmUpdate_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtUtDenmUpdate.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtUtDenmUpdate_template::bitmask()
{
set_specific();
return single_value->field_bitmask;
}

const INTEGER_template& ExtUtDenmUpdate_template::bitmask() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field bitmask of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_bitmask;
}

ExtActionID_template& ExtUtDenmUpdate_template::actionID()
{
set_specific();
return single_value->field_actionID;
}

const ExtActionID_template& ExtUtDenmUpdate_template::actionID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field actionID of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_actionID;
}

INTEGER_template& ExtUtDenmUpdate_template::detectionTime()
{
set_specific();
return single_value->field_detectionTime;
}

const INTEGER_template& ExtUtDenmUpdate_template::detectionTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field detectionTime of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_detectionTime;
}

INTEGER_template& ExtUtDenmUpdate_template::validityDuration()
{
set_specific();
return single_value->field_validityDuration;
}

const INTEGER_template& ExtUtDenmUpdate_template::validityDuration() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field validityDuration of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_validityDuration;
}

ExtSituationContainer_template& ExtUtDenmUpdate_template::situation()
{
set_specific();
return single_value->field_situation;
}

const ExtSituationContainer_template& ExtUtDenmUpdate_template::situation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field situation of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_situation;
}

INTEGER_template& ExtUtDenmUpdate_template::relevanceDistance()
{
set_specific();
return single_value->field_relevanceDistance;
}

const INTEGER_template& ExtUtDenmUpdate_template::relevanceDistance() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field relevanceDistance of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_relevanceDistance;
}

INTEGER_template& ExtUtDenmUpdate_template::relevanceTrafficDirection()
{
set_specific();
return single_value->field_relevanceTrafficDirection;
}

const INTEGER_template& ExtUtDenmUpdate_template::relevanceTrafficDirection() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field relevanceTrafficDirection of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_relevanceTrafficDirection;
}

INTEGER_template& ExtUtDenmUpdate_template::transmissionInterval()
{
set_specific();
return single_value->field_transmissionInterval;
}

const INTEGER_template& ExtUtDenmUpdate_template::transmissionInterval() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field transmissionInterval of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_transmissionInterval;
}

INTEGER_template& ExtUtDenmUpdate_template::repetitionInterval()
{
set_specific();
return single_value->field_repetitionInterval;
}

const INTEGER_template& ExtUtDenmUpdate_template::repetitionInterval() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field repetitionInterval of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_repetitionInterval;
}

INTEGER_template& ExtUtDenmUpdate_template::alacarteLength()
{
set_specific();
return single_value->field_alacarteLength;
}

const INTEGER_template& ExtUtDenmUpdate_template::alacarteLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field alacarteLength of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_alacarteLength;
}

ExtAlacarteContainer_template& ExtUtDenmUpdate_template::alacarte()
{
set_specific();
return single_value->field_alacarte;
}

const ExtAlacarteContainer_template& ExtUtDenmUpdate_template::alacarte() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field alacarte of a non-specific template of type @TTCN_EncDec.ExtUtDenmUpdate.");
return single_value->field_alacarte;
}

int ExtUtDenmUpdate_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmUpdate which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 3;
      if (single_value->field_validityDuration.is_present()) ret_val++;
      if (single_value->field_situation.is_present()) ret_val++;
      if (single_value->field_relevanceDistance.is_present()) ret_val++;
      if (single_value->field_relevanceTrafficDirection.is_present()) ret_val++;
      if (single_value->field_transmissionInterval.is_present()) ret_val++;
      if (single_value->field_repetitionInterval.is_present()) ret_val++;
      if (single_value->field_alacarteLength.is_present()) ret_val++;
      if (single_value->field_alacarte.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmUpdate containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmUpdate containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmUpdate containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmUpdate containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmUpdate containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmUpdate.");
  }
  return 0;
}

void ExtUtDenmUpdate_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ bitmask := ");
single_value->field_bitmask.log();
TTCN_Logger::log_event_str(", actionID := ");
single_value->field_actionID.log();
TTCN_Logger::log_event_str(", detectionTime := ");
single_value->field_detectionTime.log();
TTCN_Logger::log_event_str(", validityDuration := ");
single_value->field_validityDuration.log();
TTCN_Logger::log_event_str(", situation := ");
single_value->field_situation.log();
TTCN_Logger::log_event_str(", relevanceDistance := ");
single_value->field_relevanceDistance.log();
TTCN_Logger::log_event_str(", relevanceTrafficDirection := ");
single_value->field_relevanceTrafficDirection.log();
TTCN_Logger::log_event_str(", transmissionInterval := ");
single_value->field_transmissionInterval.log();
TTCN_Logger::log_event_str(", repetitionInterval := ");
single_value->field_repetitionInterval.log();
TTCN_Logger::log_event_str(", alacarteLength := ");
single_value->field_alacarteLength.log();
TTCN_Logger::log_event_str(", alacarte := ");
single_value->field_alacarte.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtUtDenmUpdate_template::log_match(const ExtUtDenmUpdate& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_bitmask.match(match_value.bitmask(), legacy)){
TTCN_Logger::log_logmatch_info(".bitmask");
single_value->field_bitmask.log_match(match_value.bitmask(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_actionID.match(match_value.actionID(), legacy)){
TTCN_Logger::log_logmatch_info(".actionID");
single_value->field_actionID.log_match(match_value.actionID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_detectionTime.match(match_value.detectionTime(), legacy)){
TTCN_Logger::log_logmatch_info(".detectionTime");
single_value->field_detectionTime.log_match(match_value.detectionTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.validityDuration().ispresent()){
if(!single_value->field_validityDuration.match(match_value.validityDuration(), legacy)){
TTCN_Logger::log_logmatch_info(".validityDuration");
single_value->field_validityDuration.log_match(match_value.validityDuration(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_validityDuration.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".validityDuration := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_validityDuration.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.situation().ispresent()){
if(!single_value->field_situation.match(match_value.situation(), legacy)){
TTCN_Logger::log_logmatch_info(".situation");
single_value->field_situation.log_match(match_value.situation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_situation.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".situation := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_situation.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.relevanceDistance().ispresent()){
if(!single_value->field_relevanceDistance.match(match_value.relevanceDistance(), legacy)){
TTCN_Logger::log_logmatch_info(".relevanceDistance");
single_value->field_relevanceDistance.log_match(match_value.relevanceDistance(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_relevanceDistance.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".relevanceDistance := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_relevanceDistance.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.relevanceTrafficDirection().ispresent()){
if(!single_value->field_relevanceTrafficDirection.match(match_value.relevanceTrafficDirection(), legacy)){
TTCN_Logger::log_logmatch_info(".relevanceTrafficDirection");
single_value->field_relevanceTrafficDirection.log_match(match_value.relevanceTrafficDirection(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_relevanceTrafficDirection.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".relevanceTrafficDirection := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_relevanceTrafficDirection.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.transmissionInterval().ispresent()){
if(!single_value->field_transmissionInterval.match(match_value.transmissionInterval(), legacy)){
TTCN_Logger::log_logmatch_info(".transmissionInterval");
single_value->field_transmissionInterval.log_match(match_value.transmissionInterval(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_transmissionInterval.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".transmissionInterval := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_transmissionInterval.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.repetitionInterval().ispresent()){
if(!single_value->field_repetitionInterval.match(match_value.repetitionInterval(), legacy)){
TTCN_Logger::log_logmatch_info(".repetitionInterval");
single_value->field_repetitionInterval.log_match(match_value.repetitionInterval(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_repetitionInterval.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".repetitionInterval := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_repetitionInterval.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.alacarteLength().ispresent()){
if(!single_value->field_alacarteLength.match(match_value.alacarteLength(), legacy)){
TTCN_Logger::log_logmatch_info(".alacarteLength");
single_value->field_alacarteLength.log_match(match_value.alacarteLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_alacarteLength.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".alacarteLength := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_alacarteLength.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.alacarte().ispresent()){
if(!single_value->field_alacarte.match(match_value.alacarte(), legacy)){
TTCN_Logger::log_logmatch_info(".alacarte");
single_value->field_alacarte.log_match(match_value.alacarte(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_alacarte.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".alacarte := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_alacarte.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ bitmask := ");
single_value->field_bitmask.log_match(match_value.bitmask(), legacy);
TTCN_Logger::log_event_str(", actionID := ");
single_value->field_actionID.log_match(match_value.actionID(), legacy);
TTCN_Logger::log_event_str(", detectionTime := ");
single_value->field_detectionTime.log_match(match_value.detectionTime(), legacy);
TTCN_Logger::log_event_str(", validityDuration := ");
if (match_value.validityDuration().ispresent()) single_value->field_validityDuration.log_match(match_value.validityDuration(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_validityDuration.log();
if (single_value->field_validityDuration.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", situation := ");
if (match_value.situation().ispresent()) single_value->field_situation.log_match(match_value.situation(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_situation.log();
if (single_value->field_situation.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", relevanceDistance := ");
if (match_value.relevanceDistance().ispresent()) single_value->field_relevanceDistance.log_match(match_value.relevanceDistance(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_relevanceDistance.log();
if (single_value->field_relevanceDistance.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", relevanceTrafficDirection := ");
if (match_value.relevanceTrafficDirection().ispresent()) single_value->field_relevanceTrafficDirection.log_match(match_value.relevanceTrafficDirection(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_relevanceTrafficDirection.log();
if (single_value->field_relevanceTrafficDirection.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", transmissionInterval := ");
if (match_value.transmissionInterval().ispresent()) single_value->field_transmissionInterval.log_match(match_value.transmissionInterval(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_transmissionInterval.log();
if (single_value->field_transmissionInterval.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", repetitionInterval := ");
if (match_value.repetitionInterval().ispresent()) single_value->field_repetitionInterval.log_match(match_value.repetitionInterval(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_repetitionInterval.log();
if (single_value->field_repetitionInterval.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", alacarteLength := ");
if (match_value.alacarteLength().ispresent()) single_value->field_alacarteLength.log_match(match_value.alacarteLength(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_alacarteLength.log();
if (single_value->field_alacarteLength.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", alacarte := ");
if (match_value.alacarte().ispresent()) single_value->field_alacarte.log_match(match_value.alacarte(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_alacarte.log();
if (single_value->field_alacarte.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtUtDenmUpdate_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_bitmask.encode_text(text_buf);
single_value->field_actionID.encode_text(text_buf);
single_value->field_detectionTime.encode_text(text_buf);
single_value->field_validityDuration.encode_text(text_buf);
single_value->field_situation.encode_text(text_buf);
single_value->field_relevanceDistance.encode_text(text_buf);
single_value->field_relevanceTrafficDirection.encode_text(text_buf);
single_value->field_transmissionInterval.encode_text(text_buf);
single_value->field_repetitionInterval.encode_text(text_buf);
single_value->field_alacarteLength.encode_text(text_buf);
single_value->field_alacarte.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmUpdate.");
}
}

void ExtUtDenmUpdate_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_bitmask.decode_text(text_buf);
single_value->field_actionID.decode_text(text_buf);
single_value->field_detectionTime.decode_text(text_buf);
single_value->field_validityDuration.decode_text(text_buf);
single_value->field_situation.decode_text(text_buf);
single_value->field_relevanceDistance.decode_text(text_buf);
single_value->field_relevanceTrafficDirection.decode_text(text_buf);
single_value->field_transmissionInterval.decode_text(text_buf);
single_value->field_repetitionInterval.decode_text(text_buf);
single_value->field_alacarteLength.decode_text(text_buf);
single_value->field_alacarte.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtUtDenmUpdate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtUtDenmUpdate.");
}
}

void ExtUtDenmUpdate_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtUtDenmUpdate'");
    }
    if (strcmp("bitmask", param_field) == 0) {
      bitmask().set_param(param);
      return;
    } else if (strcmp("actionID", param_field) == 0) {
      actionID().set_param(param);
      return;
    } else if (strcmp("detectionTime", param_field) == 0) {
      detectionTime().set_param(param);
      return;
    } else if (strcmp("validityDuration", param_field) == 0) {
      validityDuration().set_param(param);
      return;
    } else if (strcmp("situation", param_field) == 0) {
      situation().set_param(param);
      return;
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      relevanceDistance().set_param(param);
      return;
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      relevanceTrafficDirection().set_param(param);
      return;
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      transmissionInterval().set_param(param);
      return;
    } else if (strcmp("repetitionInterval", param_field) == 0) {
      repetitionInterval().set_param(param);
      return;
    } else if (strcmp("alacarteLength", param_field) == 0) {
      alacarteLength().set_param(param);
      return;
    } else if (strcmp("alacarte", param_field) == 0) {
      alacarte().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtUtDenmUpdate'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtUtDenmUpdate_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (11<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtUtDenmUpdate has 11 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) bitmask().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) actionID().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) detectionTime().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) validityDuration().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) situation().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) relevanceDistance().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) relevanceTrafficDirection().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) transmissionInterval().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) repetitionInterval().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) alacarteLength().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) alacarte().set_param(*mp->get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "bitmask")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          bitmask().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "actionID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          actionID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "detectionTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          detectionTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validityDuration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validityDuration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "situation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          situation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceDistance")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceDistance().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceTrafficDirection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceTrafficDirection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transmissionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transmissionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "repetitionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          repetitionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarteLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarteLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarte")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarte().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtDenmUpdate: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtUtDenmUpdate");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtUtDenmUpdate_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtUtDenmUpdate'");
    }
    if (strcmp("bitmask", param_field) == 0) {
      return bitmask().get_param(param_name);
    } else if (strcmp("actionID", param_field) == 0) {
      return actionID().get_param(param_name);
    } else if (strcmp("detectionTime", param_field) == 0) {
      return detectionTime().get_param(param_name);
    } else if (strcmp("validityDuration", param_field) == 0) {
      return validityDuration().get_param(param_name);
    } else if (strcmp("situation", param_field) == 0) {
      return situation().get_param(param_name);
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      return relevanceDistance().get_param(param_name);
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      return relevanceTrafficDirection().get_param(param_name);
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      return transmissionInterval().get_param(param_name);
    } else if (strcmp("repetitionInterval", param_field) == 0) {
      return repetitionInterval().get_param(param_name);
    } else if (strcmp("alacarteLength", param_field) == 0) {
      return alacarteLength().get_param(param_name);
    } else if (strcmp("alacarte", param_field) == 0) {
      return alacarte().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtDenmUpdate'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_bitmask = single_value->field_bitmask.get_param(param_name);
    mp_field_bitmask->set_id(new Module_Param_FieldName(mcopystr("bitmask")));
    mp->add_elem(mp_field_bitmask);
    Module_Param* mp_field_actionID = single_value->field_actionID.get_param(param_name);
    mp_field_actionID->set_id(new Module_Param_FieldName(mcopystr("actionID")));
    mp->add_elem(mp_field_actionID);
    Module_Param* mp_field_detectionTime = single_value->field_detectionTime.get_param(param_name);
    mp_field_detectionTime->set_id(new Module_Param_FieldName(mcopystr("detectionTime")));
    mp->add_elem(mp_field_detectionTime);
    Module_Param* mp_field_validityDuration = single_value->field_validityDuration.get_param(param_name);
    mp_field_validityDuration->set_id(new Module_Param_FieldName(mcopystr("validityDuration")));
    mp->add_elem(mp_field_validityDuration);
    Module_Param* mp_field_situation = single_value->field_situation.get_param(param_name);
    mp_field_situation->set_id(new Module_Param_FieldName(mcopystr("situation")));
    mp->add_elem(mp_field_situation);
    Module_Param* mp_field_relevanceDistance = single_value->field_relevanceDistance.get_param(param_name);
    mp_field_relevanceDistance->set_id(new Module_Param_FieldName(mcopystr("relevanceDistance")));
    mp->add_elem(mp_field_relevanceDistance);
    Module_Param* mp_field_relevanceTrafficDirection = single_value->field_relevanceTrafficDirection.get_param(param_name);
    mp_field_relevanceTrafficDirection->set_id(new Module_Param_FieldName(mcopystr("relevanceTrafficDirection")));
    mp->add_elem(mp_field_relevanceTrafficDirection);
    Module_Param* mp_field_transmissionInterval = single_value->field_transmissionInterval.get_param(param_name);
    mp_field_transmissionInterval->set_id(new Module_Param_FieldName(mcopystr("transmissionInterval")));
    mp->add_elem(mp_field_transmissionInterval);
    Module_Param* mp_field_repetitionInterval = single_value->field_repetitionInterval.get_param(param_name);
    mp_field_repetitionInterval->set_id(new Module_Param_FieldName(mcopystr("repetitionInterval")));
    mp->add_elem(mp_field_repetitionInterval);
    Module_Param* mp_field_alacarteLength = single_value->field_alacarteLength.get_param(param_name);
    mp_field_alacarteLength->set_id(new Module_Param_FieldName(mcopystr("alacarteLength")));
    mp->add_elem(mp_field_alacarteLength);
    Module_Param* mp_field_alacarte = single_value->field_alacarte.get_param(param_name);
    mp_field_alacarte->set_id(new Module_Param_FieldName(mcopystr("alacarte")));
    mp->add_elem(mp_field_alacarte);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtUtDenmUpdate_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_bitmask.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_actionID.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_detectionTime.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_validityDuration.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_situation.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_relevanceDistance.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_relevanceTrafficDirection.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_transmissionInterval.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_repetitionInterval.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_alacarteLength.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
single_value->field_alacarte.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtUtDenmUpdate");
}

boolean ExtUtDenmUpdate_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtUtDenmUpdate_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtDenmInd::ExtDenmInd()
{
  bound_flag = FALSE;
}

ExtDenmInd::ExtDenmInd(const INTEGER& par_gnNextHeader,
    const INTEGER& par_gnHeaderType,
    const INTEGER& par_gnHeaderSubtype,
    const INTEGER& par_gnLifetime,
    const INTEGER& par_gnTrafficClass,
    const INTEGER& par_btpDestinationPort,
    const INTEGER& par_btpInfo)
  :   field_gnNextHeader(par_gnNextHeader),
  field_gnHeaderType(par_gnHeaderType),
  field_gnHeaderSubtype(par_gnHeaderSubtype),
  field_gnLifetime(par_gnLifetime),
  field_gnTrafficClass(par_gnTrafficClass),
  field_btpDestinationPort(par_btpDestinationPort),
  field_btpInfo(par_btpInfo)
{
  bound_flag = TRUE;
}

ExtDenmInd::ExtDenmInd(const ExtDenmInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtDenmInd.");
bound_flag = TRUE;
if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
else field_gnNextHeader.clean_up();
if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
else field_gnHeaderType.clean_up();
if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
else field_gnHeaderSubtype.clean_up();
if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
else field_gnLifetime.clean_up();
if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
else field_gnTrafficClass.clean_up();
if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
else field_btpDestinationPort.clean_up();
if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
else field_btpInfo.clean_up();
}

void ExtDenmInd::clean_up()
{
field_gnNextHeader.clean_up();
field_gnHeaderType.clean_up();
field_gnHeaderSubtype.clean_up();
field_gnLifetime.clean_up();
field_gnTrafficClass.clean_up();
field_btpDestinationPort.clean_up();
field_btpInfo.clean_up();
bound_flag = FALSE;
}

ExtDenmInd& ExtDenmInd::operator=(const ExtDenmInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtDenmInd.");
  bound_flag = TRUE;
  if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
  else field_gnNextHeader.clean_up();
  if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
  else field_gnHeaderType.clean_up();
  if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
  else field_gnHeaderSubtype.clean_up();
  if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
  else field_gnLifetime.clean_up();
  if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
  else field_gnTrafficClass.clean_up();
  if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
  else field_btpDestinationPort.clean_up();
  if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
  else field_btpInfo.clean_up();
}
return *this;
}

boolean ExtDenmInd::operator==(const ExtDenmInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_gnNextHeader==other_value.field_gnNextHeader
  && field_gnHeaderType==other_value.field_gnHeaderType
  && field_gnHeaderSubtype==other_value.field_gnHeaderSubtype
  && field_gnLifetime==other_value.field_gnLifetime
  && field_gnTrafficClass==other_value.field_gnTrafficClass
  && field_btpDestinationPort==other_value.field_btpDestinationPort
  && field_btpInfo==other_value.field_btpInfo;
}

boolean ExtDenmInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_gnNextHeader.is_bound()) return TRUE;
if(field_gnHeaderType.is_bound()) return TRUE;
if(field_gnHeaderSubtype.is_bound()) return TRUE;
if(field_gnLifetime.is_bound()) return TRUE;
if(field_gnTrafficClass.is_bound()) return TRUE;
if(field_btpDestinationPort.is_bound()) return TRUE;
if(field_btpInfo.is_bound()) return TRUE;
return FALSE;
}
boolean ExtDenmInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_gnNextHeader.is_value()) return FALSE;
if(!field_gnHeaderType.is_value()) return FALSE;
if(!field_gnHeaderSubtype.is_value()) return FALSE;
if(!field_gnLifetime.is_value()) return FALSE;
if(!field_gnTrafficClass.is_value()) return FALSE;
if(!field_btpDestinationPort.is_value()) return FALSE;
if(!field_btpInfo.is_value()) return FALSE;
return TRUE;
}
int ExtDenmInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtDenmInd");
  return 7;
}

void ExtDenmInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ gnNextHeader := ");
field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
}

void ExtDenmInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtDenmInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtDenmInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtDenmInd has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtDenmInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtDenmInd");
  }
}

Module_Param* ExtDenmInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtDenmInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtDenmInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_gnNextHeader = field_gnNextHeader.get_param(param_name);
  mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
  mp->add_elem(mp_field_gnNextHeader);
  Module_Param* mp_field_gnHeaderType = field_gnHeaderType.get_param(param_name);
  mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
  mp->add_elem(mp_field_gnHeaderType);
  Module_Param* mp_field_gnHeaderSubtype = field_gnHeaderSubtype.get_param(param_name);
  mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
  mp->add_elem(mp_field_gnHeaderSubtype);
  Module_Param* mp_field_gnLifetime = field_gnLifetime.get_param(param_name);
  mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
  mp->add_elem(mp_field_gnLifetime);
  Module_Param* mp_field_gnTrafficClass = field_gnTrafficClass.get_param(param_name);
  mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
  mp->add_elem(mp_field_gnTrafficClass);
  Module_Param* mp_field_btpDestinationPort = field_btpDestinationPort.get_param(param_name);
  mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
  mp->add_elem(mp_field_btpDestinationPort);
  Module_Param* mp_field_btpInfo = field_btpInfo.get_param(param_name);
  mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
  mp->add_elem(mp_field_btpInfo);
  return mp;
  }

void ExtDenmInd::set_implicit_omit()
{
if (gnNextHeader().is_bound()) gnNextHeader().set_implicit_omit();
if (gnHeaderType().is_bound()) gnHeaderType().set_implicit_omit();
if (gnHeaderSubtype().is_bound()) gnHeaderSubtype().set_implicit_omit();
if (gnLifetime().is_bound()) gnLifetime().set_implicit_omit();
if (gnTrafficClass().is_bound()) gnTrafficClass().set_implicit_omit();
if (btpDestinationPort().is_bound()) btpDestinationPort().set_implicit_omit();
if (btpInfo().is_bound()) btpInfo().set_implicit_omit();
}

void ExtDenmInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtDenmInd.");
field_gnNextHeader.encode_text(text_buf);
field_gnHeaderType.encode_text(text_buf);
field_gnHeaderSubtype.encode_text(text_buf);
field_gnLifetime.encode_text(text_buf);
field_gnTrafficClass.encode_text(text_buf);
field_btpDestinationPort.encode_text(text_buf);
field_btpInfo.encode_text(text_buf);
}

void ExtDenmInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_gnNextHeader.decode_text(text_buf);
field_gnHeaderType.decode_text(text_buf);
field_gnHeaderSubtype.decode_text(text_buf);
field_gnLifetime.decode_text(text_buf);
field_gnTrafficClass.decode_text(text_buf);
field_btpDestinationPort.decode_text(text_buf);
field_btpInfo.decode_text(text_buf);
}

void ExtDenmInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtDenmInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtDenmInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_gnNextHeader.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnHeaderType.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnHeaderSubtype.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnLifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnTrafficClass.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_btpDestinationPort.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_btpInfo.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtDenmInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_gnNextHeader.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_gnHeaderType.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_gnHeaderSubtype.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_gnLifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_gnTrafficClass.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_btpDestinationPort.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_btpInfo.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[6]);
  return myleaf.length = encoded_length;
}

int ExtDenmInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtDenmInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnNextHeader");
    enc_len += field_gnNextHeader.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnHeaderType");
    enc_len += field_gnHeaderType.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnHeaderSubtype");
    enc_len += field_gnHeaderSubtype.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnLifetime");
    enc_len += field_gnLifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnTrafficClass");
    enc_len += field_gnTrafficClass.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpDestinationPort");
    enc_len += field_btpDestinationPort.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpInfo");
    enc_len += field_btpInfo.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtDenmInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "gnNextHeader", name_len)) {
         int ret_val = field_gnNextHeader.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnNextHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "gnHeaderType", name_len)) {
         int ret_val = field_gnHeaderType.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnHeaderType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "gnHeaderSubtype", name_len)) {
         int ret_val = field_gnHeaderSubtype.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnHeaderSubtype");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "gnLifetime", name_len)) {
         int ret_val = field_gnLifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnLifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "gnTrafficClass", name_len)) {
         int ret_val = field_gnTrafficClass.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnTrafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "btpDestinationPort", name_len)) {
         int ret_val = field_btpDestinationPort.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpDestinationPort");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "btpInfo", name_len)) {
         int ret_val = field_btpInfo.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpInfo");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_gnNextHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnNextHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_gnHeaderType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnHeaderType");
    return JSON_ERROR_FATAL;
  }
if (!field_gnHeaderSubtype.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnHeaderSubtype");
    return JSON_ERROR_FATAL;
  }
if (!field_gnLifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnLifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_gnTrafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnTrafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_btpDestinationPort.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpDestinationPort");
    return JSON_ERROR_FATAL;
  }
if (!field_btpInfo.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpInfo");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtDenmInd_template::single_value_struct {
INTEGER_template field_gnNextHeader;
INTEGER_template field_gnHeaderType;
INTEGER_template field_gnHeaderSubtype;
INTEGER_template field_gnLifetime;
INTEGER_template field_gnTrafficClass;
INTEGER_template field_btpDestinationPort;
INTEGER_template field_btpInfo;
};

void ExtDenmInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_gnNextHeader = ANY_VALUE;
single_value->field_gnHeaderType = ANY_VALUE;
single_value->field_gnHeaderSubtype = ANY_VALUE;
single_value->field_gnLifetime = ANY_VALUE;
single_value->field_gnTrafficClass = ANY_VALUE;
single_value->field_btpDestinationPort = ANY_VALUE;
single_value->field_btpInfo = ANY_VALUE;
}
}
}

void ExtDenmInd_template::copy_value(const ExtDenmInd& other_value)
{
single_value = new single_value_struct;
if (other_value.gnNextHeader().is_bound()) {
  single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
  single_value->field_gnNextHeader.clean_up();
}
if (other_value.gnHeaderType().is_bound()) {
  single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
  single_value->field_gnHeaderType.clean_up();
}
if (other_value.gnHeaderSubtype().is_bound()) {
  single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
  single_value->field_gnHeaderSubtype.clean_up();
}
if (other_value.gnLifetime().is_bound()) {
  single_value->field_gnLifetime = other_value.gnLifetime();
} else {
  single_value->field_gnLifetime.clean_up();
}
if (other_value.gnTrafficClass().is_bound()) {
  single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
  single_value->field_gnTrafficClass.clean_up();
}
if (other_value.btpDestinationPort().is_bound()) {
  single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
  single_value->field_btpDestinationPort.clean_up();
}
if (other_value.btpInfo().is_bound()) {
  single_value->field_btpInfo = other_value.btpInfo();
} else {
  single_value->field_btpInfo.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtDenmInd_template::copy_template(const ExtDenmInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.gnNextHeader().get_selection()) {
single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
single_value->field_gnNextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderType().get_selection()) {
single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
single_value->field_gnHeaderType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderSubtype().get_selection()) {
single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
single_value->field_gnHeaderSubtype.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnLifetime().get_selection()) {
single_value->field_gnLifetime = other_value.gnLifetime();
} else {
single_value->field_gnLifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnTrafficClass().get_selection()) {
single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
single_value->field_gnTrafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpDestinationPort().get_selection()) {
single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
single_value->field_btpDestinationPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpInfo().get_selection()) {
single_value->field_btpInfo = other_value.btpInfo();
} else {
single_value->field_btpInfo.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtDenmInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtDenmInd.");
break;
}
set_selection(other_value);
}

ExtDenmInd_template::ExtDenmInd_template()
{
}

ExtDenmInd_template::ExtDenmInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtDenmInd_template::ExtDenmInd_template(const ExtDenmInd& other_value)
{
copy_value(other_value);
}

ExtDenmInd_template::ExtDenmInd_template(const OPTIONAL<ExtDenmInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtDenmInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtDenmInd from an unbound optional field.");
}
}

ExtDenmInd_template::ExtDenmInd_template(const ExtDenmInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtDenmInd_template::~ExtDenmInd_template()
{
clean_up();
}

ExtDenmInd_template& ExtDenmInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtDenmInd_template& ExtDenmInd_template::operator=(const ExtDenmInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtDenmInd_template& ExtDenmInd_template::operator=(const OPTIONAL<ExtDenmInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtDenmInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtDenmInd.");
}
return *this;
}

ExtDenmInd_template& ExtDenmInd_template::operator=(const ExtDenmInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtDenmInd_template::match(const ExtDenmInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.gnNextHeader().is_bound()) return FALSE;
if(!single_value->field_gnNextHeader.match(other_value.gnNextHeader(), legacy))return FALSE;
if(!other_value.gnHeaderType().is_bound()) return FALSE;
if(!single_value->field_gnHeaderType.match(other_value.gnHeaderType(), legacy))return FALSE;
if(!other_value.gnHeaderSubtype().is_bound()) return FALSE;
if(!single_value->field_gnHeaderSubtype.match(other_value.gnHeaderSubtype(), legacy))return FALSE;
if(!other_value.gnLifetime().is_bound()) return FALSE;
if(!single_value->field_gnLifetime.match(other_value.gnLifetime(), legacy))return FALSE;
if(!other_value.gnTrafficClass().is_bound()) return FALSE;
if(!single_value->field_gnTrafficClass.match(other_value.gnTrafficClass(), legacy))return FALSE;
if(!other_value.btpDestinationPort().is_bound()) return FALSE;
if(!single_value->field_btpDestinationPort.match(other_value.btpDestinationPort(), legacy))return FALSE;
if(!other_value.btpInfo().is_bound()) return FALSE;
if(!single_value->field_btpInfo.match(other_value.btpInfo(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtDenmInd.");
}
return FALSE;
}

boolean ExtDenmInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_gnNextHeader.is_bound()) return TRUE;
if (single_value->field_gnHeaderType.is_bound()) return TRUE;
if (single_value->field_gnHeaderSubtype.is_bound()) return TRUE;
if (single_value->field_gnLifetime.is_bound()) return TRUE;
if (single_value->field_gnTrafficClass.is_bound()) return TRUE;
if (single_value->field_btpDestinationPort.is_bound()) return TRUE;
if (single_value->field_btpInfo.is_bound()) return TRUE;
return FALSE;
}

boolean ExtDenmInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_gnNextHeader.is_value()) return FALSE;
if (!single_value->field_gnHeaderType.is_value()) return FALSE;
if (!single_value->field_gnHeaderSubtype.is_value()) return FALSE;
if (!single_value->field_gnLifetime.is_value()) return FALSE;
if (!single_value->field_gnTrafficClass.is_value()) return FALSE;
if (!single_value->field_btpDestinationPort.is_value()) return FALSE;
if (!single_value->field_btpInfo.is_value()) return FALSE;
return TRUE;
}

void ExtDenmInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtDenmInd ExtDenmInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtDenmInd.");
ExtDenmInd ret_val;
if (single_value->field_gnNextHeader.is_bound()) {
ret_val.gnNextHeader() = single_value->field_gnNextHeader.valueof();
}
if (single_value->field_gnHeaderType.is_bound()) {
ret_val.gnHeaderType() = single_value->field_gnHeaderType.valueof();
}
if (single_value->field_gnHeaderSubtype.is_bound()) {
ret_val.gnHeaderSubtype() = single_value->field_gnHeaderSubtype.valueof();
}
if (single_value->field_gnLifetime.is_bound()) {
ret_val.gnLifetime() = single_value->field_gnLifetime.valueof();
}
if (single_value->field_gnTrafficClass.is_bound()) {
ret_val.gnTrafficClass() = single_value->field_gnTrafficClass.valueof();
}
if (single_value->field_btpDestinationPort.is_bound()) {
ret_val.btpDestinationPort() = single_value->field_btpDestinationPort.valueof();
}
if (single_value->field_btpInfo.is_bound()) {
ret_val.btpInfo() = single_value->field_btpInfo.valueof();
}
return ret_val;
}

void ExtDenmInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtDenmInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtDenmInd_template[list_length];
}

ExtDenmInd_template& ExtDenmInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtDenmInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtDenmInd.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtDenmInd_template::gnNextHeader()
{
set_specific();
return single_value->field_gnNextHeader;
}

const INTEGER_template& ExtDenmInd_template::gnNextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnNextHeader of a non-specific template of type @TTCN_EncDec.ExtDenmInd.");
return single_value->field_gnNextHeader;
}

INTEGER_template& ExtDenmInd_template::gnHeaderType()
{
set_specific();
return single_value->field_gnHeaderType;
}

const INTEGER_template& ExtDenmInd_template::gnHeaderType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderType of a non-specific template of type @TTCN_EncDec.ExtDenmInd.");
return single_value->field_gnHeaderType;
}

INTEGER_template& ExtDenmInd_template::gnHeaderSubtype()
{
set_specific();
return single_value->field_gnHeaderSubtype;
}

const INTEGER_template& ExtDenmInd_template::gnHeaderSubtype() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderSubtype of a non-specific template of type @TTCN_EncDec.ExtDenmInd.");
return single_value->field_gnHeaderSubtype;
}

INTEGER_template& ExtDenmInd_template::gnLifetime()
{
set_specific();
return single_value->field_gnLifetime;
}

const INTEGER_template& ExtDenmInd_template::gnLifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnLifetime of a non-specific template of type @TTCN_EncDec.ExtDenmInd.");
return single_value->field_gnLifetime;
}

INTEGER_template& ExtDenmInd_template::gnTrafficClass()
{
set_specific();
return single_value->field_gnTrafficClass;
}

const INTEGER_template& ExtDenmInd_template::gnTrafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnTrafficClass of a non-specific template of type @TTCN_EncDec.ExtDenmInd.");
return single_value->field_gnTrafficClass;
}

INTEGER_template& ExtDenmInd_template::btpDestinationPort()
{
set_specific();
return single_value->field_btpDestinationPort;
}

const INTEGER_template& ExtDenmInd_template::btpDestinationPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpDestinationPort of a non-specific template of type @TTCN_EncDec.ExtDenmInd.");
return single_value->field_btpDestinationPort;
}

INTEGER_template& ExtDenmInd_template::btpInfo()
{
set_specific();
return single_value->field_btpInfo;
}

const INTEGER_template& ExtDenmInd_template::btpInfo() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpInfo of a non-specific template of type @TTCN_EncDec.ExtDenmInd.");
return single_value->field_btpInfo;
}

int ExtDenmInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtDenmInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 7;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtDenmInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtDenmInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtDenmInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtDenmInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtDenmInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtDenmInd.");
  }
  return 0;
}

void ExtDenmInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ gnNextHeader := ");
single_value->field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtDenmInd_template::log_match(const ExtDenmInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_gnNextHeader.match(match_value.gnNextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".gnNextHeader");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnHeaderType.match(match_value.gnHeaderType(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderType");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnHeaderSubtype.match(match_value.gnHeaderSubtype(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderSubtype");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnLifetime.match(match_value.gnLifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".gnLifetime");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnTrafficClass.match(match_value.gnTrafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".gnTrafficClass");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_btpDestinationPort.match(match_value.btpDestinationPort(), legacy)){
TTCN_Logger::log_logmatch_info(".btpDestinationPort");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_btpInfo.match(match_value.btpInfo(), legacy)){
TTCN_Logger::log_logmatch_info(".btpInfo");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ gnNextHeader := ");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtDenmInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_gnNextHeader.encode_text(text_buf);
single_value->field_gnHeaderType.encode_text(text_buf);
single_value->field_gnHeaderSubtype.encode_text(text_buf);
single_value->field_gnLifetime.encode_text(text_buf);
single_value->field_gnTrafficClass.encode_text(text_buf);
single_value->field_btpDestinationPort.encode_text(text_buf);
single_value->field_btpInfo.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtDenmInd.");
}
}

void ExtDenmInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_gnNextHeader.decode_text(text_buf);
single_value->field_gnHeaderType.decode_text(text_buf);
single_value->field_gnHeaderSubtype.decode_text(text_buf);
single_value->field_gnLifetime.decode_text(text_buf);
single_value->field_gnTrafficClass.decode_text(text_buf);
single_value->field_btpDestinationPort.decode_text(text_buf);
single_value->field_btpInfo.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtDenmInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtDenmInd.");
}
}

void ExtDenmInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtDenmInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtDenmInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtDenmInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtDenmInd has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtDenmInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtDenmInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtDenmInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtDenmInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtDenmInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_gnNextHeader = single_value->field_gnNextHeader.get_param(param_name);
    mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
    mp->add_elem(mp_field_gnNextHeader);
    Module_Param* mp_field_gnHeaderType = single_value->field_gnHeaderType.get_param(param_name);
    mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
    mp->add_elem(mp_field_gnHeaderType);
    Module_Param* mp_field_gnHeaderSubtype = single_value->field_gnHeaderSubtype.get_param(param_name);
    mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
    mp->add_elem(mp_field_gnHeaderSubtype);
    Module_Param* mp_field_gnLifetime = single_value->field_gnLifetime.get_param(param_name);
    mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
    mp->add_elem(mp_field_gnLifetime);
    Module_Param* mp_field_gnTrafficClass = single_value->field_gnTrafficClass.get_param(param_name);
    mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
    mp->add_elem(mp_field_gnTrafficClass);
    Module_Param* mp_field_btpDestinationPort = single_value->field_btpDestinationPort.get_param(param_name);
    mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
    mp->add_elem(mp_field_btpDestinationPort);
    Module_Param* mp_field_btpInfo = single_value->field_btpInfo.get_param(param_name);
    mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
    mp->add_elem(mp_field_btpInfo);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtDenmInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_gnNextHeader.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtDenmInd");
single_value->field_gnHeaderType.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtDenmInd");
single_value->field_gnHeaderSubtype.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtDenmInd");
single_value->field_gnLifetime.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtDenmInd");
single_value->field_gnTrafficClass.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtDenmInd");
single_value->field_btpDestinationPort.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtDenmInd");
single_value->field_btpInfo.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtDenmInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtDenmInd");
}

boolean ExtDenmInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtDenmInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtUtDenmEventInd::ExtUtDenmEventInd()
{
  bound_flag = FALSE;
}

ExtUtDenmEventInd::ExtUtDenmEventInd(const INTEGER& par_denmPduLength,
    const OCTETSTRING& par_denMsg)
  :   field_denmPduLength(par_denmPduLength),
  field_denMsg(par_denMsg)
{
  bound_flag = TRUE;
}

ExtUtDenmEventInd::ExtUtDenmEventInd(const ExtUtDenmEventInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtUtDenmEventInd.");
bound_flag = TRUE;
if (other_value.denmPduLength().is_bound()) field_denmPduLength = other_value.denmPduLength();
else field_denmPduLength.clean_up();
if (other_value.denMsg().is_bound()) field_denMsg = other_value.denMsg();
else field_denMsg.clean_up();
}

void ExtUtDenmEventInd::clean_up()
{
field_denmPduLength.clean_up();
field_denMsg.clean_up();
bound_flag = FALSE;
}

ExtUtDenmEventInd& ExtUtDenmEventInd::operator=(const ExtUtDenmEventInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtUtDenmEventInd.");
  bound_flag = TRUE;
  if (other_value.denmPduLength().is_bound()) field_denmPduLength = other_value.denmPduLength();
  else field_denmPduLength.clean_up();
  if (other_value.denMsg().is_bound()) field_denMsg = other_value.denMsg();
  else field_denMsg.clean_up();
}
return *this;
}

boolean ExtUtDenmEventInd::operator==(const ExtUtDenmEventInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_denmPduLength==other_value.field_denmPduLength
  && field_denMsg==other_value.field_denMsg;
}

boolean ExtUtDenmEventInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_denmPduLength.is_bound()) return TRUE;
if(field_denMsg.is_bound()) return TRUE;
return FALSE;
}
boolean ExtUtDenmEventInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_denmPduLength.is_value()) return FALSE;
if(!field_denMsg.is_value()) return FALSE;
return TRUE;
}
int ExtUtDenmEventInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtUtDenmEventInd");
  return 2;
}

void ExtUtDenmEventInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ denmPduLength := ");
field_denmPduLength.log();
TTCN_Logger::log_event_str(", denMsg := ");
field_denMsg.log();
TTCN_Logger::log_event_str(" }");
}

void ExtUtDenmEventInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtUtDenmEventInd'");
    }
    if (strcmp("denmPduLength", param_field) == 0) {
      denmPduLength().set_param(param);
      return;
    } else if (strcmp("denMsg", param_field) == 0) {
      denMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtDenmEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtUtDenmEventInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) denmPduLength().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) denMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "denmPduLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          denmPduLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "denMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          denMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtDenmEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtUtDenmEventInd");
  }
}

Module_Param* ExtUtDenmEventInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtUtDenmEventInd'");
    }
    if (strcmp("denmPduLength", param_field) == 0) {
      return denmPduLength().get_param(param_name);
    } else if (strcmp("denMsg", param_field) == 0) {
      return denMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtDenmEventInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_denmPduLength = field_denmPduLength.get_param(param_name);
  mp_field_denmPduLength->set_id(new Module_Param_FieldName(mcopystr("denmPduLength")));
  mp->add_elem(mp_field_denmPduLength);
  Module_Param* mp_field_denMsg = field_denMsg.get_param(param_name);
  mp_field_denMsg->set_id(new Module_Param_FieldName(mcopystr("denMsg")));
  mp->add_elem(mp_field_denMsg);
  return mp;
  }

void ExtUtDenmEventInd::set_implicit_omit()
{
if (denmPduLength().is_bound()) denmPduLength().set_implicit_omit();
if (denMsg().is_bound()) denMsg().set_implicit_omit();
}

void ExtUtDenmEventInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtUtDenmEventInd.");
field_denmPduLength.encode_text(text_buf);
field_denMsg.encode_text(text_buf);
}

void ExtUtDenmEventInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_denmPduLength.decode_text(text_buf);
field_denMsg.decode_text(text_buf);
}

void ExtUtDenmEventInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtUtDenmEventInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtUtDenmEventInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  int value_of_length_field0 = 0;
  decoded_field_length = field_denmPduLength.RAW_decode(ExtUtDenmEventInd_denmPduLength_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field0+=(int)field_denmPduLength*8;
  decoded_field_length = field_denMsg.RAW_decode(OCTETSTRING_descr_, p_buf, min_of_ints(2, limit, value_of_length_field0), local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field0 -= decoded_field_length;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtUtDenmEventInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ExtUtDenmEventInd_denmPduLength_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, OCTETSTRING_descr_.raw);
  encoded_length += 16;
  myleaf.body.node.nodes[0]->calc = CALC_LENGTH;
  myleaf.body.node.nodes[0]->coding_descr = &ExtUtDenmEventInd_denmPduLength_descr_;
  myleaf.body.node.nodes[0]->calcof.lengthto.num_of_fields = 1;
  myleaf.body.node.nodes[0]->calcof.lengthto.unit = 8;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields = init_lengthto_fields_list(1);
  myleaf.body.node.nodes[0]->length = 16;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields[0].level = myleaf.body.node.nodes[1]->curr_pos.level;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields[0].pos = myleaf.body.node.nodes[1]->curr_pos.pos;
  encoded_length += field_denMsg.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int ExtUtDenmEventInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtUtDenmEventInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "denmPduLength");
    enc_len += field_denmPduLength.JSON_encode(ExtUtDenmEventInd_denmPduLength_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "denMsg");
    enc_len += field_denMsg.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtUtDenmEventInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (13 == name_len && 0 == strncmp(fld_name, "denmPduLength", name_len)) {
         int ret_val = field_denmPduLength.JSON_decode(ExtUtDenmEventInd_denmPduLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "denmPduLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "denMsg", name_len)) {
         int ret_val = field_denMsg.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "denMsg");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_denmPduLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "denmPduLength");
    return JSON_ERROR_FATAL;
  }
if (!field_denMsg.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "denMsg");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtUtDenmEventInd_template::single_value_struct {
INTEGER_template field_denmPduLength;
OCTETSTRING_template field_denMsg;
};

void ExtUtDenmEventInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_denmPduLength = ANY_VALUE;
single_value->field_denMsg = ANY_VALUE;
}
}
}

void ExtUtDenmEventInd_template::copy_value(const ExtUtDenmEventInd& other_value)
{
single_value = new single_value_struct;
if (other_value.denmPduLength().is_bound()) {
  single_value->field_denmPduLength = other_value.denmPduLength();
} else {
  single_value->field_denmPduLength.clean_up();
}
if (other_value.denMsg().is_bound()) {
  single_value->field_denMsg = other_value.denMsg();
} else {
  single_value->field_denMsg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtUtDenmEventInd_template::copy_template(const ExtUtDenmEventInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.denmPduLength().get_selection()) {
single_value->field_denmPduLength = other_value.denmPduLength();
} else {
single_value->field_denmPduLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.denMsg().get_selection()) {
single_value->field_denMsg = other_value.denMsg();
} else {
single_value->field_denMsg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtUtDenmEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmEventInd.");
break;
}
set_selection(other_value);
}

ExtUtDenmEventInd_template::ExtUtDenmEventInd_template()
{
}

ExtUtDenmEventInd_template::ExtUtDenmEventInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtUtDenmEventInd_template::ExtUtDenmEventInd_template(const ExtUtDenmEventInd& other_value)
{
copy_value(other_value);
}

ExtUtDenmEventInd_template::ExtUtDenmEventInd_template(const OPTIONAL<ExtUtDenmEventInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtDenmEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtUtDenmEventInd from an unbound optional field.");
}
}

ExtUtDenmEventInd_template::ExtUtDenmEventInd_template(const ExtUtDenmEventInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtUtDenmEventInd_template::~ExtUtDenmEventInd_template()
{
clean_up();
}

ExtUtDenmEventInd_template& ExtUtDenmEventInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtUtDenmEventInd_template& ExtUtDenmEventInd_template::operator=(const ExtUtDenmEventInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtUtDenmEventInd_template& ExtUtDenmEventInd_template::operator=(const OPTIONAL<ExtUtDenmEventInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtDenmEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtUtDenmEventInd.");
}
return *this;
}

ExtUtDenmEventInd_template& ExtUtDenmEventInd_template::operator=(const ExtUtDenmEventInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtUtDenmEventInd_template::match(const ExtUtDenmEventInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.denmPduLength().is_bound()) return FALSE;
if(!single_value->field_denmPduLength.match(other_value.denmPduLength(), legacy))return FALSE;
if(!other_value.denMsg().is_bound()) return FALSE;
if(!single_value->field_denMsg.match(other_value.denMsg(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmEventInd.");
}
return FALSE;
}

boolean ExtUtDenmEventInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_denmPduLength.is_bound()) return TRUE;
if (single_value->field_denMsg.is_bound()) return TRUE;
return FALSE;
}

boolean ExtUtDenmEventInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_denmPduLength.is_value()) return FALSE;
if (!single_value->field_denMsg.is_value()) return FALSE;
return TRUE;
}

void ExtUtDenmEventInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtUtDenmEventInd ExtUtDenmEventInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtUtDenmEventInd.");
ExtUtDenmEventInd ret_val;
if (single_value->field_denmPduLength.is_bound()) {
ret_val.denmPduLength() = single_value->field_denmPduLength.valueof();
}
if (single_value->field_denMsg.is_bound()) {
ret_val.denMsg() = single_value->field_denMsg.valueof();
}
return ret_val;
}

void ExtUtDenmEventInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtUtDenmEventInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtUtDenmEventInd_template[list_length];
}

ExtUtDenmEventInd_template& ExtUtDenmEventInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtUtDenmEventInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtUtDenmEventInd.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtUtDenmEventInd_template::denmPduLength()
{
set_specific();
return single_value->field_denmPduLength;
}

const INTEGER_template& ExtUtDenmEventInd_template::denmPduLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field denmPduLength of a non-specific template of type @TTCN_EncDec.ExtUtDenmEventInd.");
return single_value->field_denmPduLength;
}

OCTETSTRING_template& ExtUtDenmEventInd_template::denMsg()
{
set_specific();
return single_value->field_denMsg;
}

const OCTETSTRING_template& ExtUtDenmEventInd_template::denMsg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field denMsg of a non-specific template of type @TTCN_EncDec.ExtUtDenmEventInd.");
return single_value->field_denMsg;
}

int ExtUtDenmEventInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmEventInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmEventInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmEventInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmEventInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmEventInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtDenmEventInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmEventInd.");
  }
  return 0;
}

void ExtUtDenmEventInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ denmPduLength := ");
single_value->field_denmPduLength.log();
TTCN_Logger::log_event_str(", denMsg := ");
single_value->field_denMsg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtUtDenmEventInd_template::log_match(const ExtUtDenmEventInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_denmPduLength.match(match_value.denmPduLength(), legacy)){
TTCN_Logger::log_logmatch_info(".denmPduLength");
single_value->field_denmPduLength.log_match(match_value.denmPduLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_denMsg.match(match_value.denMsg(), legacy)){
TTCN_Logger::log_logmatch_info(".denMsg");
single_value->field_denMsg.log_match(match_value.denMsg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ denmPduLength := ");
single_value->field_denmPduLength.log_match(match_value.denmPduLength(), legacy);
TTCN_Logger::log_event_str(", denMsg := ");
single_value->field_denMsg.log_match(match_value.denMsg(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtUtDenmEventInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_denmPduLength.encode_text(text_buf);
single_value->field_denMsg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtDenmEventInd.");
}
}

void ExtUtDenmEventInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_denmPduLength.decode_text(text_buf);
single_value->field_denMsg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtUtDenmEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtUtDenmEventInd.");
}
}

void ExtUtDenmEventInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtUtDenmEventInd'");
    }
    if (strcmp("denmPduLength", param_field) == 0) {
      denmPduLength().set_param(param);
      return;
    } else if (strcmp("denMsg", param_field) == 0) {
      denMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtUtDenmEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtUtDenmEventInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtUtDenmEventInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) denmPduLength().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) denMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "denmPduLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          denmPduLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "denMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          denMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtDenmEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtUtDenmEventInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtUtDenmEventInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtUtDenmEventInd'");
    }
    if (strcmp("denmPduLength", param_field) == 0) {
      return denmPduLength().get_param(param_name);
    } else if (strcmp("denMsg", param_field) == 0) {
      return denMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtDenmEventInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_denmPduLength = single_value->field_denmPduLength.get_param(param_name);
    mp_field_denmPduLength->set_id(new Module_Param_FieldName(mcopystr("denmPduLength")));
    mp->add_elem(mp_field_denmPduLength);
    Module_Param* mp_field_denMsg = single_value->field_denMsg.get_param(param_name);
    mp_field_denMsg->set_id(new Module_Param_FieldName(mcopystr("denMsg")));
    mp->add_elem(mp_field_denMsg);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtUtDenmEventInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_denmPduLength.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmEventInd");
single_value->field_denMsg.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtDenmEventInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtUtDenmEventInd");
}

boolean ExtUtDenmEventInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtUtDenmEventInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtUtMapEventInd::ExtUtMapEventInd()
{
  bound_flag = FALSE;
}

ExtUtMapEventInd::ExtUtMapEventInd(const INTEGER& par_mapPduLength,
    const OCTETSTRING& par_mapMsg)
  :   field_mapPduLength(par_mapPduLength),
  field_mapMsg(par_mapMsg)
{
  bound_flag = TRUE;
}

ExtUtMapEventInd::ExtUtMapEventInd(const ExtUtMapEventInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtUtMapEventInd.");
bound_flag = TRUE;
if (other_value.mapPduLength().is_bound()) field_mapPduLength = other_value.mapPduLength();
else field_mapPduLength.clean_up();
if (other_value.mapMsg().is_bound()) field_mapMsg = other_value.mapMsg();
else field_mapMsg.clean_up();
}

void ExtUtMapEventInd::clean_up()
{
field_mapPduLength.clean_up();
field_mapMsg.clean_up();
bound_flag = FALSE;
}

ExtUtMapEventInd& ExtUtMapEventInd::operator=(const ExtUtMapEventInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtUtMapEventInd.");
  bound_flag = TRUE;
  if (other_value.mapPduLength().is_bound()) field_mapPduLength = other_value.mapPduLength();
  else field_mapPduLength.clean_up();
  if (other_value.mapMsg().is_bound()) field_mapMsg = other_value.mapMsg();
  else field_mapMsg.clean_up();
}
return *this;
}

boolean ExtUtMapEventInd::operator==(const ExtUtMapEventInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_mapPduLength==other_value.field_mapPduLength
  && field_mapMsg==other_value.field_mapMsg;
}

boolean ExtUtMapEventInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_mapPduLength.is_bound()) return TRUE;
if(field_mapMsg.is_bound()) return TRUE;
return FALSE;
}
boolean ExtUtMapEventInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_mapPduLength.is_value()) return FALSE;
if(!field_mapMsg.is_value()) return FALSE;
return TRUE;
}
int ExtUtMapEventInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtUtMapEventInd");
  return 2;
}

void ExtUtMapEventInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ mapPduLength := ");
field_mapPduLength.log();
TTCN_Logger::log_event_str(", mapMsg := ");
field_mapMsg.log();
TTCN_Logger::log_event_str(" }");
}

void ExtUtMapEventInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtUtMapEventInd'");
    }
    if (strcmp("mapPduLength", param_field) == 0) {
      mapPduLength().set_param(param);
      return;
    } else if (strcmp("mapMsg", param_field) == 0) {
      mapMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtMapEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtUtMapEventInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) mapPduLength().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) mapMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mapPduLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mapPduLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mapMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mapMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtMapEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtUtMapEventInd");
  }
}

Module_Param* ExtUtMapEventInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtUtMapEventInd'");
    }
    if (strcmp("mapPduLength", param_field) == 0) {
      return mapPduLength().get_param(param_name);
    } else if (strcmp("mapMsg", param_field) == 0) {
      return mapMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtMapEventInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_mapPduLength = field_mapPduLength.get_param(param_name);
  mp_field_mapPduLength->set_id(new Module_Param_FieldName(mcopystr("mapPduLength")));
  mp->add_elem(mp_field_mapPduLength);
  Module_Param* mp_field_mapMsg = field_mapMsg.get_param(param_name);
  mp_field_mapMsg->set_id(new Module_Param_FieldName(mcopystr("mapMsg")));
  mp->add_elem(mp_field_mapMsg);
  return mp;
  }

void ExtUtMapEventInd::set_implicit_omit()
{
if (mapPduLength().is_bound()) mapPduLength().set_implicit_omit();
if (mapMsg().is_bound()) mapMsg().set_implicit_omit();
}

void ExtUtMapEventInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtUtMapEventInd.");
field_mapPduLength.encode_text(text_buf);
field_mapMsg.encode_text(text_buf);
}

void ExtUtMapEventInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_mapPduLength.decode_text(text_buf);
field_mapMsg.decode_text(text_buf);
}

void ExtUtMapEventInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtUtMapEventInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtUtMapEventInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  int value_of_length_field0 = 0;
  decoded_field_length = field_mapPduLength.RAW_decode(ExtUtMapEventInd_mapPduLength_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field0+=(int)field_mapPduLength*8;
  decoded_field_length = field_mapMsg.RAW_decode(OCTETSTRING_descr_, p_buf, min_of_ints(2, limit, value_of_length_field0), local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field0 -= decoded_field_length;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtUtMapEventInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ExtUtMapEventInd_mapPduLength_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, OCTETSTRING_descr_.raw);
  encoded_length += 16;
  myleaf.body.node.nodes[0]->calc = CALC_LENGTH;
  myleaf.body.node.nodes[0]->coding_descr = &ExtUtMapEventInd_mapPduLength_descr_;
  myleaf.body.node.nodes[0]->calcof.lengthto.num_of_fields = 1;
  myleaf.body.node.nodes[0]->calcof.lengthto.unit = 8;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields = init_lengthto_fields_list(1);
  myleaf.body.node.nodes[0]->length = 16;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields[0].level = myleaf.body.node.nodes[1]->curr_pos.level;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields[0].pos = myleaf.body.node.nodes[1]->curr_pos.pos;
  encoded_length += field_mapMsg.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int ExtUtMapEventInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtUtMapEventInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "mapPduLength");
    enc_len += field_mapPduLength.JSON_encode(ExtUtMapEventInd_mapPduLength_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "mapMsg");
    enc_len += field_mapMsg.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtUtMapEventInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "mapPduLength", name_len)) {
         int ret_val = field_mapPduLength.JSON_decode(ExtUtMapEventInd_mapPduLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "mapPduLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "mapMsg", name_len)) {
         int ret_val = field_mapMsg.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "mapMsg");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_mapPduLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "mapPduLength");
    return JSON_ERROR_FATAL;
  }
if (!field_mapMsg.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "mapMsg");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtUtMapEventInd_template::single_value_struct {
INTEGER_template field_mapPduLength;
OCTETSTRING_template field_mapMsg;
};

void ExtUtMapEventInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_mapPduLength = ANY_VALUE;
single_value->field_mapMsg = ANY_VALUE;
}
}
}

void ExtUtMapEventInd_template::copy_value(const ExtUtMapEventInd& other_value)
{
single_value = new single_value_struct;
if (other_value.mapPduLength().is_bound()) {
  single_value->field_mapPduLength = other_value.mapPduLength();
} else {
  single_value->field_mapPduLength.clean_up();
}
if (other_value.mapMsg().is_bound()) {
  single_value->field_mapMsg = other_value.mapMsg();
} else {
  single_value->field_mapMsg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtUtMapEventInd_template::copy_template(const ExtUtMapEventInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.mapPduLength().get_selection()) {
single_value->field_mapPduLength = other_value.mapPduLength();
} else {
single_value->field_mapPduLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mapMsg().get_selection()) {
single_value->field_mapMsg = other_value.mapMsg();
} else {
single_value->field_mapMsg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtUtMapEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtMapEventInd.");
break;
}
set_selection(other_value);
}

ExtUtMapEventInd_template::ExtUtMapEventInd_template()
{
}

ExtUtMapEventInd_template::ExtUtMapEventInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtUtMapEventInd_template::ExtUtMapEventInd_template(const ExtUtMapEventInd& other_value)
{
copy_value(other_value);
}

ExtUtMapEventInd_template::ExtUtMapEventInd_template(const OPTIONAL<ExtUtMapEventInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtMapEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtUtMapEventInd from an unbound optional field.");
}
}

ExtUtMapEventInd_template::ExtUtMapEventInd_template(const ExtUtMapEventInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtUtMapEventInd_template::~ExtUtMapEventInd_template()
{
clean_up();
}

ExtUtMapEventInd_template& ExtUtMapEventInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtUtMapEventInd_template& ExtUtMapEventInd_template::operator=(const ExtUtMapEventInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtUtMapEventInd_template& ExtUtMapEventInd_template::operator=(const OPTIONAL<ExtUtMapEventInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtMapEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtUtMapEventInd.");
}
return *this;
}

ExtUtMapEventInd_template& ExtUtMapEventInd_template::operator=(const ExtUtMapEventInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtUtMapEventInd_template::match(const ExtUtMapEventInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.mapPduLength().is_bound()) return FALSE;
if(!single_value->field_mapPduLength.match(other_value.mapPduLength(), legacy))return FALSE;
if(!other_value.mapMsg().is_bound()) return FALSE;
if(!single_value->field_mapMsg.match(other_value.mapMsg(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtMapEventInd.");
}
return FALSE;
}

boolean ExtUtMapEventInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_mapPduLength.is_bound()) return TRUE;
if (single_value->field_mapMsg.is_bound()) return TRUE;
return FALSE;
}

boolean ExtUtMapEventInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_mapPduLength.is_value()) return FALSE;
if (!single_value->field_mapMsg.is_value()) return FALSE;
return TRUE;
}

void ExtUtMapEventInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtUtMapEventInd ExtUtMapEventInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtUtMapEventInd.");
ExtUtMapEventInd ret_val;
if (single_value->field_mapPduLength.is_bound()) {
ret_val.mapPduLength() = single_value->field_mapPduLength.valueof();
}
if (single_value->field_mapMsg.is_bound()) {
ret_val.mapMsg() = single_value->field_mapMsg.valueof();
}
return ret_val;
}

void ExtUtMapEventInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtUtMapEventInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtUtMapEventInd_template[list_length];
}

ExtUtMapEventInd_template& ExtUtMapEventInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtUtMapEventInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtUtMapEventInd.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtUtMapEventInd_template::mapPduLength()
{
set_specific();
return single_value->field_mapPduLength;
}

const INTEGER_template& ExtUtMapEventInd_template::mapPduLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mapPduLength of a non-specific template of type @TTCN_EncDec.ExtUtMapEventInd.");
return single_value->field_mapPduLength;
}

OCTETSTRING_template& ExtUtMapEventInd_template::mapMsg()
{
set_specific();
return single_value->field_mapMsg;
}

const OCTETSTRING_template& ExtUtMapEventInd_template::mapMsg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mapMsg of a non-specific template of type @TTCN_EncDec.ExtUtMapEventInd.");
return single_value->field_mapMsg;
}

int ExtUtMapEventInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtMapEventInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtMapEventInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtMapEventInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtMapEventInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtMapEventInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtMapEventInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtMapEventInd.");
  }
  return 0;
}

void ExtUtMapEventInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ mapPduLength := ");
single_value->field_mapPduLength.log();
TTCN_Logger::log_event_str(", mapMsg := ");
single_value->field_mapMsg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtUtMapEventInd_template::log_match(const ExtUtMapEventInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_mapPduLength.match(match_value.mapPduLength(), legacy)){
TTCN_Logger::log_logmatch_info(".mapPduLength");
single_value->field_mapPduLength.log_match(match_value.mapPduLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mapMsg.match(match_value.mapMsg(), legacy)){
TTCN_Logger::log_logmatch_info(".mapMsg");
single_value->field_mapMsg.log_match(match_value.mapMsg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ mapPduLength := ");
single_value->field_mapPduLength.log_match(match_value.mapPduLength(), legacy);
TTCN_Logger::log_event_str(", mapMsg := ");
single_value->field_mapMsg.log_match(match_value.mapMsg(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtUtMapEventInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_mapPduLength.encode_text(text_buf);
single_value->field_mapMsg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtMapEventInd.");
}
}

void ExtUtMapEventInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_mapPduLength.decode_text(text_buf);
single_value->field_mapMsg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtUtMapEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtUtMapEventInd.");
}
}

void ExtUtMapEventInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtUtMapEventInd'");
    }
    if (strcmp("mapPduLength", param_field) == 0) {
      mapPduLength().set_param(param);
      return;
    } else if (strcmp("mapMsg", param_field) == 0) {
      mapMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtUtMapEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtUtMapEventInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtUtMapEventInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) mapPduLength().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) mapMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mapPduLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mapPduLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mapMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mapMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtMapEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtUtMapEventInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtUtMapEventInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtUtMapEventInd'");
    }
    if (strcmp("mapPduLength", param_field) == 0) {
      return mapPduLength().get_param(param_name);
    } else if (strcmp("mapMsg", param_field) == 0) {
      return mapMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtMapEventInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_mapPduLength = single_value->field_mapPduLength.get_param(param_name);
    mp_field_mapPduLength->set_id(new Module_Param_FieldName(mcopystr("mapPduLength")));
    mp->add_elem(mp_field_mapPduLength);
    Module_Param* mp_field_mapMsg = single_value->field_mapMsg.get_param(param_name);
    mp_field_mapMsg->set_id(new Module_Param_FieldName(mcopystr("mapMsg")));
    mp->add_elem(mp_field_mapMsg);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtUtMapEventInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_mapPduLength.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtMapEventInd");
single_value->field_mapMsg.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtMapEventInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtUtMapEventInd");
}

boolean ExtUtMapEventInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtUtMapEventInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtUtSpatEventInd::ExtUtSpatEventInd()
{
  bound_flag = FALSE;
}

ExtUtSpatEventInd::ExtUtSpatEventInd(const INTEGER& par_spatPduLength,
    const OCTETSTRING& par_spatMsg)
  :   field_spatPduLength(par_spatPduLength),
  field_spatMsg(par_spatMsg)
{
  bound_flag = TRUE;
}

ExtUtSpatEventInd::ExtUtSpatEventInd(const ExtUtSpatEventInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtUtSpatEventInd.");
bound_flag = TRUE;
if (other_value.spatPduLength().is_bound()) field_spatPduLength = other_value.spatPduLength();
else field_spatPduLength.clean_up();
if (other_value.spatMsg().is_bound()) field_spatMsg = other_value.spatMsg();
else field_spatMsg.clean_up();
}

void ExtUtSpatEventInd::clean_up()
{
field_spatPduLength.clean_up();
field_spatMsg.clean_up();
bound_flag = FALSE;
}

ExtUtSpatEventInd& ExtUtSpatEventInd::operator=(const ExtUtSpatEventInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtUtSpatEventInd.");
  bound_flag = TRUE;
  if (other_value.spatPduLength().is_bound()) field_spatPduLength = other_value.spatPduLength();
  else field_spatPduLength.clean_up();
  if (other_value.spatMsg().is_bound()) field_spatMsg = other_value.spatMsg();
  else field_spatMsg.clean_up();
}
return *this;
}

boolean ExtUtSpatEventInd::operator==(const ExtUtSpatEventInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_spatPduLength==other_value.field_spatPduLength
  && field_spatMsg==other_value.field_spatMsg;
}

boolean ExtUtSpatEventInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_spatPduLength.is_bound()) return TRUE;
if(field_spatMsg.is_bound()) return TRUE;
return FALSE;
}
boolean ExtUtSpatEventInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_spatPduLength.is_value()) return FALSE;
if(!field_spatMsg.is_value()) return FALSE;
return TRUE;
}
int ExtUtSpatEventInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtUtSpatEventInd");
  return 2;
}

void ExtUtSpatEventInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ spatPduLength := ");
field_spatPduLength.log();
TTCN_Logger::log_event_str(", spatMsg := ");
field_spatMsg.log();
TTCN_Logger::log_event_str(" }");
}

void ExtUtSpatEventInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtUtSpatEventInd'");
    }
    if (strcmp("spatPduLength", param_field) == 0) {
      spatPduLength().set_param(param);
      return;
    } else if (strcmp("spatMsg", param_field) == 0) {
      spatMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtSpatEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtUtSpatEventInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) spatPduLength().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) spatMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spatPduLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spatPduLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spatMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spatMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtSpatEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtUtSpatEventInd");
  }
}

Module_Param* ExtUtSpatEventInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtUtSpatEventInd'");
    }
    if (strcmp("spatPduLength", param_field) == 0) {
      return spatPduLength().get_param(param_name);
    } else if (strcmp("spatMsg", param_field) == 0) {
      return spatMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtSpatEventInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_spatPduLength = field_spatPduLength.get_param(param_name);
  mp_field_spatPduLength->set_id(new Module_Param_FieldName(mcopystr("spatPduLength")));
  mp->add_elem(mp_field_spatPduLength);
  Module_Param* mp_field_spatMsg = field_spatMsg.get_param(param_name);
  mp_field_spatMsg->set_id(new Module_Param_FieldName(mcopystr("spatMsg")));
  mp->add_elem(mp_field_spatMsg);
  return mp;
  }

void ExtUtSpatEventInd::set_implicit_omit()
{
if (spatPduLength().is_bound()) spatPduLength().set_implicit_omit();
if (spatMsg().is_bound()) spatMsg().set_implicit_omit();
}

void ExtUtSpatEventInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtUtSpatEventInd.");
field_spatPduLength.encode_text(text_buf);
field_spatMsg.encode_text(text_buf);
}

void ExtUtSpatEventInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_spatPduLength.decode_text(text_buf);
field_spatMsg.decode_text(text_buf);
}

void ExtUtSpatEventInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtUtSpatEventInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtUtSpatEventInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  int value_of_length_field0 = 0;
  decoded_field_length = field_spatPduLength.RAW_decode(ExtUtSpatEventInd_spatPduLength_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field0+=(int)field_spatPduLength*8;
  decoded_field_length = field_spatMsg.RAW_decode(OCTETSTRING_descr_, p_buf, min_of_ints(2, limit, value_of_length_field0), local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field0 -= decoded_field_length;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtUtSpatEventInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ExtUtSpatEventInd_spatPduLength_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, OCTETSTRING_descr_.raw);
  encoded_length += 16;
  myleaf.body.node.nodes[0]->calc = CALC_LENGTH;
  myleaf.body.node.nodes[0]->coding_descr = &ExtUtSpatEventInd_spatPduLength_descr_;
  myleaf.body.node.nodes[0]->calcof.lengthto.num_of_fields = 1;
  myleaf.body.node.nodes[0]->calcof.lengthto.unit = 8;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields = init_lengthto_fields_list(1);
  myleaf.body.node.nodes[0]->length = 16;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields[0].level = myleaf.body.node.nodes[1]->curr_pos.level;
  myleaf.body.node.nodes[0]->calcof.lengthto.fields[0].pos = myleaf.body.node.nodes[1]->curr_pos.pos;
  encoded_length += field_spatMsg.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int ExtUtSpatEventInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtUtSpatEventInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "spatPduLength");
    enc_len += field_spatPduLength.JSON_encode(ExtUtSpatEventInd_spatPduLength_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "spatMsg");
    enc_len += field_spatMsg.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtUtSpatEventInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (13 == name_len && 0 == strncmp(fld_name, "spatPduLength", name_len)) {
         int ret_val = field_spatPduLength.JSON_decode(ExtUtSpatEventInd_spatPduLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "spatPduLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "spatMsg", name_len)) {
         int ret_val = field_spatMsg.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "spatMsg");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_spatPduLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "spatPduLength");
    return JSON_ERROR_FATAL;
  }
if (!field_spatMsg.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "spatMsg");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtUtSpatEventInd_template::single_value_struct {
INTEGER_template field_spatPduLength;
OCTETSTRING_template field_spatMsg;
};

void ExtUtSpatEventInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_spatPduLength = ANY_VALUE;
single_value->field_spatMsg = ANY_VALUE;
}
}
}

void ExtUtSpatEventInd_template::copy_value(const ExtUtSpatEventInd& other_value)
{
single_value = new single_value_struct;
if (other_value.spatPduLength().is_bound()) {
  single_value->field_spatPduLength = other_value.spatPduLength();
} else {
  single_value->field_spatPduLength.clean_up();
}
if (other_value.spatMsg().is_bound()) {
  single_value->field_spatMsg = other_value.spatMsg();
} else {
  single_value->field_spatMsg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtUtSpatEventInd_template::copy_template(const ExtUtSpatEventInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.spatPduLength().get_selection()) {
single_value->field_spatPduLength = other_value.spatPduLength();
} else {
single_value->field_spatPduLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.spatMsg().get_selection()) {
single_value->field_spatMsg = other_value.spatMsg();
} else {
single_value->field_spatMsg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtUtSpatEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtSpatEventInd.");
break;
}
set_selection(other_value);
}

ExtUtSpatEventInd_template::ExtUtSpatEventInd_template()
{
}

ExtUtSpatEventInd_template::ExtUtSpatEventInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtUtSpatEventInd_template::ExtUtSpatEventInd_template(const ExtUtSpatEventInd& other_value)
{
copy_value(other_value);
}

ExtUtSpatEventInd_template::ExtUtSpatEventInd_template(const OPTIONAL<ExtUtSpatEventInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtSpatEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtUtSpatEventInd from an unbound optional field.");
}
}

ExtUtSpatEventInd_template::ExtUtSpatEventInd_template(const ExtUtSpatEventInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtUtSpatEventInd_template::~ExtUtSpatEventInd_template()
{
clean_up();
}

ExtUtSpatEventInd_template& ExtUtSpatEventInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtUtSpatEventInd_template& ExtUtSpatEventInd_template::operator=(const ExtUtSpatEventInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtUtSpatEventInd_template& ExtUtSpatEventInd_template::operator=(const OPTIONAL<ExtUtSpatEventInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtUtSpatEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtUtSpatEventInd.");
}
return *this;
}

ExtUtSpatEventInd_template& ExtUtSpatEventInd_template::operator=(const ExtUtSpatEventInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtUtSpatEventInd_template::match(const ExtUtSpatEventInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.spatPduLength().is_bound()) return FALSE;
if(!single_value->field_spatPduLength.match(other_value.spatPduLength(), legacy))return FALSE;
if(!other_value.spatMsg().is_bound()) return FALSE;
if(!single_value->field_spatMsg.match(other_value.spatMsg(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtSpatEventInd.");
}
return FALSE;
}

boolean ExtUtSpatEventInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_spatPduLength.is_bound()) return TRUE;
if (single_value->field_spatMsg.is_bound()) return TRUE;
return FALSE;
}

boolean ExtUtSpatEventInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_spatPduLength.is_value()) return FALSE;
if (!single_value->field_spatMsg.is_value()) return FALSE;
return TRUE;
}

void ExtUtSpatEventInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtUtSpatEventInd ExtUtSpatEventInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtUtSpatEventInd.");
ExtUtSpatEventInd ret_val;
if (single_value->field_spatPduLength.is_bound()) {
ret_val.spatPduLength() = single_value->field_spatPduLength.valueof();
}
if (single_value->field_spatMsg.is_bound()) {
ret_val.spatMsg() = single_value->field_spatMsg.valueof();
}
return ret_val;
}

void ExtUtSpatEventInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtUtSpatEventInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtUtSpatEventInd_template[list_length];
}

ExtUtSpatEventInd_template& ExtUtSpatEventInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtUtSpatEventInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtUtSpatEventInd.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtUtSpatEventInd_template::spatPduLength()
{
set_specific();
return single_value->field_spatPduLength;
}

const INTEGER_template& ExtUtSpatEventInd_template::spatPduLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spatPduLength of a non-specific template of type @TTCN_EncDec.ExtUtSpatEventInd.");
return single_value->field_spatPduLength;
}

OCTETSTRING_template& ExtUtSpatEventInd_template::spatMsg()
{
set_specific();
return single_value->field_spatMsg;
}

const OCTETSTRING_template& ExtUtSpatEventInd_template::spatMsg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spatMsg of a non-specific template of type @TTCN_EncDec.ExtUtSpatEventInd.");
return single_value->field_spatMsg;
}

int ExtUtSpatEventInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtSpatEventInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtSpatEventInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtSpatEventInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtSpatEventInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtSpatEventInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtUtSpatEventInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtSpatEventInd.");
  }
  return 0;
}

void ExtUtSpatEventInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ spatPduLength := ");
single_value->field_spatPduLength.log();
TTCN_Logger::log_event_str(", spatMsg := ");
single_value->field_spatMsg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtUtSpatEventInd_template::log_match(const ExtUtSpatEventInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_spatPduLength.match(match_value.spatPduLength(), legacy)){
TTCN_Logger::log_logmatch_info(".spatPduLength");
single_value->field_spatPduLength.log_match(match_value.spatPduLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_spatMsg.match(match_value.spatMsg(), legacy)){
TTCN_Logger::log_logmatch_info(".spatMsg");
single_value->field_spatMsg.log_match(match_value.spatMsg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ spatPduLength := ");
single_value->field_spatPduLength.log_match(match_value.spatPduLength(), legacy);
TTCN_Logger::log_event_str(", spatMsg := ");
single_value->field_spatMsg.log_match(match_value.spatMsg(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtUtSpatEventInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_spatPduLength.encode_text(text_buf);
single_value->field_spatMsg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtUtSpatEventInd.");
}
}

void ExtUtSpatEventInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_spatPduLength.decode_text(text_buf);
single_value->field_spatMsg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtUtSpatEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtUtSpatEventInd.");
}
}

void ExtUtSpatEventInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtUtSpatEventInd'");
    }
    if (strcmp("spatPduLength", param_field) == 0) {
      spatPduLength().set_param(param);
      return;
    } else if (strcmp("spatMsg", param_field) == 0) {
      spatMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtUtSpatEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtUtSpatEventInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtUtSpatEventInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) spatPduLength().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) spatMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spatPduLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spatPduLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spatMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spatMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtUtSpatEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtUtSpatEventInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtUtSpatEventInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtUtSpatEventInd'");
    }
    if (strcmp("spatPduLength", param_field) == 0) {
      return spatPduLength().get_param(param_name);
    } else if (strcmp("spatMsg", param_field) == 0) {
      return spatMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtUtSpatEventInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_spatPduLength = single_value->field_spatPduLength.get_param(param_name);
    mp_field_spatPduLength->set_id(new Module_Param_FieldName(mcopystr("spatPduLength")));
    mp->add_elem(mp_field_spatPduLength);
    Module_Param* mp_field_spatMsg = single_value->field_spatMsg.get_param(param_name);
    mp_field_spatMsg->set_id(new Module_Param_FieldName(mcopystr("spatMsg")));
    mp->add_elem(mp_field_spatMsg);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtUtSpatEventInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_spatPduLength.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtSpatEventInd");
single_value->field_spatMsg.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtUtSpatEventInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtUtSpatEventInd");
}

boolean ExtUtSpatEventInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtUtSpatEventInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtBtpPayload::ExtBtpPayload()
{
  bound_flag = FALSE;
}

ExtBtpPayload::ExtBtpPayload(const OCTETSTRING& par_rawPayload)
  :   field_rawPayload(par_rawPayload)
{
  bound_flag = TRUE;
}

ExtBtpPayload::ExtBtpPayload(const ExtBtpPayload& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtBtpPayload.");
bound_flag = TRUE;
if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
else field_rawPayload.clean_up();
}

void ExtBtpPayload::clean_up()
{
field_rawPayload.clean_up();
bound_flag = FALSE;
}

ExtBtpPayload& ExtBtpPayload::operator=(const ExtBtpPayload& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtBtpPayload.");
  bound_flag = TRUE;
  if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
  else field_rawPayload.clean_up();
}
return *this;
}

boolean ExtBtpPayload::operator==(const ExtBtpPayload& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_rawPayload==other_value.field_rawPayload;
}

boolean ExtBtpPayload::is_bound() const
{
if (bound_flag) return TRUE;
if(field_rawPayload.is_bound()) return TRUE;
return FALSE;
}
boolean ExtBtpPayload::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_rawPayload.is_value()) return FALSE;
return TRUE;
}
int ExtBtpPayload::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtBtpPayload");
  return 1;
}

void ExtBtpPayload::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ rawPayload := ");
field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
}

void ExtBtpPayload::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtBtpPayload'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtBtpPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtBtpPayload has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtBtpPayload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtBtpPayload");
  }
}

Module_Param* ExtBtpPayload::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtBtpPayload'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtBtpPayload'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_rawPayload = field_rawPayload.get_param(param_name);
  mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
  mp->add_elem(mp_field_rawPayload);
  return mp;
  }

void ExtBtpPayload::set_implicit_omit()
{
if (rawPayload().is_bound()) rawPayload().set_implicit_omit();
}

void ExtBtpPayload::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtBtpPayload.");
field_rawPayload.encode_text(text_buf);
}

void ExtBtpPayload::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_rawPayload.decode_text(text_buf);
}

void ExtBtpPayload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtBtpPayload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtBtpPayload::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_rawPayload.RAW_decode(LibItsBtp__TypesAndValues::BtpRawPayload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtBtpPayload::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibItsBtp__TypesAndValues::BtpRawPayload_descr_.raw);
  encoded_length += field_rawPayload.RAW_encode(LibItsBtp__TypesAndValues::BtpRawPayload_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int ExtBtpPayload::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtBtpPayload.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rawPayload");
    enc_len += field_rawPayload.JSON_encode(LibItsBtp__TypesAndValues::BtpRawPayload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtBtpPayload::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "rawPayload", name_len)) {
         int ret_val = field_rawPayload.JSON_decode(LibItsBtp__TypesAndValues::BtpRawPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rawPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_rawPayload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rawPayload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtBtpPayload_template::single_value_struct {
OCTETSTRING_template field_rawPayload;
};

void ExtBtpPayload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_rawPayload = ANY_VALUE;
}
}
}

void ExtBtpPayload_template::copy_value(const ExtBtpPayload& other_value)
{
single_value = new single_value_struct;
if (other_value.rawPayload().is_bound()) {
  single_value->field_rawPayload = other_value.rawPayload();
} else {
  single_value->field_rawPayload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtBtpPayload_template::copy_template(const ExtBtpPayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.rawPayload().get_selection()) {
single_value->field_rawPayload = other_value.rawPayload();
} else {
single_value->field_rawPayload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtBtpPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpPayload.");
break;
}
set_selection(other_value);
}

ExtBtpPayload_template::ExtBtpPayload_template()
{
}

ExtBtpPayload_template::ExtBtpPayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtBtpPayload_template::ExtBtpPayload_template(const ExtBtpPayload& other_value)
{
copy_value(other_value);
}

ExtBtpPayload_template::ExtBtpPayload_template(const OPTIONAL<ExtBtpPayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtBtpPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtBtpPayload from an unbound optional field.");
}
}

ExtBtpPayload_template::ExtBtpPayload_template(const ExtBtpPayload_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtBtpPayload_template::~ExtBtpPayload_template()
{
clean_up();
}

ExtBtpPayload_template& ExtBtpPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtBtpPayload_template& ExtBtpPayload_template::operator=(const ExtBtpPayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtBtpPayload_template& ExtBtpPayload_template::operator=(const OPTIONAL<ExtBtpPayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtBtpPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtBtpPayload.");
}
return *this;
}

ExtBtpPayload_template& ExtBtpPayload_template::operator=(const ExtBtpPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtBtpPayload_template::match(const ExtBtpPayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.rawPayload().is_bound()) return FALSE;
if(!single_value->field_rawPayload.match(other_value.rawPayload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpPayload.");
}
return FALSE;
}

boolean ExtBtpPayload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_rawPayload.is_bound()) return TRUE;
return FALSE;
}

boolean ExtBtpPayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_rawPayload.is_value()) return FALSE;
return TRUE;
}

void ExtBtpPayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtBtpPayload ExtBtpPayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtBtpPayload.");
ExtBtpPayload ret_val;
if (single_value->field_rawPayload.is_bound()) {
ret_val.rawPayload() = single_value->field_rawPayload.valueof();
}
return ret_val;
}

void ExtBtpPayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtBtpPayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtBtpPayload_template[list_length];
}

ExtBtpPayload_template& ExtBtpPayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtBtpPayload.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtBtpPayload.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& ExtBtpPayload_template::rawPayload()
{
set_specific();
return single_value->field_rawPayload;
}

const OCTETSTRING_template& ExtBtpPayload_template::rawPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawPayload of a non-specific template of type @TTCN_EncDec.ExtBtpPayload.");
return single_value->field_rawPayload;
}

int ExtBtpPayload_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpPayload which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpPayload containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpPayload containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpPayload containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpPayload containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpPayload containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpPayload.");
  }
  return 0;
}

void ExtBtpPayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ rawPayload := ");
single_value->field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtBtpPayload_template::log_match(const ExtBtpPayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_rawPayload.match(match_value.rawPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".rawPayload");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ rawPayload := ");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtBtpPayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_rawPayload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpPayload.");
}
}

void ExtBtpPayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_rawPayload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtBtpPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtBtpPayload.");
}
}

void ExtBtpPayload_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtBtpPayload'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtBtpPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtBtpPayload_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtBtpPayload has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtBtpPayload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtBtpPayload");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtBtpPayload_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtBtpPayload'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtBtpPayload'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_rawPayload = single_value->field_rawPayload.get_param(param_name);
    mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
    mp->add_elem(mp_field_rawPayload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtBtpPayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_rawPayload.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtBtpPayload");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtBtpPayload");
}

boolean ExtBtpPayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtBtpPayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtBtpReq::ExtBtpReq()
{
  bound_flag = FALSE;
}

ExtBtpReq::ExtBtpReq(const OCTETSTRING& par_nextheader,
    const LibItsBtp__TypesAndValues::BtpHeader& par_header,
    const OPTIONAL<ExtBtpPayload>& par_payload)
  :   field_nextheader(par_nextheader),
  field_header(par_header),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

ExtBtpReq::ExtBtpReq(const ExtBtpReq& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtBtpReq.");
bound_flag = TRUE;
if (other_value.nextheader().is_bound()) field_nextheader = other_value.nextheader();
else field_nextheader.clean_up();
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void ExtBtpReq::clean_up()
{
field_nextheader.clean_up();
field_header.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

ExtBtpReq& ExtBtpReq::operator=(const ExtBtpReq& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtBtpReq.");
  bound_flag = TRUE;
  if (other_value.nextheader().is_bound()) field_nextheader = other_value.nextheader();
  else field_nextheader.clean_up();
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean ExtBtpReq::operator==(const ExtBtpReq& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_nextheader==other_value.field_nextheader
  && field_header==other_value.field_header
  && field_payload==other_value.field_payload;
}

boolean ExtBtpReq::is_bound() const
{
if (bound_flag) return TRUE;
if(field_nextheader.is_bound()) return TRUE;
if(field_header.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_payload.get_selection() || field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean ExtBtpReq::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_nextheader.is_value()) return FALSE;
if(!field_header.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_payload.get_selection() && !field_payload.is_value()) return FALSE;
return TRUE;
}
int ExtBtpReq::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtBtpReq");
  int ret_val = 2;
  if (field_payload.ispresent()) ret_val++;
  return ret_val;
}

void ExtBtpReq::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ nextheader := ");
field_nextheader.log();
TTCN_Logger::log_event_str(", header := ");
field_header.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void ExtBtpReq::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtBtpReq'");
    }
    if (strcmp("nextheader", param_field) == 0) {
      nextheader().set_param(param);
      return;
    } else if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtBtpReq'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtBtpReq has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nextheader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextheader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextheader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtBtpReq: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtBtpReq");
  }
}

Module_Param* ExtBtpReq::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtBtpReq'");
    }
    if (strcmp("nextheader", param_field) == 0) {
      return nextheader().get_param(param_name);
    } else if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtBtpReq'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_nextheader = field_nextheader.get_param(param_name);
  mp_field_nextheader->set_id(new Module_Param_FieldName(mcopystr("nextheader")));
  mp->add_elem(mp_field_nextheader);
  Module_Param* mp_field_header = field_header.get_param(param_name);
  mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
  mp->add_elem(mp_field_header);
  Module_Param* mp_field_payload = field_payload.get_param(param_name);
  mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
  mp->add_elem(mp_field_payload);
  return mp;
  }

void ExtBtpReq::set_implicit_omit()
{
if (nextheader().is_bound()) nextheader().set_implicit_omit();
if (header().is_bound()) header().set_implicit_omit();
if (!payload().is_bound()) payload() = OMIT_VALUE;
else payload().set_implicit_omit();
}

void ExtBtpReq::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtBtpReq.");
field_nextheader.encode_text(text_buf);
field_header.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void ExtBtpReq::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_nextheader.decode_text(text_buf);
field_header.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void ExtBtpReq::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtBtpReq::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtBtpReq::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  int selected_field = -1;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_nextheader.RAW_decode(General__Types::OCT1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (field_nextheader ==  os_0) selected_field = 0;
  else if (field_nextheader ==  os_1) selected_field = 1;
  else selected_field = -1;
  decoded_field_length = field_header.RAW_decode(ExtBtpReq_header_descr_, p_buf, limit, local_top_order, no_err, selected_field);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_payload().RAW_decode(ExtBtpPayload_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_payload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_payload=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtBtpReq::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, General__Types::OCT1_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ExtBtpReq_header_descr_.raw);
  if (field_payload.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, ExtBtpPayload_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  encoded_length += field_nextheader.RAW_encode(General__Types::OCT1_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_header.RAW_encode(ExtBtpReq_header_descr_, *myleaf.body.node.nodes[1]);
  if (field_payload.ispresent()) {
  encoded_length += field_payload().RAW_encode(ExtBtpPayload_descr_, *myleaf.body.node.nodes[2]);
  }
  switch (field_header.get_selection()) {
  case LibItsBtp__TypesAndValues::BtpHeader::ALT_btpAHeader:
  if (field_nextheader !=  os_0) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
     os_0.RAW_encode(General__Types::OCT1_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsBtp__TypesAndValues::BtpHeader::ALT_btpBHeader:
  if (field_nextheader !=  os_1) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
     os_1.RAW_encode(General__Types::OCT1_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  default:;
  }
  return myleaf.length = encoded_length;
}

int ExtBtpReq::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtBtpReq.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nextheader");
    enc_len += field_nextheader.JSON_encode(General__Types::OCT1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header");
    enc_len += field_header.JSON_encode(ExtBtpReq_header_descr_, p_tok);
  }

  if (field_payload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(ExtBtpPayload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtBtpReq::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "nextheader", name_len)) {
         int ret_val = field_nextheader.JSON_decode(General__Types::OCT1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nextheader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "header", name_len)) {
         int ret_val = field_header.JSON_decode(ExtBtpReq_header_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
         int ret_val = field_payload.JSON_decode(ExtBtpPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_nextheader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nextheader");
    return JSON_ERROR_FATAL;
  }
if (!field_header.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header");
    return JSON_ERROR_FATAL;
  }
if (!field_payload.is_bound()) {
    field_payload = OMIT_VALUE;
  }

  return dec_len;
}

struct ExtBtpReq_template::single_value_struct {
OCTETSTRING_template field_nextheader;
LibItsBtp__TypesAndValues::BtpHeader_template field_header;
ExtBtpPayload_template field_payload;
};

void ExtBtpReq_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_nextheader = ANY_VALUE;
single_value->field_header = ANY_VALUE;
single_value->field_payload = ANY_OR_OMIT;
}
}
}

void ExtBtpReq_template::copy_value(const ExtBtpReq& other_value)
{
single_value = new single_value_struct;
if (other_value.nextheader().is_bound()) {
  single_value->field_nextheader = other_value.nextheader();
} else {
  single_value->field_nextheader.clean_up();
}
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.payload().is_bound()) {
  if (other_value.payload().ispresent()) single_value->field_payload = other_value.payload()();
  else single_value->field_payload = OMIT_VALUE;
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtBtpReq_template::copy_template(const ExtBtpReq_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.nextheader().get_selection()) {
single_value->field_nextheader = other_value.nextheader();
} else {
single_value->field_nextheader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtBtpReq_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpReq.");
break;
}
set_selection(other_value);
}

ExtBtpReq_template::ExtBtpReq_template()
{
}

ExtBtpReq_template::ExtBtpReq_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtBtpReq_template::ExtBtpReq_template(const ExtBtpReq& other_value)
{
copy_value(other_value);
}

ExtBtpReq_template::ExtBtpReq_template(const OPTIONAL<ExtBtpReq>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtBtpReq&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtBtpReq from an unbound optional field.");
}
}

ExtBtpReq_template::ExtBtpReq_template(const ExtBtpReq_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtBtpReq_template::~ExtBtpReq_template()
{
clean_up();
}

ExtBtpReq_template& ExtBtpReq_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtBtpReq_template& ExtBtpReq_template::operator=(const ExtBtpReq& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtBtpReq_template& ExtBtpReq_template::operator=(const OPTIONAL<ExtBtpReq>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtBtpReq&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtBtpReq.");
}
return *this;
}

ExtBtpReq_template& ExtBtpReq_template::operator=(const ExtBtpReq_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtBtpReq_template::match(const ExtBtpReq& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.nextheader().is_bound()) return FALSE;
if(!single_value->field_nextheader.match(other_value.nextheader(), legacy))return FALSE;
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if((other_value.payload().ispresent() ? !single_value->field_payload.match((const ExtBtpPayload&)other_value.payload(), legacy) : !single_value->field_payload.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpReq.");
}
return FALSE;
}

boolean ExtBtpReq_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_nextheader.is_bound()) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_payload.is_omit() || single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean ExtBtpReq_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_nextheader.is_value()) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_payload.is_omit() && !single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void ExtBtpReq_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtBtpReq ExtBtpReq_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtBtpReq.");
ExtBtpReq ret_val;
if (single_value->field_nextheader.is_bound()) {
ret_val.nextheader() = single_value->field_nextheader.valueof();
}
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_payload.is_omit()) ret_val.payload() = OMIT_VALUE;
else if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void ExtBtpReq_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtBtpReq.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtBtpReq_template[list_length];
}

ExtBtpReq_template& ExtBtpReq_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtBtpReq.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtBtpReq.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& ExtBtpReq_template::nextheader()
{
set_specific();
return single_value->field_nextheader;
}

const OCTETSTRING_template& ExtBtpReq_template::nextheader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nextheader of a non-specific template of type @TTCN_EncDec.ExtBtpReq.");
return single_value->field_nextheader;
}

LibItsBtp__TypesAndValues::BtpHeader_template& ExtBtpReq_template::header()
{
set_specific();
return single_value->field_header;
}

const LibItsBtp__TypesAndValues::BtpHeader_template& ExtBtpReq_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @TTCN_EncDec.ExtBtpReq.");
return single_value->field_header;
}

ExtBtpPayload_template& ExtBtpReq_template::payload()
{
set_specific();
return single_value->field_payload;
}

const ExtBtpPayload_template& ExtBtpReq_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @TTCN_EncDec.ExtBtpReq.");
return single_value->field_payload;
}

int ExtBtpReq_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpReq which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_payload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpReq containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpReq containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpReq containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpReq containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpReq containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpReq.");
  }
  return 0;
}

void ExtBtpReq_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ nextheader := ");
single_value->field_nextheader.log();
TTCN_Logger::log_event_str(", header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtBtpReq_template::log_match(const ExtBtpReq& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_nextheader.match(match_value.nextheader(), legacy)){
TTCN_Logger::log_logmatch_info(".nextheader");
single_value->field_nextheader.log_match(match_value.nextheader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.payload().ispresent()){
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_payload.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".payload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_payload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ nextheader := ");
single_value->field_nextheader.log_match(match_value.nextheader(), legacy);
TTCN_Logger::log_event_str(", header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", payload := ");
if (match_value.payload().ispresent()) single_value->field_payload.log_match(match_value.payload(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_payload.log();
if (single_value->field_payload.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtBtpReq_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_nextheader.encode_text(text_buf);
single_value->field_header.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpReq.");
}
}

void ExtBtpReq_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_nextheader.decode_text(text_buf);
single_value->field_header.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtBtpReq_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtBtpReq.");
}
}

void ExtBtpReq_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtBtpReq'");
    }
    if (strcmp("nextheader", param_field) == 0) {
      nextheader().set_param(param);
      return;
    } else if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtBtpReq'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtBtpReq_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtBtpReq has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nextheader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextheader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextheader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtBtpReq: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtBtpReq");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtBtpReq_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtBtpReq'");
    }
    if (strcmp("nextheader", param_field) == 0) {
      return nextheader().get_param(param_name);
    } else if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtBtpReq'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_nextheader = single_value->field_nextheader.get_param(param_name);
    mp_field_nextheader->set_id(new Module_Param_FieldName(mcopystr("nextheader")));
    mp->add_elem(mp_field_nextheader);
    Module_Param* mp_field_header = single_value->field_header.get_param(param_name);
    mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
    mp->add_elem(mp_field_header);
    Module_Param* mp_field_payload = single_value->field_payload.get_param(param_name);
    mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
    mp->add_elem(mp_field_payload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtBtpReq_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_nextheader.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtBtpReq");
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtBtpReq");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtBtpReq");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtBtpReq");
}

boolean ExtBtpReq_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtBtpReq_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtBtpInd::ExtBtpInd()
{
  bound_flag = FALSE;
}

ExtBtpInd::ExtBtpInd(const OCTETSTRING& par_nextheader,
    const LibItsBtp__TypesAndValues::BtpHeader& par_header,
    const OPTIONAL<OCTETSTRING>& par_rawPayload)
  :   field_nextheader(par_nextheader),
  field_header(par_header),
  field_rawPayload(par_rawPayload)
{
  bound_flag = TRUE;
}

ExtBtpInd::ExtBtpInd(const ExtBtpInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtBtpInd.");
bound_flag = TRUE;
if (other_value.nextheader().is_bound()) field_nextheader = other_value.nextheader();
else field_nextheader.clean_up();
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
else field_rawPayload.clean_up();
}

void ExtBtpInd::clean_up()
{
field_nextheader.clean_up();
field_header.clean_up();
field_rawPayload.clean_up();
bound_flag = FALSE;
}

ExtBtpInd& ExtBtpInd::operator=(const ExtBtpInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtBtpInd.");
  bound_flag = TRUE;
  if (other_value.nextheader().is_bound()) field_nextheader = other_value.nextheader();
  else field_nextheader.clean_up();
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
  else field_rawPayload.clean_up();
}
return *this;
}

boolean ExtBtpInd::operator==(const ExtBtpInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_nextheader==other_value.field_nextheader
  && field_header==other_value.field_header
  && field_rawPayload==other_value.field_rawPayload;
}

boolean ExtBtpInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_nextheader.is_bound()) return TRUE;
if(field_header.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_rawPayload.get_selection() || field_rawPayload.is_bound()) return TRUE;
return FALSE;
}
boolean ExtBtpInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_nextheader.is_value()) return FALSE;
if(!field_header.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_rawPayload.get_selection() && !field_rawPayload.is_value()) return FALSE;
return TRUE;
}
int ExtBtpInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtBtpInd");
  int ret_val = 2;
  if (field_rawPayload.ispresent()) ret_val++;
  return ret_val;
}

void ExtBtpInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ nextheader := ");
field_nextheader.log();
TTCN_Logger::log_event_str(", header := ");
field_header.log();
TTCN_Logger::log_event_str(", rawPayload := ");
field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
}

void ExtBtpInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtBtpInd'");
    }
    if (strcmp("nextheader", param_field) == 0) {
      nextheader().set_param(param);
      return;
    } else if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtBtpInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtBtpInd has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nextheader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextheader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextheader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtBtpInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtBtpInd");
  }
}

Module_Param* ExtBtpInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtBtpInd'");
    }
    if (strcmp("nextheader", param_field) == 0) {
      return nextheader().get_param(param_name);
    } else if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtBtpInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_nextheader = field_nextheader.get_param(param_name);
  mp_field_nextheader->set_id(new Module_Param_FieldName(mcopystr("nextheader")));
  mp->add_elem(mp_field_nextheader);
  Module_Param* mp_field_header = field_header.get_param(param_name);
  mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
  mp->add_elem(mp_field_header);
  Module_Param* mp_field_rawPayload = field_rawPayload.get_param(param_name);
  mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
  mp->add_elem(mp_field_rawPayload);
  return mp;
  }

void ExtBtpInd::set_implicit_omit()
{
if (nextheader().is_bound()) nextheader().set_implicit_omit();
if (header().is_bound()) header().set_implicit_omit();
if (!rawPayload().is_bound()) rawPayload() = OMIT_VALUE;
else rawPayload().set_implicit_omit();
}

void ExtBtpInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtBtpInd.");
field_nextheader.encode_text(text_buf);
field_header.encode_text(text_buf);
field_rawPayload.encode_text(text_buf);
}

void ExtBtpInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_nextheader.decode_text(text_buf);
field_header.decode_text(text_buf);
field_rawPayload.decode_text(text_buf);
}

void ExtBtpInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtBtpInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtBtpInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  int selected_field = -1;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_nextheader.RAW_decode(General__Types::OCT1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (field_nextheader ==  os_0) selected_field = 0;
  else if (field_nextheader ==  os_1) selected_field = 1;
  else selected_field = -1;
  decoded_field_length = field_header.RAW_decode(ExtBtpInd_header_descr_, p_buf, limit, local_top_order, no_err, selected_field);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_rawPayload().RAW_decode(OCTETSTRING_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_rawPayload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_rawPayload=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtBtpInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, General__Types::OCT1_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ExtBtpInd_header_descr_.raw);
  if (field_rawPayload.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, OCTETSTRING_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  encoded_length += field_nextheader.RAW_encode(General__Types::OCT1_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_header.RAW_encode(ExtBtpInd_header_descr_, *myleaf.body.node.nodes[1]);
  if (field_rawPayload.ispresent()) {
  encoded_length += field_rawPayload().RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[2]);
  }
  switch (field_header.get_selection()) {
  case LibItsBtp__TypesAndValues::BtpHeader::ALT_btpAHeader:
  if (field_nextheader !=  os_0) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
     os_0.RAW_encode(General__Types::OCT1_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsBtp__TypesAndValues::BtpHeader::ALT_btpBHeader:
  if (field_nextheader !=  os_1) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
     os_1.RAW_encode(General__Types::OCT1_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  default:;
  }
  return myleaf.length = encoded_length;
}

int ExtBtpInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtBtpInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nextheader");
    enc_len += field_nextheader.JSON_encode(General__Types::OCT1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header");
    enc_len += field_header.JSON_encode(ExtBtpInd_header_descr_, p_tok);
  }

  if (field_rawPayload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rawPayload");
    enc_len += field_rawPayload.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtBtpInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "nextheader", name_len)) {
         int ret_val = field_nextheader.JSON_decode(General__Types::OCT1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nextheader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "header", name_len)) {
         int ret_val = field_header.JSON_decode(ExtBtpInd_header_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "rawPayload", name_len)) {
         int ret_val = field_rawPayload.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rawPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_nextheader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nextheader");
    return JSON_ERROR_FATAL;
  }
if (!field_header.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header");
    return JSON_ERROR_FATAL;
  }
if (!field_rawPayload.is_bound()) {
    field_rawPayload = OMIT_VALUE;
  }

  return dec_len;
}

struct ExtBtpInd_template::single_value_struct {
OCTETSTRING_template field_nextheader;
LibItsBtp__TypesAndValues::BtpHeader_template field_header;
OCTETSTRING_template field_rawPayload;
};

void ExtBtpInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_nextheader = ANY_VALUE;
single_value->field_header = ANY_VALUE;
single_value->field_rawPayload = ANY_OR_OMIT;
}
}
}

void ExtBtpInd_template::copy_value(const ExtBtpInd& other_value)
{
single_value = new single_value_struct;
if (other_value.nextheader().is_bound()) {
  single_value->field_nextheader = other_value.nextheader();
} else {
  single_value->field_nextheader.clean_up();
}
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.rawPayload().is_bound()) {
  if (other_value.rawPayload().ispresent()) single_value->field_rawPayload = other_value.rawPayload()();
  else single_value->field_rawPayload = OMIT_VALUE;
} else {
  single_value->field_rawPayload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtBtpInd_template::copy_template(const ExtBtpInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.nextheader().get_selection()) {
single_value->field_nextheader = other_value.nextheader();
} else {
single_value->field_nextheader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rawPayload().get_selection()) {
single_value->field_rawPayload = other_value.rawPayload();
} else {
single_value->field_rawPayload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtBtpInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpInd.");
break;
}
set_selection(other_value);
}

ExtBtpInd_template::ExtBtpInd_template()
{
}

ExtBtpInd_template::ExtBtpInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtBtpInd_template::ExtBtpInd_template(const ExtBtpInd& other_value)
{
copy_value(other_value);
}

ExtBtpInd_template::ExtBtpInd_template(const OPTIONAL<ExtBtpInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtBtpInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtBtpInd from an unbound optional field.");
}
}

ExtBtpInd_template::ExtBtpInd_template(const ExtBtpInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtBtpInd_template::~ExtBtpInd_template()
{
clean_up();
}

ExtBtpInd_template& ExtBtpInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtBtpInd_template& ExtBtpInd_template::operator=(const ExtBtpInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtBtpInd_template& ExtBtpInd_template::operator=(const OPTIONAL<ExtBtpInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtBtpInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtBtpInd.");
}
return *this;
}

ExtBtpInd_template& ExtBtpInd_template::operator=(const ExtBtpInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtBtpInd_template::match(const ExtBtpInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.nextheader().is_bound()) return FALSE;
if(!single_value->field_nextheader.match(other_value.nextheader(), legacy))return FALSE;
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.rawPayload().is_bound()) return FALSE;
if((other_value.rawPayload().ispresent() ? !single_value->field_rawPayload.match((const OCTETSTRING&)other_value.rawPayload(), legacy) : !single_value->field_rawPayload.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpInd.");
}
return FALSE;
}

boolean ExtBtpInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_nextheader.is_bound()) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_rawPayload.is_omit() || single_value->field_rawPayload.is_bound()) return TRUE;
return FALSE;
}

boolean ExtBtpInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_nextheader.is_value()) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_rawPayload.is_omit() && !single_value->field_rawPayload.is_value()) return FALSE;
return TRUE;
}

void ExtBtpInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtBtpInd ExtBtpInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtBtpInd.");
ExtBtpInd ret_val;
if (single_value->field_nextheader.is_bound()) {
ret_val.nextheader() = single_value->field_nextheader.valueof();
}
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_rawPayload.is_omit()) ret_val.rawPayload() = OMIT_VALUE;
else if (single_value->field_rawPayload.is_bound()) {
ret_val.rawPayload() = single_value->field_rawPayload.valueof();
}
return ret_val;
}

void ExtBtpInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtBtpInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtBtpInd_template[list_length];
}

ExtBtpInd_template& ExtBtpInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtBtpInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtBtpInd.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& ExtBtpInd_template::nextheader()
{
set_specific();
return single_value->field_nextheader;
}

const OCTETSTRING_template& ExtBtpInd_template::nextheader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nextheader of a non-specific template of type @TTCN_EncDec.ExtBtpInd.");
return single_value->field_nextheader;
}

LibItsBtp__TypesAndValues::BtpHeader_template& ExtBtpInd_template::header()
{
set_specific();
return single_value->field_header;
}

const LibItsBtp__TypesAndValues::BtpHeader_template& ExtBtpInd_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @TTCN_EncDec.ExtBtpInd.");
return single_value->field_header;
}

OCTETSTRING_template& ExtBtpInd_template::rawPayload()
{
set_specific();
return single_value->field_rawPayload;
}

const OCTETSTRING_template& ExtBtpInd_template::rawPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawPayload of a non-specific template of type @TTCN_EncDec.ExtBtpInd.");
return single_value->field_rawPayload;
}

int ExtBtpInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_rawPayload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtBtpInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpInd.");
  }
  return 0;
}

void ExtBtpInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ nextheader := ");
single_value->field_nextheader.log();
TTCN_Logger::log_event_str(", header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", rawPayload := ");
single_value->field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtBtpInd_template::log_match(const ExtBtpInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_nextheader.match(match_value.nextheader(), legacy)){
TTCN_Logger::log_logmatch_info(".nextheader");
single_value->field_nextheader.log_match(match_value.nextheader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.rawPayload().ispresent()){
if(!single_value->field_rawPayload.match(match_value.rawPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".rawPayload");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_rawPayload.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".rawPayload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_rawPayload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ nextheader := ");
single_value->field_nextheader.log_match(match_value.nextheader(), legacy);
TTCN_Logger::log_event_str(", header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", rawPayload := ");
if (match_value.rawPayload().ispresent()) single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_rawPayload.log();
if (single_value->field_rawPayload.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtBtpInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_nextheader.encode_text(text_buf);
single_value->field_header.encode_text(text_buf);
single_value->field_rawPayload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtBtpInd.");
}
}

void ExtBtpInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_nextheader.decode_text(text_buf);
single_value->field_header.decode_text(text_buf);
single_value->field_rawPayload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtBtpInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtBtpInd.");
}
}

void ExtBtpInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtBtpInd'");
    }
    if (strcmp("nextheader", param_field) == 0) {
      nextheader().set_param(param);
      return;
    } else if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtBtpInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtBtpInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtBtpInd has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nextheader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextheader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextheader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtBtpInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtBtpInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtBtpInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtBtpInd'");
    }
    if (strcmp("nextheader", param_field) == 0) {
      return nextheader().get_param(param_name);
    } else if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtBtpInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_nextheader = single_value->field_nextheader.get_param(param_name);
    mp_field_nextheader->set_id(new Module_Param_FieldName(mcopystr("nextheader")));
    mp->add_elem(mp_field_nextheader);
    Module_Param* mp_field_header = single_value->field_header.get_param(param_name);
    mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
    mp->add_elem(mp_field_header);
    Module_Param* mp_field_rawPayload = single_value->field_rawPayload.get_param(param_name);
    mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
    mp->add_elem(mp_field_rawPayload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtBtpInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_nextheader.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtBtpInd");
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtBtpInd");
single_value->field_rawPayload.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtBtpInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtBtpInd");
}

boolean ExtBtpInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtBtpInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtCamInd::ExtCamInd()
{
  bound_flag = FALSE;
}

ExtCamInd::ExtCamInd(const INTEGER& par_gnNextHeader,
    const INTEGER& par_gnHeaderType,
    const INTEGER& par_gnHeaderSubtype,
    const INTEGER& par_gnLifetime,
    const INTEGER& par_gnTrafficClass,
    const INTEGER& par_btpDestinationPort,
    const INTEGER& par_btpInfo)
  :   field_gnNextHeader(par_gnNextHeader),
  field_gnHeaderType(par_gnHeaderType),
  field_gnHeaderSubtype(par_gnHeaderSubtype),
  field_gnLifetime(par_gnLifetime),
  field_gnTrafficClass(par_gnTrafficClass),
  field_btpDestinationPort(par_btpDestinationPort),
  field_btpInfo(par_btpInfo)
{
  bound_flag = TRUE;
}

ExtCamInd::ExtCamInd(const ExtCamInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtCamInd.");
bound_flag = TRUE;
if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
else field_gnNextHeader.clean_up();
if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
else field_gnHeaderType.clean_up();
if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
else field_gnHeaderSubtype.clean_up();
if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
else field_gnLifetime.clean_up();
if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
else field_gnTrafficClass.clean_up();
if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
else field_btpDestinationPort.clean_up();
if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
else field_btpInfo.clean_up();
}

void ExtCamInd::clean_up()
{
field_gnNextHeader.clean_up();
field_gnHeaderType.clean_up();
field_gnHeaderSubtype.clean_up();
field_gnLifetime.clean_up();
field_gnTrafficClass.clean_up();
field_btpDestinationPort.clean_up();
field_btpInfo.clean_up();
bound_flag = FALSE;
}

ExtCamInd& ExtCamInd::operator=(const ExtCamInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtCamInd.");
  bound_flag = TRUE;
  if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
  else field_gnNextHeader.clean_up();
  if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
  else field_gnHeaderType.clean_up();
  if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
  else field_gnHeaderSubtype.clean_up();
  if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
  else field_gnLifetime.clean_up();
  if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
  else field_gnTrafficClass.clean_up();
  if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
  else field_btpDestinationPort.clean_up();
  if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
  else field_btpInfo.clean_up();
}
return *this;
}

boolean ExtCamInd::operator==(const ExtCamInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_gnNextHeader==other_value.field_gnNextHeader
  && field_gnHeaderType==other_value.field_gnHeaderType
  && field_gnHeaderSubtype==other_value.field_gnHeaderSubtype
  && field_gnLifetime==other_value.field_gnLifetime
  && field_gnTrafficClass==other_value.field_gnTrafficClass
  && field_btpDestinationPort==other_value.field_btpDestinationPort
  && field_btpInfo==other_value.field_btpInfo;
}

boolean ExtCamInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_gnNextHeader.is_bound()) return TRUE;
if(field_gnHeaderType.is_bound()) return TRUE;
if(field_gnHeaderSubtype.is_bound()) return TRUE;
if(field_gnLifetime.is_bound()) return TRUE;
if(field_gnTrafficClass.is_bound()) return TRUE;
if(field_btpDestinationPort.is_bound()) return TRUE;
if(field_btpInfo.is_bound()) return TRUE;
return FALSE;
}
boolean ExtCamInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_gnNextHeader.is_value()) return FALSE;
if(!field_gnHeaderType.is_value()) return FALSE;
if(!field_gnHeaderSubtype.is_value()) return FALSE;
if(!field_gnLifetime.is_value()) return FALSE;
if(!field_gnTrafficClass.is_value()) return FALSE;
if(!field_btpDestinationPort.is_value()) return FALSE;
if(!field_btpInfo.is_value()) return FALSE;
return TRUE;
}
int ExtCamInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtCamInd");
  return 7;
}

void ExtCamInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ gnNextHeader := ");
field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
}

void ExtCamInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtCamInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtCamInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtCamInd has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtCamInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtCamInd");
  }
}

Module_Param* ExtCamInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtCamInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtCamInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_gnNextHeader = field_gnNextHeader.get_param(param_name);
  mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
  mp->add_elem(mp_field_gnNextHeader);
  Module_Param* mp_field_gnHeaderType = field_gnHeaderType.get_param(param_name);
  mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
  mp->add_elem(mp_field_gnHeaderType);
  Module_Param* mp_field_gnHeaderSubtype = field_gnHeaderSubtype.get_param(param_name);
  mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
  mp->add_elem(mp_field_gnHeaderSubtype);
  Module_Param* mp_field_gnLifetime = field_gnLifetime.get_param(param_name);
  mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
  mp->add_elem(mp_field_gnLifetime);
  Module_Param* mp_field_gnTrafficClass = field_gnTrafficClass.get_param(param_name);
  mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
  mp->add_elem(mp_field_gnTrafficClass);
  Module_Param* mp_field_btpDestinationPort = field_btpDestinationPort.get_param(param_name);
  mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
  mp->add_elem(mp_field_btpDestinationPort);
  Module_Param* mp_field_btpInfo = field_btpInfo.get_param(param_name);
  mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
  mp->add_elem(mp_field_btpInfo);
  return mp;
  }

void ExtCamInd::set_implicit_omit()
{
if (gnNextHeader().is_bound()) gnNextHeader().set_implicit_omit();
if (gnHeaderType().is_bound()) gnHeaderType().set_implicit_omit();
if (gnHeaderSubtype().is_bound()) gnHeaderSubtype().set_implicit_omit();
if (gnLifetime().is_bound()) gnLifetime().set_implicit_omit();
if (gnTrafficClass().is_bound()) gnTrafficClass().set_implicit_omit();
if (btpDestinationPort().is_bound()) btpDestinationPort().set_implicit_omit();
if (btpInfo().is_bound()) btpInfo().set_implicit_omit();
}

void ExtCamInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtCamInd.");
field_gnNextHeader.encode_text(text_buf);
field_gnHeaderType.encode_text(text_buf);
field_gnHeaderSubtype.encode_text(text_buf);
field_gnLifetime.encode_text(text_buf);
field_gnTrafficClass.encode_text(text_buf);
field_btpDestinationPort.encode_text(text_buf);
field_btpInfo.encode_text(text_buf);
}

void ExtCamInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_gnNextHeader.decode_text(text_buf);
field_gnHeaderType.decode_text(text_buf);
field_gnHeaderSubtype.decode_text(text_buf);
field_gnLifetime.decode_text(text_buf);
field_gnTrafficClass.decode_text(text_buf);
field_btpDestinationPort.decode_text(text_buf);
field_btpInfo.decode_text(text_buf);
}

void ExtCamInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtCamInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtCamInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_gnNextHeader.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnHeaderType.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnHeaderSubtype.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnLifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnTrafficClass.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_btpDestinationPort.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_btpInfo.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtCamInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_gnNextHeader.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_gnHeaderType.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_gnHeaderSubtype.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_gnLifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_gnTrafficClass.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_btpDestinationPort.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_btpInfo.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[6]);
  return myleaf.length = encoded_length;
}

int ExtCamInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtCamInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnNextHeader");
    enc_len += field_gnNextHeader.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnHeaderType");
    enc_len += field_gnHeaderType.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnHeaderSubtype");
    enc_len += field_gnHeaderSubtype.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnLifetime");
    enc_len += field_gnLifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnTrafficClass");
    enc_len += field_gnTrafficClass.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpDestinationPort");
    enc_len += field_btpDestinationPort.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpInfo");
    enc_len += field_btpInfo.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtCamInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "gnNextHeader", name_len)) {
         int ret_val = field_gnNextHeader.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnNextHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "gnHeaderType", name_len)) {
         int ret_val = field_gnHeaderType.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnHeaderType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "gnHeaderSubtype", name_len)) {
         int ret_val = field_gnHeaderSubtype.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnHeaderSubtype");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "gnLifetime", name_len)) {
         int ret_val = field_gnLifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnLifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "gnTrafficClass", name_len)) {
         int ret_val = field_gnTrafficClass.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnTrafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "btpDestinationPort", name_len)) {
         int ret_val = field_btpDestinationPort.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpDestinationPort");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "btpInfo", name_len)) {
         int ret_val = field_btpInfo.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpInfo");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_gnNextHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnNextHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_gnHeaderType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnHeaderType");
    return JSON_ERROR_FATAL;
  }
if (!field_gnHeaderSubtype.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnHeaderSubtype");
    return JSON_ERROR_FATAL;
  }
if (!field_gnLifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnLifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_gnTrafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnTrafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_btpDestinationPort.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpDestinationPort");
    return JSON_ERROR_FATAL;
  }
if (!field_btpInfo.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpInfo");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtCamInd_template::single_value_struct {
INTEGER_template field_gnNextHeader;
INTEGER_template field_gnHeaderType;
INTEGER_template field_gnHeaderSubtype;
INTEGER_template field_gnLifetime;
INTEGER_template field_gnTrafficClass;
INTEGER_template field_btpDestinationPort;
INTEGER_template field_btpInfo;
};

void ExtCamInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_gnNextHeader = ANY_VALUE;
single_value->field_gnHeaderType = ANY_VALUE;
single_value->field_gnHeaderSubtype = ANY_VALUE;
single_value->field_gnLifetime = ANY_VALUE;
single_value->field_gnTrafficClass = ANY_VALUE;
single_value->field_btpDestinationPort = ANY_VALUE;
single_value->field_btpInfo = ANY_VALUE;
}
}
}

void ExtCamInd_template::copy_value(const ExtCamInd& other_value)
{
single_value = new single_value_struct;
if (other_value.gnNextHeader().is_bound()) {
  single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
  single_value->field_gnNextHeader.clean_up();
}
if (other_value.gnHeaderType().is_bound()) {
  single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
  single_value->field_gnHeaderType.clean_up();
}
if (other_value.gnHeaderSubtype().is_bound()) {
  single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
  single_value->field_gnHeaderSubtype.clean_up();
}
if (other_value.gnLifetime().is_bound()) {
  single_value->field_gnLifetime = other_value.gnLifetime();
} else {
  single_value->field_gnLifetime.clean_up();
}
if (other_value.gnTrafficClass().is_bound()) {
  single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
  single_value->field_gnTrafficClass.clean_up();
}
if (other_value.btpDestinationPort().is_bound()) {
  single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
  single_value->field_btpDestinationPort.clean_up();
}
if (other_value.btpInfo().is_bound()) {
  single_value->field_btpInfo = other_value.btpInfo();
} else {
  single_value->field_btpInfo.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtCamInd_template::copy_template(const ExtCamInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.gnNextHeader().get_selection()) {
single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
single_value->field_gnNextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderType().get_selection()) {
single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
single_value->field_gnHeaderType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderSubtype().get_selection()) {
single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
single_value->field_gnHeaderSubtype.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnLifetime().get_selection()) {
single_value->field_gnLifetime = other_value.gnLifetime();
} else {
single_value->field_gnLifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnTrafficClass().get_selection()) {
single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
single_value->field_gnTrafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpDestinationPort().get_selection()) {
single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
single_value->field_btpDestinationPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpInfo().get_selection()) {
single_value->field_btpInfo = other_value.btpInfo();
} else {
single_value->field_btpInfo.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtCamInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtCamInd.");
break;
}
set_selection(other_value);
}

ExtCamInd_template::ExtCamInd_template()
{
}

ExtCamInd_template::ExtCamInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtCamInd_template::ExtCamInd_template(const ExtCamInd& other_value)
{
copy_value(other_value);
}

ExtCamInd_template::ExtCamInd_template(const OPTIONAL<ExtCamInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtCamInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtCamInd from an unbound optional field.");
}
}

ExtCamInd_template::ExtCamInd_template(const ExtCamInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtCamInd_template::~ExtCamInd_template()
{
clean_up();
}

ExtCamInd_template& ExtCamInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtCamInd_template& ExtCamInd_template::operator=(const ExtCamInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtCamInd_template& ExtCamInd_template::operator=(const OPTIONAL<ExtCamInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtCamInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtCamInd.");
}
return *this;
}

ExtCamInd_template& ExtCamInd_template::operator=(const ExtCamInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtCamInd_template::match(const ExtCamInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.gnNextHeader().is_bound()) return FALSE;
if(!single_value->field_gnNextHeader.match(other_value.gnNextHeader(), legacy))return FALSE;
if(!other_value.gnHeaderType().is_bound()) return FALSE;
if(!single_value->field_gnHeaderType.match(other_value.gnHeaderType(), legacy))return FALSE;
if(!other_value.gnHeaderSubtype().is_bound()) return FALSE;
if(!single_value->field_gnHeaderSubtype.match(other_value.gnHeaderSubtype(), legacy))return FALSE;
if(!other_value.gnLifetime().is_bound()) return FALSE;
if(!single_value->field_gnLifetime.match(other_value.gnLifetime(), legacy))return FALSE;
if(!other_value.gnTrafficClass().is_bound()) return FALSE;
if(!single_value->field_gnTrafficClass.match(other_value.gnTrafficClass(), legacy))return FALSE;
if(!other_value.btpDestinationPort().is_bound()) return FALSE;
if(!single_value->field_btpDestinationPort.match(other_value.btpDestinationPort(), legacy))return FALSE;
if(!other_value.btpInfo().is_bound()) return FALSE;
if(!single_value->field_btpInfo.match(other_value.btpInfo(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtCamInd.");
}
return FALSE;
}

boolean ExtCamInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_gnNextHeader.is_bound()) return TRUE;
if (single_value->field_gnHeaderType.is_bound()) return TRUE;
if (single_value->field_gnHeaderSubtype.is_bound()) return TRUE;
if (single_value->field_gnLifetime.is_bound()) return TRUE;
if (single_value->field_gnTrafficClass.is_bound()) return TRUE;
if (single_value->field_btpDestinationPort.is_bound()) return TRUE;
if (single_value->field_btpInfo.is_bound()) return TRUE;
return FALSE;
}

boolean ExtCamInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_gnNextHeader.is_value()) return FALSE;
if (!single_value->field_gnHeaderType.is_value()) return FALSE;
if (!single_value->field_gnHeaderSubtype.is_value()) return FALSE;
if (!single_value->field_gnLifetime.is_value()) return FALSE;
if (!single_value->field_gnTrafficClass.is_value()) return FALSE;
if (!single_value->field_btpDestinationPort.is_value()) return FALSE;
if (!single_value->field_btpInfo.is_value()) return FALSE;
return TRUE;
}

void ExtCamInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtCamInd ExtCamInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtCamInd.");
ExtCamInd ret_val;
if (single_value->field_gnNextHeader.is_bound()) {
ret_val.gnNextHeader() = single_value->field_gnNextHeader.valueof();
}
if (single_value->field_gnHeaderType.is_bound()) {
ret_val.gnHeaderType() = single_value->field_gnHeaderType.valueof();
}
if (single_value->field_gnHeaderSubtype.is_bound()) {
ret_val.gnHeaderSubtype() = single_value->field_gnHeaderSubtype.valueof();
}
if (single_value->field_gnLifetime.is_bound()) {
ret_val.gnLifetime() = single_value->field_gnLifetime.valueof();
}
if (single_value->field_gnTrafficClass.is_bound()) {
ret_val.gnTrafficClass() = single_value->field_gnTrafficClass.valueof();
}
if (single_value->field_btpDestinationPort.is_bound()) {
ret_val.btpDestinationPort() = single_value->field_btpDestinationPort.valueof();
}
if (single_value->field_btpInfo.is_bound()) {
ret_val.btpInfo() = single_value->field_btpInfo.valueof();
}
return ret_val;
}

void ExtCamInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtCamInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtCamInd_template[list_length];
}

ExtCamInd_template& ExtCamInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtCamInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtCamInd.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtCamInd_template::gnNextHeader()
{
set_specific();
return single_value->field_gnNextHeader;
}

const INTEGER_template& ExtCamInd_template::gnNextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnNextHeader of a non-specific template of type @TTCN_EncDec.ExtCamInd.");
return single_value->field_gnNextHeader;
}

INTEGER_template& ExtCamInd_template::gnHeaderType()
{
set_specific();
return single_value->field_gnHeaderType;
}

const INTEGER_template& ExtCamInd_template::gnHeaderType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderType of a non-specific template of type @TTCN_EncDec.ExtCamInd.");
return single_value->field_gnHeaderType;
}

INTEGER_template& ExtCamInd_template::gnHeaderSubtype()
{
set_specific();
return single_value->field_gnHeaderSubtype;
}

const INTEGER_template& ExtCamInd_template::gnHeaderSubtype() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderSubtype of a non-specific template of type @TTCN_EncDec.ExtCamInd.");
return single_value->field_gnHeaderSubtype;
}

INTEGER_template& ExtCamInd_template::gnLifetime()
{
set_specific();
return single_value->field_gnLifetime;
}

const INTEGER_template& ExtCamInd_template::gnLifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnLifetime of a non-specific template of type @TTCN_EncDec.ExtCamInd.");
return single_value->field_gnLifetime;
}

INTEGER_template& ExtCamInd_template::gnTrafficClass()
{
set_specific();
return single_value->field_gnTrafficClass;
}

const INTEGER_template& ExtCamInd_template::gnTrafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnTrafficClass of a non-specific template of type @TTCN_EncDec.ExtCamInd.");
return single_value->field_gnTrafficClass;
}

INTEGER_template& ExtCamInd_template::btpDestinationPort()
{
set_specific();
return single_value->field_btpDestinationPort;
}

const INTEGER_template& ExtCamInd_template::btpDestinationPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpDestinationPort of a non-specific template of type @TTCN_EncDec.ExtCamInd.");
return single_value->field_btpDestinationPort;
}

INTEGER_template& ExtCamInd_template::btpInfo()
{
set_specific();
return single_value->field_btpInfo;
}

const INTEGER_template& ExtCamInd_template::btpInfo() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpInfo of a non-specific template of type @TTCN_EncDec.ExtCamInd.");
return single_value->field_btpInfo;
}

int ExtCamInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtCamInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 7;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtCamInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtCamInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtCamInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtCamInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtCamInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtCamInd.");
  }
  return 0;
}

void ExtCamInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ gnNextHeader := ");
single_value->field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtCamInd_template::log_match(const ExtCamInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_gnNextHeader.match(match_value.gnNextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".gnNextHeader");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnHeaderType.match(match_value.gnHeaderType(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderType");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnHeaderSubtype.match(match_value.gnHeaderSubtype(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderSubtype");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnLifetime.match(match_value.gnLifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".gnLifetime");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnTrafficClass.match(match_value.gnTrafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".gnTrafficClass");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_btpDestinationPort.match(match_value.btpDestinationPort(), legacy)){
TTCN_Logger::log_logmatch_info(".btpDestinationPort");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_btpInfo.match(match_value.btpInfo(), legacy)){
TTCN_Logger::log_logmatch_info(".btpInfo");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ gnNextHeader := ");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtCamInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_gnNextHeader.encode_text(text_buf);
single_value->field_gnHeaderType.encode_text(text_buf);
single_value->field_gnHeaderSubtype.encode_text(text_buf);
single_value->field_gnLifetime.encode_text(text_buf);
single_value->field_gnTrafficClass.encode_text(text_buf);
single_value->field_btpDestinationPort.encode_text(text_buf);
single_value->field_btpInfo.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtCamInd.");
}
}

void ExtCamInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_gnNextHeader.decode_text(text_buf);
single_value->field_gnHeaderType.decode_text(text_buf);
single_value->field_gnHeaderSubtype.decode_text(text_buf);
single_value->field_gnLifetime.decode_text(text_buf);
single_value->field_gnTrafficClass.decode_text(text_buf);
single_value->field_btpDestinationPort.decode_text(text_buf);
single_value->field_btpInfo.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtCamInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtCamInd.");
}
}

void ExtCamInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtCamInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtCamInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtCamInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtCamInd has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtCamInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtCamInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtCamInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtCamInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtCamInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_gnNextHeader = single_value->field_gnNextHeader.get_param(param_name);
    mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
    mp->add_elem(mp_field_gnNextHeader);
    Module_Param* mp_field_gnHeaderType = single_value->field_gnHeaderType.get_param(param_name);
    mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
    mp->add_elem(mp_field_gnHeaderType);
    Module_Param* mp_field_gnHeaderSubtype = single_value->field_gnHeaderSubtype.get_param(param_name);
    mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
    mp->add_elem(mp_field_gnHeaderSubtype);
    Module_Param* mp_field_gnLifetime = single_value->field_gnLifetime.get_param(param_name);
    mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
    mp->add_elem(mp_field_gnLifetime);
    Module_Param* mp_field_gnTrafficClass = single_value->field_gnTrafficClass.get_param(param_name);
    mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
    mp->add_elem(mp_field_gnTrafficClass);
    Module_Param* mp_field_btpDestinationPort = single_value->field_btpDestinationPort.get_param(param_name);
    mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
    mp->add_elem(mp_field_btpDestinationPort);
    Module_Param* mp_field_btpInfo = single_value->field_btpInfo.get_param(param_name);
    mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
    mp->add_elem(mp_field_btpInfo);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtCamInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_gnNextHeader.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtCamInd");
single_value->field_gnHeaderType.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtCamInd");
single_value->field_gnHeaderSubtype.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtCamInd");
single_value->field_gnLifetime.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtCamInd");
single_value->field_gnTrafficClass.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtCamInd");
single_value->field_btpDestinationPort.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtCamInd");
single_value->field_btpInfo.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtCamInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtCamInd");
}

boolean ExtCamInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtCamInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MapSpatInd::copy_value(const MapSpatInd& other_value)
{
switch (other_value.union_selection) {
case ALT_mapInd:
field_mapInd = new LibItsMapSpat__TestSystem::MapInd(*other_value.field_mapInd);
break;
case ALT_spatInd:
field_spatInd = new LibItsMapSpat__TestSystem::SpatInd(*other_value.field_spatInd);
break;
default:
TTCN_error("Assignment of an unbound union value of type @TTCN_EncDec.MapSpatInd.");
}
union_selection = other_value.union_selection;
}

MapSpatInd::MapSpatInd()
{
union_selection = UNBOUND_VALUE;
}

MapSpatInd::MapSpatInd(const MapSpatInd& other_value)
: Base_Type(){
copy_value(other_value);
}

MapSpatInd::~MapSpatInd()
{
clean_up();
}

MapSpatInd& MapSpatInd::operator=(const MapSpatInd& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean MapSpatInd::operator==(const MapSpatInd& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @TTCN_EncDec.MapSpatInd.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @TTCN_EncDec.MapSpatInd.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_mapInd:
return *field_mapInd == *other_value.field_mapInd;
case ALT_spatInd:
return *field_spatInd == *other_value.field_spatInd;
default:
return FALSE;
}
}

LibItsMapSpat__TestSystem::MapInd& MapSpatInd::mapInd()
{
if (union_selection != ALT_mapInd) {
clean_up();
field_mapInd = new LibItsMapSpat__TestSystem::MapInd;
union_selection = ALT_mapInd;
}
return *field_mapInd;
}

const LibItsMapSpat__TestSystem::MapInd& MapSpatInd::mapInd() const
{
if (union_selection != ALT_mapInd) TTCN_error("Using non-selected field mapInd in a value of union type @TTCN_EncDec.MapSpatInd.");
return *field_mapInd;
}

LibItsMapSpat__TestSystem::SpatInd& MapSpatInd::spatInd()
{
if (union_selection != ALT_spatInd) {
clean_up();
field_spatInd = new LibItsMapSpat__TestSystem::SpatInd;
union_selection = ALT_spatInd;
}
return *field_spatInd;
}

const LibItsMapSpat__TestSystem::SpatInd& MapSpatInd::spatInd() const
{
if (union_selection != ALT_spatInd) TTCN_error("Using non-selected field spatInd in a value of union type @TTCN_EncDec.MapSpatInd.");
return *field_spatInd;
}

boolean MapSpatInd::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @TTCN_EncDec.MapSpatInd.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @TTCN_EncDec.MapSpatInd.");
return union_selection == checked_selection;
}

boolean MapSpatInd::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean MapSpatInd::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_mapInd: return field_mapInd->is_value();
case ALT_spatInd: return field_spatInd->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void MapSpatInd::clean_up()
{
switch (union_selection) {
case ALT_mapInd:
  delete field_mapInd;
  break;
case ALT_spatInd:
  delete field_spatInd;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void MapSpatInd::log() const
{
switch (union_selection) {
case ALT_mapInd:
TTCN_Logger::log_event_str("{ mapInd := ");
field_mapInd->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_spatInd:
TTCN_Logger::log_event_str("{ spatInd := ");
field_spatInd->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void MapSpatInd::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@TTCN_EncDec.MapSpatInd'");
    }
    if (strcmp("mapInd", param_field) == 0) {
      mapInd().set_param(param);
      return;
    } else if (strcmp("spatInd", param_field) == 0) {
      spatInd().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@TTCN_EncDec.MapSpatInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "mapInd")) {
    mapInd().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "spatInd")) {
    spatInd().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @TTCN_EncDec.MapSpatInd.", mp_last->get_id()->get_name());
}

Module_Param* MapSpatInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@TTCN_EncDec.MapSpatInd'");
    }
    if (strcmp("mapInd", param_field) == 0) {
      return mapInd().get_param(param_name);
    } else if (strcmp("spatInd", param_field) == 0) {
      return spatInd().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `MapSpatInd'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_mapInd:
    mp_field = field_mapInd->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("mapInd")));
    break;
  case ALT_spatInd:
    mp_field = field_spatInd->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("spatInd")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void MapSpatInd::set_implicit_omit()
{
switch (union_selection) {
case ALT_mapInd:
field_mapInd->set_implicit_omit(); break;
case ALT_spatInd:
field_spatInd->set_implicit_omit(); break;
default: break;
}
}

void MapSpatInd::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_mapInd:
field_mapInd->encode_text(text_buf);
break;
case ALT_spatInd:
field_spatInd->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @TTCN_EncDec.MapSpatInd.");
}
}

void MapSpatInd::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_mapInd:
mapInd().decode_text(text_buf);
break;
case ALT_spatInd:
spatInd().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @TTCN_EncDec.MapSpatInd.");
}
}

void MapSpatInd_template::copy_value(const MapSpatInd& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case MapSpatInd::ALT_mapInd:
single_value.field_mapInd = new LibItsMapSpat__TestSystem::MapInd_template(other_value.mapInd());
break;
case MapSpatInd::ALT_spatInd:
single_value.field_spatInd = new LibItsMapSpat__TestSystem::SpatInd_template(other_value.spatInd());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @TTCN_EncDec.MapSpatInd.");
}
set_selection(SPECIFIC_VALUE);
}

void MapSpatInd_template::copy_template(const MapSpatInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case MapSpatInd::ALT_mapInd:
single_value.field_mapInd = new LibItsMapSpat__TestSystem::MapInd_template(*other_value.single_value.field_mapInd);
break;
case MapSpatInd::ALT_spatInd:
single_value.field_spatInd = new LibItsMapSpat__TestSystem::SpatInd_template(*other_value.single_value.field_spatInd);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @TTCN_EncDec.MapSpatInd.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MapSpatInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @TTCN_EncDec.MapSpatInd.");
}
set_selection(other_value);
}

MapSpatInd_template::MapSpatInd_template()
{
}

MapSpatInd_template::MapSpatInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MapSpatInd_template::MapSpatInd_template(const MapSpatInd& other_value)
{
copy_value(other_value);
}

MapSpatInd_template::MapSpatInd_template(const OPTIONAL<MapSpatInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapSpatInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @TTCN_EncDec.MapSpatInd from an unbound optional field.");
}
}

MapSpatInd_template::MapSpatInd_template(const MapSpatInd_template& other_value)
: Base_Template(){
copy_template(other_value);
}

MapSpatInd_template::~MapSpatInd_template()
{
clean_up();
}

void MapSpatInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case MapSpatInd::ALT_mapInd:
delete single_value.field_mapInd;
break;
case MapSpatInd::ALT_spatInd:
delete single_value.field_spatInd;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MapSpatInd_template& MapSpatInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MapSpatInd_template& MapSpatInd_template::operator=(const MapSpatInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MapSpatInd_template& MapSpatInd_template::operator=(const OPTIONAL<MapSpatInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapSpatInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @TTCN_EncDec.MapSpatInd.");
}
return *this;
}

MapSpatInd_template& MapSpatInd_template::operator=(const MapSpatInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MapSpatInd_template::match(const MapSpatInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
MapSpatInd::union_selection_type value_selection = other_value.get_selection();
if (value_selection == MapSpatInd::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case MapSpatInd::ALT_mapInd:
return single_value.field_mapInd->match(other_value.mapInd(), legacy);
case MapSpatInd::ALT_spatInd:
return single_value.field_spatInd->match(other_value.spatInd(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @TTCN_EncDec.MapSpatInd.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @TTCN_EncDec.MapSpatInd.");
}
return FALSE;
}

boolean MapSpatInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case MapSpatInd::ALT_mapInd:
return single_value.field_mapInd->is_value();
case MapSpatInd::ALT_spatInd:
return single_value.field_spatInd->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TTCN_EncDec.MapSpatInd.");
}
}

MapSpatInd MapSpatInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @TTCN_EncDec.MapSpatInd.");
MapSpatInd ret_val;
switch (single_value.union_selection) {
case MapSpatInd::ALT_mapInd:
ret_val.mapInd() = single_value.field_mapInd->valueof();
break;
case MapSpatInd::ALT_spatInd:
ret_val.spatInd() = single_value.field_spatInd->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TTCN_EncDec.MapSpatInd.");
}
return ret_val;
}

MapSpatInd_template& MapSpatInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @TTCN_EncDec.MapSpatInd.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @TTCN_EncDec.MapSpatInd.");
return value_list.list_value[list_index];
}
void MapSpatInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @TTCN_EncDec.MapSpatInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MapSpatInd_template[list_length];
}

LibItsMapSpat__TestSystem::MapInd_template& MapSpatInd_template::mapInd()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MapSpatInd::ALT_mapInd) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_mapInd = new LibItsMapSpat__TestSystem::MapInd_template(ANY_VALUE);
else single_value.field_mapInd = new LibItsMapSpat__TestSystem::MapInd_template;
single_value.union_selection = MapSpatInd::ALT_mapInd;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_mapInd;
}

const LibItsMapSpat__TestSystem::MapInd_template& MapSpatInd_template::mapInd() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field mapInd in a non-specific template of union type @TTCN_EncDec.MapSpatInd.");
if (single_value.union_selection != MapSpatInd::ALT_mapInd) TTCN_error("Accessing non-selected field mapInd in a template of union type @TTCN_EncDec.MapSpatInd.");
return *single_value.field_mapInd;
}

LibItsMapSpat__TestSystem::SpatInd_template& MapSpatInd_template::spatInd()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MapSpatInd::ALT_spatInd) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_spatInd = new LibItsMapSpat__TestSystem::SpatInd_template(ANY_VALUE);
else single_value.field_spatInd = new LibItsMapSpat__TestSystem::SpatInd_template;
single_value.union_selection = MapSpatInd::ALT_spatInd;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_spatInd;
}

const LibItsMapSpat__TestSystem::SpatInd_template& MapSpatInd_template::spatInd() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field spatInd in a non-specific template of union type @TTCN_EncDec.MapSpatInd.");
if (single_value.union_selection != MapSpatInd::ALT_spatInd) TTCN_error("Accessing non-selected field spatInd in a template of union type @TTCN_EncDec.MapSpatInd.");
return *single_value.field_spatInd;
}

boolean MapSpatInd_template::ischosen(MapSpatInd::union_selection_type checked_selection) const
{
if (checked_selection == MapSpatInd::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @TTCN_EncDec.MapSpatInd.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == MapSpatInd::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TTCN_EncDec.MapSpatInd.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @TTCN_EncDec.MapSpatInd containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @TTCN_EncDec.MapSpatInd, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @TTCN_EncDec.MapSpatInd");
}
return FALSE;
}

void MapSpatInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case MapSpatInd::ALT_mapInd:
TTCN_Logger::log_event_str("{ mapInd := ");
single_value.field_mapInd->log();
TTCN_Logger::log_event_str(" }");
break;
case MapSpatInd::ALT_spatInd:
TTCN_Logger::log_event_str("{ spatInd := ");
single_value.field_spatInd->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MapSpatInd_template::log_match(const MapSpatInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case MapSpatInd::ALT_mapInd:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".mapInd");
single_value.field_mapInd->log_match(match_value.mapInd(), legacy);
} else {
TTCN_Logger::log_event_str("{ mapInd := ");
single_value.field_mapInd->log_match(match_value.mapInd(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MapSpatInd::ALT_spatInd:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".spatInd");
single_value.field_spatInd->log_match(match_value.spatInd(), legacy);
} else {
TTCN_Logger::log_event_str("{ spatInd := ");
single_value.field_spatInd->log_match(match_value.spatInd(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MapSpatInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case MapSpatInd::ALT_mapInd:
single_value.field_mapInd->encode_text(text_buf);
break;
case MapSpatInd::ALT_spatInd:
single_value.field_spatInd->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @TTCN_EncDec.MapSpatInd.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @TTCN_EncDec.MapSpatInd.");
}
}

void MapSpatInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = MapSpatInd::UNBOUND_VALUE;
MapSpatInd::union_selection_type new_selection = (MapSpatInd::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case MapSpatInd::ALT_mapInd:
single_value.field_mapInd = new LibItsMapSpat__TestSystem::MapInd_template;
single_value.field_mapInd->decode_text(text_buf);
break;
case MapSpatInd::ALT_spatInd:
single_value.field_spatInd = new LibItsMapSpat__TestSystem::SpatInd_template;
single_value.field_spatInd->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @TTCN_EncDec.MapSpatInd.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MapSpatInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @TTCN_EncDec.MapSpatInd.");
}
}

boolean MapSpatInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MapSpatInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MapSpatInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@TTCN_EncDec.MapSpatInd'");
    }
    if (strcmp("mapInd", param_field) == 0) {
      mapInd().set_param(param);
      return;
    } else if (strcmp("spatInd", param_field) == 0) {
      spatInd().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@TTCN_EncDec.MapSpatInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MapSpatInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@TTCN_EncDec.MapSpatInd");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "mapInd")) {
      mapInd().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "spatInd")) {
      spatInd().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @TTCN_EncDec.MapSpatInd.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@TTCN_EncDec.MapSpatInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* MapSpatInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@TTCN_EncDec.MapSpatInd'");
    }
    if (strcmp("mapInd", param_field) == 0) {
      return mapInd().get_param(param_name);
    } else if (strcmp("spatInd", param_field) == 0) {
      return spatInd().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `MapSpatInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case MapSpatInd::ALT_mapInd:
      mp_field = single_value.field_mapInd->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("mapInd")));
      break;
    case MapSpatInd::ALT_spatInd:
      mp_field = single_value.field_spatInd->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("spatInd")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void MapSpatInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case MapSpatInd::ALT_mapInd:
single_value.field_mapInd->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.MapSpatInd");
return;
case MapSpatInd::ALT_spatInd:
single_value.field_spatInd->check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.MapSpatInd");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @TTCN_EncDec.MapSpatInd.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.MapSpatInd");
}

ExtMapSpatInd::ExtMapSpatInd()
{
  bound_flag = FALSE;
}

ExtMapSpatInd::ExtMapSpatInd(const INTEGER& par_gnNextHeader,
    const INTEGER& par_gnHeaderType,
    const INTEGER& par_gnHeaderSubtype,
    const INTEGER& par_gnLifetime,
    const INTEGER& par_gnTrafficClass,
    const INTEGER& par_btpDestinationPort,
    const INTEGER& par_btpInfo)
  :   field_gnNextHeader(par_gnNextHeader),
  field_gnHeaderType(par_gnHeaderType),
  field_gnHeaderSubtype(par_gnHeaderSubtype),
  field_gnLifetime(par_gnLifetime),
  field_gnTrafficClass(par_gnTrafficClass),
  field_btpDestinationPort(par_btpDestinationPort),
  field_btpInfo(par_btpInfo)
{
  bound_flag = TRUE;
}

ExtMapSpatInd::ExtMapSpatInd(const ExtMapSpatInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtMapSpatInd.");
bound_flag = TRUE;
if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
else field_gnNextHeader.clean_up();
if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
else field_gnHeaderType.clean_up();
if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
else field_gnHeaderSubtype.clean_up();
if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
else field_gnLifetime.clean_up();
if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
else field_gnTrafficClass.clean_up();
if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
else field_btpDestinationPort.clean_up();
if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
else field_btpInfo.clean_up();
}

void ExtMapSpatInd::clean_up()
{
field_gnNextHeader.clean_up();
field_gnHeaderType.clean_up();
field_gnHeaderSubtype.clean_up();
field_gnLifetime.clean_up();
field_gnTrafficClass.clean_up();
field_btpDestinationPort.clean_up();
field_btpInfo.clean_up();
bound_flag = FALSE;
}

ExtMapSpatInd& ExtMapSpatInd::operator=(const ExtMapSpatInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtMapSpatInd.");
  bound_flag = TRUE;
  if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
  else field_gnNextHeader.clean_up();
  if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
  else field_gnHeaderType.clean_up();
  if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
  else field_gnHeaderSubtype.clean_up();
  if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
  else field_gnLifetime.clean_up();
  if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
  else field_gnTrafficClass.clean_up();
  if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
  else field_btpDestinationPort.clean_up();
  if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
  else field_btpInfo.clean_up();
}
return *this;
}

boolean ExtMapSpatInd::operator==(const ExtMapSpatInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_gnNextHeader==other_value.field_gnNextHeader
  && field_gnHeaderType==other_value.field_gnHeaderType
  && field_gnHeaderSubtype==other_value.field_gnHeaderSubtype
  && field_gnLifetime==other_value.field_gnLifetime
  && field_gnTrafficClass==other_value.field_gnTrafficClass
  && field_btpDestinationPort==other_value.field_btpDestinationPort
  && field_btpInfo==other_value.field_btpInfo;
}

boolean ExtMapSpatInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_gnNextHeader.is_bound()) return TRUE;
if(field_gnHeaderType.is_bound()) return TRUE;
if(field_gnHeaderSubtype.is_bound()) return TRUE;
if(field_gnLifetime.is_bound()) return TRUE;
if(field_gnTrafficClass.is_bound()) return TRUE;
if(field_btpDestinationPort.is_bound()) return TRUE;
if(field_btpInfo.is_bound()) return TRUE;
return FALSE;
}
boolean ExtMapSpatInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_gnNextHeader.is_value()) return FALSE;
if(!field_gnHeaderType.is_value()) return FALSE;
if(!field_gnHeaderSubtype.is_value()) return FALSE;
if(!field_gnLifetime.is_value()) return FALSE;
if(!field_gnTrafficClass.is_value()) return FALSE;
if(!field_btpDestinationPort.is_value()) return FALSE;
if(!field_btpInfo.is_value()) return FALSE;
return TRUE;
}
int ExtMapSpatInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtMapSpatInd");
  return 7;
}

void ExtMapSpatInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ gnNextHeader := ");
field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
}

void ExtMapSpatInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtMapSpatInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtMapSpatInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtMapSpatInd has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtMapSpatInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtMapSpatInd");
  }
}

Module_Param* ExtMapSpatInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtMapSpatInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtMapSpatInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_gnNextHeader = field_gnNextHeader.get_param(param_name);
  mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
  mp->add_elem(mp_field_gnNextHeader);
  Module_Param* mp_field_gnHeaderType = field_gnHeaderType.get_param(param_name);
  mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
  mp->add_elem(mp_field_gnHeaderType);
  Module_Param* mp_field_gnHeaderSubtype = field_gnHeaderSubtype.get_param(param_name);
  mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
  mp->add_elem(mp_field_gnHeaderSubtype);
  Module_Param* mp_field_gnLifetime = field_gnLifetime.get_param(param_name);
  mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
  mp->add_elem(mp_field_gnLifetime);
  Module_Param* mp_field_gnTrafficClass = field_gnTrafficClass.get_param(param_name);
  mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
  mp->add_elem(mp_field_gnTrafficClass);
  Module_Param* mp_field_btpDestinationPort = field_btpDestinationPort.get_param(param_name);
  mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
  mp->add_elem(mp_field_btpDestinationPort);
  Module_Param* mp_field_btpInfo = field_btpInfo.get_param(param_name);
  mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
  mp->add_elem(mp_field_btpInfo);
  return mp;
  }

void ExtMapSpatInd::set_implicit_omit()
{
if (gnNextHeader().is_bound()) gnNextHeader().set_implicit_omit();
if (gnHeaderType().is_bound()) gnHeaderType().set_implicit_omit();
if (gnHeaderSubtype().is_bound()) gnHeaderSubtype().set_implicit_omit();
if (gnLifetime().is_bound()) gnLifetime().set_implicit_omit();
if (gnTrafficClass().is_bound()) gnTrafficClass().set_implicit_omit();
if (btpDestinationPort().is_bound()) btpDestinationPort().set_implicit_omit();
if (btpInfo().is_bound()) btpInfo().set_implicit_omit();
}

void ExtMapSpatInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtMapSpatInd.");
field_gnNextHeader.encode_text(text_buf);
field_gnHeaderType.encode_text(text_buf);
field_gnHeaderSubtype.encode_text(text_buf);
field_gnLifetime.encode_text(text_buf);
field_gnTrafficClass.encode_text(text_buf);
field_btpDestinationPort.encode_text(text_buf);
field_btpInfo.encode_text(text_buf);
}

void ExtMapSpatInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_gnNextHeader.decode_text(text_buf);
field_gnHeaderType.decode_text(text_buf);
field_gnHeaderSubtype.decode_text(text_buf);
field_gnLifetime.decode_text(text_buf);
field_gnTrafficClass.decode_text(text_buf);
field_btpDestinationPort.decode_text(text_buf);
field_btpInfo.decode_text(text_buf);
}

void ExtMapSpatInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtMapSpatInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtMapSpatInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_gnNextHeader.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnHeaderType.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnHeaderSubtype.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnLifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnTrafficClass.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_btpDestinationPort.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_btpInfo.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtMapSpatInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_gnNextHeader.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_gnHeaderType.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_gnHeaderSubtype.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_gnLifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_gnTrafficClass.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_btpDestinationPort.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_btpInfo.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[6]);
  return myleaf.length = encoded_length;
}

int ExtMapSpatInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtMapSpatInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnNextHeader");
    enc_len += field_gnNextHeader.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnHeaderType");
    enc_len += field_gnHeaderType.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnHeaderSubtype");
    enc_len += field_gnHeaderSubtype.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnLifetime");
    enc_len += field_gnLifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnTrafficClass");
    enc_len += field_gnTrafficClass.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpDestinationPort");
    enc_len += field_btpDestinationPort.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpInfo");
    enc_len += field_btpInfo.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtMapSpatInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "gnNextHeader", name_len)) {
         int ret_val = field_gnNextHeader.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnNextHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "gnHeaderType", name_len)) {
         int ret_val = field_gnHeaderType.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnHeaderType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "gnHeaderSubtype", name_len)) {
         int ret_val = field_gnHeaderSubtype.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnHeaderSubtype");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "gnLifetime", name_len)) {
         int ret_val = field_gnLifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnLifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "gnTrafficClass", name_len)) {
         int ret_val = field_gnTrafficClass.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnTrafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "btpDestinationPort", name_len)) {
         int ret_val = field_btpDestinationPort.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpDestinationPort");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "btpInfo", name_len)) {
         int ret_val = field_btpInfo.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpInfo");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_gnNextHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnNextHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_gnHeaderType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnHeaderType");
    return JSON_ERROR_FATAL;
  }
if (!field_gnHeaderSubtype.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnHeaderSubtype");
    return JSON_ERROR_FATAL;
  }
if (!field_gnLifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnLifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_gnTrafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnTrafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_btpDestinationPort.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpDestinationPort");
    return JSON_ERROR_FATAL;
  }
if (!field_btpInfo.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "btpInfo");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtMapSpatInd_template::single_value_struct {
INTEGER_template field_gnNextHeader;
INTEGER_template field_gnHeaderType;
INTEGER_template field_gnHeaderSubtype;
INTEGER_template field_gnLifetime;
INTEGER_template field_gnTrafficClass;
INTEGER_template field_btpDestinationPort;
INTEGER_template field_btpInfo;
};

void ExtMapSpatInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_gnNextHeader = ANY_VALUE;
single_value->field_gnHeaderType = ANY_VALUE;
single_value->field_gnHeaderSubtype = ANY_VALUE;
single_value->field_gnLifetime = ANY_VALUE;
single_value->field_gnTrafficClass = ANY_VALUE;
single_value->field_btpDestinationPort = ANY_VALUE;
single_value->field_btpInfo = ANY_VALUE;
}
}
}

void ExtMapSpatInd_template::copy_value(const ExtMapSpatInd& other_value)
{
single_value = new single_value_struct;
if (other_value.gnNextHeader().is_bound()) {
  single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
  single_value->field_gnNextHeader.clean_up();
}
if (other_value.gnHeaderType().is_bound()) {
  single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
  single_value->field_gnHeaderType.clean_up();
}
if (other_value.gnHeaderSubtype().is_bound()) {
  single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
  single_value->field_gnHeaderSubtype.clean_up();
}
if (other_value.gnLifetime().is_bound()) {
  single_value->field_gnLifetime = other_value.gnLifetime();
} else {
  single_value->field_gnLifetime.clean_up();
}
if (other_value.gnTrafficClass().is_bound()) {
  single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
  single_value->field_gnTrafficClass.clean_up();
}
if (other_value.btpDestinationPort().is_bound()) {
  single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
  single_value->field_btpDestinationPort.clean_up();
}
if (other_value.btpInfo().is_bound()) {
  single_value->field_btpInfo = other_value.btpInfo();
} else {
  single_value->field_btpInfo.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtMapSpatInd_template::copy_template(const ExtMapSpatInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.gnNextHeader().get_selection()) {
single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
single_value->field_gnNextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderType().get_selection()) {
single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
single_value->field_gnHeaderType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderSubtype().get_selection()) {
single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
single_value->field_gnHeaderSubtype.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnLifetime().get_selection()) {
single_value->field_gnLifetime = other_value.gnLifetime();
} else {
single_value->field_gnLifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnTrafficClass().get_selection()) {
single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
single_value->field_gnTrafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpDestinationPort().get_selection()) {
single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
single_value->field_btpDestinationPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpInfo().get_selection()) {
single_value->field_btpInfo = other_value.btpInfo();
} else {
single_value->field_btpInfo.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtMapSpatInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtMapSpatInd.");
break;
}
set_selection(other_value);
}

ExtMapSpatInd_template::ExtMapSpatInd_template()
{
}

ExtMapSpatInd_template::ExtMapSpatInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtMapSpatInd_template::ExtMapSpatInd_template(const ExtMapSpatInd& other_value)
{
copy_value(other_value);
}

ExtMapSpatInd_template::ExtMapSpatInd_template(const OPTIONAL<ExtMapSpatInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtMapSpatInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtMapSpatInd from an unbound optional field.");
}
}

ExtMapSpatInd_template::ExtMapSpatInd_template(const ExtMapSpatInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtMapSpatInd_template::~ExtMapSpatInd_template()
{
clean_up();
}

ExtMapSpatInd_template& ExtMapSpatInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtMapSpatInd_template& ExtMapSpatInd_template::operator=(const ExtMapSpatInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtMapSpatInd_template& ExtMapSpatInd_template::operator=(const OPTIONAL<ExtMapSpatInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtMapSpatInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtMapSpatInd.");
}
return *this;
}

ExtMapSpatInd_template& ExtMapSpatInd_template::operator=(const ExtMapSpatInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtMapSpatInd_template::match(const ExtMapSpatInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.gnNextHeader().is_bound()) return FALSE;
if(!single_value->field_gnNextHeader.match(other_value.gnNextHeader(), legacy))return FALSE;
if(!other_value.gnHeaderType().is_bound()) return FALSE;
if(!single_value->field_gnHeaderType.match(other_value.gnHeaderType(), legacy))return FALSE;
if(!other_value.gnHeaderSubtype().is_bound()) return FALSE;
if(!single_value->field_gnHeaderSubtype.match(other_value.gnHeaderSubtype(), legacy))return FALSE;
if(!other_value.gnLifetime().is_bound()) return FALSE;
if(!single_value->field_gnLifetime.match(other_value.gnLifetime(), legacy))return FALSE;
if(!other_value.gnTrafficClass().is_bound()) return FALSE;
if(!single_value->field_gnTrafficClass.match(other_value.gnTrafficClass(), legacy))return FALSE;
if(!other_value.btpDestinationPort().is_bound()) return FALSE;
if(!single_value->field_btpDestinationPort.match(other_value.btpDestinationPort(), legacy))return FALSE;
if(!other_value.btpInfo().is_bound()) return FALSE;
if(!single_value->field_btpInfo.match(other_value.btpInfo(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtMapSpatInd.");
}
return FALSE;
}

boolean ExtMapSpatInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_gnNextHeader.is_bound()) return TRUE;
if (single_value->field_gnHeaderType.is_bound()) return TRUE;
if (single_value->field_gnHeaderSubtype.is_bound()) return TRUE;
if (single_value->field_gnLifetime.is_bound()) return TRUE;
if (single_value->field_gnTrafficClass.is_bound()) return TRUE;
if (single_value->field_btpDestinationPort.is_bound()) return TRUE;
if (single_value->field_btpInfo.is_bound()) return TRUE;
return FALSE;
}

boolean ExtMapSpatInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_gnNextHeader.is_value()) return FALSE;
if (!single_value->field_gnHeaderType.is_value()) return FALSE;
if (!single_value->field_gnHeaderSubtype.is_value()) return FALSE;
if (!single_value->field_gnLifetime.is_value()) return FALSE;
if (!single_value->field_gnTrafficClass.is_value()) return FALSE;
if (!single_value->field_btpDestinationPort.is_value()) return FALSE;
if (!single_value->field_btpInfo.is_value()) return FALSE;
return TRUE;
}

void ExtMapSpatInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtMapSpatInd ExtMapSpatInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtMapSpatInd.");
ExtMapSpatInd ret_val;
if (single_value->field_gnNextHeader.is_bound()) {
ret_val.gnNextHeader() = single_value->field_gnNextHeader.valueof();
}
if (single_value->field_gnHeaderType.is_bound()) {
ret_val.gnHeaderType() = single_value->field_gnHeaderType.valueof();
}
if (single_value->field_gnHeaderSubtype.is_bound()) {
ret_val.gnHeaderSubtype() = single_value->field_gnHeaderSubtype.valueof();
}
if (single_value->field_gnLifetime.is_bound()) {
ret_val.gnLifetime() = single_value->field_gnLifetime.valueof();
}
if (single_value->field_gnTrafficClass.is_bound()) {
ret_val.gnTrafficClass() = single_value->field_gnTrafficClass.valueof();
}
if (single_value->field_btpDestinationPort.is_bound()) {
ret_val.btpDestinationPort() = single_value->field_btpDestinationPort.valueof();
}
if (single_value->field_btpInfo.is_bound()) {
ret_val.btpInfo() = single_value->field_btpInfo.valueof();
}
return ret_val;
}

void ExtMapSpatInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtMapSpatInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtMapSpatInd_template[list_length];
}

ExtMapSpatInd_template& ExtMapSpatInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtMapSpatInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtMapSpatInd.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtMapSpatInd_template::gnNextHeader()
{
set_specific();
return single_value->field_gnNextHeader;
}

const INTEGER_template& ExtMapSpatInd_template::gnNextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnNextHeader of a non-specific template of type @TTCN_EncDec.ExtMapSpatInd.");
return single_value->field_gnNextHeader;
}

INTEGER_template& ExtMapSpatInd_template::gnHeaderType()
{
set_specific();
return single_value->field_gnHeaderType;
}

const INTEGER_template& ExtMapSpatInd_template::gnHeaderType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderType of a non-specific template of type @TTCN_EncDec.ExtMapSpatInd.");
return single_value->field_gnHeaderType;
}

INTEGER_template& ExtMapSpatInd_template::gnHeaderSubtype()
{
set_specific();
return single_value->field_gnHeaderSubtype;
}

const INTEGER_template& ExtMapSpatInd_template::gnHeaderSubtype() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderSubtype of a non-specific template of type @TTCN_EncDec.ExtMapSpatInd.");
return single_value->field_gnHeaderSubtype;
}

INTEGER_template& ExtMapSpatInd_template::gnLifetime()
{
set_specific();
return single_value->field_gnLifetime;
}

const INTEGER_template& ExtMapSpatInd_template::gnLifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnLifetime of a non-specific template of type @TTCN_EncDec.ExtMapSpatInd.");
return single_value->field_gnLifetime;
}

INTEGER_template& ExtMapSpatInd_template::gnTrafficClass()
{
set_specific();
return single_value->field_gnTrafficClass;
}

const INTEGER_template& ExtMapSpatInd_template::gnTrafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnTrafficClass of a non-specific template of type @TTCN_EncDec.ExtMapSpatInd.");
return single_value->field_gnTrafficClass;
}

INTEGER_template& ExtMapSpatInd_template::btpDestinationPort()
{
set_specific();
return single_value->field_btpDestinationPort;
}

const INTEGER_template& ExtMapSpatInd_template::btpDestinationPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpDestinationPort of a non-specific template of type @TTCN_EncDec.ExtMapSpatInd.");
return single_value->field_btpDestinationPort;
}

INTEGER_template& ExtMapSpatInd_template::btpInfo()
{
set_specific();
return single_value->field_btpInfo;
}

const INTEGER_template& ExtMapSpatInd_template::btpInfo() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpInfo of a non-specific template of type @TTCN_EncDec.ExtMapSpatInd.");
return single_value->field_btpInfo;
}

int ExtMapSpatInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtMapSpatInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 7;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtMapSpatInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtMapSpatInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtMapSpatInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtMapSpatInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtMapSpatInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtMapSpatInd.");
  }
  return 0;
}

void ExtMapSpatInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ gnNextHeader := ");
single_value->field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtMapSpatInd_template::log_match(const ExtMapSpatInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_gnNextHeader.match(match_value.gnNextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".gnNextHeader");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnHeaderType.match(match_value.gnHeaderType(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderType");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnHeaderSubtype.match(match_value.gnHeaderSubtype(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderSubtype");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnLifetime.match(match_value.gnLifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".gnLifetime");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnTrafficClass.match(match_value.gnTrafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".gnTrafficClass");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_btpDestinationPort.match(match_value.btpDestinationPort(), legacy)){
TTCN_Logger::log_logmatch_info(".btpDestinationPort");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_btpInfo.match(match_value.btpInfo(), legacy)){
TTCN_Logger::log_logmatch_info(".btpInfo");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ gnNextHeader := ");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtMapSpatInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_gnNextHeader.encode_text(text_buf);
single_value->field_gnHeaderType.encode_text(text_buf);
single_value->field_gnHeaderSubtype.encode_text(text_buf);
single_value->field_gnLifetime.encode_text(text_buf);
single_value->field_gnTrafficClass.encode_text(text_buf);
single_value->field_btpDestinationPort.encode_text(text_buf);
single_value->field_btpInfo.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtMapSpatInd.");
}
}

void ExtMapSpatInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_gnNextHeader.decode_text(text_buf);
single_value->field_gnHeaderType.decode_text(text_buf);
single_value->field_gnHeaderSubtype.decode_text(text_buf);
single_value->field_gnLifetime.decode_text(text_buf);
single_value->field_gnTrafficClass.decode_text(text_buf);
single_value->field_btpDestinationPort.decode_text(text_buf);
single_value->field_btpInfo.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtMapSpatInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtMapSpatInd.");
}
}

void ExtMapSpatInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtMapSpatInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtMapSpatInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtMapSpatInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtMapSpatInd has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtMapSpatInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtMapSpatInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtMapSpatInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtMapSpatInd'");
    }
    if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtMapSpatInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_gnNextHeader = single_value->field_gnNextHeader.get_param(param_name);
    mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
    mp->add_elem(mp_field_gnNextHeader);
    Module_Param* mp_field_gnHeaderType = single_value->field_gnHeaderType.get_param(param_name);
    mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
    mp->add_elem(mp_field_gnHeaderType);
    Module_Param* mp_field_gnHeaderSubtype = single_value->field_gnHeaderSubtype.get_param(param_name);
    mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
    mp->add_elem(mp_field_gnHeaderSubtype);
    Module_Param* mp_field_gnLifetime = single_value->field_gnLifetime.get_param(param_name);
    mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
    mp->add_elem(mp_field_gnLifetime);
    Module_Param* mp_field_gnTrafficClass = single_value->field_gnTrafficClass.get_param(param_name);
    mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
    mp->add_elem(mp_field_gnTrafficClass);
    Module_Param* mp_field_btpDestinationPort = single_value->field_btpDestinationPort.get_param(param_name);
    mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
    mp->add_elem(mp_field_btpDestinationPort);
    Module_Param* mp_field_btpInfo = single_value->field_btpInfo.get_param(param_name);
    mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
    mp->add_elem(mp_field_btpInfo);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtMapSpatInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_gnNextHeader.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtMapSpatInd");
single_value->field_gnHeaderType.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtMapSpatInd");
single_value->field_gnHeaderSubtype.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtMapSpatInd");
single_value->field_gnLifetime.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtMapSpatInd");
single_value->field_gnTrafficClass.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtMapSpatInd");
single_value->field_btpDestinationPort.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtMapSpatInd");
single_value->field_btpInfo.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtMapSpatInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtMapSpatInd");
}

boolean ExtMapSpatInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtMapSpatInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtGnNonSecuredPacket::ExtGnNonSecuredPacket()
{
  bound_flag = FALSE;
}

ExtGnNonSecuredPacket::ExtGnNonSecuredPacket(const LibItsGeoNetworking__TypesAndValues::NextHeader& par_nextHeader,
    const INTEGER& par_reserved,
    const INTEGER& par_headerTST,
    const LibItsGeoNetworking__TypesAndValues::TrafficClass& par_trafficClass,
    const BITSTRING& par_flags,
    const INTEGER& par_plLength,
    const INTEGER& par_maxHopLimit,
    const INTEGER& par_reserved2,
    const LibItsGeoNetworking__TypesAndValues::ExtendedHeader& par_extendedHeader,
    const OPTIONAL<LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet>& par_ipv6Packet,
    const OPTIONAL<LibItsBtp__TypesAndValues::BtpHeader>& par_btpHeader,
    const OPTIONAL<OCTETSTRING>& par_btpPayload,
    const OCTETSTRING& par_rawPayload)
  :   field_nextHeader(par_nextHeader),
  field_reserved(par_reserved),
  field_headerTST(par_headerTST),
  field_trafficClass(par_trafficClass),
  field_flags(par_flags),
  field_plLength(par_plLength),
  field_maxHopLimit(par_maxHopLimit),
  field_reserved2(par_reserved2),
  field_extendedHeader(par_extendedHeader),
  field_ipv6Packet(par_ipv6Packet),
  field_btpHeader(par_btpHeader),
  field_btpPayload(par_btpPayload),
  field_rawPayload(par_rawPayload)
{
  bound_flag = TRUE;
}

ExtGnNonSecuredPacket::ExtGnNonSecuredPacket(const ExtGnNonSecuredPacket& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
bound_flag = TRUE;
if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
else field_nextHeader.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.headerTST().is_bound()) field_headerTST = other_value.headerTST();
else field_headerTST.clean_up();
if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
else field_trafficClass.clean_up();
if (other_value.flags().is_bound()) field_flags = other_value.flags();
else field_flags.clean_up();
if (other_value.plLength().is_bound()) field_plLength = other_value.plLength();
else field_plLength.clean_up();
if (other_value.maxHopLimit().is_bound()) field_maxHopLimit = other_value.maxHopLimit();
else field_maxHopLimit.clean_up();
if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
else field_reserved2.clean_up();
if (other_value.extendedHeader().is_bound()) field_extendedHeader = other_value.extendedHeader();
else field_extendedHeader.clean_up();
if (other_value.ipv6Packet().is_bound()) field_ipv6Packet = other_value.ipv6Packet();
else field_ipv6Packet.clean_up();
if (other_value.btpHeader().is_bound()) field_btpHeader = other_value.btpHeader();
else field_btpHeader.clean_up();
if (other_value.btpPayload().is_bound()) field_btpPayload = other_value.btpPayload();
else field_btpPayload.clean_up();
if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
else field_rawPayload.clean_up();
}

void ExtGnNonSecuredPacket::clean_up()
{
field_nextHeader.clean_up();
field_reserved.clean_up();
field_headerTST.clean_up();
field_trafficClass.clean_up();
field_flags.clean_up();
field_plLength.clean_up();
field_maxHopLimit.clean_up();
field_reserved2.clean_up();
field_extendedHeader.clean_up();
field_ipv6Packet.clean_up();
field_btpHeader.clean_up();
field_btpPayload.clean_up();
field_rawPayload.clean_up();
bound_flag = FALSE;
}

ExtGnNonSecuredPacket& ExtGnNonSecuredPacket::operator=(const ExtGnNonSecuredPacket& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
  bound_flag = TRUE;
  if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
  else field_nextHeader.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.headerTST().is_bound()) field_headerTST = other_value.headerTST();
  else field_headerTST.clean_up();
  if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
  else field_trafficClass.clean_up();
  if (other_value.flags().is_bound()) field_flags = other_value.flags();
  else field_flags.clean_up();
  if (other_value.plLength().is_bound()) field_plLength = other_value.plLength();
  else field_plLength.clean_up();
  if (other_value.maxHopLimit().is_bound()) field_maxHopLimit = other_value.maxHopLimit();
  else field_maxHopLimit.clean_up();
  if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
  else field_reserved2.clean_up();
  if (other_value.extendedHeader().is_bound()) field_extendedHeader = other_value.extendedHeader();
  else field_extendedHeader.clean_up();
  if (other_value.ipv6Packet().is_bound()) field_ipv6Packet = other_value.ipv6Packet();
  else field_ipv6Packet.clean_up();
  if (other_value.btpHeader().is_bound()) field_btpHeader = other_value.btpHeader();
  else field_btpHeader.clean_up();
  if (other_value.btpPayload().is_bound()) field_btpPayload = other_value.btpPayload();
  else field_btpPayload.clean_up();
  if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
  else field_rawPayload.clean_up();
}
return *this;
}

boolean ExtGnNonSecuredPacket::operator==(const ExtGnNonSecuredPacket& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_nextHeader==other_value.field_nextHeader
  && field_reserved==other_value.field_reserved
  && field_headerTST==other_value.field_headerTST
  && field_trafficClass==other_value.field_trafficClass
  && field_flags==other_value.field_flags
  && field_plLength==other_value.field_plLength
  && field_maxHopLimit==other_value.field_maxHopLimit
  && field_reserved2==other_value.field_reserved2
  && field_extendedHeader==other_value.field_extendedHeader
  && field_ipv6Packet==other_value.field_ipv6Packet
  && field_btpHeader==other_value.field_btpHeader
  && field_btpPayload==other_value.field_btpPayload
  && field_rawPayload==other_value.field_rawPayload;
}

boolean ExtGnNonSecuredPacket::is_bound() const
{
if (bound_flag) return TRUE;
if(field_nextHeader.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_headerTST.is_bound()) return TRUE;
if(field_trafficClass.is_bound()) return TRUE;
if(field_flags.is_bound()) return TRUE;
if(field_plLength.is_bound()) return TRUE;
if(field_maxHopLimit.is_bound()) return TRUE;
if(field_reserved2.is_bound()) return TRUE;
if(field_extendedHeader.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ipv6Packet.get_selection() || field_ipv6Packet.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_btpHeader.get_selection() || field_btpHeader.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_btpPayload.get_selection() || field_btpPayload.is_bound()) return TRUE;
if(field_rawPayload.is_bound()) return TRUE;
return FALSE;
}
boolean ExtGnNonSecuredPacket::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_nextHeader.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_headerTST.is_value()) return FALSE;
if(!field_trafficClass.is_value()) return FALSE;
if(!field_flags.is_value()) return FALSE;
if(!field_plLength.is_value()) return FALSE;
if(!field_maxHopLimit.is_value()) return FALSE;
if(!field_reserved2.is_value()) return FALSE;
if(!field_extendedHeader.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ipv6Packet.get_selection() && !field_ipv6Packet.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_btpHeader.get_selection() && !field_btpHeader.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_btpPayload.get_selection() && !field_btpPayload.is_value()) return FALSE;
if(!field_rawPayload.is_value()) return FALSE;
return TRUE;
}
int ExtGnNonSecuredPacket::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtGnNonSecuredPacket");
  int ret_val = 10;
  if (field_ipv6Packet.ispresent()) ret_val++;
  if (field_btpHeader.ispresent()) ret_val++;
  if (field_btpPayload.ispresent()) ret_val++;
  return ret_val;
}

void ExtGnNonSecuredPacket::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ nextHeader := ");
field_nextHeader.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", headerTST := ");
field_headerTST.log();
TTCN_Logger::log_event_str(", trafficClass := ");
field_trafficClass.log();
TTCN_Logger::log_event_str(", flags := ");
field_flags.log();
TTCN_Logger::log_event_str(", plLength := ");
field_plLength.log();
TTCN_Logger::log_event_str(", maxHopLimit := ");
field_maxHopLimit.log();
TTCN_Logger::log_event_str(", reserved2 := ");
field_reserved2.log();
TTCN_Logger::log_event_str(", extendedHeader := ");
field_extendedHeader.log();
TTCN_Logger::log_event_str(", ipv6Packet := ");
field_ipv6Packet.log();
TTCN_Logger::log_event_str(", btpHeader := ");
field_btpHeader.log();
TTCN_Logger::log_event_str(", btpPayload := ");
field_btpPayload.log();
TTCN_Logger::log_event_str(", rawPayload := ");
field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
}

void ExtGnNonSecuredPacket::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtGnNonSecuredPacket'");
    }
    if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("headerTST", param_field) == 0) {
      headerTST().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("flags", param_field) == 0) {
      flags().set_param(param);
      return;
    } else if (strcmp("plLength", param_field) == 0) {
      plLength().set_param(param);
      return;
    } else if (strcmp("maxHopLimit", param_field) == 0) {
      maxHopLimit().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else if (strcmp("extendedHeader", param_field) == 0) {
      extendedHeader().set_param(param);
      return;
    } else if (strcmp("ipv6Packet", param_field) == 0) {
      ipv6Packet().set_param(param);
      return;
    } else if (strcmp("btpHeader", param_field) == 0) {
      btpHeader().set_param(param);
      return;
    } else if (strcmp("btpPayload", param_field) == 0) {
      btpPayload().set_param(param);
      return;
    } else if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtGnNonSecuredPacket'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (13<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtGnNonSecuredPacket has 13 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) headerTST().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) plLength().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) maxHopLimit().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) extendedHeader().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) ipv6Packet().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) btpHeader().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) btpPayload().set_param(*mp->get_elem(11));
    if (mp->get_size()>12 && mp->get_elem(12)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(12));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerTST")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerTST().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "plLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          plLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maxHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maxHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "extendedHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          extendedHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv6Packet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv6Packet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGnNonSecuredPacket: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtGnNonSecuredPacket");
  }
}

Module_Param* ExtGnNonSecuredPacket::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtGnNonSecuredPacket'");
    }
    if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("headerTST", param_field) == 0) {
      return headerTST().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("flags", param_field) == 0) {
      return flags().get_param(param_name);
    } else if (strcmp("plLength", param_field) == 0) {
      return plLength().get_param(param_name);
    } else if (strcmp("maxHopLimit", param_field) == 0) {
      return maxHopLimit().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else if (strcmp("extendedHeader", param_field) == 0) {
      return extendedHeader().get_param(param_name);
    } else if (strcmp("ipv6Packet", param_field) == 0) {
      return ipv6Packet().get_param(param_name);
    } else if (strcmp("btpHeader", param_field) == 0) {
      return btpHeader().get_param(param_name);
    } else if (strcmp("btpPayload", param_field) == 0) {
      return btpPayload().get_param(param_name);
    } else if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGnNonSecuredPacket'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_nextHeader = field_nextHeader.get_param(param_name);
  mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
  mp->add_elem(mp_field_nextHeader);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_headerTST = field_headerTST.get_param(param_name);
  mp_field_headerTST->set_id(new Module_Param_FieldName(mcopystr("headerTST")));
  mp->add_elem(mp_field_headerTST);
  Module_Param* mp_field_trafficClass = field_trafficClass.get_param(param_name);
  mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
  mp->add_elem(mp_field_trafficClass);
  Module_Param* mp_field_flags = field_flags.get_param(param_name);
  mp_field_flags->set_id(new Module_Param_FieldName(mcopystr("flags")));
  mp->add_elem(mp_field_flags);
  Module_Param* mp_field_plLength = field_plLength.get_param(param_name);
  mp_field_plLength->set_id(new Module_Param_FieldName(mcopystr("plLength")));
  mp->add_elem(mp_field_plLength);
  Module_Param* mp_field_maxHopLimit = field_maxHopLimit.get_param(param_name);
  mp_field_maxHopLimit->set_id(new Module_Param_FieldName(mcopystr("maxHopLimit")));
  mp->add_elem(mp_field_maxHopLimit);
  Module_Param* mp_field_reserved2 = field_reserved2.get_param(param_name);
  mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
  mp->add_elem(mp_field_reserved2);
  Module_Param* mp_field_extendedHeader = field_extendedHeader.get_param(param_name);
  mp_field_extendedHeader->set_id(new Module_Param_FieldName(mcopystr("extendedHeader")));
  mp->add_elem(mp_field_extendedHeader);
  Module_Param* mp_field_ipv6Packet = field_ipv6Packet.get_param(param_name);
  mp_field_ipv6Packet->set_id(new Module_Param_FieldName(mcopystr("ipv6Packet")));
  mp->add_elem(mp_field_ipv6Packet);
  Module_Param* mp_field_btpHeader = field_btpHeader.get_param(param_name);
  mp_field_btpHeader->set_id(new Module_Param_FieldName(mcopystr("btpHeader")));
  mp->add_elem(mp_field_btpHeader);
  Module_Param* mp_field_btpPayload = field_btpPayload.get_param(param_name);
  mp_field_btpPayload->set_id(new Module_Param_FieldName(mcopystr("btpPayload")));
  mp->add_elem(mp_field_btpPayload);
  Module_Param* mp_field_rawPayload = field_rawPayload.get_param(param_name);
  mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
  mp->add_elem(mp_field_rawPayload);
  return mp;
  }

void ExtGnNonSecuredPacket::set_implicit_omit()
{
if (nextHeader().is_bound()) nextHeader().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (headerTST().is_bound()) headerTST().set_implicit_omit();
if (trafficClass().is_bound()) trafficClass().set_implicit_omit();
if (flags().is_bound()) flags().set_implicit_omit();
if (plLength().is_bound()) plLength().set_implicit_omit();
if (maxHopLimit().is_bound()) maxHopLimit().set_implicit_omit();
if (reserved2().is_bound()) reserved2().set_implicit_omit();
if (extendedHeader().is_bound()) extendedHeader().set_implicit_omit();
if (!ipv6Packet().is_bound()) ipv6Packet() = OMIT_VALUE;
else ipv6Packet().set_implicit_omit();
if (!btpHeader().is_bound()) btpHeader() = OMIT_VALUE;
else btpHeader().set_implicit_omit();
if (!btpPayload().is_bound()) btpPayload() = OMIT_VALUE;
else btpPayload().set_implicit_omit();
if (rawPayload().is_bound()) rawPayload().set_implicit_omit();
}

void ExtGnNonSecuredPacket::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
field_nextHeader.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_headerTST.encode_text(text_buf);
field_trafficClass.encode_text(text_buf);
field_flags.encode_text(text_buf);
field_plLength.encode_text(text_buf);
field_maxHopLimit.encode_text(text_buf);
field_reserved2.encode_text(text_buf);
field_extendedHeader.encode_text(text_buf);
field_ipv6Packet.encode_text(text_buf);
field_btpHeader.encode_text(text_buf);
field_btpPayload.encode_text(text_buf);
field_rawPayload.encode_text(text_buf);
}

void ExtGnNonSecuredPacket::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_nextHeader.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_headerTST.decode_text(text_buf);
field_trafficClass.decode_text(text_buf);
field_flags.decode_text(text_buf);
field_plLength.decode_text(text_buf);
field_maxHopLimit.decode_text(text_buf);
field_reserved2.decode_text(text_buf);
field_extendedHeader.decode_text(text_buf);
field_ipv6Packet.decode_text(text_buf);
field_btpHeader.decode_text(text_buf);
field_btpPayload.decode_text(text_buf);
field_rawPayload.decode_text(text_buf);
}

void ExtGnNonSecuredPacket::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtGnNonSecuredPacket::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtGnNonSecuredPacket::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  int selected_field = -1;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  int value_of_length_field5 = 0;
  decoded_field_length = field_nextHeader.RAW_decode(ExtGnNonSecuredPacket_nextHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(ExtGnNonSecuredPacket_reserved_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerTST.RAW_decode(ExtGnNonSecuredPacket_headerTST_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trafficClass.RAW_decode(ExtGnNonSecuredPacket_trafficClass_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_flags.RAW_decode(ExtGnNonSecuredPacket_flags_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_plLength.RAW_decode(ExtGnNonSecuredPacket_plLength_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field5+=(int)field_plLength*8;
  decoded_field_length = field_maxHopLimit.RAW_decode(ExtGnNonSecuredPacket_maxHopLimit_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved2.RAW_decode(ExtGnNonSecuredPacket_reserved2_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (field_headerTST == 0) selected_field = 8;
  else if (field_headerTST == 16) selected_field = 5;
  else if (field_headerTST == 32) selected_field = 0;
  else if (field_headerTST == 48 || field_headerTST == 49 || field_headerTST == 50) selected_field = 4;
  else if (field_headerTST == 64 || field_headerTST == 65 || field_headerTST == 66) selected_field = 3;
  else if (field_headerTST == 80) selected_field = 2;
  else if (field_headerTST == 81) selected_field = 1;
  else if (field_headerTST == 96) selected_field = 6;
  else if (field_headerTST == 97) selected_field = 7;
  else selected_field = -1;
  decoded_field_length = field_extendedHeader.RAW_decode(ExtGnNonSecuredPacket_extendedHeader_descr_, p_buf, limit, local_top_order, no_err, selected_field);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0 && value_of_length_field5 > 0 && field_nextHeader == LibItsGeoNetworking__TypesAndValues::NextHeader::e__ipv6){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_ipv6Packet().RAW_decode(ExtGnNonSecuredPacket_ipv6Packet_descr_, p_buf, min_of_ints(2, limit, value_of_length_field5), local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_ipv6Packet = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field5 -= decoded_field_length;
  }
  }
  else field_ipv6Packet=OMIT_VALUE;
  if (field_nextHeader == LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpA) selected_field = 0;
  else if (field_nextHeader == LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB) selected_field = 1;
  else selected_field = -1;
  if (limit > 0 && value_of_length_field5 > 0 && field_nextHeader == LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB&& selected_field!=-1){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_btpHeader().RAW_decode(ExtGnNonSecuredPacket_btpHeader_descr_, p_buf, min_of_ints(2, limit, value_of_length_field5), local_top_order, TRUE, selected_field);
  if (decoded_field_length < 1) {
  field_btpHeader = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field5 -= decoded_field_length;
  }
  }
  else field_btpHeader=OMIT_VALUE;
  if (limit > 0 && value_of_length_field5 > 0 && field_nextHeader == LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_btpPayload().RAW_decode(ExtGnNonSecuredPacket_btpPayload_descr_, p_buf, min_of_ints(2, limit, value_of_length_field5), local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_btpPayload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field5 -= decoded_field_length;
  }
  }
  else field_btpPayload=OMIT_VALUE;
  decoded_field_length = field_rawPayload.RAW_decode(ExtGnNonSecuredPacket_rawPayload_descr_, p_buf, min_of_ints(2, limit, value_of_length_field5), local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  value_of_length_field5 -= decoded_field_length;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtGnNonSecuredPacket::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 13;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(13);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ExtGnNonSecuredPacket_nextHeader_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ExtGnNonSecuredPacket_reserved_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, ExtGnNonSecuredPacket_headerTST_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, ExtGnNonSecuredPacket_trafficClass_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, ExtGnNonSecuredPacket_flags_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, ExtGnNonSecuredPacket_plLength_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, ExtGnNonSecuredPacket_maxHopLimit_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, ExtGnNonSecuredPacket_reserved2_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, ExtGnNonSecuredPacket_extendedHeader_descr_.raw);
  if (field_ipv6Packet.ispresent()) {
  myleaf.body.node.nodes[9] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 9, ExtGnNonSecuredPacket_ipv6Packet_descr_.raw);
  }
  else myleaf.body.node.nodes[9] = NULL;
  if (field_btpHeader.ispresent()) {
  myleaf.body.node.nodes[10] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 10, ExtGnNonSecuredPacket_btpHeader_descr_.raw);
  }
  else myleaf.body.node.nodes[10] = NULL;
  if (field_btpPayload.ispresent()) {
  myleaf.body.node.nodes[11] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 11, ExtGnNonSecuredPacket_btpPayload_descr_.raw);
  }
  else myleaf.body.node.nodes[11] = NULL;
  myleaf.body.node.nodes[12] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 12, ExtGnNonSecuredPacket_rawPayload_descr_.raw);
  encoded_length += field_nextHeader.RAW_encode(ExtGnNonSecuredPacket_nextHeader_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(ExtGnNonSecuredPacket_reserved_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_headerTST.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_trafficClass.RAW_encode(ExtGnNonSecuredPacket_trafficClass_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_flags.RAW_encode(ExtGnNonSecuredPacket_flags_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += 16;
  myleaf.body.node.nodes[5]->calc = CALC_LENGTH;
  myleaf.body.node.nodes[5]->coding_descr = &ExtGnNonSecuredPacket_plLength_descr_;
  myleaf.body.node.nodes[5]->calcof.lengthto.num_of_fields = 4;
  myleaf.body.node.nodes[5]->calcof.lengthto.unit = 8;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields = init_lengthto_fields_list(4);
  myleaf.body.node.nodes[5]->length = 16;
  if (field_ipv6Packet.ispresent()) {
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[0].level = myleaf.body.node.nodes[9]->curr_pos.level;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[0].pos = myleaf.body.node.nodes[9]->curr_pos.pos;
  } else {
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[0].level = 0;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[0].pos = 0;
  }
  if (field_btpHeader.ispresent()) {
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[1].level = myleaf.body.node.nodes[10]->curr_pos.level;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[1].pos = myleaf.body.node.nodes[10]->curr_pos.pos;
  } else {
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[1].level = 0;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[1].pos = 0;
  }
  if (field_btpPayload.ispresent()) {
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[2].level = myleaf.body.node.nodes[11]->curr_pos.level;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[2].pos = myleaf.body.node.nodes[11]->curr_pos.pos;
  } else {
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[2].level = 0;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[2].pos = 0;
  }
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[3].level = myleaf.body.node.nodes[12]->curr_pos.level;
  myleaf.body.node.nodes[5]->calcof.lengthto.fields[3].pos = myleaf.body.node.nodes[12]->curr_pos.pos;
  encoded_length += field_maxHopLimit.RAW_encode(ExtGnNonSecuredPacket_maxHopLimit_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_reserved2.RAW_encode(ExtGnNonSecuredPacket_reserved2_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_extendedHeader.RAW_encode(ExtGnNonSecuredPacket_extendedHeader_descr_, *myleaf.body.node.nodes[8]);
  if (field_ipv6Packet.ispresent()) {
  encoded_length += field_ipv6Packet().RAW_encode(ExtGnNonSecuredPacket_ipv6Packet_descr_, *myleaf.body.node.nodes[9]);
  }
  if (field_btpHeader.ispresent()) {
  encoded_length += field_btpHeader().RAW_encode(ExtGnNonSecuredPacket_btpHeader_descr_, *myleaf.body.node.nodes[10]);
  }
  if (field_btpPayload.ispresent()) {
  encoded_length += field_btpPayload().RAW_encode(ExtGnNonSecuredPacket_btpPayload_descr_, *myleaf.body.node.nodes[11]);
  }
  encoded_length += field_rawPayload.RAW_encode(ExtGnNonSecuredPacket_rawPayload_descr_, *myleaf.body.node.nodes[12]);
  switch (field_extendedHeader.get_selection()) {
  case LibItsGeoNetworking__TypesAndValues::ExtendedHeader::ALT_anyHeader:
  if (field_headerTST != 0) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 2 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  INTEGER new_val(0);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsGeoNetworking__TypesAndValues::ExtendedHeader::ALT_beaconHeader:
  if (field_headerTST != 16) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 2 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  INTEGER new_val(16);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsGeoNetworking__TypesAndValues::ExtendedHeader::ALT_geoUnicastHeader:
  if (field_headerTST != 32) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 2 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  INTEGER new_val(32);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsGeoNetworking__TypesAndValues::ExtendedHeader::ALT_geoAnycastHeader:
  if (field_headerTST != 48 && field_headerTST != 49 && field_headerTST != 50) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 2 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  INTEGER new_val(48);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsGeoNetworking__TypesAndValues::ExtendedHeader::ALT_geoBroadcastHeader:
  if (field_headerTST != 64 && field_headerTST != 65 && field_headerTST != 66) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 2 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  INTEGER new_val(64);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsGeoNetworking__TypesAndValues::ExtendedHeader::ALT_shbHeader:
  if (field_headerTST != 80) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 2 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  INTEGER new_val(80);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsGeoNetworking__TypesAndValues::ExtendedHeader::ALT_tsbHeader:
  if (field_headerTST != 81) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 2 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  INTEGER new_val(81);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsGeoNetworking__TypesAndValues::ExtendedHeader::ALT_lsRequestHeader:
  if (field_headerTST != 96) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 2 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  INTEGER new_val(96);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsGeoNetworking__TypesAndValues::ExtendedHeader::ALT_lsReplyHeader:
  if (field_headerTST != 97) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 2 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  INTEGER new_val(97);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_headerTST_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  default:;
  }
  if (field_ipv6Packet.ispresent() && (field_nextHeader != LibItsGeoNetworking__TypesAndValues::NextHeader::e__ipv6)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={0};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
  LibItsGeoNetworking__TypesAndValues::NextHeader new_val = LibItsGeoNetworking__TypesAndValues::NextHeader::e__ipv6;
  new_val.RAW_encode(ExtGnNonSecuredPacket_nextHeader_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  if (field_btpHeader.ispresent() && (field_nextHeader != LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={0};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
  LibItsGeoNetworking__TypesAndValues::NextHeader new_val = LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB;
  new_val.RAW_encode(ExtGnNonSecuredPacket_nextHeader_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  if (field_btpHeader.ispresent()) {
  switch (field_btpHeader().get_selection()) {
  case LibItsBtp__TypesAndValues::BtpHeader::ALT_btpAHeader:
  if (field_nextHeader != LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpA) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  LibItsGeoNetworking__TypesAndValues::NextHeader new_val(LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpA);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_nextHeader_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  case LibItsBtp__TypesAndValues::BtpHeader::ALT_btpBHeader:
  if (field_nextHeader != LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB) {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level = myleaf.curr_pos.level + 1;
  int new_pos[] = { 0 };
  pr_pos.pos = init_new_tree_pos(myleaf.curr_pos, 1, new_pos);
  LibItsGeoNetworking__TypesAndValues::NextHeader new_val(LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB);
  RAW_enc_tree* temp_leaf = myleaf.get_node(pr_pos);
  if (temp_leaf != NULL)
    new_val.RAW_encode(ExtGnNonSecuredPacket_nextHeader_descr_,*temp_leaf);
  else
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  free_tree_pos(pr_pos.pos);
  }
  break;
  default:;
  }
  }
  if (field_btpPayload.ispresent() && (field_nextHeader != LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={0};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
  LibItsGeoNetworking__TypesAndValues::NextHeader new_val = LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB;
  new_val.RAW_encode(ExtGnNonSecuredPacket_nextHeader_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  return myleaf.length = encoded_length;
}

int ExtGnNonSecuredPacket::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nextHeader");
    enc_len += field_nextHeader.JSON_encode(ExtGnNonSecuredPacket_nextHeader_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(ExtGnNonSecuredPacket_reserved_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerTST");
    enc_len += field_headerTST.JSON_encode(ExtGnNonSecuredPacket_headerTST_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficClass");
    enc_len += field_trafficClass.JSON_encode(ExtGnNonSecuredPacket_trafficClass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "flags");
    enc_len += field_flags.JSON_encode(ExtGnNonSecuredPacket_flags_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "plLength");
    enc_len += field_plLength.JSON_encode(ExtGnNonSecuredPacket_plLength_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "maxHopLimit");
    enc_len += field_maxHopLimit.JSON_encode(ExtGnNonSecuredPacket_maxHopLimit_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved2");
    enc_len += field_reserved2.JSON_encode(ExtGnNonSecuredPacket_reserved2_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "extendedHeader");
    enc_len += field_extendedHeader.JSON_encode(ExtGnNonSecuredPacket_extendedHeader_descr_, p_tok);
  }

  if (field_ipv6Packet.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ipv6Packet");
    enc_len += field_ipv6Packet.JSON_encode(ExtGnNonSecuredPacket_ipv6Packet_descr_, p_tok);
  }

  if (field_btpHeader.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpHeader");
    enc_len += field_btpHeader.JSON_encode(ExtGnNonSecuredPacket_btpHeader_descr_, p_tok);
  }

  if (field_btpPayload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpPayload");
    enc_len += field_btpPayload.JSON_encode(ExtGnNonSecuredPacket_btpPayload_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rawPayload");
    enc_len += field_rawPayload.JSON_encode(ExtGnNonSecuredPacket_rawPayload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtGnNonSecuredPacket::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "nextHeader", name_len)) {
         int ret_val = field_nextHeader.JSON_decode(ExtGnNonSecuredPacket_nextHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nextHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(ExtGnNonSecuredPacket_reserved_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "headerTST", name_len)) {
         int ret_val = field_headerTST.JSON_decode(ExtGnNonSecuredPacket_headerTST_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerTST");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "trafficClass", name_len)) {
         int ret_val = field_trafficClass.JSON_decode(ExtGnNonSecuredPacket_trafficClass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "flags", name_len)) {
         int ret_val = field_flags.JSON_decode(ExtGnNonSecuredPacket_flags_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "flags");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "plLength", name_len)) {
         int ret_val = field_plLength.JSON_decode(ExtGnNonSecuredPacket_plLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "plLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "maxHopLimit", name_len)) {
         int ret_val = field_maxHopLimit.JSON_decode(ExtGnNonSecuredPacket_maxHopLimit_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "maxHopLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "reserved2", name_len)) {
         int ret_val = field_reserved2.JSON_decode(ExtGnNonSecuredPacket_reserved2_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved2");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "extendedHeader", name_len)) {
         int ret_val = field_extendedHeader.JSON_decode(ExtGnNonSecuredPacket_extendedHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "extendedHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "ipv6Packet", name_len)) {
         int ret_val = field_ipv6Packet.JSON_decode(ExtGnNonSecuredPacket_ipv6Packet_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ipv6Packet");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "btpHeader", name_len)) {
         int ret_val = field_btpHeader.JSON_decode(ExtGnNonSecuredPacket_btpHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "btpPayload", name_len)) {
         int ret_val = field_btpPayload.JSON_decode(ExtGnNonSecuredPacket_btpPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "rawPayload", name_len)) {
         int ret_val = field_rawPayload.JSON_decode(ExtGnNonSecuredPacket_rawPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rawPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_nextHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nextHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_headerTST.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerTST");
    return JSON_ERROR_FATAL;
  }
if (!field_trafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_flags.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "flags");
    return JSON_ERROR_FATAL;
  }
if (!field_plLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "plLength");
    return JSON_ERROR_FATAL;
  }
if (!field_maxHopLimit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "maxHopLimit");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved2.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved2");
    return JSON_ERROR_FATAL;
  }
if (!field_extendedHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "extendedHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_ipv6Packet.is_bound()) {
    field_ipv6Packet = OMIT_VALUE;
  }
if (!field_btpHeader.is_bound()) {
    field_btpHeader = OMIT_VALUE;
  }
if (!field_btpPayload.is_bound()) {
    field_btpPayload = OMIT_VALUE;
  }
if (!field_rawPayload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rawPayload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtGnNonSecuredPacket_template::single_value_struct {
LibItsGeoNetworking__TypesAndValues::NextHeader_template field_nextHeader;
INTEGER_template field_reserved;
INTEGER_template field_headerTST;
LibItsGeoNetworking__TypesAndValues::TrafficClass_template field_trafficClass;
BITSTRING_template field_flags;
INTEGER_template field_plLength;
INTEGER_template field_maxHopLimit;
INTEGER_template field_reserved2;
LibItsGeoNetworking__TypesAndValues::ExtendedHeader_template field_extendedHeader;
LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template field_ipv6Packet;
LibItsBtp__TypesAndValues::BtpHeader_template field_btpHeader;
OCTETSTRING_template field_btpPayload;
OCTETSTRING_template field_rawPayload;
};

void ExtGnNonSecuredPacket_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_nextHeader = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_headerTST = ANY_VALUE;
single_value->field_trafficClass = ANY_VALUE;
single_value->field_flags = ANY_VALUE;
single_value->field_plLength = ANY_VALUE;
single_value->field_maxHopLimit = ANY_VALUE;
single_value->field_reserved2 = ANY_VALUE;
single_value->field_extendedHeader = ANY_VALUE;
single_value->field_ipv6Packet = ANY_OR_OMIT;
single_value->field_btpHeader = ANY_OR_OMIT;
single_value->field_btpPayload = ANY_OR_OMIT;
single_value->field_rawPayload = ANY_VALUE;
}
}
}

void ExtGnNonSecuredPacket_template::copy_value(const ExtGnNonSecuredPacket& other_value)
{
single_value = new single_value_struct;
if (other_value.nextHeader().is_bound()) {
  single_value->field_nextHeader = other_value.nextHeader();
} else {
  single_value->field_nextHeader.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.headerTST().is_bound()) {
  single_value->field_headerTST = other_value.headerTST();
} else {
  single_value->field_headerTST.clean_up();
}
if (other_value.trafficClass().is_bound()) {
  single_value->field_trafficClass = other_value.trafficClass();
} else {
  single_value->field_trafficClass.clean_up();
}
if (other_value.flags().is_bound()) {
  single_value->field_flags = other_value.flags();
} else {
  single_value->field_flags.clean_up();
}
if (other_value.plLength().is_bound()) {
  single_value->field_plLength = other_value.plLength();
} else {
  single_value->field_plLength.clean_up();
}
if (other_value.maxHopLimit().is_bound()) {
  single_value->field_maxHopLimit = other_value.maxHopLimit();
} else {
  single_value->field_maxHopLimit.clean_up();
}
if (other_value.reserved2().is_bound()) {
  single_value->field_reserved2 = other_value.reserved2();
} else {
  single_value->field_reserved2.clean_up();
}
if (other_value.extendedHeader().is_bound()) {
  single_value->field_extendedHeader = other_value.extendedHeader();
} else {
  single_value->field_extendedHeader.clean_up();
}
if (other_value.ipv6Packet().is_bound()) {
  if (other_value.ipv6Packet().ispresent()) single_value->field_ipv6Packet = other_value.ipv6Packet()();
  else single_value->field_ipv6Packet = OMIT_VALUE;
} else {
  single_value->field_ipv6Packet.clean_up();
}
if (other_value.btpHeader().is_bound()) {
  if (other_value.btpHeader().ispresent()) single_value->field_btpHeader = other_value.btpHeader()();
  else single_value->field_btpHeader = OMIT_VALUE;
} else {
  single_value->field_btpHeader.clean_up();
}
if (other_value.btpPayload().is_bound()) {
  if (other_value.btpPayload().ispresent()) single_value->field_btpPayload = other_value.btpPayload()();
  else single_value->field_btpPayload = OMIT_VALUE;
} else {
  single_value->field_btpPayload.clean_up();
}
if (other_value.rawPayload().is_bound()) {
  single_value->field_rawPayload = other_value.rawPayload();
} else {
  single_value->field_rawPayload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtGnNonSecuredPacket_template::copy_template(const ExtGnNonSecuredPacket_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.nextHeader().get_selection()) {
single_value->field_nextHeader = other_value.nextHeader();
} else {
single_value->field_nextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerTST().get_selection()) {
single_value->field_headerTST = other_value.headerTST();
} else {
single_value->field_headerTST.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trafficClass().get_selection()) {
single_value->field_trafficClass = other_value.trafficClass();
} else {
single_value->field_trafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.flags().get_selection()) {
single_value->field_flags = other_value.flags();
} else {
single_value->field_flags.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.plLength().get_selection()) {
single_value->field_plLength = other_value.plLength();
} else {
single_value->field_plLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.maxHopLimit().get_selection()) {
single_value->field_maxHopLimit = other_value.maxHopLimit();
} else {
single_value->field_maxHopLimit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved2().get_selection()) {
single_value->field_reserved2 = other_value.reserved2();
} else {
single_value->field_reserved2.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.extendedHeader().get_selection()) {
single_value->field_extendedHeader = other_value.extendedHeader();
} else {
single_value->field_extendedHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ipv6Packet().get_selection()) {
single_value->field_ipv6Packet = other_value.ipv6Packet();
} else {
single_value->field_ipv6Packet.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpHeader().get_selection()) {
single_value->field_btpHeader = other_value.btpHeader();
} else {
single_value->field_btpHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpPayload().get_selection()) {
single_value->field_btpPayload = other_value.btpPayload();
} else {
single_value->field_btpPayload.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rawPayload().get_selection()) {
single_value->field_rawPayload = other_value.rawPayload();
} else {
single_value->field_rawPayload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtGnNonSecuredPacket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
break;
}
set_selection(other_value);
}

ExtGnNonSecuredPacket_template::ExtGnNonSecuredPacket_template()
{
}

ExtGnNonSecuredPacket_template::ExtGnNonSecuredPacket_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtGnNonSecuredPacket_template::ExtGnNonSecuredPacket_template(const ExtGnNonSecuredPacket& other_value)
{
copy_value(other_value);
}

ExtGnNonSecuredPacket_template::ExtGnNonSecuredPacket_template(const OPTIONAL<ExtGnNonSecuredPacket>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGnNonSecuredPacket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtGnNonSecuredPacket from an unbound optional field.");
}
}

ExtGnNonSecuredPacket_template::ExtGnNonSecuredPacket_template(const ExtGnNonSecuredPacket_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtGnNonSecuredPacket_template::~ExtGnNonSecuredPacket_template()
{
clean_up();
}

ExtGnNonSecuredPacket_template& ExtGnNonSecuredPacket_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtGnNonSecuredPacket_template& ExtGnNonSecuredPacket_template::operator=(const ExtGnNonSecuredPacket& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtGnNonSecuredPacket_template& ExtGnNonSecuredPacket_template::operator=(const OPTIONAL<ExtGnNonSecuredPacket>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGnNonSecuredPacket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
}
return *this;
}

ExtGnNonSecuredPacket_template& ExtGnNonSecuredPacket_template::operator=(const ExtGnNonSecuredPacket_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtGnNonSecuredPacket_template::match(const ExtGnNonSecuredPacket& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.nextHeader().is_bound()) return FALSE;
if(!single_value->field_nextHeader.match(other_value.nextHeader(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.headerTST().is_bound()) return FALSE;
if(!single_value->field_headerTST.match(other_value.headerTST(), legacy))return FALSE;
if(!other_value.trafficClass().is_bound()) return FALSE;
if(!single_value->field_trafficClass.match(other_value.trafficClass(), legacy))return FALSE;
if(!other_value.flags().is_bound()) return FALSE;
if(!single_value->field_flags.match(other_value.flags(), legacy))return FALSE;
if(!other_value.plLength().is_bound()) return FALSE;
if(!single_value->field_plLength.match(other_value.plLength(), legacy))return FALSE;
if(!other_value.maxHopLimit().is_bound()) return FALSE;
if(!single_value->field_maxHopLimit.match(other_value.maxHopLimit(), legacy))return FALSE;
if(!other_value.reserved2().is_bound()) return FALSE;
if(!single_value->field_reserved2.match(other_value.reserved2(), legacy))return FALSE;
if(!other_value.extendedHeader().is_bound()) return FALSE;
if(!single_value->field_extendedHeader.match(other_value.extendedHeader(), legacy))return FALSE;
if(!other_value.ipv6Packet().is_bound()) return FALSE;
if((other_value.ipv6Packet().ispresent() ? !single_value->field_ipv6Packet.match((const LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet&)other_value.ipv6Packet(), legacy) : !single_value->field_ipv6Packet.match_omit(legacy)))return FALSE;
if(!other_value.btpHeader().is_bound()) return FALSE;
if((other_value.btpHeader().ispresent() ? !single_value->field_btpHeader.match((const LibItsBtp__TypesAndValues::BtpHeader&)other_value.btpHeader(), legacy) : !single_value->field_btpHeader.match_omit(legacy)))return FALSE;
if(!other_value.btpPayload().is_bound()) return FALSE;
if((other_value.btpPayload().ispresent() ? !single_value->field_btpPayload.match((const OCTETSTRING&)other_value.btpPayload(), legacy) : !single_value->field_btpPayload.match_omit(legacy)))return FALSE;
if(!other_value.rawPayload().is_bound()) return FALSE;
if(!single_value->field_rawPayload.match(other_value.rawPayload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
}
return FALSE;
}

boolean ExtGnNonSecuredPacket_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_nextHeader.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_headerTST.is_bound()) return TRUE;
if (single_value->field_trafficClass.is_bound()) return TRUE;
if (single_value->field_flags.is_bound()) return TRUE;
if (single_value->field_plLength.is_bound()) return TRUE;
if (single_value->field_maxHopLimit.is_bound()) return TRUE;
if (single_value->field_reserved2.is_bound()) return TRUE;
if (single_value->field_extendedHeader.is_bound()) return TRUE;
if (single_value->field_ipv6Packet.is_omit() || single_value->field_ipv6Packet.is_bound()) return TRUE;
if (single_value->field_btpHeader.is_omit() || single_value->field_btpHeader.is_bound()) return TRUE;
if (single_value->field_btpPayload.is_omit() || single_value->field_btpPayload.is_bound()) return TRUE;
if (single_value->field_rawPayload.is_bound()) return TRUE;
return FALSE;
}

boolean ExtGnNonSecuredPacket_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_nextHeader.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_headerTST.is_value()) return FALSE;
if (!single_value->field_trafficClass.is_value()) return FALSE;
if (!single_value->field_flags.is_value()) return FALSE;
if (!single_value->field_plLength.is_value()) return FALSE;
if (!single_value->field_maxHopLimit.is_value()) return FALSE;
if (!single_value->field_reserved2.is_value()) return FALSE;
if (!single_value->field_extendedHeader.is_value()) return FALSE;
if (!single_value->field_ipv6Packet.is_omit() && !single_value->field_ipv6Packet.is_value()) return FALSE;
if (!single_value->field_btpHeader.is_omit() && !single_value->field_btpHeader.is_value()) return FALSE;
if (!single_value->field_btpPayload.is_omit() && !single_value->field_btpPayload.is_value()) return FALSE;
if (!single_value->field_rawPayload.is_value()) return FALSE;
return TRUE;
}

void ExtGnNonSecuredPacket_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtGnNonSecuredPacket ExtGnNonSecuredPacket_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
ExtGnNonSecuredPacket ret_val;
if (single_value->field_nextHeader.is_bound()) {
ret_val.nextHeader() = single_value->field_nextHeader.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_headerTST.is_bound()) {
ret_val.headerTST() = single_value->field_headerTST.valueof();
}
if (single_value->field_trafficClass.is_bound()) {
ret_val.trafficClass() = single_value->field_trafficClass.valueof();
}
if (single_value->field_flags.is_bound()) {
ret_val.flags() = single_value->field_flags.valueof();
}
if (single_value->field_plLength.is_bound()) {
ret_val.plLength() = single_value->field_plLength.valueof();
}
if (single_value->field_maxHopLimit.is_bound()) {
ret_val.maxHopLimit() = single_value->field_maxHopLimit.valueof();
}
if (single_value->field_reserved2.is_bound()) {
ret_val.reserved2() = single_value->field_reserved2.valueof();
}
if (single_value->field_extendedHeader.is_bound()) {
ret_val.extendedHeader() = single_value->field_extendedHeader.valueof();
}
if (single_value->field_ipv6Packet.is_omit()) ret_val.ipv6Packet() = OMIT_VALUE;
else if (single_value->field_ipv6Packet.is_bound()) {
ret_val.ipv6Packet() = single_value->field_ipv6Packet.valueof();
}
if (single_value->field_btpHeader.is_omit()) ret_val.btpHeader() = OMIT_VALUE;
else if (single_value->field_btpHeader.is_bound()) {
ret_val.btpHeader() = single_value->field_btpHeader.valueof();
}
if (single_value->field_btpPayload.is_omit()) ret_val.btpPayload() = OMIT_VALUE;
else if (single_value->field_btpPayload.is_bound()) {
ret_val.btpPayload() = single_value->field_btpPayload.valueof();
}
if (single_value->field_rawPayload.is_bound()) {
ret_val.rawPayload() = single_value->field_rawPayload.valueof();
}
return ret_val;
}

void ExtGnNonSecuredPacket_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtGnNonSecuredPacket_template[list_length];
}

ExtGnNonSecuredPacket_template& ExtGnNonSecuredPacket_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return value_list.list_value[list_index];
}

LibItsGeoNetworking__TypesAndValues::NextHeader_template& ExtGnNonSecuredPacket_template::nextHeader()
{
set_specific();
return single_value->field_nextHeader;
}

const LibItsGeoNetworking__TypesAndValues::NextHeader_template& ExtGnNonSecuredPacket_template::nextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nextHeader of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_nextHeader;
}

INTEGER_template& ExtGnNonSecuredPacket_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& ExtGnNonSecuredPacket_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_reserved;
}

INTEGER_template& ExtGnNonSecuredPacket_template::headerTST()
{
set_specific();
return single_value->field_headerTST;
}

const INTEGER_template& ExtGnNonSecuredPacket_template::headerTST() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerTST of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_headerTST;
}

LibItsGeoNetworking__TypesAndValues::TrafficClass_template& ExtGnNonSecuredPacket_template::trafficClass()
{
set_specific();
return single_value->field_trafficClass;
}

const LibItsGeoNetworking__TypesAndValues::TrafficClass_template& ExtGnNonSecuredPacket_template::trafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficClass of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_trafficClass;
}

BITSTRING_template& ExtGnNonSecuredPacket_template::flags()
{
set_specific();
return single_value->field_flags;
}

const BITSTRING_template& ExtGnNonSecuredPacket_template::flags() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field flags of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_flags;
}

INTEGER_template& ExtGnNonSecuredPacket_template::plLength()
{
set_specific();
return single_value->field_plLength;
}

const INTEGER_template& ExtGnNonSecuredPacket_template::plLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field plLength of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_plLength;
}

INTEGER_template& ExtGnNonSecuredPacket_template::maxHopLimit()
{
set_specific();
return single_value->field_maxHopLimit;
}

const INTEGER_template& ExtGnNonSecuredPacket_template::maxHopLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field maxHopLimit of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_maxHopLimit;
}

INTEGER_template& ExtGnNonSecuredPacket_template::reserved2()
{
set_specific();
return single_value->field_reserved2;
}

const INTEGER_template& ExtGnNonSecuredPacket_template::reserved2() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved2 of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_reserved2;
}

LibItsGeoNetworking__TypesAndValues::ExtendedHeader_template& ExtGnNonSecuredPacket_template::extendedHeader()
{
set_specific();
return single_value->field_extendedHeader;
}

const LibItsGeoNetworking__TypesAndValues::ExtendedHeader_template& ExtGnNonSecuredPacket_template::extendedHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field extendedHeader of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_extendedHeader;
}

LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template& ExtGnNonSecuredPacket_template::ipv6Packet()
{
set_specific();
return single_value->field_ipv6Packet;
}

const LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template& ExtGnNonSecuredPacket_template::ipv6Packet() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ipv6Packet of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_ipv6Packet;
}

LibItsBtp__TypesAndValues::BtpHeader_template& ExtGnNonSecuredPacket_template::btpHeader()
{
set_specific();
return single_value->field_btpHeader;
}

const LibItsBtp__TypesAndValues::BtpHeader_template& ExtGnNonSecuredPacket_template::btpHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpHeader of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_btpHeader;
}

OCTETSTRING_template& ExtGnNonSecuredPacket_template::btpPayload()
{
set_specific();
return single_value->field_btpPayload;
}

const OCTETSTRING_template& ExtGnNonSecuredPacket_template::btpPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpPayload of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_btpPayload;
}

OCTETSTRING_template& ExtGnNonSecuredPacket_template::rawPayload()
{
set_specific();
return single_value->field_rawPayload;
}

const OCTETSTRING_template& ExtGnNonSecuredPacket_template::rawPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawPayload of a non-specific template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
return single_value->field_rawPayload;
}

int ExtGnNonSecuredPacket_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnNonSecuredPacket which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 10;
      if (single_value->field_ipv6Packet.is_present()) ret_val++;
      if (single_value->field_btpHeader.is_present()) ret_val++;
      if (single_value->field_btpPayload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnNonSecuredPacket containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnNonSecuredPacket containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnNonSecuredPacket containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnNonSecuredPacket containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGnNonSecuredPacket containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
  }
  return 0;
}

void ExtGnNonSecuredPacket_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ nextHeader := ");
single_value->field_nextHeader.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", headerTST := ");
single_value->field_headerTST.log();
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log();
TTCN_Logger::log_event_str(", flags := ");
single_value->field_flags.log();
TTCN_Logger::log_event_str(", plLength := ");
single_value->field_plLength.log();
TTCN_Logger::log_event_str(", maxHopLimit := ");
single_value->field_maxHopLimit.log();
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log();
TTCN_Logger::log_event_str(", extendedHeader := ");
single_value->field_extendedHeader.log();
TTCN_Logger::log_event_str(", ipv6Packet := ");
single_value->field_ipv6Packet.log();
TTCN_Logger::log_event_str(", btpHeader := ");
single_value->field_btpHeader.log();
TTCN_Logger::log_event_str(", btpPayload := ");
single_value->field_btpPayload.log();
TTCN_Logger::log_event_str(", rawPayload := ");
single_value->field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtGnNonSecuredPacket_template::log_match(const ExtGnNonSecuredPacket& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_nextHeader.match(match_value.nextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".nextHeader");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerTST.match(match_value.headerTST(), legacy)){
TTCN_Logger::log_logmatch_info(".headerTST");
single_value->field_headerTST.log_match(match_value.headerTST(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trafficClass.match(match_value.trafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficClass");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_flags.match(match_value.flags(), legacy)){
TTCN_Logger::log_logmatch_info(".flags");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_plLength.match(match_value.plLength(), legacy)){
TTCN_Logger::log_logmatch_info(".plLength");
single_value->field_plLength.log_match(match_value.plLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_maxHopLimit.match(match_value.maxHopLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".maxHopLimit");
single_value->field_maxHopLimit.log_match(match_value.maxHopLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved2.match(match_value.reserved2(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved2");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_extendedHeader.match(match_value.extendedHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".extendedHeader");
single_value->field_extendedHeader.log_match(match_value.extendedHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.ipv6Packet().ispresent()){
if(!single_value->field_ipv6Packet.match(match_value.ipv6Packet(), legacy)){
TTCN_Logger::log_logmatch_info(".ipv6Packet");
single_value->field_ipv6Packet.log_match(match_value.ipv6Packet(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ipv6Packet.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ipv6Packet := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ipv6Packet.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.btpHeader().ispresent()){
if(!single_value->field_btpHeader.match(match_value.btpHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".btpHeader");
single_value->field_btpHeader.log_match(match_value.btpHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_btpHeader.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".btpHeader := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_btpHeader.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.btpPayload().ispresent()){
if(!single_value->field_btpPayload.match(match_value.btpPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".btpPayload");
single_value->field_btpPayload.log_match(match_value.btpPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_btpPayload.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".btpPayload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_btpPayload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_rawPayload.match(match_value.rawPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".rawPayload");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ nextHeader := ");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", headerTST := ");
single_value->field_headerTST.log_match(match_value.headerTST(), legacy);
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::log_event_str(", flags := ");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::log_event_str(", plLength := ");
single_value->field_plLength.log_match(match_value.plLength(), legacy);
TTCN_Logger::log_event_str(", maxHopLimit := ");
single_value->field_maxHopLimit.log_match(match_value.maxHopLimit(), legacy);
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::log_event_str(", extendedHeader := ");
single_value->field_extendedHeader.log_match(match_value.extendedHeader(), legacy);
TTCN_Logger::log_event_str(", ipv6Packet := ");
if (match_value.ipv6Packet().ispresent()) single_value->field_ipv6Packet.log_match(match_value.ipv6Packet(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ipv6Packet.log();
if (single_value->field_ipv6Packet.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", btpHeader := ");
if (match_value.btpHeader().ispresent()) single_value->field_btpHeader.log_match(match_value.btpHeader(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_btpHeader.log();
if (single_value->field_btpHeader.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", btpPayload := ");
if (match_value.btpPayload().ispresent()) single_value->field_btpPayload.log_match(match_value.btpPayload(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_btpPayload.log();
if (single_value->field_btpPayload.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", rawPayload := ");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtGnNonSecuredPacket_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_nextHeader.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_headerTST.encode_text(text_buf);
single_value->field_trafficClass.encode_text(text_buf);
single_value->field_flags.encode_text(text_buf);
single_value->field_plLength.encode_text(text_buf);
single_value->field_maxHopLimit.encode_text(text_buf);
single_value->field_reserved2.encode_text(text_buf);
single_value->field_extendedHeader.encode_text(text_buf);
single_value->field_ipv6Packet.encode_text(text_buf);
single_value->field_btpHeader.encode_text(text_buf);
single_value->field_btpPayload.encode_text(text_buf);
single_value->field_rawPayload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
}
}

void ExtGnNonSecuredPacket_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_nextHeader.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_headerTST.decode_text(text_buf);
single_value->field_trafficClass.decode_text(text_buf);
single_value->field_flags.decode_text(text_buf);
single_value->field_plLength.decode_text(text_buf);
single_value->field_maxHopLimit.decode_text(text_buf);
single_value->field_reserved2.decode_text(text_buf);
single_value->field_extendedHeader.decode_text(text_buf);
single_value->field_ipv6Packet.decode_text(text_buf);
single_value->field_btpHeader.decode_text(text_buf);
single_value->field_btpPayload.decode_text(text_buf);
single_value->field_rawPayload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtGnNonSecuredPacket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtGnNonSecuredPacket.");
}
}

void ExtGnNonSecuredPacket_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtGnNonSecuredPacket'");
    }
    if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("headerTST", param_field) == 0) {
      headerTST().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("flags", param_field) == 0) {
      flags().set_param(param);
      return;
    } else if (strcmp("plLength", param_field) == 0) {
      plLength().set_param(param);
      return;
    } else if (strcmp("maxHopLimit", param_field) == 0) {
      maxHopLimit().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else if (strcmp("extendedHeader", param_field) == 0) {
      extendedHeader().set_param(param);
      return;
    } else if (strcmp("ipv6Packet", param_field) == 0) {
      ipv6Packet().set_param(param);
      return;
    } else if (strcmp("btpHeader", param_field) == 0) {
      btpHeader().set_param(param);
      return;
    } else if (strcmp("btpPayload", param_field) == 0) {
      btpPayload().set_param(param);
      return;
    } else if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtGnNonSecuredPacket'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtGnNonSecuredPacket_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (13<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtGnNonSecuredPacket has 13 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) headerTST().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) plLength().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) maxHopLimit().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) extendedHeader().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) ipv6Packet().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) btpHeader().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) btpPayload().set_param(*mp->get_elem(11));
    if (mp->get_size()>12 && mp->get_elem(12)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(12));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerTST")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerTST().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "plLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          plLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maxHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maxHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "extendedHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          extendedHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv6Packet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv6Packet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGnNonSecuredPacket: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtGnNonSecuredPacket");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtGnNonSecuredPacket_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtGnNonSecuredPacket'");
    }
    if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("headerTST", param_field) == 0) {
      return headerTST().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("flags", param_field) == 0) {
      return flags().get_param(param_name);
    } else if (strcmp("plLength", param_field) == 0) {
      return plLength().get_param(param_name);
    } else if (strcmp("maxHopLimit", param_field) == 0) {
      return maxHopLimit().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else if (strcmp("extendedHeader", param_field) == 0) {
      return extendedHeader().get_param(param_name);
    } else if (strcmp("ipv6Packet", param_field) == 0) {
      return ipv6Packet().get_param(param_name);
    } else if (strcmp("btpHeader", param_field) == 0) {
      return btpHeader().get_param(param_name);
    } else if (strcmp("btpPayload", param_field) == 0) {
      return btpPayload().get_param(param_name);
    } else if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGnNonSecuredPacket'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_nextHeader = single_value->field_nextHeader.get_param(param_name);
    mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
    mp->add_elem(mp_field_nextHeader);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_headerTST = single_value->field_headerTST.get_param(param_name);
    mp_field_headerTST->set_id(new Module_Param_FieldName(mcopystr("headerTST")));
    mp->add_elem(mp_field_headerTST);
    Module_Param* mp_field_trafficClass = single_value->field_trafficClass.get_param(param_name);
    mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
    mp->add_elem(mp_field_trafficClass);
    Module_Param* mp_field_flags = single_value->field_flags.get_param(param_name);
    mp_field_flags->set_id(new Module_Param_FieldName(mcopystr("flags")));
    mp->add_elem(mp_field_flags);
    Module_Param* mp_field_plLength = single_value->field_plLength.get_param(param_name);
    mp_field_plLength->set_id(new Module_Param_FieldName(mcopystr("plLength")));
    mp->add_elem(mp_field_plLength);
    Module_Param* mp_field_maxHopLimit = single_value->field_maxHopLimit.get_param(param_name);
    mp_field_maxHopLimit->set_id(new Module_Param_FieldName(mcopystr("maxHopLimit")));
    mp->add_elem(mp_field_maxHopLimit);
    Module_Param* mp_field_reserved2 = single_value->field_reserved2.get_param(param_name);
    mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
    mp->add_elem(mp_field_reserved2);
    Module_Param* mp_field_extendedHeader = single_value->field_extendedHeader.get_param(param_name);
    mp_field_extendedHeader->set_id(new Module_Param_FieldName(mcopystr("extendedHeader")));
    mp->add_elem(mp_field_extendedHeader);
    Module_Param* mp_field_ipv6Packet = single_value->field_ipv6Packet.get_param(param_name);
    mp_field_ipv6Packet->set_id(new Module_Param_FieldName(mcopystr("ipv6Packet")));
    mp->add_elem(mp_field_ipv6Packet);
    Module_Param* mp_field_btpHeader = single_value->field_btpHeader.get_param(param_name);
    mp_field_btpHeader->set_id(new Module_Param_FieldName(mcopystr("btpHeader")));
    mp->add_elem(mp_field_btpHeader);
    Module_Param* mp_field_btpPayload = single_value->field_btpPayload.get_param(param_name);
    mp_field_btpPayload->set_id(new Module_Param_FieldName(mcopystr("btpPayload")));
    mp->add_elem(mp_field_btpPayload);
    Module_Param* mp_field_rawPayload = single_value->field_rawPayload.get_param(param_name);
    mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
    mp->add_elem(mp_field_rawPayload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtGnNonSecuredPacket_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_nextHeader.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_headerTST.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_trafficClass.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_flags.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_plLength.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_maxHopLimit.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_reserved2.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_extendedHeader.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_ipv6Packet.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_btpHeader.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_btpPayload.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
single_value->field_rawPayload.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtGnNonSecuredPacket");
}

boolean ExtGnNonSecuredPacket_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtGnNonSecuredPacket_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtGeoNetworkingPdu::ExtGeoNetworkingPdu()
{
  bound_flag = FALSE;
}

ExtGeoNetworkingPdu::ExtGeoNetworkingPdu(const INTEGER& par_version,
    const LibItsGeoNetworking__TypesAndValues::BasicNextHeader& par_nextHeader,
    const INTEGER& par_reserved,
    const LibItsGeoNetworking__TypesAndValues::Lifetime& par_lifeTime,
    const INTEGER& par_routerHopLimit,
    const OPTIONAL<ExtGnNonSecuredPacket>& par_packet,
    const OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage>& par_securedMsg)
  :   field_version(par_version),
  field_nextHeader(par_nextHeader),
  field_reserved(par_reserved),
  field_lifeTime(par_lifeTime),
  field_routerHopLimit(par_routerHopLimit),
  field_packet(par_packet),
  field_securedMsg(par_securedMsg)
{
  bound_flag = TRUE;
}

ExtGeoNetworkingPdu::ExtGeoNetworkingPdu(const ExtGeoNetworkingPdu& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
bound_flag = TRUE;
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
else field_nextHeader.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.lifeTime().is_bound()) field_lifeTime = other_value.lifeTime();
else field_lifeTime.clean_up();
if (other_value.routerHopLimit().is_bound()) field_routerHopLimit = other_value.routerHopLimit();
else field_routerHopLimit.clean_up();
if (other_value.packet().is_bound()) field_packet = other_value.packet();
else field_packet.clean_up();
if (other_value.securedMsg().is_bound()) field_securedMsg = other_value.securedMsg();
else field_securedMsg.clean_up();
}

void ExtGeoNetworkingPdu::clean_up()
{
field_version.clean_up();
field_nextHeader.clean_up();
field_reserved.clean_up();
field_lifeTime.clean_up();
field_routerHopLimit.clean_up();
field_packet.clean_up();
field_securedMsg.clean_up();
bound_flag = FALSE;
}

ExtGeoNetworkingPdu& ExtGeoNetworkingPdu::operator=(const ExtGeoNetworkingPdu& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
  bound_flag = TRUE;
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
  else field_nextHeader.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.lifeTime().is_bound()) field_lifeTime = other_value.lifeTime();
  else field_lifeTime.clean_up();
  if (other_value.routerHopLimit().is_bound()) field_routerHopLimit = other_value.routerHopLimit();
  else field_routerHopLimit.clean_up();
  if (other_value.packet().is_bound()) field_packet = other_value.packet();
  else field_packet.clean_up();
  if (other_value.securedMsg().is_bound()) field_securedMsg = other_value.securedMsg();
  else field_securedMsg.clean_up();
}
return *this;
}

boolean ExtGeoNetworkingPdu::operator==(const ExtGeoNetworkingPdu& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_version==other_value.field_version
  && field_nextHeader==other_value.field_nextHeader
  && field_reserved==other_value.field_reserved
  && field_lifeTime==other_value.field_lifeTime
  && field_routerHopLimit==other_value.field_routerHopLimit
  && field_packet==other_value.field_packet
  && field_securedMsg==other_value.field_securedMsg;
}

boolean ExtGeoNetworkingPdu::is_bound() const
{
if (bound_flag) return TRUE;
if(field_version.is_bound()) return TRUE;
if(field_nextHeader.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_lifeTime.is_bound()) return TRUE;
if(field_routerHopLimit.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_packet.get_selection() || field_packet.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_securedMsg.get_selection() || field_securedMsg.is_bound()) return TRUE;
return FALSE;
}
boolean ExtGeoNetworkingPdu::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_version.is_value()) return FALSE;
if(!field_nextHeader.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_lifeTime.is_value()) return FALSE;
if(!field_routerHopLimit.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_packet.get_selection() && !field_packet.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_securedMsg.get_selection() && !field_securedMsg.is_value()) return FALSE;
return TRUE;
}
int ExtGeoNetworkingPdu::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtGeoNetworkingPdu");
  int ret_val = 5;
  if (field_packet.ispresent()) ret_val++;
  if (field_securedMsg.ispresent()) ret_val++;
  return ret_val;
}

void ExtGeoNetworkingPdu::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ version := ");
field_version.log();
TTCN_Logger::log_event_str(", nextHeader := ");
field_nextHeader.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", lifeTime := ");
field_lifeTime.log();
TTCN_Logger::log_event_str(", routerHopLimit := ");
field_routerHopLimit.log();
TTCN_Logger::log_event_str(", packet := ");
field_packet.log();
TTCN_Logger::log_event_str(", securedMsg := ");
field_securedMsg.log();
TTCN_Logger::log_event_str(" }");
}

void ExtGeoNetworkingPdu::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtGeoNetworkingPdu'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("lifeTime", param_field) == 0) {
      lifeTime().set_param(param);
      return;
    } else if (strcmp("routerHopLimit", param_field) == 0) {
      routerHopLimit().set_param(param);
      return;
    } else if (strcmp("packet", param_field) == 0) {
      packet().set_param(param);
      return;
    } else if (strcmp("securedMsg", param_field) == 0) {
      securedMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtGeoNetworkingPdu'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtGeoNetworkingPdu has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) lifeTime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) routerHopLimit().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) packet().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) securedMsg().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifeTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifeTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "routerHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          routerHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "securedMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          securedMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGeoNetworkingPdu: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtGeoNetworkingPdu");
  }
}

Module_Param* ExtGeoNetworkingPdu::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtGeoNetworkingPdu'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("lifeTime", param_field) == 0) {
      return lifeTime().get_param(param_name);
    } else if (strcmp("routerHopLimit", param_field) == 0) {
      return routerHopLimit().get_param(param_name);
    } else if (strcmp("packet", param_field) == 0) {
      return packet().get_param(param_name);
    } else if (strcmp("securedMsg", param_field) == 0) {
      return securedMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGeoNetworkingPdu'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_version = field_version.get_param(param_name);
  mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
  mp->add_elem(mp_field_version);
  Module_Param* mp_field_nextHeader = field_nextHeader.get_param(param_name);
  mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
  mp->add_elem(mp_field_nextHeader);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_lifeTime = field_lifeTime.get_param(param_name);
  mp_field_lifeTime->set_id(new Module_Param_FieldName(mcopystr("lifeTime")));
  mp->add_elem(mp_field_lifeTime);
  Module_Param* mp_field_routerHopLimit = field_routerHopLimit.get_param(param_name);
  mp_field_routerHopLimit->set_id(new Module_Param_FieldName(mcopystr("routerHopLimit")));
  mp->add_elem(mp_field_routerHopLimit);
  Module_Param* mp_field_packet = field_packet.get_param(param_name);
  mp_field_packet->set_id(new Module_Param_FieldName(mcopystr("packet")));
  mp->add_elem(mp_field_packet);
  Module_Param* mp_field_securedMsg = field_securedMsg.get_param(param_name);
  mp_field_securedMsg->set_id(new Module_Param_FieldName(mcopystr("securedMsg")));
  mp->add_elem(mp_field_securedMsg);
  return mp;
  }

void ExtGeoNetworkingPdu::set_implicit_omit()
{
if (version().is_bound()) version().set_implicit_omit();
if (nextHeader().is_bound()) nextHeader().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (lifeTime().is_bound()) lifeTime().set_implicit_omit();
if (routerHopLimit().is_bound()) routerHopLimit().set_implicit_omit();
if (!packet().is_bound()) packet() = OMIT_VALUE;
else packet().set_implicit_omit();
if (!securedMsg().is_bound()) securedMsg() = OMIT_VALUE;
else securedMsg().set_implicit_omit();
}

void ExtGeoNetworkingPdu::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
field_version.encode_text(text_buf);
field_nextHeader.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_lifeTime.encode_text(text_buf);
field_routerHopLimit.encode_text(text_buf);
field_packet.encode_text(text_buf);
field_securedMsg.encode_text(text_buf);
}

void ExtGeoNetworkingPdu::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_version.decode_text(text_buf);
field_nextHeader.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_lifeTime.decode_text(text_buf);
field_routerHopLimit.decode_text(text_buf);
field_packet.decode_text(text_buf);
field_securedMsg.decode_text(text_buf);
}

void ExtGeoNetworkingPdu::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtGeoNetworkingPdu::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtGeoNetworkingPdu::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_version.RAW_decode(ExtGeoNetworkingPdu_version_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_nextHeader.RAW_decode(ExtGeoNetworkingPdu_nextHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(ExtGeoNetworkingPdu_reserved_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_lifeTime.RAW_decode(ExtGeoNetworkingPdu_lifeTime_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_routerHopLimit.RAW_decode(ExtGeoNetworkingPdu_routerHopLimit_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0 && field_nextHeader == LibItsGeoNetworking__TypesAndValues::BasicNextHeader::e__commonHeader){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_packet().RAW_decode(ExtGeoNetworkingPdu_packet_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_packet = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_packet=OMIT_VALUE;
  if (limit > 0 && field_nextHeader == LibItsGeoNetworking__TypesAndValues::BasicNextHeader::e__securedPacket){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_securedMsg().RAW_decode(ExtGeoNetworkingPdu_securedMsg_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_securedMsg = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_securedMsg=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtGeoNetworkingPdu::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ExtGeoNetworkingPdu_version_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ExtGeoNetworkingPdu_nextHeader_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, ExtGeoNetworkingPdu_reserved_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, ExtGeoNetworkingPdu_lifeTime_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, ExtGeoNetworkingPdu_routerHopLimit_descr_.raw);
  if (field_packet.ispresent()) {
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, ExtGeoNetworkingPdu_packet_descr_.raw);
  }
  else myleaf.body.node.nodes[5] = NULL;
  if (field_securedMsg.ispresent()) {
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, ExtGeoNetworkingPdu_securedMsg_descr_.raw);
  }
  else myleaf.body.node.nodes[6] = NULL;
  encoded_length += field_version.RAW_encode(ExtGeoNetworkingPdu_version_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_nextHeader.RAW_encode(ExtGeoNetworkingPdu_nextHeader_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_reserved.RAW_encode(ExtGeoNetworkingPdu_reserved_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_lifeTime.RAW_encode(ExtGeoNetworkingPdu_lifeTime_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_routerHopLimit.RAW_encode(ExtGeoNetworkingPdu_routerHopLimit_descr_, *myleaf.body.node.nodes[4]);
  if (field_packet.ispresent()) {
  encoded_length += field_packet().RAW_encode(ExtGeoNetworkingPdu_packet_descr_, *myleaf.body.node.nodes[5]);
  }
  if (field_securedMsg.ispresent()) {
  encoded_length += field_securedMsg().RAW_encode(ExtGeoNetworkingPdu_securedMsg_descr_, *myleaf.body.node.nodes[6]);
  }
  if (field_packet.ispresent() && (field_nextHeader != LibItsGeoNetworking__TypesAndValues::BasicNextHeader::e__commonHeader)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={1};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
  LibItsGeoNetworking__TypesAndValues::BasicNextHeader new_val = LibItsGeoNetworking__TypesAndValues::BasicNextHeader::e__commonHeader;
  new_val.RAW_encode(ExtGeoNetworkingPdu_nextHeader_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  if (field_securedMsg.ispresent() && (field_nextHeader != LibItsGeoNetworking__TypesAndValues::BasicNextHeader::e__securedPacket)) {
  RAW_enc_tree* temp_leaf;
  {
  RAW_enc_tr_pos pr_pos;
  pr_pos.level=myleaf.curr_pos.level+1;
  int new_pos[]={1};
  pr_pos.pos=init_new_tree_pos(myleaf.curr_pos,1,new_pos);
  temp_leaf = myleaf.get_node(pr_pos);
  if(temp_leaf != NULL){
  LibItsGeoNetworking__TypesAndValues::BasicNextHeader new_val = LibItsGeoNetworking__TypesAndValues::BasicNextHeader::e__securedPacket;
  new_val.RAW_encode(ExtGeoNetworkingPdu_nextHeader_descr_,*temp_leaf);
  } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_OMITTED_TAG, "Encoding a tagged, but omitted value.");
  }
  free_tree_pos(pr_pos.pos);
  }
  }
  return myleaf.length = encoded_length;
}

int ExtGeoNetworkingPdu::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "version");
    enc_len += field_version.JSON_encode(ExtGeoNetworkingPdu_version_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nextHeader");
    enc_len += field_nextHeader.JSON_encode(ExtGeoNetworkingPdu_nextHeader_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(ExtGeoNetworkingPdu_reserved_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lifeTime");
    enc_len += field_lifeTime.JSON_encode(ExtGeoNetworkingPdu_lifeTime_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "routerHopLimit");
    enc_len += field_routerHopLimit.JSON_encode(ExtGeoNetworkingPdu_routerHopLimit_descr_, p_tok);
  }

  if (field_packet.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "packet");
    enc_len += field_packet.JSON_encode(ExtGeoNetworkingPdu_packet_descr_, p_tok);
  }

  if (field_securedMsg.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "securedMsg");
    enc_len += field_securedMsg.JSON_encode(ExtGeoNetworkingPdu_securedMsg_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtGeoNetworkingPdu::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "version", name_len)) {
         int ret_val = field_version.JSON_decode(ExtGeoNetworkingPdu_version_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "version");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "nextHeader", name_len)) {
         int ret_val = field_nextHeader.JSON_decode(ExtGeoNetworkingPdu_nextHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nextHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(ExtGeoNetworkingPdu_reserved_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "lifeTime", name_len)) {
         int ret_val = field_lifeTime.JSON_decode(ExtGeoNetworkingPdu_lifeTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lifeTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "routerHopLimit", name_len)) {
         int ret_val = field_routerHopLimit.JSON_decode(ExtGeoNetworkingPdu_routerHopLimit_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "routerHopLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "packet", name_len)) {
         int ret_val = field_packet.JSON_decode(ExtGeoNetworkingPdu_packet_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "packet");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "securedMsg", name_len)) {
         int ret_val = field_securedMsg.JSON_decode(ExtGeoNetworkingPdu_securedMsg_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "securedMsg");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_version.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "version");
    return JSON_ERROR_FATAL;
  }
if (!field_nextHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nextHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_lifeTime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lifeTime");
    return JSON_ERROR_FATAL;
  }
if (!field_routerHopLimit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "routerHopLimit");
    return JSON_ERROR_FATAL;
  }
if (!field_packet.is_bound()) {
    field_packet = OMIT_VALUE;
  }
if (!field_securedMsg.is_bound()) {
    field_securedMsg = OMIT_VALUE;
  }

  return dec_len;
}

struct ExtGeoNetworkingPdu_template::single_value_struct {
INTEGER_template field_version;
LibItsGeoNetworking__TypesAndValues::BasicNextHeader_template field_nextHeader;
INTEGER_template field_reserved;
LibItsGeoNetworking__TypesAndValues::Lifetime_template field_lifeTime;
INTEGER_template field_routerHopLimit;
ExtGnNonSecuredPacket_template field_packet;
LibItsSecurity__TypesAndValues::SecuredMessage_template field_securedMsg;
};

void ExtGeoNetworkingPdu_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_version = ANY_VALUE;
single_value->field_nextHeader = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_lifeTime = ANY_VALUE;
single_value->field_routerHopLimit = ANY_VALUE;
single_value->field_packet = ANY_OR_OMIT;
single_value->field_securedMsg = ANY_OR_OMIT;
}
}
}

void ExtGeoNetworkingPdu_template::copy_value(const ExtGeoNetworkingPdu& other_value)
{
single_value = new single_value_struct;
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.nextHeader().is_bound()) {
  single_value->field_nextHeader = other_value.nextHeader();
} else {
  single_value->field_nextHeader.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.lifeTime().is_bound()) {
  single_value->field_lifeTime = other_value.lifeTime();
} else {
  single_value->field_lifeTime.clean_up();
}
if (other_value.routerHopLimit().is_bound()) {
  single_value->field_routerHopLimit = other_value.routerHopLimit();
} else {
  single_value->field_routerHopLimit.clean_up();
}
if (other_value.packet().is_bound()) {
  if (other_value.packet().ispresent()) single_value->field_packet = other_value.packet()();
  else single_value->field_packet = OMIT_VALUE;
} else {
  single_value->field_packet.clean_up();
}
if (other_value.securedMsg().is_bound()) {
  if (other_value.securedMsg().ispresent()) single_value->field_securedMsg = other_value.securedMsg()();
  else single_value->field_securedMsg = OMIT_VALUE;
} else {
  single_value->field_securedMsg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtGeoNetworkingPdu_template::copy_template(const ExtGeoNetworkingPdu_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nextHeader().get_selection()) {
single_value->field_nextHeader = other_value.nextHeader();
} else {
single_value->field_nextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lifeTime().get_selection()) {
single_value->field_lifeTime = other_value.lifeTime();
} else {
single_value->field_lifeTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.routerHopLimit().get_selection()) {
single_value->field_routerHopLimit = other_value.routerHopLimit();
} else {
single_value->field_routerHopLimit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.packet().get_selection()) {
single_value->field_packet = other_value.packet();
} else {
single_value->field_packet.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.securedMsg().get_selection()) {
single_value->field_securedMsg = other_value.securedMsg();
} else {
single_value->field_securedMsg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtGeoNetworkingPdu_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
break;
}
set_selection(other_value);
}

ExtGeoNetworkingPdu_template::ExtGeoNetworkingPdu_template()
{
}

ExtGeoNetworkingPdu_template::ExtGeoNetworkingPdu_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtGeoNetworkingPdu_template::ExtGeoNetworkingPdu_template(const ExtGeoNetworkingPdu& other_value)
{
copy_value(other_value);
}

ExtGeoNetworkingPdu_template::ExtGeoNetworkingPdu_template(const OPTIONAL<ExtGeoNetworkingPdu>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGeoNetworkingPdu&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtGeoNetworkingPdu from an unbound optional field.");
}
}

ExtGeoNetworkingPdu_template::ExtGeoNetworkingPdu_template(const ExtGeoNetworkingPdu_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtGeoNetworkingPdu_template::~ExtGeoNetworkingPdu_template()
{
clean_up();
}

ExtGeoNetworkingPdu_template& ExtGeoNetworkingPdu_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtGeoNetworkingPdu_template& ExtGeoNetworkingPdu_template::operator=(const ExtGeoNetworkingPdu& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtGeoNetworkingPdu_template& ExtGeoNetworkingPdu_template::operator=(const OPTIONAL<ExtGeoNetworkingPdu>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGeoNetworkingPdu&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
}
return *this;
}

ExtGeoNetworkingPdu_template& ExtGeoNetworkingPdu_template::operator=(const ExtGeoNetworkingPdu_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtGeoNetworkingPdu_template::match(const ExtGeoNetworkingPdu& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version(), legacy))return FALSE;
if(!other_value.nextHeader().is_bound()) return FALSE;
if(!single_value->field_nextHeader.match(other_value.nextHeader(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.lifeTime().is_bound()) return FALSE;
if(!single_value->field_lifeTime.match(other_value.lifeTime(), legacy))return FALSE;
if(!other_value.routerHopLimit().is_bound()) return FALSE;
if(!single_value->field_routerHopLimit.match(other_value.routerHopLimit(), legacy))return FALSE;
if(!other_value.packet().is_bound()) return FALSE;
if((other_value.packet().ispresent() ? !single_value->field_packet.match((const ExtGnNonSecuredPacket&)other_value.packet(), legacy) : !single_value->field_packet.match_omit(legacy)))return FALSE;
if(!other_value.securedMsg().is_bound()) return FALSE;
if((other_value.securedMsg().ispresent() ? !single_value->field_securedMsg.match((const LibItsSecurity__TypesAndValues::SecuredMessage&)other_value.securedMsg(), legacy) : !single_value->field_securedMsg.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
}
return FALSE;
}

boolean ExtGeoNetworkingPdu_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_nextHeader.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_lifeTime.is_bound()) return TRUE;
if (single_value->field_routerHopLimit.is_bound()) return TRUE;
if (single_value->field_packet.is_omit() || single_value->field_packet.is_bound()) return TRUE;
if (single_value->field_securedMsg.is_omit() || single_value->field_securedMsg.is_bound()) return TRUE;
return FALSE;
}

boolean ExtGeoNetworkingPdu_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_nextHeader.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_lifeTime.is_value()) return FALSE;
if (!single_value->field_routerHopLimit.is_value()) return FALSE;
if (!single_value->field_packet.is_omit() && !single_value->field_packet.is_value()) return FALSE;
if (!single_value->field_securedMsg.is_omit() && !single_value->field_securedMsg.is_value()) return FALSE;
return TRUE;
}

void ExtGeoNetworkingPdu_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtGeoNetworkingPdu ExtGeoNetworkingPdu_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
ExtGeoNetworkingPdu ret_val;
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_nextHeader.is_bound()) {
ret_val.nextHeader() = single_value->field_nextHeader.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_lifeTime.is_bound()) {
ret_val.lifeTime() = single_value->field_lifeTime.valueof();
}
if (single_value->field_routerHopLimit.is_bound()) {
ret_val.routerHopLimit() = single_value->field_routerHopLimit.valueof();
}
if (single_value->field_packet.is_omit()) ret_val.packet() = OMIT_VALUE;
else if (single_value->field_packet.is_bound()) {
ret_val.packet() = single_value->field_packet.valueof();
}
if (single_value->field_securedMsg.is_omit()) ret_val.securedMsg() = OMIT_VALUE;
else if (single_value->field_securedMsg.is_bound()) {
ret_val.securedMsg() = single_value->field_securedMsg.valueof();
}
return ret_val;
}

void ExtGeoNetworkingPdu_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtGeoNetworkingPdu_template[list_length];
}

ExtGeoNetworkingPdu_template& ExtGeoNetworkingPdu_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
return value_list.list_value[list_index];
}

INTEGER_template& ExtGeoNetworkingPdu_template::version()
{
set_specific();
return single_value->field_version;
}

const INTEGER_template& ExtGeoNetworkingPdu_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
return single_value->field_version;
}

LibItsGeoNetworking__TypesAndValues::BasicNextHeader_template& ExtGeoNetworkingPdu_template::nextHeader()
{
set_specific();
return single_value->field_nextHeader;
}

const LibItsGeoNetworking__TypesAndValues::BasicNextHeader_template& ExtGeoNetworkingPdu_template::nextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nextHeader of a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
return single_value->field_nextHeader;
}

INTEGER_template& ExtGeoNetworkingPdu_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& ExtGeoNetworkingPdu_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
return single_value->field_reserved;
}

LibItsGeoNetworking__TypesAndValues::Lifetime_template& ExtGeoNetworkingPdu_template::lifeTime()
{
set_specific();
return single_value->field_lifeTime;
}

const LibItsGeoNetworking__TypesAndValues::Lifetime_template& ExtGeoNetworkingPdu_template::lifeTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lifeTime of a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
return single_value->field_lifeTime;
}

INTEGER_template& ExtGeoNetworkingPdu_template::routerHopLimit()
{
set_specific();
return single_value->field_routerHopLimit;
}

const INTEGER_template& ExtGeoNetworkingPdu_template::routerHopLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field routerHopLimit of a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
return single_value->field_routerHopLimit;
}

ExtGnNonSecuredPacket_template& ExtGeoNetworkingPdu_template::packet()
{
set_specific();
return single_value->field_packet;
}

const ExtGnNonSecuredPacket_template& ExtGeoNetworkingPdu_template::packet() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field packet of a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
return single_value->field_packet;
}

LibItsSecurity__TypesAndValues::SecuredMessage_template& ExtGeoNetworkingPdu_template::securedMsg()
{
set_specific();
return single_value->field_securedMsg;
}

const LibItsSecurity__TypesAndValues::SecuredMessage_template& ExtGeoNetworkingPdu_template::securedMsg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field securedMsg of a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
return single_value->field_securedMsg;
}

int ExtGeoNetworkingPdu_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingPdu which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 5;
      if (single_value->field_packet.is_present()) ret_val++;
      if (single_value->field_securedMsg.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingPdu containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingPdu containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingPdu containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingPdu containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingPdu containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
  }
  return 0;
}

void ExtGeoNetworkingPdu_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", nextHeader := ");
single_value->field_nextHeader.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", lifeTime := ");
single_value->field_lifeTime.log();
TTCN_Logger::log_event_str(", routerHopLimit := ");
single_value->field_routerHopLimit.log();
TTCN_Logger::log_event_str(", packet := ");
single_value->field_packet.log();
TTCN_Logger::log_event_str(", securedMsg := ");
single_value->field_securedMsg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtGeoNetworkingPdu_template::log_match(const ExtGeoNetworkingPdu& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_version.match(match_value.version(), legacy)){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_nextHeader.match(match_value.nextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".nextHeader");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lifeTime.match(match_value.lifeTime(), legacy)){
TTCN_Logger::log_logmatch_info(".lifeTime");
single_value->field_lifeTime.log_match(match_value.lifeTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_routerHopLimit.match(match_value.routerHopLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".routerHopLimit");
single_value->field_routerHopLimit.log_match(match_value.routerHopLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.packet().ispresent()){
if(!single_value->field_packet.match(match_value.packet(), legacy)){
TTCN_Logger::log_logmatch_info(".packet");
single_value->field_packet.log_match(match_value.packet(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_packet.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".packet := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_packet.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.securedMsg().ispresent()){
if(!single_value->field_securedMsg.match(match_value.securedMsg(), legacy)){
TTCN_Logger::log_logmatch_info(".securedMsg");
single_value->field_securedMsg.log_match(match_value.securedMsg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_securedMsg.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".securedMsg := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_securedMsg.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::log_event_str(", nextHeader := ");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", lifeTime := ");
single_value->field_lifeTime.log_match(match_value.lifeTime(), legacy);
TTCN_Logger::log_event_str(", routerHopLimit := ");
single_value->field_routerHopLimit.log_match(match_value.routerHopLimit(), legacy);
TTCN_Logger::log_event_str(", packet := ");
if (match_value.packet().ispresent()) single_value->field_packet.log_match(match_value.packet(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_packet.log();
if (single_value->field_packet.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", securedMsg := ");
if (match_value.securedMsg().ispresent()) single_value->field_securedMsg.log_match(match_value.securedMsg(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_securedMsg.log();
if (single_value->field_securedMsg.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtGeoNetworkingPdu_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_version.encode_text(text_buf);
single_value->field_nextHeader.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_lifeTime.encode_text(text_buf);
single_value->field_routerHopLimit.encode_text(text_buf);
single_value->field_packet.encode_text(text_buf);
single_value->field_securedMsg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
}
}

void ExtGeoNetworkingPdu_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_version.decode_text(text_buf);
single_value->field_nextHeader.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_lifeTime.decode_text(text_buf);
single_value->field_routerHopLimit.decode_text(text_buf);
single_value->field_packet.decode_text(text_buf);
single_value->field_securedMsg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtGeoNetworkingPdu_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtGeoNetworkingPdu.");
}
}

void ExtGeoNetworkingPdu_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtGeoNetworkingPdu'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("lifeTime", param_field) == 0) {
      lifeTime().set_param(param);
      return;
    } else if (strcmp("routerHopLimit", param_field) == 0) {
      routerHopLimit().set_param(param);
      return;
    } else if (strcmp("packet", param_field) == 0) {
      packet().set_param(param);
      return;
    } else if (strcmp("securedMsg", param_field) == 0) {
      securedMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtGeoNetworkingPdu'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtGeoNetworkingPdu_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtGeoNetworkingPdu has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) lifeTime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) routerHopLimit().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) packet().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) securedMsg().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifeTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifeTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "routerHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          routerHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "securedMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          securedMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGeoNetworkingPdu: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtGeoNetworkingPdu");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtGeoNetworkingPdu_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtGeoNetworkingPdu'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("lifeTime", param_field) == 0) {
      return lifeTime().get_param(param_name);
    } else if (strcmp("routerHopLimit", param_field) == 0) {
      return routerHopLimit().get_param(param_name);
    } else if (strcmp("packet", param_field) == 0) {
      return packet().get_param(param_name);
    } else if (strcmp("securedMsg", param_field) == 0) {
      return securedMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGeoNetworkingPdu'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_version = single_value->field_version.get_param(param_name);
    mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
    mp->add_elem(mp_field_version);
    Module_Param* mp_field_nextHeader = single_value->field_nextHeader.get_param(param_name);
    mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
    mp->add_elem(mp_field_nextHeader);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_lifeTime = single_value->field_lifeTime.get_param(param_name);
    mp_field_lifeTime->set_id(new Module_Param_FieldName(mcopystr("lifeTime")));
    mp->add_elem(mp_field_lifeTime);
    Module_Param* mp_field_routerHopLimit = single_value->field_routerHopLimit.get_param(param_name);
    mp_field_routerHopLimit->set_id(new Module_Param_FieldName(mcopystr("routerHopLimit")));
    mp->add_elem(mp_field_routerHopLimit);
    Module_Param* mp_field_packet = single_value->field_packet.get_param(param_name);
    mp_field_packet->set_id(new Module_Param_FieldName(mcopystr("packet")));
    mp->add_elem(mp_field_packet);
    Module_Param* mp_field_securedMsg = single_value->field_securedMsg.get_param(param_name);
    mp_field_securedMsg->set_id(new Module_Param_FieldName(mcopystr("securedMsg")));
    mp->add_elem(mp_field_securedMsg);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtGeoNetworkingPdu_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingPdu");
single_value->field_nextHeader.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingPdu");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingPdu");
single_value->field_lifeTime.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingPdu");
single_value->field_routerHopLimit.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingPdu");
single_value->field_packet.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingPdu");
single_value->field_securedMsg.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingPdu");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingPdu");
}

boolean ExtGeoNetworkingPdu_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtGeoNetworkingPdu_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ExtGeoNetworkingInd::ExtGeoNetworkingInd()
{
  bound_flag = FALSE;
}

ExtGeoNetworkingInd::ExtGeoNetworkingInd(const ExtGeoNetworkingPdu& par_msgIn,
    const OCTETSTRING& par_macDestinationAddress)
  :   field_msgIn(par_msgIn),
  field_macDestinationAddress(par_macDestinationAddress)
{
  bound_flag = TRUE;
}

ExtGeoNetworkingInd::ExtGeoNetworkingInd(const ExtGeoNetworkingInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @TTCN_EncDec.ExtGeoNetworkingInd.");
bound_flag = TRUE;
if (other_value.msgIn().is_bound()) field_msgIn = other_value.msgIn();
else field_msgIn.clean_up();
if (other_value.macDestinationAddress().is_bound()) field_macDestinationAddress = other_value.macDestinationAddress();
else field_macDestinationAddress.clean_up();
}

void ExtGeoNetworkingInd::clean_up()
{
field_msgIn.clean_up();
field_macDestinationAddress.clean_up();
bound_flag = FALSE;
}

ExtGeoNetworkingInd& ExtGeoNetworkingInd::operator=(const ExtGeoNetworkingInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @TTCN_EncDec.ExtGeoNetworkingInd.");
  bound_flag = TRUE;
  if (other_value.msgIn().is_bound()) field_msgIn = other_value.msgIn();
  else field_msgIn.clean_up();
  if (other_value.macDestinationAddress().is_bound()) field_macDestinationAddress = other_value.macDestinationAddress();
  else field_macDestinationAddress.clean_up();
}
return *this;
}

boolean ExtGeoNetworkingInd::operator==(const ExtGeoNetworkingInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgIn==other_value.field_msgIn
  && field_macDestinationAddress==other_value.field_macDestinationAddress;
}

boolean ExtGeoNetworkingInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgIn.is_bound()) return TRUE;
if(field_macDestinationAddress.is_bound()) return TRUE;
return FALSE;
}
boolean ExtGeoNetworkingInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgIn.is_value()) return FALSE;
if(!field_macDestinationAddress.is_value()) return FALSE;
return TRUE;
}
int ExtGeoNetworkingInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @TTCN_EncDec.ExtGeoNetworkingInd");
  return 2;
}

void ExtGeoNetworkingInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgIn := ");
field_msgIn.log();
TTCN_Logger::log_event_str(", macDestinationAddress := ");
field_macDestinationAddress.log();
TTCN_Logger::log_event_str(" }");
}

void ExtGeoNetworkingInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@TTCN_EncDec.ExtGeoNetworkingInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      msgIn().set_param(param);
      return;
    } else if (strcmp("macDestinationAddress", param_field) == 0) {
      macDestinationAddress().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@TTCN_EncDec.ExtGeoNetworkingInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @TTCN_EncDec.ExtGeoNetworkingInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgIn().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) macDestinationAddress().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "macDestinationAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          macDestinationAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGeoNetworkingInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@TTCN_EncDec.ExtGeoNetworkingInd");
  }
}

Module_Param* ExtGeoNetworkingInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@TTCN_EncDec.ExtGeoNetworkingInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      return msgIn().get_param(param_name);
    } else if (strcmp("macDestinationAddress", param_field) == 0) {
      return macDestinationAddress().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGeoNetworkingInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgIn = field_msgIn.get_param(param_name);
  mp_field_msgIn->set_id(new Module_Param_FieldName(mcopystr("msgIn")));
  mp->add_elem(mp_field_msgIn);
  Module_Param* mp_field_macDestinationAddress = field_macDestinationAddress.get_param(param_name);
  mp_field_macDestinationAddress->set_id(new Module_Param_FieldName(mcopystr("macDestinationAddress")));
  mp->add_elem(mp_field_macDestinationAddress);
  return mp;
  }

void ExtGeoNetworkingInd::set_implicit_omit()
{
if (msgIn().is_bound()) msgIn().set_implicit_omit();
if (macDestinationAddress().is_bound()) macDestinationAddress().set_implicit_omit();
}

void ExtGeoNetworkingInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @TTCN_EncDec.ExtGeoNetworkingInd.");
field_msgIn.encode_text(text_buf);
field_macDestinationAddress.encode_text(text_buf);
}

void ExtGeoNetworkingInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgIn.decode_text(text_buf);
field_macDestinationAddress.decode_text(text_buf);
}

void ExtGeoNetworkingInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtGeoNetworkingInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtGeoNetworkingInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_msgIn.RAW_decode(ExtGeoNetworkingInd_msgIn_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_macDestinationAddress.RAW_decode(LibItsExternal__TypesAndValues::MacAddress_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ExtGeoNetworkingInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ExtGeoNetworkingInd_msgIn_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibItsExternal__TypesAndValues::MacAddress_descr_.raw);
  encoded_length += field_msgIn.RAW_encode(ExtGeoNetworkingInd_msgIn_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_macDestinationAddress.RAW_encode(LibItsExternal__TypesAndValues::MacAddress_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int ExtGeoNetworkingInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @TTCN_EncDec.ExtGeoNetworkingInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "msgIn");
    enc_len += field_msgIn.JSON_encode(ExtGeoNetworkingInd_msgIn_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "macDestinationAddress");
    enc_len += field_macDestinationAddress.JSON_encode(LibItsExternal__TypesAndValues::MacAddress_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtGeoNetworkingInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "msgIn", name_len)) {
         int ret_val = field_msgIn.JSON_decode(ExtGeoNetworkingInd_msgIn_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "msgIn");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (21 == name_len && 0 == strncmp(fld_name, "macDestinationAddress", name_len)) {
         int ret_val = field_macDestinationAddress.JSON_decode(LibItsExternal__TypesAndValues::MacAddress_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "macDestinationAddress");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_msgIn.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "msgIn");
    return JSON_ERROR_FATAL;
  }
if (!field_macDestinationAddress.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "macDestinationAddress");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ExtGeoNetworkingInd_template::single_value_struct {
ExtGeoNetworkingPdu_template field_msgIn;
OCTETSTRING_template field_macDestinationAddress;
};

void ExtGeoNetworkingInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgIn = ANY_VALUE;
single_value->field_macDestinationAddress = ANY_VALUE;
}
}
}

void ExtGeoNetworkingInd_template::copy_value(const ExtGeoNetworkingInd& other_value)
{
single_value = new single_value_struct;
if (other_value.msgIn().is_bound()) {
  single_value->field_msgIn = other_value.msgIn();
} else {
  single_value->field_msgIn.clean_up();
}
if (other_value.macDestinationAddress().is_bound()) {
  single_value->field_macDestinationAddress = other_value.macDestinationAddress();
} else {
  single_value->field_macDestinationAddress.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ExtGeoNetworkingInd_template::copy_template(const ExtGeoNetworkingInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgIn().get_selection()) {
single_value->field_msgIn = other_value.msgIn();
} else {
single_value->field_msgIn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.macDestinationAddress().get_selection()) {
single_value->field_macDestinationAddress = other_value.macDestinationAddress();
} else {
single_value->field_macDestinationAddress.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtGeoNetworkingInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
break;
}
set_selection(other_value);
}

ExtGeoNetworkingInd_template::ExtGeoNetworkingInd_template()
{
}

ExtGeoNetworkingInd_template::ExtGeoNetworkingInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtGeoNetworkingInd_template::ExtGeoNetworkingInd_template(const ExtGeoNetworkingInd& other_value)
{
copy_value(other_value);
}

ExtGeoNetworkingInd_template::ExtGeoNetworkingInd_template(const OPTIONAL<ExtGeoNetworkingInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGeoNetworkingInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @TTCN_EncDec.ExtGeoNetworkingInd from an unbound optional field.");
}
}

ExtGeoNetworkingInd_template::ExtGeoNetworkingInd_template(const ExtGeoNetworkingInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ExtGeoNetworkingInd_template::~ExtGeoNetworkingInd_template()
{
clean_up();
}

ExtGeoNetworkingInd_template& ExtGeoNetworkingInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtGeoNetworkingInd_template& ExtGeoNetworkingInd_template::operator=(const ExtGeoNetworkingInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtGeoNetworkingInd_template& ExtGeoNetworkingInd_template::operator=(const OPTIONAL<ExtGeoNetworkingInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtGeoNetworkingInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
}
return *this;
}

ExtGeoNetworkingInd_template& ExtGeoNetworkingInd_template::operator=(const ExtGeoNetworkingInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtGeoNetworkingInd_template::match(const ExtGeoNetworkingInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgIn().is_bound()) return FALSE;
if(!single_value->field_msgIn.match(other_value.msgIn(), legacy))return FALSE;
if(!other_value.macDestinationAddress().is_bound()) return FALSE;
if(!single_value->field_macDestinationAddress.match(other_value.macDestinationAddress(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
}
return FALSE;
}

boolean ExtGeoNetworkingInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgIn.is_bound()) return TRUE;
if (single_value->field_macDestinationAddress.is_bound()) return TRUE;
return FALSE;
}

boolean ExtGeoNetworkingInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgIn.is_value()) return FALSE;
if (!single_value->field_macDestinationAddress.is_value()) return FALSE;
return TRUE;
}

void ExtGeoNetworkingInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtGeoNetworkingInd ExtGeoNetworkingInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
ExtGeoNetworkingInd ret_val;
if (single_value->field_msgIn.is_bound()) {
ret_val.msgIn() = single_value->field_msgIn.valueof();
}
if (single_value->field_macDestinationAddress.is_bound()) {
ret_val.macDestinationAddress() = single_value->field_macDestinationAddress.valueof();
}
return ret_val;
}

void ExtGeoNetworkingInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtGeoNetworkingInd_template[list_length];
}

ExtGeoNetworkingInd_template& ExtGeoNetworkingInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
return value_list.list_value[list_index];
}

ExtGeoNetworkingPdu_template& ExtGeoNetworkingInd_template::msgIn()
{
set_specific();
return single_value->field_msgIn;
}

const ExtGeoNetworkingPdu_template& ExtGeoNetworkingInd_template::msgIn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgIn of a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
return single_value->field_msgIn;
}

OCTETSTRING_template& ExtGeoNetworkingInd_template::macDestinationAddress()
{
set_specific();
return single_value->field_macDestinationAddress;
}

const OCTETSTRING_template& ExtGeoNetworkingInd_template::macDestinationAddress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field macDestinationAddress of a non-specific template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
return single_value->field_macDestinationAddress;
}

int ExtGeoNetworkingInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @TTCN_EncDec.ExtGeoNetworkingInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
  }
  return 0;
}

void ExtGeoNetworkingInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgIn := ");
single_value->field_msgIn.log();
TTCN_Logger::log_event_str(", macDestinationAddress := ");
single_value->field_macDestinationAddress.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtGeoNetworkingInd_template::log_match(const ExtGeoNetworkingInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgIn.match(match_value.msgIn(), legacy)){
TTCN_Logger::log_logmatch_info(".msgIn");
single_value->field_msgIn.log_match(match_value.msgIn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_macDestinationAddress.match(match_value.macDestinationAddress(), legacy)){
TTCN_Logger::log_logmatch_info(".macDestinationAddress");
single_value->field_macDestinationAddress.log_match(match_value.macDestinationAddress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgIn := ");
single_value->field_msgIn.log_match(match_value.msgIn(), legacy);
TTCN_Logger::log_event_str(", macDestinationAddress := ");
single_value->field_macDestinationAddress.log_match(match_value.macDestinationAddress(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtGeoNetworkingInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgIn.encode_text(text_buf);
single_value->field_macDestinationAddress.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
}
}

void ExtGeoNetworkingInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgIn.decode_text(text_buf);
single_value->field_macDestinationAddress.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtGeoNetworkingInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @TTCN_EncDec.ExtGeoNetworkingInd.");
}
}

void ExtGeoNetworkingInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@TTCN_EncDec.ExtGeoNetworkingInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      msgIn().set_param(param);
      return;
    } else if (strcmp("macDestinationAddress", param_field) == 0) {
      macDestinationAddress().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@TTCN_EncDec.ExtGeoNetworkingInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtGeoNetworkingInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @TTCN_EncDec.ExtGeoNetworkingInd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgIn().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) macDestinationAddress().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "macDestinationAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          macDestinationAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @TTCN_EncDec.ExtGeoNetworkingInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@TTCN_EncDec.ExtGeoNetworkingInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtGeoNetworkingInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@TTCN_EncDec.ExtGeoNetworkingInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      return msgIn().get_param(param_name);
    } else if (strcmp("macDestinationAddress", param_field) == 0) {
      return macDestinationAddress().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@TTCN_EncDec.ExtGeoNetworkingInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgIn = single_value->field_msgIn.get_param(param_name);
    mp_field_msgIn->set_id(new Module_Param_FieldName(mcopystr("msgIn")));
    mp->add_elem(mp_field_msgIn);
    Module_Param* mp_field_macDestinationAddress = single_value->field_macDestinationAddress.get_param(param_name);
    mp_field_macDestinationAddress->set_id(new Module_Param_FieldName(mcopystr("macDestinationAddress")));
    mp->add_elem(mp_field_macDestinationAddress);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtGeoNetworkingInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgIn.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingInd");
single_value->field_macDestinationAddress.check_restriction(t_res, t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@TTCN_EncDec.ExtGeoNetworkingInd");
}

boolean ExtGeoNetworkingInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtGeoNetworkingInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

OCTETSTRING f__enc__UtInitialize(const LibItsCommon__TypesAndValues::UtInitialize& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtInitialize(): Encoding @LibItsCommon_TypesAndValues.UtInitialize: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsCommon__TypesAndValues::UtInitialize_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtInitialize(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsCommon__TypesAndValues::UtInitialize f__dec__UtInitialize(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtInitialize(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsCommon__TypesAndValues::UtInitialize ret_val;
ret_val.decode(LibItsCommon__TypesAndValues::UtInitialize_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtInitialize(): Decoded @LibItsCommon_TypesAndValues.UtInitialize: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_UtInitialize(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__UtChangePosition(const LibItsCommon__TypesAndValues::UtChangePosition& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtChangePosition(): Encoding @LibItsCommon_TypesAndValues.UtChangePosition: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsCommon__TypesAndValues::UtChangePosition_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtChangePosition(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsCommon__TypesAndValues::UtChangePosition f__dec__UtChangePosition(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtChangePosition(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsCommon__TypesAndValues::UtChangePosition ret_val;
ret_val.decode(LibItsCommon__TypesAndValues::UtChangePosition_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtChangePosition(): Decoded @LibItsCommon_TypesAndValues.UtChangePosition: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_UtChangePosition(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__UtChangePositionResult(const LibItsCommon__TypesAndValues::UtChangePositionResult& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtChangePositionResult(): Encoding @LibItsCommon_TypesAndValues.UtChangePositionResult: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsCommon__TypesAndValues::UtChangePositionResult_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtChangePositionResult(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsCommon__TypesAndValues::UtChangePositionResult f__dec__UtChangePositionResult(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtChangePositionResult(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsCommon__TypesAndValues::UtChangePositionResult ret_val;
ret_val.decode(LibItsCommon__TypesAndValues::UtChangePositionResult_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtChangePositionResult(): Decoded @LibItsCommon_TypesAndValues.UtChangePositionResult: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_UtChangePositionResult(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__UtChangePseudonym(const LibItsCommon__TypesAndValues::UtChangePseudonym& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtChangePseudonym(): Encoding @LibItsCommon_TypesAndValues.UtChangePseudonym: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsCommon__TypesAndValues::UtChangePseudonym_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtChangePseudonym(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsCommon__TypesAndValues::UtChangePseudonym f__dec__UtChangePseudonym(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtChangePseudonym(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsCommon__TypesAndValues::UtChangePseudonym ret_val;
ret_val.decode(LibItsCommon__TypesAndValues::UtChangePseudonym_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtChangePseudonym(): Decoded @LibItsCommon_TypesAndValues.UtChangePseudonym: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_UtChangePseudonym(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__UtChangePseudonymResult(const LibItsCommon__TypesAndValues::UtChangePseudonymResult& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtChangePseudonymResult(): Encoding @LibItsCommon_TypesAndValues.UtChangePseudonymResult: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsCommon__TypesAndValues::UtChangePseudonymResult_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_UtChangePseudonymResult(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsCommon__TypesAndValues::UtChangePseudonymResult f__dec__UtChangePseudonymResult(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtChangePseudonymResult(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsCommon__TypesAndValues::UtChangePseudonymResult ret_val;
ret_val.decode(LibItsCommon__TypesAndValues::UtChangePseudonymResult_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_UtChangePseudonymResult(): Decoded @LibItsCommon_TypesAndValues.UtChangePseudonymResult: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_UtChangePseudonymResult(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__Ut__Gn__GenerateGeoUnicastMessage(const LibItsGeoNetworking__TypesAndValues::GenerateGeoUnicastMessage& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ut_Gn_GenerateGeoUnicastMessage(): Encoding @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsGeoNetworking__TypesAndValues::GenerateGeoUnicastMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ut_Gn_GenerateGeoUnicastMessage(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsGeoNetworking__TypesAndValues::GenerateGeoUnicastMessage f__dec__Ut__Gn__GenerateGeoUnicastMessage(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateGeoUnicastMessage(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsGeoNetworking__TypesAndValues::GenerateGeoUnicastMessage ret_val;
ret_val.decode(LibItsGeoNetworking__TypesAndValues::GenerateGeoUnicastMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateGeoUnicastMessage(): Decoded @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateGeoUnicastMessage(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__Ext__UtGnGenerateGeoBroadcastMessage(const ExtGenerateGeoBroadcastMessage& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ext_UtGnGenerateGeoBroadcastMessage(): Encoding @TTCN_EncDec.ExtGenerateGeoBroadcastMessage: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(ExtGenerateGeoBroadcastMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ext_UtGnGenerateGeoBroadcastMessage(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

OCTETSTRING f__enc__Ut__Gn__GenerateGeoBroadcastMessage(const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage& pdu)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 176, TTCN_Location::LOCATION_FUNCTION, "f_enc_Ut_Gn_GenerateGeoBroadcastMessage");
current_location.update_lineno(177);
/* TTCN_EncDec.ttcn, line 177 */
ExtGenerateGeoBroadcastMessage ext;
current_location.update_lineno(179);
/* TTCN_EncDec.ttcn, line 179 */
ext.shape() = LibItsGeoNetworking__TypesAndValues::GeoShape::enum2int(const_cast< const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage&>(pdu).shape());
current_location.update_lineno(180);
/* TTCN_EncDec.ttcn, line 180 */
ext.lifetime() = const_cast< const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage&>(pdu).lifetime();
current_location.update_lineno(182);
/* TTCN_EncDec.ttcn, line 182 */
ext.trafficClass().scf() = int2bit(LibItsGeoNetworking__TypesAndValues::SCF::enum2int(const_cast< const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage&>(pdu).trafficClass().scf()), 1);
current_location.update_lineno(183);
/* TTCN_EncDec.ttcn, line 183 */
ext.trafficClass().channelOffload() = int2bit(LibItsGeoNetworking__TypesAndValues::ChannelOffload::enum2int(const_cast< const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage&>(pdu).trafficClass().channelOffload()), 1);
current_location.update_lineno(184);
/* TTCN_EncDec.ttcn, line 184 */
ext.trafficClass().tcId() = int2bit(const_cast< const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage&>(pdu).trafficClass().tcId(), 6);
current_location.update_lineno(186);
/* TTCN_EncDec.ttcn, line 186 */
ext.reserved() = 0;
current_location.update_lineno(188);
/* TTCN_EncDec.ttcn, line 188 */
ext.area() = const_cast< const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage&>(pdu).area();
current_location.update_lineno(190);
/* TTCN_EncDec.ttcn, line 190 */
ext.payloadLength() = const_cast< const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage&>(pdu).payload().rawPayload().lengthof();
current_location.update_lineno(191);
/* TTCN_EncDec.ttcn, line 191 */
ext.payload().rawPayload() = const_cast< const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage&>(pdu).payload().rawPayload();
current_location.update_lineno(200);
/* TTCN_EncDec.ttcn, line 200 */
return f__enc__Ext__UtGnGenerateGeoBroadcastMessage(ext);
}

LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage f__dec__Ut__Gn__GenerateGeoBroadcastMessage(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateGeoBroadcastMessage(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage ret_val;
ret_val.decode(LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateGeoBroadcastMessage(): Decoded @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateGeoBroadcastMessage(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__Ut__Gn__GenerateGeoAnycastMessage(const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ut_Gn_GenerateGeoAnycastMessage(): Encoding @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsGeoNetworking__TypesAndValues::GenerateGeoAnycastMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ut_Gn_GenerateGeoAnycastMessage(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage f__dec__Ut__Gn__GenerateGeoAnycastMessage(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateGeoAnycastMessage(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage ret_val;
ret_val.decode(LibItsGeoNetworking__TypesAndValues::GenerateGeoAnycastMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateGeoAnycastMessage(): Decoded @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateGeoAnycastMessage(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__Ut__Gn__GenerateSHBMessage(const LibItsGeoNetworking__TypesAndValues::GenerateSHBMessage& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ut_Gn_GenerateSHBMessage(): Encoding @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsGeoNetworking__TypesAndValues::GenerateSHBMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ut_Gn_GenerateSHBMessage(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsGeoNetworking__TypesAndValues::GenerateSHBMessage f__dec__Ut__Gn__GenerateSHBMessage(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateSHBMessage(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsGeoNetworking__TypesAndValues::GenerateSHBMessage ret_val;
ret_val.decode(LibItsGeoNetworking__TypesAndValues::GenerateSHBMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateSHBMessage(): Decoded @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateSHBMessage(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__Ut__Gn__GenerateTSBMessage(const LibItsGeoNetworking__TypesAndValues::GenerateTSBMessage& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ut_Gn_GenerateTSBMessage(): Encoding @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsGeoNetworking__TypesAndValues::GenerateTSBMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_Ut_Gn_GenerateTSBMessage(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsGeoNetworking__TypesAndValues::GenerateTSBMessage f__dec__Ut__Gn__GenerateTSBMessage(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateTSBMessage(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsGeoNetworking__TypesAndValues::GenerateTSBMessage ret_val;
ret_val.decode(LibItsGeoNetworking__TypesAndValues::GenerateTSBMessage_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateTSBMessage(): Decoded @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_Ut_Gn_GenerateTSBMessage(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__UtGnTrigger(const LibItsGeoNetworking__TypesAndValues::UtGnTrigger& pdu)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 245, TTCN_Location::LOCATION_FUNCTION, "f_enc_UtGnTrigger");
current_location.update_lineno(248);
/* TTCN_EncDec.ttcn, line 248 */
OCTETSTRING ret__os;
current_location.update_lineno(249);
/* TTCN_EncDec.ttcn, line 249 */
if (pdu.ischosen(LibItsGeoNetworking__TypesAndValues::UtGnTrigger::ALT_geoUnicast)) {
current_location.update_lineno(249);
/* TTCN_EncDec.ttcn, line 249 */
ret__os = (os_2 + f__enc__Ut__Gn__GenerateGeoUnicastMessage(const_cast< const LibItsGeoNetworking__TypesAndValues::UtGnTrigger&>(pdu).geoUnicast()));
}
else {
current_location.update_lineno(250);
/* TTCN_EncDec.ttcn, line 250 */
if (pdu.ischosen(LibItsGeoNetworking__TypesAndValues::UtGnTrigger::ALT_geoBroadcast)) {
current_location.update_lineno(250);
/* TTCN_EncDec.ttcn, line 250 */
ret__os = (os_3 + f__enc__Ut__Gn__GenerateGeoBroadcastMessage(const_cast< const LibItsGeoNetworking__TypesAndValues::UtGnTrigger&>(pdu).geoBroadcast()));
}
else {
current_location.update_lineno(251);
/* TTCN_EncDec.ttcn, line 251 */
if (pdu.ischosen(LibItsGeoNetworking__TypesAndValues::UtGnTrigger::ALT_geoAnycast)) {
current_location.update_lineno(251);
/* TTCN_EncDec.ttcn, line 251 */
ret__os = (os_4 + f__enc__Ut__Gn__GenerateGeoAnycastMessage(const_cast< const LibItsGeoNetworking__TypesAndValues::UtGnTrigger&>(pdu).geoAnycast()));
}
else {
current_location.update_lineno(252);
/* TTCN_EncDec.ttcn, line 252 */
if (pdu.ischosen(LibItsGeoNetworking__TypesAndValues::UtGnTrigger::ALT_shb)) {
current_location.update_lineno(252);
/* TTCN_EncDec.ttcn, line 252 */
ret__os = (os_5 + f__enc__Ut__Gn__GenerateSHBMessage(const_cast< const LibItsGeoNetworking__TypesAndValues::UtGnTrigger&>(pdu).shb()));
}
else {
current_location.update_lineno(253);
/* TTCN_EncDec.ttcn, line 253 */
if (pdu.ischosen(LibItsGeoNetworking__TypesAndValues::UtGnTrigger::ALT_tsb)) {
current_location.update_lineno(253);
/* TTCN_EncDec.ttcn, line 253 */
ret__os = (os_6 + f__enc__Ut__Gn__GenerateTSBMessage(const_cast< const LibItsGeoNetworking__TypesAndValues::UtGnTrigger&>(pdu).tsb()));
}
}
}
}
}
current_location.update_lineno(255);
/* TTCN_EncDec.ttcn, line 255 */
return ret__os;
}

OCTETSTRING f__enc__ExtUt__Cam__Trigger(const ExtUtCamTrigger& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtUt_Cam_Trigger(): Encoding @TTCN_EncDec.ExtUtCamTrigger: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(ExtUtCamTrigger_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtUt_Cam_Trigger(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

ExtUtCamTrigger f__dec__ExtUt__Cam__Trigger(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Cam_Trigger(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtUtCamTrigger ret_val;
ret_val.decode(ExtUtCamTrigger_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Cam_Trigger(): Decoded @TTCN_EncDec.ExtUtCamTrigger: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtUt_Cam_Trigger(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__UtCAmTrigger(const LibItsCam__TypesAndValues::UtCamTrigger& pdu)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 304, TTCN_Location::LOCATION_FUNCTION, "f_enc_UtCAmTrigger");
current_location.update_lineno(307);
/* TTCN_EncDec.ttcn, line 307 */
ExtUtCamTrigger v__ExtUtCamTrigger;
current_location.update_lineno(308);
/* TTCN_EncDec.ttcn, line 308 */
OCTETSTRING ret__os;
current_location.update_lineno(310);
/* TTCN_EncDec.ttcn, line 310 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_changeCurvature)) {
current_location.update_lineno(311);
/* TTCN_EncDec.ttcn, line 311 */
v__ExtUtCamTrigger.changeCurvature() = const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).changeCurvature();
}
else {
current_location.update_lineno(312);
/* TTCN_EncDec.ttcn, line 312 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_changeSpeed)) {
current_location.update_lineno(313);
/* TTCN_EncDec.ttcn, line 313 */
v__ExtUtCamTrigger.changeSpeed() = const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).changeSpeed();
}
else {
current_location.update_lineno(314);
/* TTCN_EncDec.ttcn, line 314 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_setAccelerationControlStatus)) {
current_location.update_lineno(315);
/* TTCN_EncDec.ttcn, line 315 */
v__ExtUtCamTrigger.setAccelerationControlStatus() = (const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setAccelerationControlStatus() + bs_0);
}
else {
current_location.update_lineno(316);
/* TTCN_EncDec.ttcn, line 316 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_setExteriorLightsStatus)) {
current_location.update_lineno(317);
/* TTCN_EncDec.ttcn, line 317 */
v__ExtUtCamTrigger.setExteriorLightsStatus() = const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setExteriorLightsStatus();
}
else {
current_location.update_lineno(318);
/* TTCN_EncDec.ttcn, line 318 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_changeHeading)) {
current_location.update_lineno(319);
/* TTCN_EncDec.ttcn, line 319 */
v__ExtUtCamTrigger.changeHeading() = const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).changeHeading();
}
else {
current_location.update_lineno(320);
/* TTCN_EncDec.ttcn, line 320 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_setDriveDirection)) {
current_location.update_lineno(321);
/* TTCN_EncDec.ttcn, line 321 */
v__ExtUtCamTrigger.setDriveDirection() = ITS__Container::DriveDirection::enum2int(const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setDriveDirection());
}
else {
current_location.update_lineno(322);
/* TTCN_EncDec.ttcn, line 322 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_changeYawRate)) {
current_location.update_lineno(323);
/* TTCN_EncDec.ttcn, line 323 */
v__ExtUtCamTrigger.changeYawRate() = const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).changeYawRate();
}
else {
current_location.update_lineno(324);
/* TTCN_EncDec.ttcn, line 324 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_setStationType)) {
current_location.update_lineno(325);
/* TTCN_EncDec.ttcn, line 325 */
v__ExtUtCamTrigger.setStationType() = const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setStationType();
}
else {
current_location.update_lineno(326);
/* TTCN_EncDec.ttcn, line 326 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_setVehicleRole)) {
current_location.update_lineno(327);
/* TTCN_EncDec.ttcn, line 327 */
v__ExtUtCamTrigger.setVehicleRole() = ITS__Container::VehicleRole::enum2int(const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setVehicleRole());
}
else {
current_location.update_lineno(328);
/* TTCN_EncDec.ttcn, line 328 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_setEmbarkationStatus)) {
current_location.update_lineno(329);
/* TTCN_EncDec.ttcn, line 329 */
if (const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setEmbarkationStatus()) {
current_location.update_lineno(330);
/* TTCN_EncDec.ttcn, line 330 */
v__ExtUtCamTrigger.setEmbarkationStatus() = 255;
}
else {
current_location.update_lineno(332);
/* TTCN_EncDec.ttcn, line 332 */
v__ExtUtCamTrigger.setEmbarkationStatus() = 0;
}
}
else {
current_location.update_lineno(334);
/* TTCN_EncDec.ttcn, line 334 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_setPtActivation)) {
current_location.update_lineno(335);
/* TTCN_EncDec.ttcn, line 335 */
v__ExtUtCamTrigger.setPtActivation().ptActivationType() = const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setPtActivation().ptActivationType();
current_location.update_lineno(336);
/* TTCN_EncDec.ttcn, line 336 */
v__ExtUtCamTrigger.setPtActivation().ptActivationDataLength() = 0;
current_location.update_lineno(337);
/* TTCN_EncDec.ttcn, line 337 */
v__ExtUtCamTrigger.setPtActivation().ptActivationData() = const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setPtActivation().ptActivationData();
}
else {
current_location.update_lineno(338);
/* TTCN_EncDec.ttcn, line 338 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_setDangerousGoods)) {
current_location.update_lineno(339);
/* TTCN_EncDec.ttcn, line 339 */
v__ExtUtCamTrigger.setDangerousGoods() = ITS__Container::DangerousGoodsBasic::enum2int(const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setDangerousGoods());
}
else {
current_location.update_lineno(340);
/* TTCN_EncDec.ttcn, line 340 */
if (pdu.ischosen(LibItsCam__TypesAndValues::UtCamTrigger::ALT_setLightBarSirene)) {
current_location.update_lineno(341);
/* TTCN_EncDec.ttcn, line 341 */
v__ExtUtCamTrigger.setLightBarSirene() = bit2int(const_cast< const LibItsCam__TypesAndValues::UtCamTrigger&>(pdu).setLightBarSirene());
}
}
}
}
}
}
}
}
}
}
}
}
}
current_location.update_lineno(344);
/* TTCN_EncDec.ttcn, line 344 */
ret__os = f__enc__ExtUt__Cam__Trigger(v__ExtUtCamTrigger);
current_location.update_lineno(346);
/* TTCN_EncDec.ttcn, line 346 */
return ret__os;
}

ExtUtCamEventInd f__dec__ExtUt__Cam__EventInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Cam_EventInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtUtCamEventInd ret_val;
ret_val.decode(ExtUtCamEventInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Cam_EventInd(): Decoded @TTCN_EncDec.ExtUtCamEventInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtUt_Cam_EventInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

LibItsCam__TypesAndValues::UtCamEventInd f__dec__Ut__Cam__EventInd(const OCTETSTRING& stream)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 362, TTCN_Location::LOCATION_FUNCTION, "f_dec_Ut_Cam_EventInd");
current_location.update_lineno(365);
/* TTCN_EncDec.ttcn, line 365 */
ExtUtCamEventInd v__ExtUtCamEventInd(f__dec__ExtUt__Cam__EventInd(stream));
current_location.update_lineno(366);
/* TTCN_EncDec.ttcn, line 366 */
LibItsCam__TypesAndValues::UtCamEventInd v__UtCamEventInd;
current_location.update_lineno(368);
/* TTCN_EncDec.ttcn, line 368 */
v__UtCamEventInd.camMsg() = CAM__Types::dec__CAM__PDU(const_cast< const ExtUtCamEventInd&>(v__ExtUtCamEventInd).camMsg());
current_location.update_lineno(370);
/* TTCN_EncDec.ttcn, line 370 */
return v__UtCamEventInd;
}

OCTETSTRING f__enc__ExtUt__Denm__Trigger(const ExtUtDenmTrigger& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtUt_Denm_Trigger(): Encoding @TTCN_EncDec.ExtUtDenmTrigger: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(ExtUtDenmTrigger_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtUt_Denm_Trigger(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

ExtUtDenmTrigger f__dec__ExtUt__Denm__Trigger(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Denm_Trigger(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtUtDenmTrigger ret_val;
ret_val.decode(ExtUtDenmTrigger_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Denm_Trigger(): Decoded @TTCN_EncDec.ExtUtDenmTrigger: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtUt_Denm_Trigger(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__UtDenmTrigger(const LibItsDenm__TypesAndValues::UtDenmTrigger& pdu)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 424, TTCN_Location::LOCATION_FUNCTION, "f_enc_UtDenmTrigger");
current_location.update_lineno(427);
/* TTCN_EncDec.ttcn, line 427 */
ExtUtDenmTrigger v__ExtUtDenmTrigger;
current_location.update_lineno(428);
/* TTCN_EncDec.ttcn, line 428 */
OCTETSTRING ret__os;
current_location.update_lineno(430);
/* TTCN_EncDec.ttcn, line 430 */
v__ExtUtDenmTrigger.bitmask() = 0;
current_location.update_lineno(432);
/* TTCN_EncDec.ttcn, line 432 */
v__ExtUtDenmTrigger.detectionTime() = const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).detectionTime();
current_location.update_lineno(435);
/* TTCN_EncDec.ttcn, line 435 */
{
boolean tmp_37;
{
boolean tmp_34 = pdu.is_bound();
if(tmp_34) {
const OPTIONAL<INTEGER>& tmp_35 = pdu.validityDuration();
switch (tmp_35.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_34 = false;
break;
case OPTIONAL_OMIT:
tmp_34 = false;
break;
default:
{
const INTEGER& tmp_36 = (const INTEGER&) tmp_35;
tmp_34 = tmp_36.is_present();
break;}
}
}
tmp_37 = tmp_34;
}
if (tmp_37) {
current_location.update_lineno(436);
/* TTCN_EncDec.ttcn, line 436 */
v__ExtUtDenmTrigger.bitmask() = 1;
current_location.update_lineno(437);
/* TTCN_EncDec.ttcn, line 437 */
v__ExtUtDenmTrigger.validityDuration() = const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).validityDuration();
}
else {
current_location.update_lineno(439);
/* TTCN_EncDec.ttcn, line 439 */
v__ExtUtDenmTrigger.validityDuration() = 0;
}
}
current_location.update_lineno(441);
/* TTCN_EncDec.ttcn, line 441 */
{
boolean tmp_44;
{
boolean tmp_41 = pdu.is_bound();
if(tmp_41) {
const OPTIONAL<INTEGER>& tmp_42 = pdu.repetitionDuration();
switch (tmp_42.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_41 = false;
break;
case OPTIONAL_OMIT:
tmp_41 = false;
break;
default:
{
const INTEGER& tmp_43 = (const INTEGER&) tmp_42;
tmp_41 = tmp_43.is_present();
break;}
}
}
tmp_44 = tmp_41;
}
if (tmp_44) {
current_location.update_lineno(442);
/* TTCN_EncDec.ttcn, line 442 */
{
INTEGER tmp_45;
tmp_45 = (const_cast< const ExtUtDenmTrigger&>(v__ExtUtDenmTrigger).bitmask() + 2);
v__ExtUtDenmTrigger.bitmask() = tmp_45;
}
current_location.update_lineno(443);
/* TTCN_EncDec.ttcn, line 443 */
v__ExtUtDenmTrigger.repetitionDuration() = const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).repetitionDuration();
}
else {
current_location.update_lineno(445);
/* TTCN_EncDec.ttcn, line 445 */
v__ExtUtDenmTrigger.repetitionDuration() = 0;
}
}
current_location.update_lineno(448);
/* TTCN_EncDec.ttcn, line 448 */
v__ExtUtDenmTrigger.situation().informationQuality() = const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).situation().informationQuality();
current_location.update_lineno(449);
/* TTCN_EncDec.ttcn, line 449 */
v__ExtUtDenmTrigger.situation().causeCode() = const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).situation().eventType().causeCode();
current_location.update_lineno(450);
/* TTCN_EncDec.ttcn, line 450 */
v__ExtUtDenmTrigger.situation().subCauseCode() = const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).situation().eventType().subCauseCode();
current_location.update_lineno(452);
/* TTCN_EncDec.ttcn, line 452 */
v__ExtUtDenmTrigger.relevanceDistance() = ITS__Container::RelevanceDistance::enum2int(const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).relevanceDistance());
current_location.update_lineno(454);
/* TTCN_EncDec.ttcn, line 454 */
v__ExtUtDenmTrigger.relevanceTrafficDirection() = ITS__Container::RelevanceTrafficDirection::enum2int(const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).relevanceTrafficDirection());
current_location.update_lineno(455);
/* TTCN_EncDec.ttcn, line 455 */
{
boolean tmp_56;
{
boolean tmp_53 = pdu.is_bound();
if(tmp_53) {
const OPTIONAL<INTEGER>& tmp_54 = pdu.transmissionInterval();
switch (tmp_54.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_53 = false;
break;
case OPTIONAL_OMIT:
tmp_53 = false;
break;
default:
{
const INTEGER& tmp_55 = (const INTEGER&) tmp_54;
tmp_53 = tmp_55.is_present();
break;}
}
}
tmp_56 = tmp_53;
}
if (tmp_56) {
current_location.update_lineno(456);
/* TTCN_EncDec.ttcn, line 456 */
{
INTEGER tmp_57;
tmp_57 = (const_cast< const ExtUtDenmTrigger&>(v__ExtUtDenmTrigger).bitmask() + 8);
v__ExtUtDenmTrigger.bitmask() = tmp_57;
}
current_location.update_lineno(457);
/* TTCN_EncDec.ttcn, line 457 */
v__ExtUtDenmTrigger.transmissionInterval() = const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).transmissionInterval();
}
else {
current_location.update_lineno(459);
/* TTCN_EncDec.ttcn, line 459 */
v__ExtUtDenmTrigger.transmissionInterval() = 0;
}
}
current_location.update_lineno(461);
/* TTCN_EncDec.ttcn, line 461 */
{
boolean tmp_63;
{
boolean tmp_60 = pdu.is_bound();
if(tmp_60) {
const OPTIONAL<INTEGER>& tmp_61 = pdu.repetitionInterval();
switch (tmp_61.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_60 = false;
break;
case OPTIONAL_OMIT:
tmp_60 = false;
break;
default:
{
const INTEGER& tmp_62 = (const INTEGER&) tmp_61;
tmp_60 = tmp_62.is_present();
break;}
}
}
tmp_63 = tmp_60;
}
if (tmp_63) {
current_location.update_lineno(462);
/* TTCN_EncDec.ttcn, line 462 */
{
INTEGER tmp_64;
tmp_64 = (const_cast< const ExtUtDenmTrigger&>(v__ExtUtDenmTrigger).bitmask() + 32);
v__ExtUtDenmTrigger.bitmask() = tmp_64;
}
current_location.update_lineno(463);
/* TTCN_EncDec.ttcn, line 463 */
v__ExtUtDenmTrigger.repetitionInterval() = const_cast< const LibItsDenm__TypesAndValues::UtDenmTrigger&>(pdu).repetitionInterval();
}
else {
current_location.update_lineno(465);
/* TTCN_EncDec.ttcn, line 465 */
v__ExtUtDenmTrigger.repetitionInterval() = 0;
}
}
current_location.update_lineno(467);
/* TTCN_EncDec.ttcn, line 467 */
{
boolean tmp_70;
{
boolean tmp_67 = pdu.is_bound();
if(tmp_67) {
const OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer>& tmp_68 = pdu.alacarte();
switch (tmp_68.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_67 = false;
break;
case OPTIONAL_OMIT:
tmp_67 = false;
break;
default:
{
const DENM__PDU__Descriptions::AlacarteContainer& tmp_69 = (const DENM__PDU__Descriptions::AlacarteContainer&) tmp_68;
tmp_67 = tmp_69.is_present();
break;}
}
}
tmp_70 = tmp_67;
}
if (tmp_70) {
current_location.update_lineno(468);
/* TTCN_EncDec.ttcn, line 468 */
v__ExtUtDenmTrigger.alacarteLength() = 1;
current_location.update_lineno(469);
/* TTCN_EncDec.ttcn, line 469 */
ExtAlacarteContainer v__ExtAlacarteContainer;
v__ExtAlacarteContainer.TODO() = 0;
current_location.update_lineno(470);
/* TTCN_EncDec.ttcn, line 470 */
v__ExtUtDenmTrigger.alacarte() = v__ExtAlacarteContainer;
}
else {
current_location.update_lineno(472);
/* TTCN_EncDec.ttcn, line 472 */
v__ExtUtDenmTrigger.alacarteLength() = 0;
current_location.update_lineno(473);
/* TTCN_EncDec.ttcn, line 473 */
v__ExtUtDenmTrigger.alacarte() = OMIT_VALUE;
}
}
current_location.update_lineno(476);
/* TTCN_EncDec.ttcn, line 476 */
ret__os = f__enc__ExtUt__Denm__Trigger(v__ExtUtDenmTrigger);
current_location.update_lineno(477);
/* TTCN_EncDec.ttcn, line 477 */
return ret__os;
}

OCTETSTRING f__enc__ExtUt__Denm__Update(const ExtUtDenmUpdate& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtUt_Denm_Update(): Encoding @TTCN_EncDec.ExtUtDenmUpdate: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(ExtUtDenmUpdate_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtUt_Denm_Update(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

ExtUtDenmUpdate f__dec__ExtUt__Denm__Update(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Denm_Update(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtUtDenmUpdate ret_val;
ret_val.decode(ExtUtDenmUpdate_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Denm_Update(): Decoded @TTCN_EncDec.ExtUtDenmUpdate: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtUt_Denm_Update(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__UtDenmUpdate(const LibItsDenm__TypesAndValues::UtDenmUpdate& pdu)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 519, TTCN_Location::LOCATION_FUNCTION, "f_enc_UtDenmUpdate");
current_location.update_lineno(522);
/* TTCN_EncDec.ttcn, line 522 */
ExtUtDenmUpdate v__ExtUtDenmUpdate;
current_location.update_lineno(523);
/* TTCN_EncDec.ttcn, line 523 */
OCTETSTRING ret__os;
current_location.update_lineno(525);
/* TTCN_EncDec.ttcn, line 525 */
v__ExtUtDenmUpdate.bitmask() = 0;
current_location.update_lineno(527);
/* TTCN_EncDec.ttcn, line 527 */
v__ExtUtDenmUpdate.actionID().originatingStationID() = const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).actionId().originatingStationID();
current_location.update_lineno(528);
/* TTCN_EncDec.ttcn, line 528 */
v__ExtUtDenmUpdate.actionID().sequenceNumber() = const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).actionId().sequenceNumber();
current_location.update_lineno(530);
/* TTCN_EncDec.ttcn, line 530 */
v__ExtUtDenmUpdate.detectionTime() = const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).detectionTime();
current_location.update_lineno(533);
/* TTCN_EncDec.ttcn, line 533 */
{
boolean tmp_83;
{
boolean tmp_80 = pdu.is_bound();
if(tmp_80) {
const OPTIONAL<INTEGER>& tmp_81 = pdu.validityDuration();
switch (tmp_81.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_80 = false;
break;
case OPTIONAL_OMIT:
tmp_80 = false;
break;
default:
{
const INTEGER& tmp_82 = (const INTEGER&) tmp_81;
tmp_80 = tmp_82.is_present();
break;}
}
}
tmp_83 = tmp_80;
}
if (tmp_83) {
current_location.update_lineno(534);
/* TTCN_EncDec.ttcn, line 534 */
v__ExtUtDenmUpdate.bitmask() = 1;
current_location.update_lineno(535);
/* TTCN_EncDec.ttcn, line 535 */
v__ExtUtDenmUpdate.validityDuration() = const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).validityDuration();
}
else {
current_location.update_lineno(537);
/* TTCN_EncDec.ttcn, line 537 */
v__ExtUtDenmUpdate.validityDuration() = 0;
}
}
current_location.update_lineno(539);
/* TTCN_EncDec.ttcn, line 539 */
{
boolean tmp_90;
{
boolean tmp_87 = pdu.is_bound();
if(tmp_87) {
const OPTIONAL<DENM__PDU__Descriptions::SituationContainer>& tmp_88 = pdu.situation();
switch (tmp_88.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_87 = false;
break;
case OPTIONAL_OMIT:
tmp_87 = false;
break;
default:
{
const DENM__PDU__Descriptions::SituationContainer& tmp_89 = (const DENM__PDU__Descriptions::SituationContainer&) tmp_88;
tmp_87 = tmp_89.is_present();
break;}
}
}
tmp_90 = tmp_87;
}
if (tmp_90) {
current_location.update_lineno(540);
/* TTCN_EncDec.ttcn, line 540 */
v__ExtUtDenmUpdate.bitmask() = 2;
current_location.update_lineno(541);
/* TTCN_EncDec.ttcn, line 541 */
v__ExtUtDenmUpdate.situation()().informationQuality() = const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).situation()().informationQuality();
current_location.update_lineno(542);
/* TTCN_EncDec.ttcn, line 542 */
v__ExtUtDenmUpdate.situation()().causeCode() = const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).situation()().eventType().causeCode();
current_location.update_lineno(543);
/* TTCN_EncDec.ttcn, line 543 */
v__ExtUtDenmUpdate.situation()().subCauseCode() = const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).situation()().eventType().subCauseCode();
}
else {
current_location.update_lineno(545);
/* TTCN_EncDec.ttcn, line 545 */
v__ExtUtDenmUpdate.situation()().informationQuality() = 0;
current_location.update_lineno(546);
/* TTCN_EncDec.ttcn, line 546 */
v__ExtUtDenmUpdate.situation()().causeCode() = 0;
current_location.update_lineno(547);
/* TTCN_EncDec.ttcn, line 547 */
v__ExtUtDenmUpdate.situation()().subCauseCode() = 0;
}
}
current_location.update_lineno(550);
/* TTCN_EncDec.ttcn, line 550 */
{
boolean tmp_101;
{
boolean tmp_98 = pdu.is_bound();
if(tmp_98) {
const OPTIONAL<ITS__Container::RelevanceDistance>& tmp_99 = pdu.relevanceDistance();
switch (tmp_99.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_98 = false;
break;
case OPTIONAL_OMIT:
tmp_98 = false;
break;
default:
{
const ITS__Container::RelevanceDistance& tmp_100 = (const ITS__Container::RelevanceDistance&) tmp_99;
tmp_98 = tmp_100.is_present();
break;}
}
}
tmp_101 = tmp_98;
}
if (tmp_101) {
current_location.update_lineno(551);
/* TTCN_EncDec.ttcn, line 551 */
{
INTEGER tmp_102;
tmp_102 = (const_cast< const ExtUtDenmUpdate&>(v__ExtUtDenmUpdate).bitmask() + 4);
v__ExtUtDenmUpdate.bitmask() = tmp_102;
}
current_location.update_lineno(552);
/* TTCN_EncDec.ttcn, line 552 */
v__ExtUtDenmUpdate.relevanceDistance() = ITS__Container::RelevanceDistance::enum2int(const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).relevanceDistance()());
}
else {
current_location.update_lineno(554);
/* TTCN_EncDec.ttcn, line 554 */
v__ExtUtDenmUpdate.relevanceDistance() = 0;
}
}
current_location.update_lineno(557);
/* TTCN_EncDec.ttcn, line 557 */
{
boolean tmp_108;
{
boolean tmp_105 = pdu.is_bound();
if(tmp_105) {
const OPTIONAL<ITS__Container::RelevanceTrafficDirection>& tmp_106 = pdu.relevanceTrafficDirection();
switch (tmp_106.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_105 = false;
break;
case OPTIONAL_OMIT:
tmp_105 = false;
break;
default:
{
const ITS__Container::RelevanceTrafficDirection& tmp_107 = (const ITS__Container::RelevanceTrafficDirection&) tmp_106;
tmp_105 = tmp_107.is_present();
break;}
}
}
tmp_108 = tmp_105;
}
if (tmp_108) {
current_location.update_lineno(558);
/* TTCN_EncDec.ttcn, line 558 */
{
INTEGER tmp_109;
tmp_109 = (const_cast< const ExtUtDenmUpdate&>(v__ExtUtDenmUpdate).bitmask() + 8);
v__ExtUtDenmUpdate.bitmask() = tmp_109;
}
current_location.update_lineno(559);
/* TTCN_EncDec.ttcn, line 559 */
v__ExtUtDenmUpdate.relevanceTrafficDirection() = ITS__Container::RelevanceTrafficDirection::enum2int(const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).relevanceTrafficDirection()());
}
else {
current_location.update_lineno(561);
/* TTCN_EncDec.ttcn, line 561 */
v__ExtUtDenmUpdate.relevanceTrafficDirection() = 0;
}
}
current_location.update_lineno(563);
/* TTCN_EncDec.ttcn, line 563 */
{
boolean tmp_115;
{
boolean tmp_112 = pdu.is_bound();
if(tmp_112) {
const OPTIONAL<INTEGER>& tmp_113 = pdu.transmissionInterval();
switch (tmp_113.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_112 = false;
break;
case OPTIONAL_OMIT:
tmp_112 = false;
break;
default:
{
const INTEGER& tmp_114 = (const INTEGER&) tmp_113;
tmp_112 = tmp_114.is_present();
break;}
}
}
tmp_115 = tmp_112;
}
if (tmp_115) {
current_location.update_lineno(564);
/* TTCN_EncDec.ttcn, line 564 */
{
INTEGER tmp_116;
tmp_116 = (const_cast< const ExtUtDenmUpdate&>(v__ExtUtDenmUpdate).bitmask() + 32);
v__ExtUtDenmUpdate.bitmask() = tmp_116;
}
current_location.update_lineno(565);
/* TTCN_EncDec.ttcn, line 565 */
v__ExtUtDenmUpdate.transmissionInterval() = const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).transmissionInterval();
}
else {
current_location.update_lineno(567);
/* TTCN_EncDec.ttcn, line 567 */
v__ExtUtDenmUpdate.transmissionInterval() = 0;
}
}
current_location.update_lineno(569);
/* TTCN_EncDec.ttcn, line 569 */
{
boolean tmp_122;
{
boolean tmp_119 = pdu.is_bound();
if(tmp_119) {
const OPTIONAL<INTEGER>& tmp_120 = pdu.repetitionInterval();
switch (tmp_120.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_119 = false;
break;
case OPTIONAL_OMIT:
tmp_119 = false;
break;
default:
{
const INTEGER& tmp_121 = (const INTEGER&) tmp_120;
tmp_119 = tmp_121.is_present();
break;}
}
}
tmp_122 = tmp_119;
}
if (tmp_122) {
current_location.update_lineno(570);
/* TTCN_EncDec.ttcn, line 570 */
{
INTEGER tmp_123;
tmp_123 = (const_cast< const ExtUtDenmUpdate&>(v__ExtUtDenmUpdate).bitmask() + 64);
v__ExtUtDenmUpdate.bitmask() = tmp_123;
}
current_location.update_lineno(571);
/* TTCN_EncDec.ttcn, line 571 */
v__ExtUtDenmUpdate.repetitionInterval() = const_cast< const LibItsDenm__TypesAndValues::UtDenmUpdate&>(pdu).repetitionInterval();
}
else {
current_location.update_lineno(573);
/* TTCN_EncDec.ttcn, line 573 */
v__ExtUtDenmUpdate.repetitionInterval() = 0;
}
}
current_location.update_lineno(575);
/* TTCN_EncDec.ttcn, line 575 */
{
boolean tmp_129;
{
boolean tmp_126 = pdu.is_bound();
if(tmp_126) {
const OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer>& tmp_127 = pdu.alacarte();
switch (tmp_127.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_126 = false;
break;
case OPTIONAL_OMIT:
tmp_126 = false;
break;
default:
{
const DENM__PDU__Descriptions::AlacarteContainer& tmp_128 = (const DENM__PDU__Descriptions::AlacarteContainer&) tmp_127;
tmp_126 = tmp_128.is_present();
break;}
}
}
tmp_129 = tmp_126;
}
if (tmp_129) {
current_location.update_lineno(577);
/* TTCN_EncDec.ttcn, line 577 */
v__ExtUtDenmUpdate.alacarteLength() = 1;
current_location.update_lineno(578);
/* TTCN_EncDec.ttcn, line 578 */
ExtAlacarteContainer v__ExtAlacarteContainer;
v__ExtAlacarteContainer.TODO() = 0;
current_location.update_lineno(579);
/* TTCN_EncDec.ttcn, line 579 */
v__ExtUtDenmUpdate.alacarte() = v__ExtAlacarteContainer;
}
else {
current_location.update_lineno(581);
/* TTCN_EncDec.ttcn, line 581 */
v__ExtUtDenmUpdate.alacarteLength() = 0;
current_location.update_lineno(582);
/* TTCN_EncDec.ttcn, line 582 */
v__ExtUtDenmUpdate.alacarte() = OMIT_VALUE;
}
}
current_location.update_lineno(585);
/* TTCN_EncDec.ttcn, line 585 */
ret__os = f__enc__ExtUt__Denm__Update(v__ExtUtDenmUpdate);
current_location.update_lineno(586);
/* TTCN_EncDec.ttcn, line 586 */
return ret__os;
}

OCTETSTRING f__enc__ExtDenmInd(const ExtDenmInd& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtDenmInd(): Encoding @TTCN_EncDec.ExtDenmInd: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(ExtDenmInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtDenmInd(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

ExtDenmInd f__dec__ExtDenmInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtDenmInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtDenmInd ret_val;
ret_val.decode(ExtDenmInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtDenmInd(): Decoded @TTCN_EncDec.ExtDenmInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtDenmInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

ExtUtDenmEventInd f__dec__ExtUt__Denm__EventInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Denm_EventInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtUtDenmEventInd ret_val;
ret_val.decode(ExtUtDenmEventInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Denm_EventInd(): Decoded @TTCN_EncDec.ExtUtDenmEventInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtUt_Denm_EventInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

LibItsDenm__TypesAndValues::UtDenmEventInd f__dec__Ut__Denm__EventInd(const OCTETSTRING& stream)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 632, TTCN_Location::LOCATION_FUNCTION, "f_dec_Ut_Denm_EventInd");
current_location.update_lineno(635);
/* TTCN_EncDec.ttcn, line 635 */
ExtUtDenmEventInd v__ExtUtDenmEventInd(f__dec__ExtUt__Denm__EventInd(stream));
current_location.update_lineno(636);
/* TTCN_EncDec.ttcn, line 636 */
LibItsDenm__TypesAndValues::UtDenmEventInd v__UtDenmEventInd;
current_location.update_lineno(638);
/* TTCN_EncDec.ttcn, line 638 */
v__UtDenmEventInd.denMsg() = DENM__Types::dec__DENM__PDU(const_cast< const ExtUtDenmEventInd&>(v__ExtUtDenmEventInd).denMsg());
current_location.update_lineno(640);
/* TTCN_EncDec.ttcn, line 640 */
return v__UtDenmEventInd;
}

ExtUtMapEventInd f__dec__ExtUt__Map__EventInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Map_EventInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtUtMapEventInd ret_val;
ret_val.decode(ExtUtMapEventInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Map_EventInd(): Decoded @TTCN_EncDec.ExtUtMapEventInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtUt_Map_EventInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

LibItsMapSpat__TypesAndValues::UtMapEventInd f__dec__Ut__Map__EventInd(const OCTETSTRING& stream)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 696, TTCN_Location::LOCATION_FUNCTION, "f_dec_Ut_Map_EventInd");
current_location.update_lineno(699);
/* TTCN_EncDec.ttcn, line 699 */
ExtUtMapEventInd v__ExtUtMapEventInd(f__dec__ExtUt__Map__EventInd(stream));
current_location.update_lineno(700);
/* TTCN_EncDec.ttcn, line 700 */
LibItsMapSpat__TypesAndValues::UtMapEventInd v__UtMapEventInd;
current_location.update_lineno(702);
/* TTCN_EncDec.ttcn, line 702 */
v__UtMapEventInd.mapMsg() = MAP__Types::dec__MAP__PDU(const_cast< const ExtUtMapEventInd&>(v__ExtUtMapEventInd).mapMsg());
current_location.update_lineno(704);
/* TTCN_EncDec.ttcn, line 704 */
return v__UtMapEventInd;
}

ExtUtSpatEventInd f__dec__ExtUt__Spat__EventInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Spat_EventInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtUtSpatEventInd ret_val;
ret_val.decode(ExtUtSpatEventInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtUt_Spat_EventInd(): Decoded @TTCN_EncDec.ExtUtSpatEventInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtUt_Spat_EventInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

LibItsMapSpat__TypesAndValues::UtSpatEventInd f__dec__Ut__Spat__EventInd(const OCTETSTRING& stream)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 720, TTCN_Location::LOCATION_FUNCTION, "f_dec_Ut_Spat_EventInd");
current_location.update_lineno(723);
/* TTCN_EncDec.ttcn, line 723 */
ExtUtSpatEventInd v__ExtUtSpatEventInd(f__dec__ExtUt__Spat__EventInd(stream));
current_location.update_lineno(724);
/* TTCN_EncDec.ttcn, line 724 */
LibItsMapSpat__TypesAndValues::UtSpatEventInd v__UtSpatEventInd;
current_location.update_lineno(726);
/* TTCN_EncDec.ttcn, line 726 */
v__UtSpatEventInd.spatMsg() = SPAT__Types::dec__SPAT__PDU(const_cast< const ExtUtSpatEventInd&>(v__ExtUtSpatEventInd).spatMsg());
current_location.update_lineno(728);
/* TTCN_EncDec.ttcn, line 728 */
return v__UtSpatEventInd;
}

OCTETSTRING f__enc__ExtBtpReq(const ExtBtpReq& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtBtpReq(): Encoding @TTCN_EncDec.ExtBtpReq: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(ExtBtpReq_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtBtpReq(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

OCTETSTRING f__enc__BtpReq(const LibItsBtp__TestSystem::BtpReq& pdu)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 754, TTCN_Location::LOCATION_FUNCTION, "f_enc_BtpReq");
current_location.update_lineno(757);
/* TTCN_EncDec.ttcn, line 757 */
ExtBtpReq v__ExtBtpReq;
current_location.update_lineno(759);
/* TTCN_EncDec.ttcn, line 759 */
v__ExtBtpReq.nextheader() = os_7;
current_location.update_lineno(760);
/* TTCN_EncDec.ttcn, line 760 */
v__ExtBtpReq.header() = const_cast< const LibItsBtp__TestSystem::BtpReq&>(pdu).msgOut().header();
current_location.update_lineno(761);
/* TTCN_EncDec.ttcn, line 761 */
v__ExtBtpReq.payload()().rawPayload() = const_cast< const LibItsBtp__TestSystem::BtpReq&>(pdu).msgOut().payload()().rawPayload();
current_location.update_lineno(767);
/* TTCN_EncDec.ttcn, line 767 */
return f__enc__ExtBtpReq(v__ExtBtpReq);
}

ExtBtpInd f__dec__ExtBtpInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtBtpInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_WARNING);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtBtpInd ret_val;
ret_val.decode(ExtBtpInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtBtpInd(): Decoded @TTCN_EncDec.ExtBtpInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtBtpInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

LibItsBtp__TestSystem::BtpInd f__dec__BtpInd(const OCTETSTRING& stream)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 786, TTCN_Location::LOCATION_FUNCTION, "f_dec_BtpInd");
current_location.update_lineno(788);
/* TTCN_EncDec.ttcn, line 788 */
ExtBtpInd v__ExtBtpInd(f__dec__ExtBtpInd(stream));
current_location.update_lineno(790);
/* TTCN_EncDec.ttcn, line 790 */
LibItsBtp__TestSystem::BtpInd v__BtpInd;
current_location.update_lineno(792);
/* TTCN_EncDec.ttcn, line 792 */
v__BtpInd.msgIn().header() = const_cast< const ExtBtpInd&>(v__ExtBtpInd).header();
current_location.update_lineno(793);
/* TTCN_EncDec.ttcn, line 793 */
{
boolean tmp_145;
{
boolean tmp_142 = v__ExtBtpInd.is_bound();
if(tmp_142) {
const OPTIONAL<OCTETSTRING>& tmp_143 = v__ExtBtpInd.rawPayload();
switch (tmp_143.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_142 = false;
break;
case OPTIONAL_OMIT:
tmp_142 = false;
break;
default:
{
const OCTETSTRING& tmp_144 = (const OCTETSTRING&) tmp_143;
tmp_142 = tmp_144.is_present();
break;}
}
}
tmp_145 = tmp_142;
}
if (tmp_145) {
current_location.update_lineno(794);
/* TTCN_EncDec.ttcn, line 794 */
v__BtpInd.msgIn().payload()().rawPayload() = const_cast< const ExtBtpInd&>(v__ExtBtpInd).rawPayload();
current_location.update_lineno(796);
/* TTCN_EncDec.ttcn, line 796 */
LibItsBtp__TypesAndValues::DecodedBtpPayload v__decodedPayload;
current_location.update_lineno(797);
/* TTCN_EncDec.ttcn, line 797 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).nextheader() == os_0)) {
current_location.update_lineno(798);
/* TTCN_EncDec.ttcn, line 798 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).header().btpAHeader().destinationPort() == 2001)) {
current_location.update_lineno(800);
/* TTCN_EncDec.ttcn, line 800 */
v__decodedPayload.camPacket() = CAM__Types::dec__CAM__PDU(const_cast< const ExtBtpInd&>(v__ExtBtpInd).rawPayload());
}
else {
current_location.update_lineno(803);
/* TTCN_EncDec.ttcn, line 803 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).header().btpAHeader().destinationPort() == 2002)) {
current_location.update_lineno(804);
/* TTCN_EncDec.ttcn, line 804 */
v__decodedPayload.denmPacket() = DENM__Types::dec__DENM__PDU(const_cast< const ExtBtpInd&>(v__ExtBtpInd).rawPayload());
}
else {
current_location.update_lineno(807);
/* TTCN_EncDec.ttcn, line 807 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).header().btpAHeader().destinationPort() == 2003)) {
current_location.update_lineno(808);
/* TTCN_EncDec.ttcn, line 808 */
v__decodedPayload.mapPacket() = MAP__Types::dec__MAP__PDU(const_cast< const ExtBtpInd&>(v__ExtBtpInd).rawPayload());
}
else {
current_location.update_lineno(811);
/* TTCN_EncDec.ttcn, line 811 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).header().btpAHeader().destinationPort() == 2004)) {
current_location.update_lineno(812);
/* TTCN_EncDec.ttcn, line 812 */
v__decodedPayload.spatPacket() = SPAT__Types::dec__SPAT__PDU(const_cast< const ExtBtpInd&>(v__ExtBtpInd).rawPayload());
}
}
}
}
}
else {
current_location.update_lineno(816);
/* TTCN_EncDec.ttcn, line 816 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).nextheader() == os_1)) {
current_location.update_lineno(817);
/* TTCN_EncDec.ttcn, line 817 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).header().btpBHeader().destinationPort() == 2001)) {
current_location.update_lineno(819);
/* TTCN_EncDec.ttcn, line 819 */
v__decodedPayload.camPacket() = CAM__Types::dec__CAM__PDU(const_cast< const ExtBtpInd&>(v__ExtBtpInd).rawPayload());
}
else {
current_location.update_lineno(822);
/* TTCN_EncDec.ttcn, line 822 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).header().btpBHeader().destinationPort() == 2002)) {
current_location.update_lineno(823);
/* TTCN_EncDec.ttcn, line 823 */
v__decodedPayload.denmPacket() = DENM__Types::dec__DENM__PDU(const_cast< const ExtBtpInd&>(v__ExtBtpInd).rawPayload());
}
else {
current_location.update_lineno(826);
/* TTCN_EncDec.ttcn, line 826 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).header().btpAHeader().destinationPort() == 2003)) {
current_location.update_lineno(827);
/* TTCN_EncDec.ttcn, line 827 */
v__decodedPayload.mapPacket() = MAP__Types::dec__MAP__PDU(const_cast< const ExtBtpInd&>(v__ExtBtpInd).rawPayload());
}
else {
current_location.update_lineno(830);
/* TTCN_EncDec.ttcn, line 830 */
if ((const_cast< const ExtBtpInd&>(v__ExtBtpInd).header().btpAHeader().destinationPort() == 2004)) {
current_location.update_lineno(831);
/* TTCN_EncDec.ttcn, line 831 */
v__decodedPayload.spatPacket() = SPAT__Types::dec__SPAT__PDU(const_cast< const ExtBtpInd&>(v__ExtBtpInd).rawPayload());
}
}
}
}
}
}
current_location.update_lineno(837);
/* TTCN_EncDec.ttcn, line 837 */
if (v__decodedPayload.is_bound()) {
current_location.update_lineno(838);
/* TTCN_EncDec.ttcn, line 838 */
v__BtpInd.msgIn().payload()().decodedPayload() = v__decodedPayload;
}
else {
current_location.update_lineno(840);
/* TTCN_EncDec.ttcn, line 840 */
v__BtpInd.msgIn().payload()().decodedPayload() = OMIT_VALUE;
}
}
else {
current_location.update_lineno(844);
/* TTCN_EncDec.ttcn, line 844 */
v__BtpInd.msgIn().payload() = OMIT_VALUE;
}
}
current_location.update_lineno(847);
/* TTCN_EncDec.ttcn, line 847 */
return v__BtpInd;
}

OCTETSTRING f__enc__ExtCamInd(const ExtCamInd& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtCamInd(): Encoding @TTCN_EncDec.ExtCamInd: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(ExtCamInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_ExtCamInd(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

ExtCamInd f__dec__ExtCamInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtCamInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtCamInd ret_val;
ret_val.decode(ExtCamInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtCamInd(): Decoded @TTCN_EncDec.ExtCamInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtCamInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

ExtMapSpatInd f__dec__ExtMapSpatInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtMapSpatInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtMapSpatInd ret_val;
ret_val.decode(ExtMapSpatInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtMapSpatInd(): Decoded @TTCN_EncDec.ExtMapSpatInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtMapSpatInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

MapSpatInd f__dec__MapSpatInd(const OCTETSTRING& stream)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 905, TTCN_Location::LOCATION_FUNCTION, "f_dec_MapSpatInd");
current_location.update_lineno(906);
/* TTCN_EncDec.ttcn, line 906 */
OCTETSTRING v__os__per;
current_location.update_lineno(906);
/* TTCN_EncDec.ttcn, line 906 */
OCTETSTRING v__os__raw;
current_location.update_lineno(907);
/* TTCN_EncDec.ttcn, line 907 */
INTEGER v__lengthof__ExtMapSpatInd(12);
current_location.update_lineno(909);
/* TTCN_EncDec.ttcn, line 909 */
INTEGER v__start__of__raw((stream.lengthof() - v__lengthof__ExtMapSpatInd));
current_location.update_lineno(911);
/* TTCN_EncDec.ttcn, line 911 */
v__os__per = substr(stream, 0, v__start__of__raw);
current_location.update_lineno(912);
/* TTCN_EncDec.ttcn, line 912 */
v__os__raw = substr(stream, v__start__of__raw, v__lengthof__ExtMapSpatInd);
current_location.update_lineno(914);
/* TTCN_EncDec.ttcn, line 914 */
ExtMapSpatInd v__ExtMapSpatInd(f__dec__ExtMapSpatInd(v__os__raw));
current_location.update_lineno(916);
/* TTCN_EncDec.ttcn, line 916 */
MapSpatInd v__MapSpatInd;
current_location.update_lineno(918);
/* TTCN_EncDec.ttcn, line 918 */
if ((const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).btpDestinationPort() == 2003)) {
current_location.update_lineno(919);
/* TTCN_EncDec.ttcn, line 919 */
v__MapSpatInd.mapInd().msgIn().msgMap() = MAP__Types::dec__MAP__PDU(v__os__per);
current_location.update_lineno(920);
/* TTCN_EncDec.ttcn, line 920 */
v__MapSpatInd.mapInd().gnNextHeader() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnNextHeader();
current_location.update_lineno(921);
/* TTCN_EncDec.ttcn, line 921 */
v__MapSpatInd.mapInd().gnHeaderType() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnHeaderType();
current_location.update_lineno(922);
/* TTCN_EncDec.ttcn, line 922 */
v__MapSpatInd.mapInd().gnHeaderSubtype() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnHeaderSubtype();
current_location.update_lineno(923);
/* TTCN_EncDec.ttcn, line 923 */
v__MapSpatInd.mapInd().gnLifetime() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnLifetime();
current_location.update_lineno(924);
/* TTCN_EncDec.ttcn, line 924 */
v__MapSpatInd.mapInd().gnTrafficClass() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnTrafficClass();
current_location.update_lineno(925);
/* TTCN_EncDec.ttcn, line 925 */
v__MapSpatInd.mapInd().btpDestinationPort() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).btpDestinationPort();
current_location.update_lineno(926);
/* TTCN_EncDec.ttcn, line 926 */
v__MapSpatInd.mapInd().btpInfo() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).btpInfo();
}
else {
current_location.update_lineno(928);
/* TTCN_EncDec.ttcn, line 928 */
if ((const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).btpDestinationPort() == 2004)) {
current_location.update_lineno(929);
/* TTCN_EncDec.ttcn, line 929 */
v__MapSpatInd.spatInd().msgIn().msgSpat() = SPAT__Types::dec__SPAT__PDU(v__os__per);
current_location.update_lineno(930);
/* TTCN_EncDec.ttcn, line 930 */
v__MapSpatInd.spatInd().gnNextHeader() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnNextHeader();
current_location.update_lineno(931);
/* TTCN_EncDec.ttcn, line 931 */
v__MapSpatInd.spatInd().gnHeaderType() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnHeaderType();
current_location.update_lineno(932);
/* TTCN_EncDec.ttcn, line 932 */
v__MapSpatInd.spatInd().gnHeaderSubtype() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnHeaderSubtype();
current_location.update_lineno(933);
/* TTCN_EncDec.ttcn, line 933 */
v__MapSpatInd.spatInd().gnLifetime() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnLifetime();
current_location.update_lineno(934);
/* TTCN_EncDec.ttcn, line 934 */
v__MapSpatInd.spatInd().gnTrafficClass() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).gnTrafficClass();
current_location.update_lineno(935);
/* TTCN_EncDec.ttcn, line 935 */
v__MapSpatInd.spatInd().btpDestinationPort() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).btpDestinationPort();
current_location.update_lineno(936);
/* TTCN_EncDec.ttcn, line 936 */
v__MapSpatInd.spatInd().btpInfo() = const_cast< const ExtMapSpatInd&>(v__ExtMapSpatInd).btpInfo();
}
}
current_location.update_lineno(939);
/* TTCN_EncDec.ttcn, line 939 */
return v__MapSpatInd;
}

OCTETSTRING f__enc__GeoNetworkingPdu(const LibItsGeoNetworking__TypesAndValues::GeoNetworkingPdu& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_GeoNetworkingPdu(): Encoding @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsGeoNetworking__TypesAndValues::GeoNetworkingPdu_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_GeoNetworkingPdu(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsGeoNetworking__TypesAndValues::GeoNetworkingPdu f__dec__GeoNetworkingPdu(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_GeoNetworkingPdu(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsGeoNetworking__TypesAndValues::GeoNetworkingPdu ret_val;
ret_val.decode(LibItsGeoNetworking__TypesAndValues::GeoNetworkingPdu_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_GeoNetworkingPdu(): Decoded @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_GeoNetworkingPdu(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__BeaconHeader(const LibItsGeoNetworking__TypesAndValues::BeaconHeader& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_BeaconHeader(): Encoding @LibItsGeoNetworking_TypesAndValues.BeaconHeader: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsGeoNetworking__TypesAndValues::BeaconHeader_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_BeaconHeader(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsGeoNetworking__TypesAndValues::BeaconHeader f__dec__BeaconHeader(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_BeaconHeader(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsGeoNetworking__TypesAndValues::BeaconHeader ret_val;
ret_val.decode(LibItsGeoNetworking__TypesAndValues::BeaconHeader_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_BeaconHeader(): Decoded @LibItsGeoNetworking_TypesAndValues.BeaconHeader: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_BeaconHeader(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__GN__Address(const LibItsGeoNetworking__TypesAndValues::GN__Address& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_GN_Address(): Encoding @LibItsGeoNetworking_TypesAndValues.GN_Address: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsGeoNetworking__TypesAndValues::GN__Address_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_GN_Address(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsGeoNetworking__TypesAndValues::GN__Address f__dec__GN__Address(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_GN_Address(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsGeoNetworking__TypesAndValues::GN__Address ret_val;
ret_val.decode(LibItsGeoNetworking__TypesAndValues::GN__Address_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_GN_Address(): Decoded @LibItsGeoNetworking_TypesAndValues.GN_Address: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_GN_Address(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__GeoNetworkingReq(const LibItsGeoNetworking__TestSystem::GeoNetworkingReq& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_GeoNetworkingReq(): Encoding @LibItsGeoNetworking_TestSystem.GeoNetworkingReq: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsGeoNetworking__TestSystem::GeoNetworkingReq_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_GeoNetworkingReq(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

ExtGeoNetworkingInd f__dec__ExtGeoNetworkingInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtGeoNetworkingInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
ExtGeoNetworkingInd ret_val;
ret_val.decode(ExtGeoNetworkingInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_ExtGeoNetworkingInd(): Decoded @TTCN_EncDec.ExtGeoNetworkingInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_ExtGeoNetworkingInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

LibItsGeoNetworking__TestSystem::GeoNetworkingInd f__dec__GeoNetworkingInd(const OCTETSTRING& stream)
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 1061, TTCN_Location::LOCATION_FUNCTION, "f_dec_GeoNetworkingInd");
current_location.update_lineno(1062);
/* TTCN_EncDec.ttcn, line 1062 */
ExtGeoNetworkingInd EGNI(f__dec__ExtGeoNetworkingInd(stream));
current_location.update_lineno(1063);
/* TTCN_EncDec.ttcn, line 1063 */
LibItsGeoNetworking__TestSystem::GeoNetworkingInd GNI;
current_location.update_lineno(1065);
/* TTCN_EncDec.ttcn, line 1065 */
GNI.msgIn().basicHeader().version() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().version();
current_location.update_lineno(1066);
/* TTCN_EncDec.ttcn, line 1066 */
GNI.msgIn().basicHeader().nextHeader() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().nextHeader();
current_location.update_lineno(1067);
/* TTCN_EncDec.ttcn, line 1067 */
GNI.msgIn().basicHeader().reserved() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().reserved();
current_location.update_lineno(1068);
/* TTCN_EncDec.ttcn, line 1068 */
GNI.msgIn().basicHeader().lifeTime() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().lifeTime();
current_location.update_lineno(1069);
/* TTCN_EncDec.ttcn, line 1069 */
GNI.msgIn().basicHeader().routerHopLimit() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().routerHopLimit();
current_location.update_lineno(1071);
/* TTCN_EncDec.ttcn, line 1071 */
{
boolean tmp_185;
{
boolean tmp_181 = EGNI.is_bound();
if(tmp_181) {
const ExtGeoNetworkingPdu& tmp_182 = EGNI.msgIn();
tmp_181 = tmp_182.is_bound();
if(tmp_181) {
const OPTIONAL<ExtGnNonSecuredPacket>& tmp_183 = tmp_182.packet();
switch (tmp_183.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_181 = false;
break;
case OPTIONAL_OMIT:
tmp_181 = false;
break;
default:
{
const ExtGnNonSecuredPacket& tmp_184 = (const ExtGnNonSecuredPacket&) tmp_183;
tmp_181 = tmp_184.is_present();
break;}
}
}
}
tmp_185 = tmp_181;
}
if (tmp_185) {
current_location.update_lineno(1072);
/* TTCN_EncDec.ttcn, line 1072 */
GNI.msgIn().gnPacket().packet().commonHeader().nextHeader() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().nextHeader();
current_location.update_lineno(1074);
/* TTCN_EncDec.ttcn, line 1074 */
GNI.msgIn().gnPacket().packet().commonHeader().reserved() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().reserved();
current_location.update_lineno(1078);
/* TTCN_EncDec.ttcn, line 1078 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 0) goto tmp_188_0;
current_location.update_lineno(1083);
/* TTCN_EncDec.ttcn, line 1083 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 16) goto tmp_188_1;
current_location.update_lineno(1088);
/* TTCN_EncDec.ttcn, line 1088 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 32) goto tmp_188_2;
current_location.update_lineno(1093);
/* TTCN_EncDec.ttcn, line 1093 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 48) goto tmp_188_3;
current_location.update_lineno(1098);
/* TTCN_EncDec.ttcn, line 1098 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 49) goto tmp_188_4;
current_location.update_lineno(1103);
/* TTCN_EncDec.ttcn, line 1103 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 50) goto tmp_188_5;
current_location.update_lineno(1108);
/* TTCN_EncDec.ttcn, line 1108 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 64) goto tmp_188_6;
current_location.update_lineno(1113);
/* TTCN_EncDec.ttcn, line 1113 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 65) goto tmp_188_7;
current_location.update_lineno(1118);
/* TTCN_EncDec.ttcn, line 1118 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 66) goto tmp_188_8;
current_location.update_lineno(1123);
/* TTCN_EncDec.ttcn, line 1123 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 80) goto tmp_188_9;
current_location.update_lineno(1128);
/* TTCN_EncDec.ttcn, line 1128 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 81) goto tmp_188_10;
current_location.update_lineno(1133);
/* TTCN_EncDec.ttcn, line 1133 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 96) goto tmp_188_11;
current_location.update_lineno(1138);
/* TTCN_EncDec.ttcn, line 1138 */
if(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().headerTST() == 97) goto tmp_188_12;
goto tmp_188_end;
tmp_188_0:
{
current_location.update_lineno(1079);
/* TTCN_EncDec.ttcn, line 1079 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_190 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::AnyHeaderType& tmp_191 = tmp_190.anyHdr();
tmp_191.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__any;
tmp_191.headerSubType() = 0;
}
}
goto tmp_188_end;
}
tmp_188_1:
{
current_location.update_lineno(1084);
/* TTCN_EncDec.ttcn, line 1084 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_193 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::BeaconHeaderType& tmp_194 = tmp_193.beaconHdr();
tmp_194.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__beacon;
tmp_194.headerSubType() = 0;
}
}
goto tmp_188_end;
}
tmp_188_2:
{
current_location.update_lineno(1089);
/* TTCN_EncDec.ttcn, line 1089 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_196 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::GeoUnicastHeaderType& tmp_197 = tmp_196.geoUnicastHdr();
tmp_197.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__geoUnicast;
tmp_197.headerSubType() = 0;
}
}
goto tmp_188_end;
}
tmp_188_3:
{
current_location.update_lineno(1094);
/* TTCN_EncDec.ttcn, line 1094 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_199 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::GeoAnycastHeaderType& tmp_200 = tmp_199.geoAnycastHdr();
tmp_200.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__geoAnycast;
tmp_200.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeGeoAnycast::e__geoAnycastCircle;
}
}
goto tmp_188_end;
}
tmp_188_4:
{
current_location.update_lineno(1099);
/* TTCN_EncDec.ttcn, line 1099 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_202 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::GeoAnycastHeaderType& tmp_203 = tmp_202.geoAnycastHdr();
tmp_203.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__geoAnycast;
tmp_203.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeGeoAnycast::e__geoAnycastRect;
}
}
goto tmp_188_end;
}
tmp_188_5:
{
current_location.update_lineno(1104);
/* TTCN_EncDec.ttcn, line 1104 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_205 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::GeoAnycastHeaderType& tmp_206 = tmp_205.geoAnycastHdr();
tmp_206.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__geoAnycast;
tmp_206.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeGeoAnycast::e__geoAnycastElip;
}
}
goto tmp_188_end;
}
tmp_188_6:
{
current_location.update_lineno(1109);
/* TTCN_EncDec.ttcn, line 1109 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_208 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::GeoBroadcastHeaderType& tmp_209 = tmp_208.geoBroadcastHdr();
tmp_209.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__geoBroadcast;
tmp_209.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeGeoBroadcast::e__geoBroadcastCircle;
}
}
goto tmp_188_end;
}
tmp_188_7:
{
current_location.update_lineno(1114);
/* TTCN_EncDec.ttcn, line 1114 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_211 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::GeoBroadcastHeaderType& tmp_212 = tmp_211.geoBroadcastHdr();
tmp_212.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__geoBroadcast;
tmp_212.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeGeoBroadcast::e__geoBroadcastRect;
}
}
goto tmp_188_end;
}
tmp_188_8:
{
current_location.update_lineno(1119);
/* TTCN_EncDec.ttcn, line 1119 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_214 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::GeoBroadcastHeaderType& tmp_215 = tmp_214.geoBroadcastHdr();
tmp_215.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__geoBroadcast;
tmp_215.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeGeoBroadcast::e__geoBroadcastElip;
}
}
goto tmp_188_end;
}
tmp_188_9:
{
current_location.update_lineno(1124);
/* TTCN_EncDec.ttcn, line 1124 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_217 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::TsbHeaderType& tmp_218 = tmp_217.tsbHdr();
tmp_218.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__topologicallyScopedBroadcast;
tmp_218.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeTSB::e__singleHop;
}
}
goto tmp_188_end;
}
tmp_188_10:
{
current_location.update_lineno(1129);
/* TTCN_EncDec.ttcn, line 1129 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_220 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::TsbHeaderType& tmp_221 = tmp_220.tsbHdr();
tmp_221.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__topologicallyScopedBroadcast;
tmp_221.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeTSB::e__multiHop;
}
}
goto tmp_188_end;
}
tmp_188_11:
{
current_location.update_lineno(1134);
/* TTCN_EncDec.ttcn, line 1134 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_223 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::LsHeaderType& tmp_224 = tmp_223.lsHdr();
tmp_224.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__locationService;
tmp_224.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeLs::e__lsRequest;
}
}
goto tmp_188_end;
}
tmp_188_12:
{
current_location.update_lineno(1139);
/* TTCN_EncDec.ttcn, line 1139 */
{
LibItsGeoNetworking__TypesAndValues::HeaderTST& tmp_226 = GNI.msgIn().gnPacket().packet().commonHeader().headerTST(); /* 7388 */
{
LibItsGeoNetworking__TypesAndValues::LsHeaderType& tmp_227 = tmp_226.lsHdr();
tmp_227.headerType() = LibItsGeoNetworking__TypesAndValues::HeaderType::e__locationService;
tmp_227.headerSubType() = LibItsGeoNetworking__TypesAndValues::HeaderSubTypeLs::e__lsReply;
}
}
goto tmp_188_end;
}
tmp_188_end: /* empty */;
current_location.update_lineno(1147);
/* TTCN_EncDec.ttcn, line 1147 */
GNI.msgIn().gnPacket().packet().commonHeader().trafficClass() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().trafficClass();
current_location.update_lineno(1149);
/* TTCN_EncDec.ttcn, line 1149 */
GNI.msgIn().gnPacket().packet().commonHeader().flags() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().flags();
current_location.update_lineno(1151);
/* TTCN_EncDec.ttcn, line 1151 */
GNI.msgIn().gnPacket().packet().commonHeader().plLength() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().plLength();
current_location.update_lineno(1153);
/* TTCN_EncDec.ttcn, line 1153 */
GNI.msgIn().gnPacket().packet().commonHeader().maxHopLimit() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().maxHopLimit();
current_location.update_lineno(1155);
/* TTCN_EncDec.ttcn, line 1155 */
GNI.msgIn().gnPacket().packet().commonHeader().reserved2() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().reserved2();
current_location.update_lineno(1158);
/* TTCN_EncDec.ttcn, line 1158 */
GNI.msgIn().gnPacket().packet().extendedHeader() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().extendedHeader();
current_location.update_lineno(1160);
/* TTCN_EncDec.ttcn, line 1160 */
{
boolean tmp_240;
{
boolean tmp_234 = EGNI.is_bound();
if(tmp_234) {
const ExtGeoNetworkingPdu& tmp_235 = EGNI.msgIn();
tmp_234 = tmp_235.is_bound();
if(tmp_234) {
const OPTIONAL<ExtGnNonSecuredPacket>& tmp_236 = tmp_235.packet();
switch (tmp_236.get_selection()) {
case OPTIONAL_UNBOUND:
case OPTIONAL_OMIT:
tmp_234 = false;
break;
default:
break;
}
if(tmp_234) {
const ExtGnNonSecuredPacket& tmp_237 = (const ExtGnNonSecuredPacket&) tmp_236;
tmp_234 = tmp_237.is_bound();
if(tmp_234) {
const OPTIONAL<LibItsBtp__TypesAndValues::BtpHeader>& tmp_238 = tmp_237.btpHeader();
switch (tmp_238.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_234 = false;
break;
case OPTIONAL_OMIT:
tmp_234 = false;
break;
default:
{
const LibItsBtp__TypesAndValues::BtpHeader& tmp_239 = (const LibItsBtp__TypesAndValues::BtpHeader&) tmp_238;
tmp_234 = tmp_239.is_present();
break;}
}
}
}
}
}
tmp_240 = tmp_234;
}
if (tmp_240) {
current_location.update_lineno(1161);
/* TTCN_EncDec.ttcn, line 1161 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().nextHeader() == LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpA)) {
current_location.update_lineno(1162);
/* TTCN_EncDec.ttcn, line 1162 */
LibItsBtp__TypesAndValues::BtpPacket v__btpPacket;
current_location.update_lineno(1164);
/* TTCN_EncDec.ttcn, line 1164 */
{
boolean tmp_247;
{
boolean tmp_241 = EGNI.is_bound();
if(tmp_241) {
const ExtGeoNetworkingPdu& tmp_242 = EGNI.msgIn();
tmp_241 = tmp_242.is_bound();
if(tmp_241) {
const OPTIONAL<ExtGnNonSecuredPacket>& tmp_243 = tmp_242.packet();
switch (tmp_243.get_selection()) {
case OPTIONAL_UNBOUND:
case OPTIONAL_OMIT:
tmp_241 = false;
break;
default:
break;
}
if(tmp_241) {
const ExtGnNonSecuredPacket& tmp_244 = (const ExtGnNonSecuredPacket&) tmp_243;
tmp_241 = tmp_244.is_bound();
if(tmp_241) {
const OPTIONAL<OCTETSTRING>& tmp_245 = tmp_244.btpPayload();
switch (tmp_245.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_241 = false;
break;
case OPTIONAL_OMIT:
tmp_241 = false;
break;
default:
{
const OCTETSTRING& tmp_246 = (const OCTETSTRING&) tmp_245;
tmp_241 = tmp_246.is_present();
break;}
}
}
}
}
}
tmp_247 = tmp_241;
}
if (tmp_247) {
current_location.update_lineno(1166);
/* TTCN_EncDec.ttcn, line 1166 */
LibItsBtp__TypesAndValues::DecodedBtpPayload v__decodedPayload;
current_location.update_lineno(1167);
/* TTCN_EncDec.ttcn, line 1167 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader()().btpAHeader().destinationPort() == 2001)) {
current_location.update_lineno(1168);
/* TTCN_EncDec.ttcn, line 1168 */
v__decodedPayload.camPacket() = CAM__Types::dec__CAM__PDU(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload());
}
else {
current_location.update_lineno(1171);
/* TTCN_EncDec.ttcn, line 1171 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader()().btpAHeader().destinationPort() == 2002)) {
current_location.update_lineno(1172);
/* TTCN_EncDec.ttcn, line 1172 */
v__decodedPayload.denmPacket() = DENM__Types::dec__DENM__PDU(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload());
}
else {
current_location.update_lineno(1175);
/* TTCN_EncDec.ttcn, line 1175 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader()().btpAHeader().destinationPort() == 2003)) {
current_location.update_lineno(1176);
/* TTCN_EncDec.ttcn, line 1176 */
v__decodedPayload.mapPacket() = MAP__Types::dec__MAP__PDU(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload());
}
else {
current_location.update_lineno(1179);
/* TTCN_EncDec.ttcn, line 1179 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader()().btpAHeader().destinationPort() == 2004)) {
current_location.update_lineno(1180);
/* TTCN_EncDec.ttcn, line 1180 */
v__decodedPayload.spatPacket() = SPAT__Types::dec__SPAT__PDU(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload());
}
}
}
}
current_location.update_lineno(1184);
/* TTCN_EncDec.ttcn, line 1184 */
if (v__decodedPayload.is_bound()) {
current_location.update_lineno(1185);
/* TTCN_EncDec.ttcn, line 1185 */
v__btpPacket.header() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader();
{
LibItsBtp__TypesAndValues::BtpPayload& tmp_253 = v__btpPacket.payload();
tmp_253.decodedPayload() = v__decodedPayload;
tmp_253.rawPayload() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload();
}
}
else {
current_location.update_lineno(1189);
/* TTCN_EncDec.ttcn, line 1189 */
v__btpPacket.header() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader();
{
LibItsBtp__TypesAndValues::BtpPayload& tmp_255 = v__btpPacket.payload();
tmp_255.decodedPayload() = OMIT_VALUE;
tmp_255.rawPayload() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload();
}
}
}
else {
current_location.update_lineno(1195);
/* TTCN_EncDec.ttcn, line 1195 */
v__btpPacket.header() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader();
v__btpPacket.payload() = OMIT_VALUE;
}
}
current_location.update_lineno(1199);
/* TTCN_EncDec.ttcn, line 1199 */
{
LibItsGeoNetworking__TypesAndValues::DecodedPayload& tmp_258 = GNI.msgIn().gnPacket().packet().payload()().decodedPayload(); /* 7388 */
tmp_258.btpPacket() = v__btpPacket;
}
current_location.update_lineno(1200);
/* TTCN_EncDec.ttcn, line 1200 */
GNI.msgIn().gnPacket().packet().payload()().rawPayload() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().rawPayload();
}
else {
current_location.update_lineno(1202);
/* TTCN_EncDec.ttcn, line 1202 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().nextHeader() == LibItsGeoNetworking__TypesAndValues::NextHeader::e__btpB)) {
current_location.update_lineno(1204);
/* TTCN_EncDec.ttcn, line 1204 */
LibItsBtp__TypesAndValues::BtpPacket v__btpPacket;
current_location.update_lineno(1205);
/* TTCN_EncDec.ttcn, line 1205 */
{
boolean tmp_266;
{
boolean tmp_260 = EGNI.is_bound();
if(tmp_260) {
const ExtGeoNetworkingPdu& tmp_261 = EGNI.msgIn();
tmp_260 = tmp_261.is_bound();
if(tmp_260) {
const OPTIONAL<ExtGnNonSecuredPacket>& tmp_262 = tmp_261.packet();
switch (tmp_262.get_selection()) {
case OPTIONAL_UNBOUND:
case OPTIONAL_OMIT:
tmp_260 = false;
break;
default:
break;
}
if(tmp_260) {
const ExtGnNonSecuredPacket& tmp_263 = (const ExtGnNonSecuredPacket&) tmp_262;
tmp_260 = tmp_263.is_bound();
if(tmp_260) {
const OPTIONAL<OCTETSTRING>& tmp_264 = tmp_263.btpPayload();
switch (tmp_264.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_260 = false;
break;
case OPTIONAL_OMIT:
tmp_260 = false;
break;
default:
{
const OCTETSTRING& tmp_265 = (const OCTETSTRING&) tmp_264;
tmp_260 = tmp_265.is_present();
break;}
}
}
}
}
}
tmp_266 = tmp_260;
}
if (tmp_266) {
current_location.update_lineno(1207);
/* TTCN_EncDec.ttcn, line 1207 */
LibItsBtp__TypesAndValues::DecodedBtpPayload v__decodedPayload;
current_location.update_lineno(1208);
/* TTCN_EncDec.ttcn, line 1208 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader()().btpBHeader().destinationPort() == 2001)) {
current_location.update_lineno(1210);
/* TTCN_EncDec.ttcn, line 1210 */
v__decodedPayload.camPacket() = CAM__Types::dec__CAM__PDU(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload());
}
else {
current_location.update_lineno(1213);
/* TTCN_EncDec.ttcn, line 1213 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader()().btpBHeader().destinationPort() == 2002)) {
current_location.update_lineno(1215);
/* TTCN_EncDec.ttcn, line 1215 */
v__decodedPayload.denmPacket() = DENM__Types::dec__DENM__PDU(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload());
}
else {
current_location.update_lineno(1218);
/* TTCN_EncDec.ttcn, line 1218 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader()().btpBHeader().destinationPort() == 2003)) {
current_location.update_lineno(1220);
/* TTCN_EncDec.ttcn, line 1220 */
v__decodedPayload.mapPacket() = MAP__Types::dec__MAP__PDU(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload());
}
else {
current_location.update_lineno(1223);
/* TTCN_EncDec.ttcn, line 1223 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader()().btpBHeader().destinationPort() == 2004)) {
current_location.update_lineno(1225);
/* TTCN_EncDec.ttcn, line 1225 */
v__decodedPayload.spatPacket() = SPAT__Types::dec__SPAT__PDU(const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload());
}
}
}
}
current_location.update_lineno(1230);
/* TTCN_EncDec.ttcn, line 1230 */
if (v__decodedPayload.is_bound()) {
current_location.update_lineno(1231);
/* TTCN_EncDec.ttcn, line 1231 */
v__btpPacket.header() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader();
{
LibItsBtp__TypesAndValues::BtpPayload& tmp_272 = v__btpPacket.payload();
tmp_272.decodedPayload() = v__decodedPayload;
tmp_272.rawPayload() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload();
}
}
else {
current_location.update_lineno(1235);
/* TTCN_EncDec.ttcn, line 1235 */
v__btpPacket.header() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader();
{
LibItsBtp__TypesAndValues::BtpPayload& tmp_274 = v__btpPacket.payload();
tmp_274.decodedPayload() = OMIT_VALUE;
tmp_274.rawPayload() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpPayload();
}
}
}
else {
current_location.update_lineno(1240);
/* TTCN_EncDec.ttcn, line 1240 */
v__btpPacket.header() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().btpHeader();
v__btpPacket.payload() = OMIT_VALUE;
}
}
current_location.update_lineno(1244);
/* TTCN_EncDec.ttcn, line 1244 */
{
LibItsGeoNetworking__TypesAndValues::DecodedPayload& tmp_277 = GNI.msgIn().gnPacket().packet().payload()().decodedPayload(); /* 7388 */
tmp_277.btpPacket() = v__btpPacket;
}
current_location.update_lineno(1245);
/* TTCN_EncDec.ttcn, line 1245 */
GNI.msgIn().gnPacket().packet().payload()().rawPayload() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().rawPayload();
}
else {
current_location.update_lineno(1247);
/* TTCN_EncDec.ttcn, line 1247 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().nextHeader() == LibItsGeoNetworking__TypesAndValues::NextHeader::e__ipv6)) {
current_location.update_lineno(1250);
/* TTCN_EncDec.ttcn, line 1250 */
GNI.msgIn().gnPacket().packet().payload()().decodedPayload() = OMIT_VALUE;
current_location.update_lineno(1251);
/* TTCN_EncDec.ttcn, line 1251 */
GNI.msgIn().gnPacket().packet().payload()().rawPayload() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().rawPayload();
}
else {
current_location.update_lineno(1253);
/* TTCN_EncDec.ttcn, line 1253 */
if ((const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().packet()().nextHeader() == LibItsGeoNetworking__TypesAndValues::NextHeader::e__any)) {
current_location.update_lineno(1254);
/* TTCN_EncDec.ttcn, line 1254 */
GNI.msgIn().gnPacket().packet().payload() = OMIT_VALUE;
}
}
}
}
}
}
}
}
current_location.update_lineno(1259);
/* TTCN_EncDec.ttcn, line 1259 */
GNI.msgIn().gnPacket().securedMsg() = const_cast< const ExtGeoNetworkingInd&>(EGNI).msgIn().securedMsg();
current_location.update_lineno(1260);
/* TTCN_EncDec.ttcn, line 1260 */
GNI.macDestinationAddress() = const_cast< const ExtGeoNetworkingInd&>(EGNI).macDestinationAddress();
current_location.update_lineno(1262);
/* TTCN_EncDec.ttcn, line 1262 */
try {
TTCN_Logger::begin_event(TTCN_USER);
GNI.log();
TTCN_Logger::end_event();
} catch (...) {
TTCN_Logger::finish_event();
throw;
}
current_location.update_lineno(1264);
/* TTCN_EncDec.ttcn, line 1264 */
return GNI;
}

OCTETSTRING f__enc__IPv6OverGeoNetworkingReq(const LibItsIpv6OverGeoNetworking__TestSystem::IPv6OverGeoNetworkingReq& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_IPv6OverGeoNetworkingReq(): Encoding @LibItsIpv6OverGeoNetworking_TestSystem.IPv6OverGeoNetworkingReq: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsIpv6OverGeoNetworking__TestSystem::IPv6OverGeoNetworkingReq_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_IPv6OverGeoNetworkingReq(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsIpv6OverGeoNetworking__TestSystem::IPv6OverGeoNetworkingInd f__dec__IPv6OverGeoNetworkingInd(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_IPv6OverGeoNetworkingInd(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsIpv6OverGeoNetworking__TestSystem::IPv6OverGeoNetworkingInd ret_val;
ret_val.decode(LibItsIpv6OverGeoNetworking__TestSystem::IPv6OverGeoNetworkingInd_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_IPv6OverGeoNetworkingInd(): Decoded @LibItsIpv6OverGeoNetworking_TestSystem.IPv6OverGeoNetworkingInd: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_IPv6OverGeoNetworkingInd(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}

OCTETSTRING f__enc__LongPosVector(const LibItsGeoNetworking__TypesAndValues::LongPosVector& pdu)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_LongPosVector(): Encoding @LibItsGeoNetworking_TypesAndValues.LongPosVector: ");
pdu.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_Buffer ttcn_buffer;
pdu.encode(LibItsGeoNetworking__TypesAndValues::LongPosVector_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
OCTETSTRING ret_val;
ttcn_buffer.get_string(ret_val);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_enc_LongPosVector(): Stream after encoding: ");
ret_val.log();
TTCN_Logger::end_event();
}
return ret_val;
}

LibItsGeoNetworking__TypesAndValues::LongPosVector f__dec__LongPosVector(const OCTETSTRING& stream)
{
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_LongPosVector(): Stream before decoding: ");
stream.log();
TTCN_Logger::end_event();
}
TTCN_EncDec::set_error_behavior(TTCN_EncDec::ET_ALL, TTCN_EncDec::EB_DEFAULT);
TTCN_EncDec::clear_error();
TTCN_Buffer ttcn_buffer(stream);
LibItsGeoNetworking__TypesAndValues::LongPosVector ret_val;
ret_val.decode(LibItsGeoNetworking__TypesAndValues::LongPosVector_descr_, ttcn_buffer, TTCN_EncDec::CT_RAW);
if (TTCN_Logger::log_this_event(TTCN_Logger::DEBUG_ENCDEC)) {
TTCN_Logger::begin_event(TTCN_Logger::DEBUG_ENCDEC);
TTCN_Logger::log_event_str("f_dec_LongPosVector(): Decoded @LibItsGeoNetworking_TypesAndValues.LongPosVector: ");
ret_val.log();
TTCN_Logger::end_event();
}
if (TTCN_EncDec::get_last_error_type() == TTCN_EncDec::ET_NONE) {
if (ttcn_buffer.get_pos() < ttcn_buffer.get_len()-1 && TTCN_Logger::log_this_event(TTCN_WARNING)) {
ttcn_buffer.cut();
OCTETSTRING remaining_stream;
ttcn_buffer.get_string(remaining_stream);
TTCN_Logger::begin_event(TTCN_WARNING);
TTCN_Logger::log_event_str("f_dec_LongPosVector(): Warning: Data remained at the end of the stream after successful decoding: ");
remaining_stream.log();
TTCN_Logger::end_event();
}
}
return ret_val;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "TTCN_EncDec");
LibItsBtp__TestSystem::module_object.pre_init_module();
LibItsCam__TypesAndValues::module_object.pre_init_module();
LibItsCam__TestSystem::module_object.pre_init_module();
LibItsDenm__TypesAndValues::module_object.pre_init_module();
LibItsDenm__TestSystem::module_object.pre_init_module();
LibItsIpv6OverGeoNetworking__TestSystem::module_object.pre_init_module();
LibItsGeoNetworking__TestSystem::module_object.pre_init_module();
LibItsGeoNetworking__TypesAndValues::module_object.pre_init_module();
CAM__Types::module_object.pre_init_module();
DENM__Types::module_object.pre_init_module();
MAP__Types::module_object.pre_init_module();
SPAT__Types::module_object.pre_init_module();
General__Types::module_object.pre_init_module();
module_object.add_function("f_enc_UtInitialize", (genericfunc_t)&f__enc__UtInitialize, NULL);
module_object.add_function("f_dec_UtInitialize", (genericfunc_t)&f__dec__UtInitialize, NULL);
module_object.add_function("f_enc_UtChangePosition", (genericfunc_t)&f__enc__UtChangePosition, NULL);
module_object.add_function("f_dec_UtChangePosition", (genericfunc_t)&f__dec__UtChangePosition, NULL);
module_object.add_function("f_enc_UtChangePositionResult", (genericfunc_t)&f__enc__UtChangePositionResult, NULL);
module_object.add_function("f_dec_UtChangePositionResult", (genericfunc_t)&f__dec__UtChangePositionResult, NULL);
module_object.add_function("f_enc_UtChangePseudonym", (genericfunc_t)&f__enc__UtChangePseudonym, NULL);
module_object.add_function("f_dec_UtChangePseudonym", (genericfunc_t)&f__dec__UtChangePseudonym, NULL);
module_object.add_function("f_enc_UtChangePseudonymResult", (genericfunc_t)&f__enc__UtChangePseudonymResult, NULL);
module_object.add_function("f_dec_UtChangePseudonymResult", (genericfunc_t)&f__dec__UtChangePseudonymResult, NULL);
module_object.add_function("f_enc_Ut_Gn_GenerateGeoUnicastMessage", (genericfunc_t)&f__enc__Ut__Gn__GenerateGeoUnicastMessage, NULL);
module_object.add_function("f_dec_Ut_Gn_GenerateGeoUnicastMessage", (genericfunc_t)&f__dec__Ut__Gn__GenerateGeoUnicastMessage, NULL);
module_object.add_function("f_enc_Ext_UtGnGenerateGeoBroadcastMessage", (genericfunc_t)&f__enc__Ext__UtGnGenerateGeoBroadcastMessage, NULL);
module_object.add_function("f_enc_Ut_Gn_GenerateGeoBroadcastMessage", (genericfunc_t)&f__enc__Ut__Gn__GenerateGeoBroadcastMessage, NULL);
module_object.add_function("f_dec_Ut_Gn_GenerateGeoBroadcastMessage", (genericfunc_t)&f__dec__Ut__Gn__GenerateGeoBroadcastMessage, NULL);
module_object.add_function("f_enc_Ut_Gn_GenerateGeoAnycastMessage", (genericfunc_t)&f__enc__Ut__Gn__GenerateGeoAnycastMessage, NULL);
module_object.add_function("f_dec_Ut_Gn_GenerateGeoAnycastMessage", (genericfunc_t)&f__dec__Ut__Gn__GenerateGeoAnycastMessage, NULL);
module_object.add_function("f_enc_Ut_Gn_GenerateSHBMessage", (genericfunc_t)&f__enc__Ut__Gn__GenerateSHBMessage, NULL);
module_object.add_function("f_dec_Ut_Gn_GenerateSHBMessage", (genericfunc_t)&f__dec__Ut__Gn__GenerateSHBMessage, NULL);
module_object.add_function("f_enc_Ut_Gn_GenerateTSBMessage", (genericfunc_t)&f__enc__Ut__Gn__GenerateTSBMessage, NULL);
module_object.add_function("f_dec_Ut_Gn_GenerateTSBMessage", (genericfunc_t)&f__dec__Ut__Gn__GenerateTSBMessage, NULL);
module_object.add_function("f_enc_UtGnTrigger", (genericfunc_t)&f__enc__UtGnTrigger, NULL);
module_object.add_function("f_enc_ExtUt_Cam_Trigger", (genericfunc_t)&f__enc__ExtUt__Cam__Trigger, NULL);
module_object.add_function("f_dec_ExtUt_Cam_Trigger", (genericfunc_t)&f__dec__ExtUt__Cam__Trigger, NULL);
module_object.add_function("f_enc_UtCAmTrigger", (genericfunc_t)&f__enc__UtCAmTrigger, NULL);
module_object.add_function("f_dec_ExtUt_Cam_EventInd", (genericfunc_t)&f__dec__ExtUt__Cam__EventInd, NULL);
module_object.add_function("f_dec_Ut_Cam_EventInd", (genericfunc_t)&f__dec__Ut__Cam__EventInd, NULL);
module_object.add_function("f_enc_ExtUt_Denm_Trigger", (genericfunc_t)&f__enc__ExtUt__Denm__Trigger, NULL);
module_object.add_function("f_dec_ExtUt_Denm_Trigger", (genericfunc_t)&f__dec__ExtUt__Denm__Trigger, NULL);
module_object.add_function("f_enc_UtDenmTrigger", (genericfunc_t)&f__enc__UtDenmTrigger, NULL);
module_object.add_function("f_enc_ExtUt_Denm_Update", (genericfunc_t)&f__enc__ExtUt__Denm__Update, NULL);
module_object.add_function("f_dec_ExtUt_Denm_Update", (genericfunc_t)&f__dec__ExtUt__Denm__Update, NULL);
module_object.add_function("f_enc_UtDenmUpdate", (genericfunc_t)&f__enc__UtDenmUpdate, NULL);
module_object.add_function("f_enc_ExtDenmInd", (genericfunc_t)&f__enc__ExtDenmInd, NULL);
module_object.add_function("f_dec_ExtDenmInd", (genericfunc_t)&f__dec__ExtDenmInd, NULL);
module_object.add_function("f_dec_ExtUt_Denm_EventInd", (genericfunc_t)&f__dec__ExtUt__Denm__EventInd, NULL);
module_object.add_function("f_dec_Ut_Denm_EventInd", (genericfunc_t)&f__dec__Ut__Denm__EventInd, NULL);
module_object.add_function("f_dec_ExtUt_Map_EventInd", (genericfunc_t)&f__dec__ExtUt__Map__EventInd, NULL);
module_object.add_function("f_dec_Ut_Map_EventInd", (genericfunc_t)&f__dec__Ut__Map__EventInd, NULL);
module_object.add_function("f_dec_ExtUt_Spat_EventInd", (genericfunc_t)&f__dec__ExtUt__Spat__EventInd, NULL);
module_object.add_function("f_dec_Ut_Spat_EventInd", (genericfunc_t)&f__dec__Ut__Spat__EventInd, NULL);
module_object.add_function("f_enc_ExtBtpReq", (genericfunc_t)&f__enc__ExtBtpReq, NULL);
module_object.add_function("f_enc_BtpReq", (genericfunc_t)&f__enc__BtpReq, NULL);
module_object.add_function("f_dec_ExtBtpInd", (genericfunc_t)&f__dec__ExtBtpInd, NULL);
module_object.add_function("f_dec_BtpInd", (genericfunc_t)&f__dec__BtpInd, NULL);
module_object.add_function("f_enc_ExtCamInd", (genericfunc_t)&f__enc__ExtCamInd, NULL);
module_object.add_function("f_dec_ExtCamInd", (genericfunc_t)&f__dec__ExtCamInd, NULL);
module_object.add_function("f_dec_ExtMapSpatInd", (genericfunc_t)&f__dec__ExtMapSpatInd, NULL);
module_object.add_function("f_dec_MapSpatInd", (genericfunc_t)&f__dec__MapSpatInd, NULL);
module_object.add_function("f_enc_GeoNetworkingPdu", (genericfunc_t)&f__enc__GeoNetworkingPdu, NULL);
module_object.add_function("f_dec_GeoNetworkingPdu", (genericfunc_t)&f__dec__GeoNetworkingPdu, NULL);
module_object.add_function("f_enc_BeaconHeader", (genericfunc_t)&f__enc__BeaconHeader, NULL);
module_object.add_function("f_dec_BeaconHeader", (genericfunc_t)&f__dec__BeaconHeader, NULL);
module_object.add_function("f_enc_GN_Address", (genericfunc_t)&f__enc__GN__Address, NULL);
module_object.add_function("f_dec_GN_Address", (genericfunc_t)&f__dec__GN__Address, NULL);
module_object.add_function("f_enc_GeoNetworkingReq", (genericfunc_t)&f__enc__GeoNetworkingReq, NULL);
module_object.add_function("f_dec_ExtGeoNetworkingInd", (genericfunc_t)&f__dec__ExtGeoNetworkingInd, NULL);
module_object.add_function("f_dec_GeoNetworkingInd", (genericfunc_t)&f__dec__GeoNetworkingInd, NULL);
module_object.add_function("f_enc_IPv6OverGeoNetworkingReq", (genericfunc_t)&f__enc__IPv6OverGeoNetworkingReq, NULL);
module_object.add_function("f_dec_IPv6OverGeoNetworkingInd", (genericfunc_t)&f__dec__IPv6OverGeoNetworkingInd, NULL);
module_object.add_function("f_enc_LongPosVector", (genericfunc_t)&f__enc__LongPosVector, NULL);
module_object.add_function("f_dec_LongPosVector", (genericfunc_t)&f__dec__LongPosVector, NULL);
}

static void post_init_module()
{
TTCN_Location current_location("TTCN_EncDec.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "TTCN_EncDec");
LibItsBtp__TestSystem::module_object.post_init_module();
LibItsCam__TypesAndValues::module_object.post_init_module();
LibItsCam__TestSystem::module_object.post_init_module();
LibItsDenm__TypesAndValues::module_object.post_init_module();
LibItsDenm__TestSystem::module_object.post_init_module();
LibItsIpv6OverGeoNetworking__TestSystem::module_object.post_init_module();
LibItsGeoNetworking__TestSystem::module_object.post_init_module();
LibItsGeoNetworking__TypesAndValues::module_object.post_init_module();
CAM__Types::module_object.post_init_module();
DENM__Types::module_object.post_init_module();
MAP__Types::module_object.post_init_module();
SPAT__Types::module_object.post_init_module();
General__Types::module_object.post_init_module();
}


} /* end of namespace */
