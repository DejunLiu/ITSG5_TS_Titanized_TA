// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef LibItsMapSpat__TypesAndValues_HH
#define LibItsMapSpat__TypesAndValues_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "LibCommon_BasicTypesAndValues.hh"
#include "MAP_SPAT_ETSI.hh"
#include "LibItsCommon_TypesAndValues.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef LibItsMapSpat__TypesAndValues_HH
#endif

namespace LibItsMapSpat__TypesAndValues {

/* Forward declarations of classes */

class Event;
class Event_template;
class UtMapSpatTrigger;
class UtMapSpatTrigger_template;
class UtMapSpatTriggerResult;
class UtMapSpatTriggerResult_template;
class UtMapEventInd;
class UtMapEventInd_template;
class UtSpatEventInd;
class UtSpatEventInd_template;
class UtMapEventIndList;
class UtMapEventIndList_template;
class UtSpatEventIndList;
class UtSpatEventIndList_template;

} /* end of namespace */

#ifndef LibItsMapSpat__TypesAndValues_HH
#define LibItsMapSpat__TypesAndValues_HH

namespace LibItsMapSpat__TypesAndValues {

/* Class definitions */

class Event : public Base_Type { // enum
friend class Event_template;
public:
enum enum_type { spatMsg = 0, mapNewContent = 1, mapRepL10s = 2, mapRepG10s = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
Event();
Event(int other_value);
Event(enum_type other_value);
Event(const Event& other_value);

Event& operator=(int other_value);
Event& operator=(enum_type other_value);
Event& operator=(const Event& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Event& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Event& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Event& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Event& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Event& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Event& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Event& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class Event_template : public Base_Template {
union {
Event::enum_type single_value;
struct {
unsigned int n_values;
Event_template *list_value;
} value_list;
};

void copy_template(const Event_template& other_value);

public:
Event_template();
Event_template(template_sel other_value);
Event_template(int other_value);
Event_template(Event::enum_type other_value);
Event_template(const Event& other_value);
Event_template(const OPTIONAL<Event>& other_value);
Event_template(const Event_template& other_value);
~Event_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Event_template& operator=(template_sel other_value);
Event_template& operator=(int other_value);
Event_template& operator=(Event::enum_type other_value);
Event_template& operator=(const Event& other_value);
Event_template& operator=(const OPTIONAL<Event>& other_value);
Event_template& operator=(const Event_template& other_value);

boolean match(Event::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const Event& other_value, boolean legacy = FALSE) const;
Event::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Event_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Event& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class UtMapSpatTrigger {
  Event field_event;
  boolean bound_flag;
public:
  UtMapSpatTrigger();
  UtMapSpatTrigger(const Event& par_event);
  UtMapSpatTrigger(const UtMapSpatTrigger& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtMapSpatTrigger& operator=(const UtMapSpatTrigger& other_value);
  boolean operator==(const UtMapSpatTrigger& other_value) const;
  inline boolean operator!=(const UtMapSpatTrigger& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline Event& event()
    {return field_event;}
  inline const Event& event() const
    {return field_event;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class UtMapSpatTrigger_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtMapSpatTrigger_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtMapSpatTrigger& other_value);
void copy_template(const UtMapSpatTrigger_template& other_value);

public:
UtMapSpatTrigger_template();
UtMapSpatTrigger_template(template_sel other_value);
UtMapSpatTrigger_template(const UtMapSpatTrigger& other_value);
UtMapSpatTrigger_template(const OPTIONAL<UtMapSpatTrigger>& other_value);
UtMapSpatTrigger_template(const UtMapSpatTrigger_template& other_value);
~UtMapSpatTrigger_template();
UtMapSpatTrigger_template& operator=(template_sel other_value);
UtMapSpatTrigger_template& operator=(const UtMapSpatTrigger& other_value);
UtMapSpatTrigger_template& operator=(const OPTIONAL<UtMapSpatTrigger>& other_value);
UtMapSpatTrigger_template& operator=(const UtMapSpatTrigger_template& other_value);
boolean match(const UtMapSpatTrigger& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtMapSpatTrigger valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtMapSpatTrigger_template& list_item(unsigned int list_index) const;
Event_template& event();
const Event_template& event() const;
int size_of() const;
void log() const;
void log_match(const UtMapSpatTrigger& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtMapSpatTriggerResult {
  BOOLEAN field_result;
  INTEGER field_msgCount;
  boolean bound_flag;
public:
  UtMapSpatTriggerResult();
  UtMapSpatTriggerResult(const BOOLEAN& par_result,
    const INTEGER& par_msgCount);
  UtMapSpatTriggerResult(const UtMapSpatTriggerResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtMapSpatTriggerResult& operator=(const UtMapSpatTriggerResult& other_value);
  boolean operator==(const UtMapSpatTriggerResult& other_value) const;
  inline boolean operator!=(const UtMapSpatTriggerResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& result()
    {return field_result;}
  inline const BOOLEAN& result() const
    {return field_result;}
  inline INTEGER& msgCount()
    {return field_msgCount;}
  inline const INTEGER& msgCount() const
    {return field_msgCount;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class UtMapSpatTriggerResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtMapSpatTriggerResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtMapSpatTriggerResult& other_value);
void copy_template(const UtMapSpatTriggerResult_template& other_value);

public:
UtMapSpatTriggerResult_template();
UtMapSpatTriggerResult_template(template_sel other_value);
UtMapSpatTriggerResult_template(const UtMapSpatTriggerResult& other_value);
UtMapSpatTriggerResult_template(const OPTIONAL<UtMapSpatTriggerResult>& other_value);
UtMapSpatTriggerResult_template(const UtMapSpatTriggerResult_template& other_value);
~UtMapSpatTriggerResult_template();
UtMapSpatTriggerResult_template& operator=(template_sel other_value);
UtMapSpatTriggerResult_template& operator=(const UtMapSpatTriggerResult& other_value);
UtMapSpatTriggerResult_template& operator=(const OPTIONAL<UtMapSpatTriggerResult>& other_value);
UtMapSpatTriggerResult_template& operator=(const UtMapSpatTriggerResult_template& other_value);
boolean match(const UtMapSpatTriggerResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtMapSpatTriggerResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtMapSpatTriggerResult_template& list_item(unsigned int list_index) const;
BOOLEAN_template& result();
const BOOLEAN_template& result() const;
INTEGER_template& msgCount();
const INTEGER_template& msgCount() const;
int size_of() const;
void log() const;
void log_match(const UtMapSpatTriggerResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtMapEventInd : public Base_Type {
  MAP__SPAT__ETSI::MAP__PDU field_mapMsg;
  boolean bound_flag;
public:
  UtMapEventInd();
  UtMapEventInd(const MAP__SPAT__ETSI::MAP__PDU& par_mapMsg);
  UtMapEventInd(const UtMapEventInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtMapEventInd& operator=(const UtMapEventInd& other_value);
  boolean operator==(const UtMapEventInd& other_value) const;
  inline boolean operator!=(const UtMapEventInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline MAP__SPAT__ETSI::MAP__PDU& mapMsg()
    {return field_mapMsg;}
  inline const MAP__SPAT__ETSI::MAP__PDU& mapMsg() const
    {return field_mapMsg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtMapEventInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtMapEventInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtMapEventInd& other_value);
void copy_template(const UtMapEventInd_template& other_value);

public:
UtMapEventInd_template();
UtMapEventInd_template(template_sel other_value);
UtMapEventInd_template(const UtMapEventInd& other_value);
UtMapEventInd_template(const OPTIONAL<UtMapEventInd>& other_value);
UtMapEventInd_template(const UtMapEventInd_template& other_value);
~UtMapEventInd_template();
UtMapEventInd_template& operator=(template_sel other_value);
UtMapEventInd_template& operator=(const UtMapEventInd& other_value);
UtMapEventInd_template& operator=(const OPTIONAL<UtMapEventInd>& other_value);
UtMapEventInd_template& operator=(const UtMapEventInd_template& other_value);
boolean match(const UtMapEventInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtMapEventInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtMapEventInd_template& list_item(unsigned int list_index) const;
MAP__SPAT__ETSI::MAP__PDU_template& mapMsg();
const MAP__SPAT__ETSI::MAP__PDU_template& mapMsg() const;
int size_of() const;
void log() const;
void log_match(const UtMapEventInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtSpatEventInd : public Base_Type {
  MAP__SPAT__ETSI::SPAT__PDU field_spatMsg;
  boolean bound_flag;
public:
  UtSpatEventInd();
  UtSpatEventInd(const MAP__SPAT__ETSI::SPAT__PDU& par_spatMsg);
  UtSpatEventInd(const UtSpatEventInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtSpatEventInd& operator=(const UtSpatEventInd& other_value);
  boolean operator==(const UtSpatEventInd& other_value) const;
  inline boolean operator!=(const UtSpatEventInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline MAP__SPAT__ETSI::SPAT__PDU& spatMsg()
    {return field_spatMsg;}
  inline const MAP__SPAT__ETSI::SPAT__PDU& spatMsg() const
    {return field_spatMsg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtSpatEventInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtSpatEventInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtSpatEventInd& other_value);
void copy_template(const UtSpatEventInd_template& other_value);

public:
UtSpatEventInd_template();
UtSpatEventInd_template(template_sel other_value);
UtSpatEventInd_template(const UtSpatEventInd& other_value);
UtSpatEventInd_template(const OPTIONAL<UtSpatEventInd>& other_value);
UtSpatEventInd_template(const UtSpatEventInd_template& other_value);
~UtSpatEventInd_template();
UtSpatEventInd_template& operator=(template_sel other_value);
UtSpatEventInd_template& operator=(const UtSpatEventInd& other_value);
UtSpatEventInd_template& operator=(const OPTIONAL<UtSpatEventInd>& other_value);
UtSpatEventInd_template& operator=(const UtSpatEventInd_template& other_value);
boolean match(const UtSpatEventInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtSpatEventInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtSpatEventInd_template& list_item(unsigned int list_index) const;
MAP__SPAT__ETSI::SPAT__PDU_template& spatMsg();
const MAP__SPAT__ETSI::SPAT__PDU_template& spatMsg() const;
int size_of() const;
void log() const;
void log_match(const UtSpatEventInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtMapEventIndList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UtMapEventInd **value_elements;
} *val_ptr;

static const UtMapEventInd UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const UtMapEventIndList& other_value);

public:
  typedef UtMapEventInd of_type;
UtMapEventIndList();
UtMapEventIndList(null_type other_value);
UtMapEventIndList(const UtMapEventIndList& other_value);
~UtMapEventIndList();

void clean_up();
UtMapEventIndList& operator=(null_type other_value);
UtMapEventIndList& operator=(const UtMapEventIndList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const UtMapEventIndList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UtMapEventIndList& other_value) const { return !(*this == other_value); }

UtMapEventInd& operator[](int index_value);
UtMapEventInd& operator[](const INTEGER& index_value);
const UtMapEventInd& operator[](int index_value) const;
const UtMapEventInd& operator[](const INTEGER& index_value) const;

UtMapEventIndList operator<<=(int rotate_count) const;
UtMapEventIndList operator<<=(const INTEGER& rotate_count) const;
UtMapEventIndList operator>>=(int rotate_count) const;
UtMapEventIndList operator>>=(const INTEGER& rotate_count) const;

UtMapEventIndList operator+(const UtMapEventIndList& other_value) const;

UtMapEventIndList substr(int index, int returncount) const;

UtMapEventIndList replace(int index, int len, const UtMapEventIndList& repl) const;

UtMapEventIndList replace(int index, int len, const UtMapEventIndList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class UtMapEventIndList_template : public Record_Of_Template {
union {
struct {
int n_elements;
UtMapEventInd_template **value_elements;
} single_value;
struct {
unsigned int n_values;
UtMapEventIndList_template *list_value;
} value_list;
};
void copy_value(const UtMapEventIndList& other_value);
void copy_template(const UtMapEventIndList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
UtMapEventIndList_template();
UtMapEventIndList_template(template_sel other_value);
UtMapEventIndList_template(null_type other_value);
UtMapEventIndList_template(const UtMapEventIndList& other_value);
UtMapEventIndList_template(const OPTIONAL<UtMapEventIndList>& other_value);
UtMapEventIndList_template(const UtMapEventIndList_template& other_value);
~UtMapEventIndList_template();

void clean_up();
UtMapEventIndList_template& operator=(template_sel other_value);
UtMapEventIndList_template& operator=(null_type other_value);
UtMapEventIndList_template& operator=(const UtMapEventIndList& other_value);
UtMapEventIndList_template& operator=(const OPTIONAL<UtMapEventIndList>& other_value);
UtMapEventIndList_template& operator=(const UtMapEventIndList_template& other_value);

UtMapEventInd_template& operator[](int index_value);
UtMapEventInd_template& operator[](const INTEGER& index_value);
const UtMapEventInd_template& operator[](int index_value) const;
const UtMapEventInd_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const UtMapEventIndList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
UtMapEventIndList valueof() const;
UtMapEventIndList substr(int index, int returncount) const;

UtMapEventIndList replace(int index, int len, const UtMapEventIndList_template& repl) const;

UtMapEventIndList replace(int index, int len, const UtMapEventIndList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
UtMapEventIndList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const UtMapEventIndList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class UtSpatEventIndList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UtSpatEventInd **value_elements;
} *val_ptr;

static const UtSpatEventInd UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const UtSpatEventIndList& other_value);

public:
  typedef UtSpatEventInd of_type;
UtSpatEventIndList();
UtSpatEventIndList(null_type other_value);
UtSpatEventIndList(const UtSpatEventIndList& other_value);
~UtSpatEventIndList();

void clean_up();
UtSpatEventIndList& operator=(null_type other_value);
UtSpatEventIndList& operator=(const UtSpatEventIndList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const UtSpatEventIndList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UtSpatEventIndList& other_value) const { return !(*this == other_value); }

UtSpatEventInd& operator[](int index_value);
UtSpatEventInd& operator[](const INTEGER& index_value);
const UtSpatEventInd& operator[](int index_value) const;
const UtSpatEventInd& operator[](const INTEGER& index_value) const;

UtSpatEventIndList operator<<=(int rotate_count) const;
UtSpatEventIndList operator<<=(const INTEGER& rotate_count) const;
UtSpatEventIndList operator>>=(int rotate_count) const;
UtSpatEventIndList operator>>=(const INTEGER& rotate_count) const;

UtSpatEventIndList operator+(const UtSpatEventIndList& other_value) const;

UtSpatEventIndList substr(int index, int returncount) const;

UtSpatEventIndList replace(int index, int len, const UtSpatEventIndList& repl) const;

UtSpatEventIndList replace(int index, int len, const UtSpatEventIndList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class UtSpatEventIndList_template : public Record_Of_Template {
union {
struct {
int n_elements;
UtSpatEventInd_template **value_elements;
} single_value;
struct {
unsigned int n_values;
UtSpatEventIndList_template *list_value;
} value_list;
};
void copy_value(const UtSpatEventIndList& other_value);
void copy_template(const UtSpatEventIndList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
UtSpatEventIndList_template();
UtSpatEventIndList_template(template_sel other_value);
UtSpatEventIndList_template(null_type other_value);
UtSpatEventIndList_template(const UtSpatEventIndList& other_value);
UtSpatEventIndList_template(const OPTIONAL<UtSpatEventIndList>& other_value);
UtSpatEventIndList_template(const UtSpatEventIndList_template& other_value);
~UtSpatEventIndList_template();

void clean_up();
UtSpatEventIndList_template& operator=(template_sel other_value);
UtSpatEventIndList_template& operator=(null_type other_value);
UtSpatEventIndList_template& operator=(const UtSpatEventIndList& other_value);
UtSpatEventIndList_template& operator=(const OPTIONAL<UtSpatEventIndList>& other_value);
UtSpatEventIndList_template& operator=(const UtSpatEventIndList_template& other_value);

UtSpatEventInd_template& operator[](int index_value);
UtSpatEventInd_template& operator[](const INTEGER& index_value);
const UtSpatEventInd_template& operator[](int index_value) const;
const UtSpatEventInd_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const UtSpatEventIndList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
UtSpatEventIndList valueof() const;
UtSpatEventIndList substr(int index, int returncount) const;

UtSpatEventIndList replace(int index, int len, const UtSpatEventIndList_template& repl) const;

UtSpatEventIndList replace(int index, int len, const UtSpatEventIndList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
UtSpatEventIndList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const UtSpatEventIndList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const UtMapEventIndList& other_value);
inline boolean operator!=(null_type null_value, const UtMapEventIndList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const UtSpatEventIndList& other_value);
inline boolean operator!=(null_type null_value, const UtSpatEventIndList& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_Typedescriptor_t Event_descr_;
extern const TTCN_Typedescriptor_t UtMapSpatTrigger_descr_;
extern const XERdescriptor_t UtMapSpatTriggerResult_result_xer_;
extern const TTCN_Typedescriptor_t UtMapSpatTriggerResult_result_descr_;
extern const TTCN_Typedescriptor_t UtMapSpatTriggerResult_descr_;
extern const TTCN_RAWdescriptor_t UtMapEventInd_raw_;
extern const TTCN_JSONdescriptor_t UtMapEventInd_json_;
extern const TTCN_Typedescriptor_t UtMapEventInd_descr_;
extern const TTCN_RAWdescriptor_t UtSpatEventInd_raw_;
extern const TTCN_JSONdescriptor_t UtSpatEventInd_json_;
extern const TTCN_Typedescriptor_t UtSpatEventInd_descr_;
extern const TTCN_Typedescriptor_t UtMapEventIndList_descr_;
extern const TTCN_Typedescriptor_t UtSpatEventIndList_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
