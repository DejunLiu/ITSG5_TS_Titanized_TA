// This C++ source file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "ITS_Container.hh"

namespace ITS__Container {

/* Global variable definitions */

static const ASN_Tag_t ItsPduHeader_protocolVersion_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ItsPduHeader_protocolVersion_ber_ = { 1u, ItsPduHeader_protocolVersion_tag_ };
// No XER for ItsPduHeader_protocolVersion
const TTCN_Typedescriptor_t ItsPduHeader_protocolVersion_descr_ = { "@ITS-Container.ItsPduHeader.protocolVersion", &ItsPduHeader_protocolVersion_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ItsPduHeader_messageID_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ItsPduHeader_messageID_ber_ = { 1u, ItsPduHeader_messageID_tag_ };
// No XER for ItsPduHeader_messageID
const TTCN_Typedescriptor_t ItsPduHeader_messageID_descr_ = { "@ITS-Container.ItsPduHeader.messageID", &ItsPduHeader_messageID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& StationID_descr_ = INTEGER_descr_;
static const ASN_Tag_t ItsPduHeader_stationID_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t ItsPduHeader_stationID_ber_ = { 1u, ItsPduHeader_stationID_tag_ };
// No XER for ItsPduHeader_stationID
const TTCN_Typedescriptor_t ItsPduHeader_stationID_descr_ = { "@ITS-Container.ItsPduHeader.stationID", &ItsPduHeader_stationID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ItsPduHeader
const TTCN_JSONdescriptor_t ItsPduHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ItsPduHeader_descr_ = { "@ITS-Container.ItsPduHeader", &SEQUENCE_ber_, NULL, NULL, NULL, &ItsPduHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& Latitude_descr_ = INTEGER_descr_;
static const ASN_Tag_t ReferencePosition_latitude_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ReferencePosition_latitude_ber_ = { 1u, ReferencePosition_latitude_tag_ };
// No XER for ReferencePosition_latitude
const TTCN_Typedescriptor_t ReferencePosition_latitude_descr_ = { "@ITS-Container.ReferencePosition.latitude", &ReferencePosition_latitude_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& Longitude_descr_ = INTEGER_descr_;
static const ASN_Tag_t ReferencePosition_longitude_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ReferencePosition_longitude_ber_ = { 1u, ReferencePosition_longitude_tag_ };
// No XER for ReferencePosition_longitude
const TTCN_Typedescriptor_t ReferencePosition_longitude_descr_ = { "@ITS-Container.ReferencePosition.longitude", &ReferencePosition_longitude_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& SemiAxisLength_descr_ = INTEGER_descr_;
static const ASN_Tag_t PosConfidenceEllipse_semiMajorConfidence_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t PosConfidenceEllipse_semiMajorConfidence_ber_ = { 1u, PosConfidenceEllipse_semiMajorConfidence_tag_ };
// No XER for PosConfidenceEllipse_semiMajorConfidence
const TTCN_Typedescriptor_t PosConfidenceEllipse_semiMajorConfidence_descr_ = { "@ITS-Container.PosConfidenceEllipse.semiMajorConfidence", &PosConfidenceEllipse_semiMajorConfidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t PosConfidenceEllipse_semiMinorConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t PosConfidenceEllipse_semiMinorConfidence_ber_ = { 1u, PosConfidenceEllipse_semiMinorConfidence_tag_ };
// No XER for PosConfidenceEllipse_semiMinorConfidence
const TTCN_Typedescriptor_t PosConfidenceEllipse_semiMinorConfidence_descr_ = { "@ITS-Container.PosConfidenceEllipse.semiMinorConfidence", &PosConfidenceEllipse_semiMinorConfidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& HeadingValue_descr_ = INTEGER_descr_;
static const ASN_Tag_t PosConfidenceEllipse_semiMajorOrientation_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t PosConfidenceEllipse_semiMajorOrientation_ber_ = { 1u, PosConfidenceEllipse_semiMajorOrientation_tag_ };
// No XER for PosConfidenceEllipse_semiMajorOrientation
const TTCN_Typedescriptor_t PosConfidenceEllipse_semiMajorOrientation_descr_ = { "@ITS-Container.PosConfidenceEllipse.semiMajorOrientation", &PosConfidenceEllipse_semiMajorOrientation_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for PosConfidenceEllipse
const TTCN_JSONdescriptor_t PosConfidenceEllipse_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PosConfidenceEllipse_descr_ = { "@ITS-Container.PosConfidenceEllipse", &SEQUENCE_ber_, NULL, NULL, NULL, &PosConfidenceEllipse_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ReferencePosition_positionConfidenceEllipse_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t ReferencePosition_positionConfidenceEllipse_ber_ = { 1u, ReferencePosition_positionConfidenceEllipse_tag_ };
// No XER for ReferencePosition_positionConfidenceEllipse
const TTCN_Typedescriptor_t ReferencePosition_positionConfidenceEllipse_descr_ = { "@ITS-Container.ReferencePosition.positionConfidenceEllipse", &ReferencePosition_positionConfidenceEllipse_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& AltitudeValue_descr_ = INTEGER_descr_;
static const ASN_Tag_t Altitude_altitudeValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t Altitude_altitudeValue_ber_ = { 1u, Altitude_altitudeValue_tag_ };
// No XER for Altitude_altitudeValue
const TTCN_Typedescriptor_t Altitude_altitudeValue_descr_ = { "@ITS-Container.Altitude.altitudeValue", &Altitude_altitudeValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for AltitudeConfidence
const TTCN_JSONdescriptor_t AltitudeConfidence_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AltitudeConfidence_descr_ = { "@ITS-Container.AltitudeConfidence", &ENUMERATED_ber_, NULL, NULL, NULL, &AltitudeConfidence_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Altitude_altitudeConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t Altitude_altitudeConfidence_ber_ = { 1u, Altitude_altitudeConfidence_tag_ };
// No XER for Altitude_altitudeConfidence
const TTCN_Typedescriptor_t Altitude_altitudeConfidence_descr_ = { "@ITS-Container.Altitude.altitudeConfidence", &Altitude_altitudeConfidence_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Altitude
const TTCN_JSONdescriptor_t Altitude_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Altitude_descr_ = { "@ITS-Container.Altitude", &SEQUENCE_ber_, NULL, NULL, NULL, &Altitude_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ReferencePosition_altitude_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t ReferencePosition_altitude_ber_ = { 1u, ReferencePosition_altitude_tag_ };
// No XER for ReferencePosition_altitude
const TTCN_Typedescriptor_t ReferencePosition_altitude_descr_ = { "@ITS-Container.ReferencePosition.altitude", &ReferencePosition_altitude_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ReferencePosition
const TTCN_JSONdescriptor_t ReferencePosition_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ReferencePosition_descr_ = { "@ITS-Container.ReferencePosition", &SEQUENCE_ber_, NULL, NULL, NULL, &ReferencePosition_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& DeltaLatitude_descr_ = INTEGER_descr_;
static const ASN_Tag_t DeltaReferencePosition_deltaLatitude_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t DeltaReferencePosition_deltaLatitude_ber_ = { 1u, DeltaReferencePosition_deltaLatitude_tag_ };
// No XER for DeltaReferencePosition_deltaLatitude
const TTCN_Typedescriptor_t DeltaReferencePosition_deltaLatitude_descr_ = { "@ITS-Container.DeltaReferencePosition.deltaLatitude", &DeltaReferencePosition_deltaLatitude_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& DeltaLongitude_descr_ = INTEGER_descr_;
static const ASN_Tag_t DeltaReferencePosition_deltaLongitude_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t DeltaReferencePosition_deltaLongitude_ber_ = { 1u, DeltaReferencePosition_deltaLongitude_tag_ };
// No XER for DeltaReferencePosition_deltaLongitude
const TTCN_Typedescriptor_t DeltaReferencePosition_deltaLongitude_descr_ = { "@ITS-Container.DeltaReferencePosition.deltaLongitude", &DeltaReferencePosition_deltaLongitude_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& DeltaAltitude_descr_ = INTEGER_descr_;
static const ASN_Tag_t DeltaReferencePosition_deltaAltitude_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t DeltaReferencePosition_deltaAltitude_ber_ = { 1u, DeltaReferencePosition_deltaAltitude_tag_ };
// No XER for DeltaReferencePosition_deltaAltitude
const TTCN_Typedescriptor_t DeltaReferencePosition_deltaAltitude_descr_ = { "@ITS-Container.DeltaReferencePosition.deltaAltitude", &DeltaReferencePosition_deltaAltitude_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for DeltaReferencePosition
const TTCN_JSONdescriptor_t DeltaReferencePosition_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DeltaReferencePosition_descr_ = { "@ITS-Container.DeltaReferencePosition", &SEQUENCE_ber_, NULL, NULL, NULL, &DeltaReferencePosition_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t PathPoint_pathPosition_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t PathPoint_pathPosition_ber_ = { 1u, PathPoint_pathPosition_tag_ };
// No XER for PathPoint_pathPosition
const TTCN_Typedescriptor_t PathPoint_pathPosition_descr_ = { "@ITS-Container.PathPoint.pathPosition", &PathPoint_pathPosition_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for PathPoint
const TTCN_JSONdescriptor_t PathPoint_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PathPoint_descr_ = { "@ITS-Container.PathPoint", &SEQUENCE_ber_, NULL, NULL, NULL, &PathPoint_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& PathDeltaTime_descr_ = INTEGER_descr_;
static const ASN_Tag_t PathPoint_pathDeltaTime_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t PathPoint_pathDeltaTime_ber_ = { 1u, PathPoint_pathDeltaTime_tag_ };
// No XER for PathPoint_pathDeltaTime
const TTCN_Typedescriptor_t PathPoint_pathDeltaTime_descr_ = { "@ITS-Container.PathPoint.pathDeltaTime", &PathPoint_pathDeltaTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& PtActivationType_descr_ = INTEGER_descr_;
static const ASN_Tag_t PtActivation_ptActivationType_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t PtActivation_ptActivationType_ber_ = { 1u, PtActivation_ptActivationType_tag_ };
// No XER for PtActivation_ptActivationType
const TTCN_Typedescriptor_t PtActivation_ptActivationType_descr_ = { "@ITS-Container.PtActivation.ptActivationType", &PtActivation_ptActivationType_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& PtActivationData_descr_ = OCTETSTRING_descr_;
static const ASN_Tag_t PtActivation_ptActivationData_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t PtActivation_ptActivationData_ber_ = { 1u, PtActivation_ptActivationData_tag_ };
// No XER for PtActivation_ptActivationData
const TTCN_Typedescriptor_t PtActivation_ptActivationData_descr_ = { "@ITS-Container.PtActivation.ptActivationData", &PtActivation_ptActivationData_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, NULL, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for PtActivation
const TTCN_JSONdescriptor_t PtActivation_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PtActivation_descr_ = { "@ITS-Container.PtActivation", &SEQUENCE_ber_, NULL, NULL, NULL, &PtActivation_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& AccelerationControl_descr_ = BITSTRING_descr_;
const TTCN_Typedescriptor_t& CauseCodeType_descr_ = INTEGER_descr_;
static const ASN_Tag_t CauseCode_causeCode_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t CauseCode_causeCode_ber_ = { 1u, CauseCode_causeCode_tag_ };
// No XER for CauseCode_causeCode
const TTCN_Typedescriptor_t CauseCode_causeCode_descr_ = { "@ITS-Container.CauseCode.causeCode", &CauseCode_causeCode_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& SubCauseCodeType_descr_ = INTEGER_descr_;
static const ASN_Tag_t CauseCode_subCauseCode_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t CauseCode_subCauseCode_ber_ = { 1u, CauseCode_subCauseCode_tag_ };
// No XER for CauseCode_subCauseCode
const TTCN_Typedescriptor_t CauseCode_subCauseCode_descr_ = { "@ITS-Container.CauseCode.subCauseCode", &CauseCode_subCauseCode_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CauseCode
const TTCN_JSONdescriptor_t CauseCode_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CauseCode_descr_ = { "@ITS-Container.CauseCode", &SEQUENCE_ber_, NULL, NULL, NULL, &CauseCode_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& TrafficConditionSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& AccidentSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& RoadworksSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& HumanPresenceOnTheRoadSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& WrongWayDrivingSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& AdverseWeatherCondition__ExtremeWeatherConditionSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& AdverseWeatherCondition__AdhesionSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& AdverseWeatherCondition__VisibilitySubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& AdverseWeatherCondition__PrecipitationSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& SlowVehicleSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& StationaryVehicleSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& HumanProblemSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& EmergencyVehicleApproachingSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& HazardousLocation__DangerousCurveSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& HazardousLocation__SurfaceConditionSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& HazardousLocation__ObstacleOnTheRoadSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& HazardousLocation__AnimalOnTheRoadSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& CollisionRiskSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& SignalViolationSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& RescueAndRecoveryWorkInProgressSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& DangerousEndOfQueueSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& DangerousSituationSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& VehicleBreakdownSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& PostCrashSubCauseCode_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& CurvatureValue_descr_ = INTEGER_descr_;
static const ASN_Tag_t Curvature_curvatureValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t Curvature_curvatureValue_ber_ = { 1u, Curvature_curvatureValue_tag_ };
// No XER for Curvature_curvatureValue
const TTCN_Typedescriptor_t Curvature_curvatureValue_descr_ = { "@ITS-Container.Curvature.curvatureValue", &Curvature_curvatureValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CurvatureConfidence
const TTCN_JSONdescriptor_t CurvatureConfidence_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CurvatureConfidence_descr_ = { "@ITS-Container.CurvatureConfidence", &ENUMERATED_ber_, NULL, NULL, NULL, &CurvatureConfidence_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Curvature_curvatureConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t Curvature_curvatureConfidence_ber_ = { 1u, Curvature_curvatureConfidence_tag_ };
// No XER for Curvature_curvatureConfidence
const TTCN_Typedescriptor_t Curvature_curvatureConfidence_descr_ = { "@ITS-Container.Curvature.curvatureConfidence", &Curvature_curvatureConfidence_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Curvature
const TTCN_JSONdescriptor_t Curvature_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Curvature_descr_ = { "@ITS-Container.Curvature", &SEQUENCE_ber_, NULL, NULL, NULL, &Curvature_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CurvatureCalculationMode
const TTCN_JSONdescriptor_t CurvatureCalculationMode_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CurvatureCalculationMode_descr_ = { "@ITS-Container.CurvatureCalculationMode", &ENUMERATED_ber_, NULL, NULL, NULL, &CurvatureCalculationMode_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Heading_headingValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t Heading_headingValue_ber_ = { 1u, Heading_headingValue_tag_ };
// No XER for Heading_headingValue
const TTCN_Typedescriptor_t Heading_headingValue_descr_ = { "@ITS-Container.Heading.headingValue", &Heading_headingValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& HeadingConfidence_descr_ = INTEGER_descr_;
static const ASN_Tag_t Heading_headingConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t Heading_headingConfidence_ber_ = { 1u, Heading_headingConfidence_tag_ };
// No XER for Heading_headingConfidence
const TTCN_Typedescriptor_t Heading_headingConfidence_descr_ = { "@ITS-Container.Heading.headingConfidence", &Heading_headingConfidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Heading
const TTCN_JSONdescriptor_t Heading_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Heading_descr_ = { "@ITS-Container.Heading", &SEQUENCE_ber_, NULL, NULL, NULL, &Heading_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LanePosition_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& DrivingLaneStatus_descr_ = BITSTRING_descr_;
static const ASN_Tag_t ClosedLanes_drivingLaneStatus_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ClosedLanes_drivingLaneStatus_ber_ = { 1u, ClosedLanes_drivingLaneStatus_tag_ };
// No XER for ClosedLanes_drivingLaneStatus
const TTCN_Typedescriptor_t ClosedLanes_drivingLaneStatus_descr_ = { "@ITS-Container.ClosedLanes.drivingLaneStatus", &ClosedLanes_drivingLaneStatus_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ClosedLanes
const TTCN_JSONdescriptor_t ClosedLanes_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ClosedLanes_descr_ = { "@ITS-Container.ClosedLanes", &SEQUENCE_ber_, NULL, NULL, NULL, &ClosedLanes_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for HardShoulderStatus
const TTCN_JSONdescriptor_t HardShoulderStatus_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HardShoulderStatus_descr_ = { "@ITS-Container.HardShoulderStatus", &ENUMERATED_ber_, NULL, NULL, NULL, &HardShoulderStatus_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ClosedLanes_hardShoulderStatus_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ClosedLanes_hardShoulderStatus_ber_ = { 1u, ClosedLanes_hardShoulderStatus_tag_ };
// No XER for ClosedLanes_hardShoulderStatus
const TTCN_Typedescriptor_t ClosedLanes_hardShoulderStatus_descr_ = { "@ITS-Container.ClosedLanes.hardShoulderStatus", &ClosedLanes_hardShoulderStatus_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& PerformanceClass_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& SpeedValue_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& SpeedConfidence_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& VehicleMass_descr_ = INTEGER_descr_;
static const ASN_Tag_t Speed_speedValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t Speed_speedValue_ber_ = { 1u, Speed_speedValue_tag_ };
// No XER for Speed_speedValue
const TTCN_Typedescriptor_t Speed_speedValue_descr_ = { "@ITS-Container.Speed.speedValue", &Speed_speedValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Speed_speedConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t Speed_speedConfidence_ber_ = { 1u, Speed_speedConfidence_tag_ };
// No XER for Speed_speedConfidence
const TTCN_Typedescriptor_t Speed_speedConfidence_descr_ = { "@ITS-Container.Speed.speedConfidence", &Speed_speedConfidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Speed
const TTCN_JSONdescriptor_t Speed_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Speed_descr_ = { "@ITS-Container.Speed", &SEQUENCE_ber_, NULL, NULL, NULL, &Speed_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for DriveDirection
const TTCN_JSONdescriptor_t DriveDirection_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DriveDirection_descr_ = { "@ITS-Container.DriveDirection", &ENUMERATED_ber_, NULL, NULL, NULL, &DriveDirection_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& EmbarkationStatus_descr_ = BOOLEAN_descr_;
const TTCN_Typedescriptor_t& LongitudinalAccelerationValue_descr_ = INTEGER_descr_;
static const ASN_Tag_t LongitudinalAcceleration_longitudinalAccelerationValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t LongitudinalAcceleration_longitudinalAccelerationValue_ber_ = { 1u, LongitudinalAcceleration_longitudinalAccelerationValue_tag_ };
// No XER for LongitudinalAcceleration_longitudinalAccelerationValue
const TTCN_Typedescriptor_t LongitudinalAcceleration_longitudinalAccelerationValue_descr_ = { "@ITS-Container.LongitudinalAcceleration.longitudinalAccelerationValue", &LongitudinalAcceleration_longitudinalAccelerationValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& AccelerationConfidence_descr_ = INTEGER_descr_;
static const ASN_Tag_t LongitudinalAcceleration_longitudinalAccelerationConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t LongitudinalAcceleration_longitudinalAccelerationConfidence_ber_ = { 1u, LongitudinalAcceleration_longitudinalAccelerationConfidence_tag_ };
// No XER for LongitudinalAcceleration_longitudinalAccelerationConfidence
const TTCN_Typedescriptor_t LongitudinalAcceleration_longitudinalAccelerationConfidence_descr_ = { "@ITS-Container.LongitudinalAcceleration.longitudinalAccelerationConfidence", &LongitudinalAcceleration_longitudinalAccelerationConfidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LongitudinalAcceleration
const TTCN_JSONdescriptor_t LongitudinalAcceleration_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LongitudinalAcceleration_descr_ = { "@ITS-Container.LongitudinalAcceleration", &SEQUENCE_ber_, NULL, NULL, NULL, &LongitudinalAcceleration_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LateralAccelerationValue_descr_ = INTEGER_descr_;
static const ASN_Tag_t LateralAcceleration_lateralAccelerationValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t LateralAcceleration_lateralAccelerationValue_ber_ = { 1u, LateralAcceleration_lateralAccelerationValue_tag_ };
// No XER for LateralAcceleration_lateralAccelerationValue
const TTCN_Typedescriptor_t LateralAcceleration_lateralAccelerationValue_descr_ = { "@ITS-Container.LateralAcceleration.lateralAccelerationValue", &LateralAcceleration_lateralAccelerationValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LateralAcceleration_lateralAccelerationConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t LateralAcceleration_lateralAccelerationConfidence_ber_ = { 1u, LateralAcceleration_lateralAccelerationConfidence_tag_ };
// No XER for LateralAcceleration_lateralAccelerationConfidence
const TTCN_Typedescriptor_t LateralAcceleration_lateralAccelerationConfidence_descr_ = { "@ITS-Container.LateralAcceleration.lateralAccelerationConfidence", &LateralAcceleration_lateralAccelerationConfidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LateralAcceleration
const TTCN_JSONdescriptor_t LateralAcceleration_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LateralAcceleration_descr_ = { "@ITS-Container.LateralAcceleration", &SEQUENCE_ber_, NULL, NULL, NULL, &LateralAcceleration_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& VerticalAccelerationValue_descr_ = INTEGER_descr_;
static const ASN_Tag_t VerticalAcceleration_verticalAccelerationValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t VerticalAcceleration_verticalAccelerationValue_ber_ = { 1u, VerticalAcceleration_verticalAccelerationValue_tag_ };
// No XER for VerticalAcceleration_verticalAccelerationValue
const TTCN_Typedescriptor_t VerticalAcceleration_verticalAccelerationValue_descr_ = { "@ITS-Container.VerticalAcceleration.verticalAccelerationValue", &VerticalAcceleration_verticalAccelerationValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t VerticalAcceleration_verticalAccelerationConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t VerticalAcceleration_verticalAccelerationConfidence_ber_ = { 1u, VerticalAcceleration_verticalAccelerationConfidence_tag_ };
// No XER for VerticalAcceleration_verticalAccelerationConfidence
const TTCN_Typedescriptor_t VerticalAcceleration_verticalAccelerationConfidence_descr_ = { "@ITS-Container.VerticalAcceleration.verticalAccelerationConfidence", &VerticalAcceleration_verticalAccelerationConfidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for VerticalAcceleration
const TTCN_JSONdescriptor_t VerticalAcceleration_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t VerticalAcceleration_descr_ = { "@ITS-Container.VerticalAcceleration", &SEQUENCE_ber_, NULL, NULL, NULL, &VerticalAcceleration_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& StationType_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& ExteriorLights_descr_ = BITSTRING_descr_;
// No XER for DangerousGoodsBasic
const TTCN_JSONdescriptor_t DangerousGoodsBasic_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DangerousGoodsBasic_descr_ = { "@ITS-Container.DangerousGoodsBasic", &ENUMERATED_ber_, NULL, NULL, NULL, &DangerousGoodsBasic_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DangerousGoodsExtended_dangerousGoodsType_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t DangerousGoodsExtended_dangerousGoodsType_ber_ = { 1u, DangerousGoodsExtended_dangerousGoodsType_tag_ };
// No XER for DangerousGoodsExtended_dangerousGoodsType
const TTCN_Typedescriptor_t DangerousGoodsExtended_dangerousGoodsType_descr_ = { "@ITS-Container.DangerousGoodsExtended.dangerousGoodsType", &DangerousGoodsExtended_dangerousGoodsType_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DangerousGoodsExtended_unNumber_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t DangerousGoodsExtended_unNumber_ber_ = { 1u, DangerousGoodsExtended_unNumber_tag_ };
// No XER for DangerousGoodsExtended_unNumber
const TTCN_Typedescriptor_t DangerousGoodsExtended_unNumber_descr_ = { "@ITS-Container.DangerousGoodsExtended.unNumber", &DangerousGoodsExtended_unNumber_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DangerousGoodsExtended_elevatedTemperature_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t DangerousGoodsExtended_elevatedTemperature_ber_ = { 1u, DangerousGoodsExtended_elevatedTemperature_tag_ };
// No XER for DangerousGoodsExtended_elevatedTemperature
const TTCN_Typedescriptor_t DangerousGoodsExtended_elevatedTemperature_descr_ = { "@ITS-Container.DangerousGoodsExtended.elevatedTemperature", &DangerousGoodsExtended_elevatedTemperature_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, NULL, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DangerousGoodsExtended_tunnelsRestricted_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t DangerousGoodsExtended_tunnelsRestricted_ber_ = { 1u, DangerousGoodsExtended_tunnelsRestricted_tag_ };
// No XER for DangerousGoodsExtended_tunnelsRestricted
const TTCN_Typedescriptor_t DangerousGoodsExtended_tunnelsRestricted_descr_ = { "@ITS-Container.DangerousGoodsExtended.tunnelsRestricted", &DangerousGoodsExtended_tunnelsRestricted_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, NULL, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DangerousGoodsExtended_limitedQuantity_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t DangerousGoodsExtended_limitedQuantity_ber_ = { 1u, DangerousGoodsExtended_limitedQuantity_tag_ };
// No XER for DangerousGoodsExtended_limitedQuantity
const TTCN_Typedescriptor_t DangerousGoodsExtended_limitedQuantity_descr_ = { "@ITS-Container.DangerousGoodsExtended.limitedQuantity", &DangerousGoodsExtended_limitedQuantity_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, NULL, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for DangerousGoodsExtended
const TTCN_JSONdescriptor_t DangerousGoodsExtended_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DangerousGoodsExtended_descr_ = { "@ITS-Container.DangerousGoodsExtended", &SEQUENCE_ber_, NULL, NULL, NULL, &DangerousGoodsExtended_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DangerousGoodsExtended_emergencyActionCode_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t DangerousGoodsExtended_emergencyActionCode_ber_ = { 1u, DangerousGoodsExtended_emergencyActionCode_tag_ };
// No XER for DangerousGoodsExtended_emergencyActionCode
const TTCN_Typedescriptor_t DangerousGoodsExtended_emergencyActionCode_descr_ = { "@ITS-Container.DangerousGoodsExtended.emergencyActionCode", &DangerousGoodsExtended_emergencyActionCode_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DangerousGoodsExtended_phoneNumber_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t DangerousGoodsExtended_phoneNumber_ber_ = { 1u, DangerousGoodsExtended_phoneNumber_tag_ };
// No XER for DangerousGoodsExtended_phoneNumber
const TTCN_Typedescriptor_t DangerousGoodsExtended_phoneNumber_descr_ = { "@ITS-Container.DangerousGoodsExtended.phoneNumber", &DangerousGoodsExtended_phoneNumber_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DangerousGoodsExtended_companyName_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t DangerousGoodsExtended_companyName_ber_ = { 1u, DangerousGoodsExtended_companyName_tag_ };
// No XER for DangerousGoodsExtended_companyName
const TTCN_Typedescriptor_t DangerousGoodsExtended_companyName_descr_ = { "@ITS-Container.DangerousGoodsExtended.companyName", &DangerousGoodsExtended_companyName_ber_, NULL, NULL, NULL, &UTF8String_json_, NULL, TTCN_Typedescriptor_t::UTF8STRING };
const TTCN_Typedescriptor_t& SpecialTransportType_descr_ = BITSTRING_descr_;
const TTCN_Typedescriptor_t& LightBarSirenInUse_descr_ = BITSTRING_descr_;
const TTCN_Typedescriptor_t& HeightLonCarr_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& PosLonCarr_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& PosPillar_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& PosCentMass_descr_ = INTEGER_descr_;
// No XER for RequestResponseIndication
const TTCN_JSONdescriptor_t RequestResponseIndication_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RequestResponseIndication_descr_ = { "@ITS-Container.RequestResponseIndication", &ENUMERATED_ber_, NULL, NULL, NULL, &RequestResponseIndication_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& SpeedLimit_descr_ = INTEGER_descr_;
// No XER for StationarySince
const TTCN_JSONdescriptor_t StationarySince_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t StationarySince_descr_ = { "@ITS-Container.StationarySince", &ENUMERATED_ber_, NULL, NULL, NULL, &StationarySince_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& Temperature_descr_ = INTEGER_descr_;
// No XER for TrafficRule
const TTCN_JSONdescriptor_t TrafficRule_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TrafficRule_descr_ = { "@ITS-Container.TrafficRule", &ENUMERATED_ber_, NULL, NULL, NULL, &TrafficRule_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& WheelBaseVehicle_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& TurningRadius_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& PosFrontAx_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& PositionOfOccupants_descr_ = BITSTRING_descr_;
// No XER for PositioningSolutionType
const TTCN_JSONdescriptor_t PositioningSolutionType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PositioningSolutionType_descr_ = { "@ITS-Container.PositioningSolutionType", &ENUMERATED_ber_, NULL, NULL, NULL, &PositioningSolutionType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for VehicleIdentification
const TTCN_JSONdescriptor_t VehicleIdentification_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t VehicleIdentification_descr_ = { "@ITS-Container.VehicleIdentification", &SEQUENCE_ber_, NULL, NULL, NULL, &VehicleIdentification_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& WMInumber_descr_ = IA5String_descr_;
static const ASN_Tag_t VehicleIdentification_wMInumber_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t VehicleIdentification_wMInumber_ber_ = { 1u, VehicleIdentification_wMInumber_tag_ };
// No XER for VehicleIdentification_wMInumber
const TTCN_Typedescriptor_t VehicleIdentification_wMInumber_descr_ = { "@ITS-Container.VehicleIdentification.wMInumber", &VehicleIdentification_wMInumber_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& VDS_descr_ = IA5String_descr_;
static const ASN_Tag_t VehicleIdentification_vDS_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t VehicleIdentification_vDS_ber_ = { 1u, VehicleIdentification_vDS_tag_ };
// No XER for VehicleIdentification_vDS
const TTCN_Typedescriptor_t VehicleIdentification_vDS_descr_ = { "@ITS-Container.VehicleIdentification.vDS", &VehicleIdentification_vDS_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& EnergyStorageType_descr_ = BITSTRING_descr_;
const TTCN_Typedescriptor_t& VehicleLengthValue_descr_ = INTEGER_descr_;
static const ASN_Tag_t VehicleLength_vehicleLengthValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t VehicleLength_vehicleLengthValue_ber_ = { 1u, VehicleLength_vehicleLengthValue_tag_ };
// No XER for VehicleLength_vehicleLengthValue
const TTCN_Typedescriptor_t VehicleLength_vehicleLengthValue_descr_ = { "@ITS-Container.VehicleLength.vehicleLengthValue", &VehicleLength_vehicleLengthValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for VehicleLengthConfidenceIndication
const TTCN_JSONdescriptor_t VehicleLengthConfidenceIndication_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t VehicleLengthConfidenceIndication_descr_ = { "@ITS-Container.VehicleLengthConfidenceIndication", &ENUMERATED_ber_, NULL, NULL, NULL, &VehicleLengthConfidenceIndication_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t VehicleLength_vehicleLengthConfidenceIndication_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t VehicleLength_vehicleLengthConfidenceIndication_ber_ = { 1u, VehicleLength_vehicleLengthConfidenceIndication_tag_ };
// No XER for VehicleLength_vehicleLengthConfidenceIndication
const TTCN_Typedescriptor_t VehicleLength_vehicleLengthConfidenceIndication_descr_ = { "@ITS-Container.VehicleLength.vehicleLengthConfidenceIndication", &VehicleLength_vehicleLengthConfidenceIndication_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for VehicleLength
const TTCN_JSONdescriptor_t VehicleLength_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t VehicleLength_descr_ = { "@ITS-Container.VehicleLength", &SEQUENCE_ber_, NULL, NULL, NULL, &VehicleLength_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& VehicleWidth_descr_ = INTEGER_descr_;
// No XER for PathHistory
const TTCN_JSONdescriptor_t PathHistory_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PathHistory_descr_ = { "@ITS-Container.PathHistory", &SEQUENCE_ber_, NULL, NULL, NULL, &PathHistory_json_, &PathPoint_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& EmergencyPriority_descr_ = BITSTRING_descr_;
const TTCN_Typedescriptor_t& InformationQuality_descr_ = INTEGER_descr_;
// No XER for RoadType
const TTCN_JSONdescriptor_t RoadType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RoadType_descr_ = { "@ITS-Container.RoadType", &ENUMERATED_ber_, NULL, NULL, NULL, &RoadType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& SteeringWheelAngleValue_descr_ = INTEGER_descr_;
static const ASN_Tag_t SteeringWheelAngle_steeringWheelAngleValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t SteeringWheelAngle_steeringWheelAngleValue_ber_ = { 1u, SteeringWheelAngle_steeringWheelAngleValue_tag_ };
// No XER for SteeringWheelAngle_steeringWheelAngleValue
const TTCN_Typedescriptor_t SteeringWheelAngle_steeringWheelAngleValue_descr_ = { "@ITS-Container.SteeringWheelAngle.steeringWheelAngleValue", &SteeringWheelAngle_steeringWheelAngleValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& SteeringWheelAngleConfidence_descr_ = INTEGER_descr_;
static const ASN_Tag_t SteeringWheelAngle_steeringWheelAngleConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t SteeringWheelAngle_steeringWheelAngleConfidence_ber_ = { 1u, SteeringWheelAngle_steeringWheelAngleConfidence_tag_ };
// No XER for SteeringWheelAngle_steeringWheelAngleConfidence
const TTCN_Typedescriptor_t SteeringWheelAngle_steeringWheelAngleConfidence_descr_ = { "@ITS-Container.SteeringWheelAngle.steeringWheelAngleConfidence", &SteeringWheelAngle_steeringWheelAngleConfidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SteeringWheelAngle
const TTCN_JSONdescriptor_t SteeringWheelAngle_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SteeringWheelAngle_descr_ = { "@ITS-Container.SteeringWheelAngle", &SEQUENCE_ber_, NULL, NULL, NULL, &SteeringWheelAngle_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& TimestampIts_descr_ = INTEGER_descr_;
// No XER for VehicleRole
const TTCN_JSONdescriptor_t VehicleRole_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t VehicleRole_descr_ = { "@ITS-Container.VehicleRole", &ENUMERATED_ber_, NULL, NULL, NULL, &VehicleRole_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& YawRateValue_descr_ = INTEGER_descr_;
static const ASN_Tag_t YawRate_yawRateValue_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t YawRate_yawRateValue_ber_ = { 1u, YawRate_yawRateValue_tag_ };
// No XER for YawRate_yawRateValue
const TTCN_Typedescriptor_t YawRate_yawRateValue_descr_ = { "@ITS-Container.YawRate.yawRateValue", &YawRate_yawRateValue_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for YawRateConfidence
const TTCN_JSONdescriptor_t YawRateConfidence_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t YawRateConfidence_descr_ = { "@ITS-Container.YawRateConfidence", &ENUMERATED_ber_, NULL, NULL, NULL, &YawRateConfidence_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t YawRate_yawRateConfidence_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t YawRate_yawRateConfidence_ber_ = { 1u, YawRate_yawRateConfidence_tag_ };
// No XER for YawRate_yawRateConfidence
const TTCN_Typedescriptor_t YawRate_yawRateConfidence_descr_ = { "@ITS-Container.YawRate.yawRateConfidence", &YawRate_yawRateConfidence_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for YawRate
const TTCN_JSONdescriptor_t YawRate_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t YawRate_descr_ = { "@ITS-Container.YawRate", &SEQUENCE_ber_, NULL, NULL, NULL, &YawRate_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ProtectedZoneType
const TTCN_JSONdescriptor_t ProtectedZoneType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ProtectedZoneType_descr_ = { "@ITS-Container.ProtectedZoneType", &ENUMERATED_ber_, NULL, NULL, NULL, &ProtectedZoneType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RelevanceDistance
const TTCN_JSONdescriptor_t RelevanceDistance_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RelevanceDistance_descr_ = { "@ITS-Container.RelevanceDistance", &ENUMERATED_ber_, NULL, NULL, NULL, &RelevanceDistance_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RelevanceTrafficDirection
const TTCN_JSONdescriptor_t RelevanceTrafficDirection_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RelevanceTrafficDirection_descr_ = { "@ITS-Container.RelevanceTrafficDirection", &ENUMERATED_ber_, NULL, NULL, NULL, &RelevanceTrafficDirection_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& TransmissionInterval_descr_ = INTEGER_descr_;
const TTCN_Typedescriptor_t& ValidityDuration_descr_ = INTEGER_descr_;
static const ASN_Tag_t ActionID_originatingStationID_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ActionID_originatingStationID_ber_ = { 1u, ActionID_originatingStationID_tag_ };
// No XER for ActionID_originatingStationID
const TTCN_Typedescriptor_t ActionID_originatingStationID_descr_ = { "@ITS-Container.ActionID.originatingStationID", &ActionID_originatingStationID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& SequenceNumber_descr_ = INTEGER_descr_;
static const ASN_Tag_t ActionID_sequenceNumber_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ActionID_sequenceNumber_ber_ = { 1u, ActionID_sequenceNumber_tag_ };
// No XER for ActionID_sequenceNumber
const TTCN_Typedescriptor_t ActionID_sequenceNumber_descr_ = { "@ITS-Container.ActionID.sequenceNumber", &ActionID_sequenceNumber_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ActionID
const TTCN_JSONdescriptor_t ActionID_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ActionID_descr_ = { "@ITS-Container.ActionID", &SEQUENCE_ber_, NULL, NULL, NULL, &ActionID_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ItineraryPath
const TTCN_JSONdescriptor_t ItineraryPath_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ItineraryPath_descr_ = { "@ITS-Container.ItineraryPath", &SEQUENCE_ber_, NULL, NULL, NULL, &ItineraryPath_json_, &ReferencePosition_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ProtectedCommunicationZone_protectedZoneType_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneType_ber_ = { 1u, ProtectedCommunicationZone_protectedZoneType_tag_ };
// No XER for ProtectedCommunicationZone_protectedZoneType
const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneType_descr_ = { "@ITS-Container.ProtectedCommunicationZone.protectedZoneType", &ProtectedCommunicationZone_protectedZoneType_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ProtectedCommunicationZone_protectedZoneLatitude_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneLatitude_ber_ = { 1u, ProtectedCommunicationZone_protectedZoneLatitude_tag_ };
// No XER for ProtectedCommunicationZone_protectedZoneLatitude
const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneLatitude_descr_ = { "@ITS-Container.ProtectedCommunicationZone.protectedZoneLatitude", &ProtectedCommunicationZone_protectedZoneLatitude_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ProtectedCommunicationZone_protectedZoneLongitude_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneLongitude_ber_ = { 1u, ProtectedCommunicationZone_protectedZoneLongitude_tag_ };
// No XER for ProtectedCommunicationZone_protectedZoneLongitude
const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneLongitude_descr_ = { "@ITS-Container.ProtectedCommunicationZone.protectedZoneLongitude", &ProtectedCommunicationZone_protectedZoneLongitude_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ProtectedCommunicationZone
const TTCN_JSONdescriptor_t ProtectedCommunicationZone_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ProtectedCommunicationZone_descr_ = { "@ITS-Container.ProtectedCommunicationZone", &SEQUENCE_ber_, NULL, NULL, NULL, &ProtectedCommunicationZone_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ProtectedCommunicationZone_expiryTime_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ProtectedCommunicationZone_expiryTime_ber_ = { 1u, ProtectedCommunicationZone_expiryTime_tag_ };
// No XER for ProtectedCommunicationZone_expiryTime
const TTCN_Typedescriptor_t ProtectedCommunicationZone_expiryTime_descr_ = { "@ITS-Container.ProtectedCommunicationZone.expiryTime", &ProtectedCommunicationZone_expiryTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& ProtectedZoneRadius_descr_ = INTEGER_descr_;
static const ASN_Tag_t ProtectedCommunicationZone_protectedZoneRadius_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneRadius_ber_ = { 1u, ProtectedCommunicationZone_protectedZoneRadius_tag_ };
// No XER for ProtectedCommunicationZone_protectedZoneRadius
const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneRadius_descr_ = { "@ITS-Container.ProtectedCommunicationZone.protectedZoneRadius", &ProtectedCommunicationZone_protectedZoneRadius_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& ProtectedZoneID_descr_ = INTEGER_descr_;
static const ASN_Tag_t ProtectedCommunicationZone_protectedZoneID_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneID_ber_ = { 1u, ProtectedCommunicationZone_protectedZoneID_tag_ };
// No XER for ProtectedCommunicationZone_protectedZoneID
const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneID_descr_ = { "@ITS-Container.ProtectedCommunicationZone.protectedZoneID", &ProtectedCommunicationZone_protectedZoneID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Traces
const TTCN_JSONdescriptor_t Traces_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Traces_descr_ = { "@ITS-Container.Traces", &SEQUENCE_ber_, NULL, NULL, NULL, &Traces_json_, &PathHistory_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& NumberOfOccupants_descr_ = INTEGER_descr_;
// No XER for PositionOfPillars
const TTCN_JSONdescriptor_t PositionOfPillars_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PositionOfPillars_descr_ = { "@ITS-Container.PositionOfPillars", &SEQUENCE_ber_, NULL, NULL, NULL, &PositionOfPillars_json_, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RestrictedTypes
const TTCN_JSONdescriptor_t RestrictedTypes_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RestrictedTypes_descr_ = { "@ITS-Container.RestrictedTypes", &SEQUENCE_ber_, NULL, NULL, NULL, &RestrictedTypes_json_, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for EventHistory
const TTCN_JSONdescriptor_t EventHistory_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EventHistory_descr_ = { "@ITS-Container.EventHistory", &SEQUENCE_ber_, NULL, NULL, NULL, &EventHistory_json_, &EventPoint_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t EventPoint_eventPosition_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t EventPoint_eventPosition_ber_ = { 1u, EventPoint_eventPosition_tag_ };
// No XER for EventPoint_eventPosition
const TTCN_Typedescriptor_t EventPoint_eventPosition_descr_ = { "@ITS-Container.EventPoint.eventPosition", &EventPoint_eventPosition_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t EventPoint_informationQuality_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t EventPoint_informationQuality_ber_ = { 1u, EventPoint_informationQuality_tag_ };
// No XER for EventPoint_informationQuality
const TTCN_Typedescriptor_t EventPoint_informationQuality_descr_ = { "@ITS-Container.EventPoint.informationQuality", &EventPoint_informationQuality_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for EventPoint
const TTCN_JSONdescriptor_t EventPoint_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EventPoint_descr_ = { "@ITS-Container.EventPoint", &SEQUENCE_ber_, NULL, NULL, NULL, &EventPoint_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t EventPoint_eventDeltaTime_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t EventPoint_eventDeltaTime_ber_ = { 1u, EventPoint_eventDeltaTime_tag_ };
// No XER for EventPoint_eventDeltaTime
const TTCN_Typedescriptor_t EventPoint_eventDeltaTime_descr_ = { "@ITS-Container.EventPoint.eventDeltaTime", &EventPoint_eventDeltaTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ProtectedCommunicationZonesRSU
const TTCN_JSONdescriptor_t ProtectedCommunicationZonesRSU_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ProtectedCommunicationZonesRSU_descr_ = { "@ITS-Container.ProtectedCommunicationZonesRSU", &SEQUENCE_ber_, NULL, NULL, NULL, &ProtectedCommunicationZonesRSU_json_, &ProtectedCommunicationZone_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t CenDsrcTollingZone_protectedZoneLatitude_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t CenDsrcTollingZone_protectedZoneLatitude_ber_ = { 1u, CenDsrcTollingZone_protectedZoneLatitude_tag_ };
// No XER for CenDsrcTollingZone_protectedZoneLatitude
const TTCN_Typedescriptor_t CenDsrcTollingZone_protectedZoneLatitude_descr_ = { "@ITS-Container.CenDsrcTollingZone.protectedZoneLatitude", &CenDsrcTollingZone_protectedZoneLatitude_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t CenDsrcTollingZone_protectedZoneLongitude_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t CenDsrcTollingZone_protectedZoneLongitude_ber_ = { 1u, CenDsrcTollingZone_protectedZoneLongitude_tag_ };
// No XER for CenDsrcTollingZone_protectedZoneLongitude
const TTCN_Typedescriptor_t CenDsrcTollingZone_protectedZoneLongitude_descr_ = { "@ITS-Container.CenDsrcTollingZone.protectedZoneLongitude", &CenDsrcTollingZone_protectedZoneLongitude_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CenDsrcTollingZone
const TTCN_JSONdescriptor_t CenDsrcTollingZone_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CenDsrcTollingZone_descr_ = { "@ITS-Container.CenDsrcTollingZone", &SEQUENCE_ber_, NULL, NULL, NULL, &CenDsrcTollingZone_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& CenDsrcTollingZoneID_descr_ = INTEGER_descr_;
static const ASN_Tag_t CenDsrcTollingZone_cenDsrcTollingZoneID_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t CenDsrcTollingZone_cenDsrcTollingZoneID_ber_ = { 1u, CenDsrcTollingZone_cenDsrcTollingZoneID_tag_ };
// No XER for CenDsrcTollingZone_cenDsrcTollingZoneID
const TTCN_Typedescriptor_t CenDsrcTollingZone_cenDsrcTollingZoneID_descr_ = { "@ITS-Container.CenDsrcTollingZone.cenDsrcTollingZoneID", &CenDsrcTollingZone_cenDsrcTollingZoneID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
TTCN_Module module_object("ITS-Container", __DATE__, __TIME__, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

ItsPduHeader::ItsPduHeader()
{
  bound_flag = FALSE;
}

ItsPduHeader::ItsPduHeader(const INTEGER& par_protocolVersion,
    const INTEGER& par_messageID,
    const INTEGER& par_stationID)
  :   field_protocolVersion(par_protocolVersion),
  field_messageID(par_messageID),
  field_stationID(par_stationID)
{
  bound_flag = TRUE;
}

ItsPduHeader::ItsPduHeader(const ItsPduHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.ItsPduHeader.");
bound_flag = TRUE;
if (other_value.protocolVersion().is_bound()) field_protocolVersion = other_value.protocolVersion();
else field_protocolVersion.clean_up();
if (other_value.messageID().is_bound()) field_messageID = other_value.messageID();
else field_messageID.clean_up();
if (other_value.stationID().is_bound()) field_stationID = other_value.stationID();
else field_stationID.clean_up();
}

void ItsPduHeader::clean_up()
{
field_protocolVersion.clean_up();
field_messageID.clean_up();
field_stationID.clean_up();
bound_flag = FALSE;
}

ItsPduHeader& ItsPduHeader::operator=(const ItsPduHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.ItsPduHeader.");
  bound_flag = TRUE;
  if (other_value.protocolVersion().is_bound()) field_protocolVersion = other_value.protocolVersion();
  else field_protocolVersion.clean_up();
  if (other_value.messageID().is_bound()) field_messageID = other_value.messageID();
  else field_messageID.clean_up();
  if (other_value.stationID().is_bound()) field_stationID = other_value.stationID();
  else field_stationID.clean_up();
}
return *this;
}

boolean ItsPduHeader::operator==(const ItsPduHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_protocolVersion==other_value.field_protocolVersion
  && field_messageID==other_value.field_messageID
  && field_stationID==other_value.field_stationID;
}

boolean ItsPduHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_protocolVersion.is_bound()) return TRUE;
if(field_messageID.is_bound()) return TRUE;
if(field_stationID.is_bound()) return TRUE;
return FALSE;
}
boolean ItsPduHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_protocolVersion.is_value()) return FALSE;
if(!field_messageID.is_value()) return FALSE;
if(!field_stationID.is_value()) return FALSE;
return TRUE;
}
int ItsPduHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.ItsPduHeader");
  return 3;
}

void ItsPduHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ protocolVersion := ");
field_protocolVersion.log();
TTCN_Logger::log_event_str(", messageID := ");
field_messageID.log();
TTCN_Logger::log_event_str(", stationID := ");
field_stationID.log();
TTCN_Logger::log_event_str(" }");
}

void ItsPduHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.ItsPduHeader'");
    }
    if (strcmp("protocolVersion", param_field) == 0) {
      protocolVersion().set_param(param);
      return;
    } else if (strcmp("messageID", param_field) == 0) {
      messageID().set_param(param);
      return;
    } else if (strcmp("stationID", param_field) == 0) {
      stationID().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.ItsPduHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @ITS-Container.ItsPduHeader has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protocolVersion().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) messageID().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) stationID().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocolVersion")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocolVersion().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "messageID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          messageID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ItsPduHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.ItsPduHeader");
  }
}

Module_Param* ItsPduHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.ItsPduHeader'");
    }
    if (strcmp("protocolVersion", param_field) == 0) {
      return protocolVersion().get_param(param_name);
    } else if (strcmp("messageID", param_field) == 0) {
      return messageID().get_param(param_name);
    } else if (strcmp("stationID", param_field) == 0) {
      return stationID().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ItsPduHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_protocolVersion = field_protocolVersion.get_param(param_name);
  mp_field_protocolVersion->set_id(new Module_Param_FieldName(mcopystr("protocolVersion")));
  mp->add_elem(mp_field_protocolVersion);
  Module_Param* mp_field_messageID = field_messageID.get_param(param_name);
  mp_field_messageID->set_id(new Module_Param_FieldName(mcopystr("messageID")));
  mp->add_elem(mp_field_messageID);
  Module_Param* mp_field_stationID = field_stationID.get_param(param_name);
  mp_field_stationID->set_id(new Module_Param_FieldName(mcopystr("stationID")));
  mp->add_elem(mp_field_stationID);
  return mp;
  }

void ItsPduHeader::set_implicit_omit()
{
if (protocolVersion().is_bound()) protocolVersion().set_implicit_omit();
if (messageID().is_bound()) messageID().set_implicit_omit();
if (stationID().is_bound()) stationID().set_implicit_omit();
}

void ItsPduHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.ItsPduHeader.");
field_protocolVersion.encode_text(text_buf);
field_messageID.encode_text(text_buf);
field_stationID.encode_text(text_buf);
}

void ItsPduHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_protocolVersion.decode_text(text_buf);
field_messageID.decode_text(text_buf);
field_stationID.decode_text(text_buf);
}

void ItsPduHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ItsPduHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ItsPduHeader::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("protocolVersion': ");
  new_tlv->add_TLV(field_protocolVersion.BER_encode_TLV(ItsPduHeader_protocolVersion_descr_, p_coding));
  ec_1.set_msg("messageID': ");
  new_tlv->add_TLV(field_messageID.BER_encode_TLV(ItsPduHeader_messageID_descr_, p_coding));
  ec_1.set_msg("stationID': ");
  new_tlv->add_TLV(field_stationID.BER_encode_TLV(ItsPduHeader_stationID_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ItsPduHeader::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.ItsPduHeader' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("protocolVersion': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_protocolVersion.BER_decode_TLV(ItsPduHeader_protocolVersion_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("messageID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_messageID.BER_decode_TLV(ItsPduHeader_messageID_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("stationID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_stationID.BER_decode_TLV(ItsPduHeader_stationID_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ItsPduHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.ItsPduHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protocolVersion");
    enc_len += field_protocolVersion.JSON_encode(ItsPduHeader_protocolVersion_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "messageID");
    enc_len += field_messageID.JSON_encode(ItsPduHeader_messageID_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stationID");
    enc_len += field_stationID.JSON_encode(ItsPduHeader_stationID_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ItsPduHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (15 == name_len && 0 == strncmp(fld_name, "protocolVersion", name_len)) {
         int ret_val = field_protocolVersion.JSON_decode(ItsPduHeader_protocolVersion_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protocolVersion");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "messageID", name_len)) {
         int ret_val = field_messageID.JSON_decode(ItsPduHeader_messageID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "messageID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "stationID", name_len)) {
         int ret_val = field_stationID.JSON_decode(ItsPduHeader_stationID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stationID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_protocolVersion.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protocolVersion");
    return JSON_ERROR_FATAL;
  }
if (!field_messageID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "messageID");
    return JSON_ERROR_FATAL;
  }
if (!field_stationID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "stationID");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ItsPduHeader_template::single_value_struct {
INTEGER_template field_protocolVersion;
INTEGER_template field_messageID;
INTEGER_template field_stationID;
};

void ItsPduHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_protocolVersion = ANY_VALUE;
single_value->field_messageID = ANY_VALUE;
single_value->field_stationID = ANY_VALUE;
}
}
}

void ItsPduHeader_template::copy_value(const ItsPduHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.protocolVersion().is_bound()) {
  single_value->field_protocolVersion = other_value.protocolVersion();
} else {
  single_value->field_protocolVersion.clean_up();
}
if (other_value.messageID().is_bound()) {
  single_value->field_messageID = other_value.messageID();
} else {
  single_value->field_messageID.clean_up();
}
if (other_value.stationID().is_bound()) {
  single_value->field_stationID = other_value.stationID();
} else {
  single_value->field_stationID.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ItsPduHeader_template::copy_template(const ItsPduHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.protocolVersion().get_selection()) {
single_value->field_protocolVersion = other_value.protocolVersion();
} else {
single_value->field_protocolVersion.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.messageID().get_selection()) {
single_value->field_messageID = other_value.messageID();
} else {
single_value->field_messageID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stationID().get_selection()) {
single_value->field_stationID = other_value.stationID();
} else {
single_value->field_stationID.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ItsPduHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.ItsPduHeader.");
break;
}
set_selection(other_value);
}

ItsPduHeader_template::ItsPduHeader_template()
{
}

ItsPduHeader_template::ItsPduHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ItsPduHeader_template::ItsPduHeader_template(const ItsPduHeader& other_value)
{
copy_value(other_value);
}

ItsPduHeader_template::ItsPduHeader_template(const OPTIONAL<ItsPduHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ItsPduHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.ItsPduHeader from an unbound optional field.");
}
}

ItsPduHeader_template::ItsPduHeader_template(const ItsPduHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ItsPduHeader_template::~ItsPduHeader_template()
{
clean_up();
}

ItsPduHeader_template& ItsPduHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ItsPduHeader_template& ItsPduHeader_template::operator=(const ItsPduHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ItsPduHeader_template& ItsPduHeader_template::operator=(const OPTIONAL<ItsPduHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ItsPduHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.ItsPduHeader.");
}
return *this;
}

ItsPduHeader_template& ItsPduHeader_template::operator=(const ItsPduHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ItsPduHeader_template::match(const ItsPduHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.protocolVersion().is_bound()) return FALSE;
if(!single_value->field_protocolVersion.match(other_value.protocolVersion(), legacy))return FALSE;
if(!other_value.messageID().is_bound()) return FALSE;
if(!single_value->field_messageID.match(other_value.messageID(), legacy))return FALSE;
if(!other_value.stationID().is_bound()) return FALSE;
if(!single_value->field_stationID.match(other_value.stationID(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.ItsPduHeader.");
}
return FALSE;
}

boolean ItsPduHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_protocolVersion.is_bound()) return TRUE;
if (single_value->field_messageID.is_bound()) return TRUE;
if (single_value->field_stationID.is_bound()) return TRUE;
return FALSE;
}

boolean ItsPduHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_protocolVersion.is_value()) return FALSE;
if (!single_value->field_messageID.is_value()) return FALSE;
if (!single_value->field_stationID.is_value()) return FALSE;
return TRUE;
}

void ItsPduHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ItsPduHeader ItsPduHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.ItsPduHeader.");
ItsPduHeader ret_val;
if (single_value->field_protocolVersion.is_bound()) {
ret_val.protocolVersion() = single_value->field_protocolVersion.valueof();
}
if (single_value->field_messageID.is_bound()) {
ret_val.messageID() = single_value->field_messageID.valueof();
}
if (single_value->field_stationID.is_bound()) {
ret_val.stationID() = single_value->field_stationID.valueof();
}
return ret_val;
}

void ItsPduHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.ItsPduHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ItsPduHeader_template[list_length];
}

ItsPduHeader_template& ItsPduHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.ItsPduHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.ItsPduHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& ItsPduHeader_template::protocolVersion()
{
set_specific();
return single_value->field_protocolVersion;
}

const INTEGER_template& ItsPduHeader_template::protocolVersion() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protocolVersion of a non-specific template of type @ITS-Container.ItsPduHeader.");
return single_value->field_protocolVersion;
}

INTEGER_template& ItsPduHeader_template::messageID()
{
set_specific();
return single_value->field_messageID;
}

const INTEGER_template& ItsPduHeader_template::messageID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field messageID of a non-specific template of type @ITS-Container.ItsPduHeader.");
return single_value->field_messageID;
}

INTEGER_template& ItsPduHeader_template::stationID()
{
set_specific();
return single_value->field_stationID;
}

const INTEGER_template& ItsPduHeader_template::stationID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stationID of a non-specific template of type @ITS-Container.ItsPduHeader.");
return single_value->field_stationID;
}

int ItsPduHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ItsPduHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.ItsPduHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ItsPduHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ItsPduHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ItsPduHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ItsPduHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.ItsPduHeader.");
  }
  return 0;
}

void ItsPduHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ protocolVersion := ");
single_value->field_protocolVersion.log();
TTCN_Logger::log_event_str(", messageID := ");
single_value->field_messageID.log();
TTCN_Logger::log_event_str(", stationID := ");
single_value->field_stationID.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ItsPduHeader_template::log_match(const ItsPduHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_protocolVersion.match(match_value.protocolVersion(), legacy)){
TTCN_Logger::log_logmatch_info(".protocolVersion");
single_value->field_protocolVersion.log_match(match_value.protocolVersion(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_messageID.match(match_value.messageID(), legacy)){
TTCN_Logger::log_logmatch_info(".messageID");
single_value->field_messageID.log_match(match_value.messageID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stationID.match(match_value.stationID(), legacy)){
TTCN_Logger::log_logmatch_info(".stationID");
single_value->field_stationID.log_match(match_value.stationID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ protocolVersion := ");
single_value->field_protocolVersion.log_match(match_value.protocolVersion(), legacy);
TTCN_Logger::log_event_str(", messageID := ");
single_value->field_messageID.log_match(match_value.messageID(), legacy);
TTCN_Logger::log_event_str(", stationID := ");
single_value->field_stationID.log_match(match_value.stationID(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ItsPduHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_protocolVersion.encode_text(text_buf);
single_value->field_messageID.encode_text(text_buf);
single_value->field_stationID.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.ItsPduHeader.");
}
}

void ItsPduHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_protocolVersion.decode_text(text_buf);
single_value->field_messageID.decode_text(text_buf);
single_value->field_stationID.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ItsPduHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.ItsPduHeader.");
}
}

void ItsPduHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.ItsPduHeader'");
    }
    if (strcmp("protocolVersion", param_field) == 0) {
      protocolVersion().set_param(param);
      return;
    } else if (strcmp("messageID", param_field) == 0) {
      messageID().set_param(param);
      return;
    } else if (strcmp("stationID", param_field) == 0) {
      stationID().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.ItsPduHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ItsPduHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @ITS-Container.ItsPduHeader has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protocolVersion().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) messageID().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) stationID().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocolVersion")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocolVersion().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "messageID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          messageID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ItsPduHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.ItsPduHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ItsPduHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.ItsPduHeader'");
    }
    if (strcmp("protocolVersion", param_field) == 0) {
      return protocolVersion().get_param(param_name);
    } else if (strcmp("messageID", param_field) == 0) {
      return messageID().get_param(param_name);
    } else if (strcmp("stationID", param_field) == 0) {
      return stationID().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ItsPduHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_protocolVersion = single_value->field_protocolVersion.get_param(param_name);
    mp_field_protocolVersion->set_id(new Module_Param_FieldName(mcopystr("protocolVersion")));
    mp->add_elem(mp_field_protocolVersion);
    Module_Param* mp_field_messageID = single_value->field_messageID.get_param(param_name);
    mp_field_messageID->set_id(new Module_Param_FieldName(mcopystr("messageID")));
    mp->add_elem(mp_field_messageID);
    Module_Param* mp_field_stationID = single_value->field_stationID.get_param(param_name);
    mp_field_stationID->set_id(new Module_Param_FieldName(mcopystr("stationID")));
    mp->add_elem(mp_field_stationID);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ItsPduHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_protocolVersion.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ItsPduHeader");
single_value->field_messageID.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ItsPduHeader");
single_value->field_stationID.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ItsPduHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.ItsPduHeader");
}

boolean ItsPduHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ItsPduHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PosConfidenceEllipse::PosConfidenceEllipse()
{
  bound_flag = FALSE;
}

PosConfidenceEllipse::PosConfidenceEllipse(const INTEGER& par_semiMajorConfidence,
    const INTEGER& par_semiMinorConfidence,
    const INTEGER& par_semiMajorOrientation)
  :   field_semiMajorConfidence(par_semiMajorConfidence),
  field_semiMinorConfidence(par_semiMinorConfidence),
  field_semiMajorOrientation(par_semiMajorOrientation)
{
  bound_flag = TRUE;
}

PosConfidenceEllipse::PosConfidenceEllipse(const PosConfidenceEllipse& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.PosConfidenceEllipse.");
bound_flag = TRUE;
if (other_value.semiMajorConfidence().is_bound()) field_semiMajorConfidence = other_value.semiMajorConfidence();
else field_semiMajorConfidence.clean_up();
if (other_value.semiMinorConfidence().is_bound()) field_semiMinorConfidence = other_value.semiMinorConfidence();
else field_semiMinorConfidence.clean_up();
if (other_value.semiMajorOrientation().is_bound()) field_semiMajorOrientation = other_value.semiMajorOrientation();
else field_semiMajorOrientation.clean_up();
}

void PosConfidenceEllipse::clean_up()
{
field_semiMajorConfidence.clean_up();
field_semiMinorConfidence.clean_up();
field_semiMajorOrientation.clean_up();
bound_flag = FALSE;
}

PosConfidenceEllipse& PosConfidenceEllipse::operator=(const PosConfidenceEllipse& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.PosConfidenceEllipse.");
  bound_flag = TRUE;
  if (other_value.semiMajorConfidence().is_bound()) field_semiMajorConfidence = other_value.semiMajorConfidence();
  else field_semiMajorConfidence.clean_up();
  if (other_value.semiMinorConfidence().is_bound()) field_semiMinorConfidence = other_value.semiMinorConfidence();
  else field_semiMinorConfidence.clean_up();
  if (other_value.semiMajorOrientation().is_bound()) field_semiMajorOrientation = other_value.semiMajorOrientation();
  else field_semiMajorOrientation.clean_up();
}
return *this;
}

boolean PosConfidenceEllipse::operator==(const PosConfidenceEllipse& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_semiMajorConfidence==other_value.field_semiMajorConfidence
  && field_semiMinorConfidence==other_value.field_semiMinorConfidence
  && field_semiMajorOrientation==other_value.field_semiMajorOrientation;
}

boolean PosConfidenceEllipse::is_bound() const
{
if (bound_flag) return TRUE;
if(field_semiMajorConfidence.is_bound()) return TRUE;
if(field_semiMinorConfidence.is_bound()) return TRUE;
if(field_semiMajorOrientation.is_bound()) return TRUE;
return FALSE;
}
boolean PosConfidenceEllipse::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_semiMajorConfidence.is_value()) return FALSE;
if(!field_semiMinorConfidence.is_value()) return FALSE;
if(!field_semiMajorOrientation.is_value()) return FALSE;
return TRUE;
}
int PosConfidenceEllipse::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.PosConfidenceEllipse");
  return 3;
}

void PosConfidenceEllipse::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ semiMajorConfidence := ");
field_semiMajorConfidence.log();
TTCN_Logger::log_event_str(", semiMinorConfidence := ");
field_semiMinorConfidence.log();
TTCN_Logger::log_event_str(", semiMajorOrientation := ");
field_semiMajorOrientation.log();
TTCN_Logger::log_event_str(" }");
}

void PosConfidenceEllipse::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.PosConfidenceEllipse'");
    }
    if (strcmp("semiMajorConfidence", param_field) == 0) {
      semiMajorConfidence().set_param(param);
      return;
    } else if (strcmp("semiMinorConfidence", param_field) == 0) {
      semiMinorConfidence().set_param(param);
      return;
    } else if (strcmp("semiMajorOrientation", param_field) == 0) {
      semiMajorOrientation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.PosConfidenceEllipse'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @ITS-Container.PosConfidenceEllipse has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) semiMajorConfidence().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) semiMinorConfidence().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) semiMajorOrientation().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "semiMajorConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          semiMajorConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "semiMinorConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          semiMinorConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "semiMajorOrientation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          semiMajorOrientation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.PosConfidenceEllipse: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.PosConfidenceEllipse");
  }
}

Module_Param* PosConfidenceEllipse::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.PosConfidenceEllipse'");
    }
    if (strcmp("semiMajorConfidence", param_field) == 0) {
      return semiMajorConfidence().get_param(param_name);
    } else if (strcmp("semiMinorConfidence", param_field) == 0) {
      return semiMinorConfidence().get_param(param_name);
    } else if (strcmp("semiMajorOrientation", param_field) == 0) {
      return semiMajorOrientation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.PosConfidenceEllipse'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_semiMajorConfidence = field_semiMajorConfidence.get_param(param_name);
  mp_field_semiMajorConfidence->set_id(new Module_Param_FieldName(mcopystr("semiMajorConfidence")));
  mp->add_elem(mp_field_semiMajorConfidence);
  Module_Param* mp_field_semiMinorConfidence = field_semiMinorConfidence.get_param(param_name);
  mp_field_semiMinorConfidence->set_id(new Module_Param_FieldName(mcopystr("semiMinorConfidence")));
  mp->add_elem(mp_field_semiMinorConfidence);
  Module_Param* mp_field_semiMajorOrientation = field_semiMajorOrientation.get_param(param_name);
  mp_field_semiMajorOrientation->set_id(new Module_Param_FieldName(mcopystr("semiMajorOrientation")));
  mp->add_elem(mp_field_semiMajorOrientation);
  return mp;
  }

void PosConfidenceEllipse::set_implicit_omit()
{
if (semiMajorConfidence().is_bound()) semiMajorConfidence().set_implicit_omit();
if (semiMinorConfidence().is_bound()) semiMinorConfidence().set_implicit_omit();
if (semiMajorOrientation().is_bound()) semiMajorOrientation().set_implicit_omit();
}

void PosConfidenceEllipse::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.PosConfidenceEllipse.");
field_semiMajorConfidence.encode_text(text_buf);
field_semiMinorConfidence.encode_text(text_buf);
field_semiMajorOrientation.encode_text(text_buf);
}

void PosConfidenceEllipse::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_semiMajorConfidence.decode_text(text_buf);
field_semiMinorConfidence.decode_text(text_buf);
field_semiMajorOrientation.decode_text(text_buf);
}

void PosConfidenceEllipse::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PosConfidenceEllipse::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* PosConfidenceEllipse::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("semiMajorConfidence': ");
  new_tlv->add_TLV(field_semiMajorConfidence.BER_encode_TLV(PosConfidenceEllipse_semiMajorConfidence_descr_, p_coding));
  ec_1.set_msg("semiMinorConfidence': ");
  new_tlv->add_TLV(field_semiMinorConfidence.BER_encode_TLV(PosConfidenceEllipse_semiMinorConfidence_descr_, p_coding));
  ec_1.set_msg("semiMajorOrientation': ");
  new_tlv->add_TLV(field_semiMajorOrientation.BER_encode_TLV(PosConfidenceEllipse_semiMajorOrientation_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean PosConfidenceEllipse::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.PosConfidenceEllipse' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("semiMajorConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_semiMajorConfidence.BER_decode_TLV(PosConfidenceEllipse_semiMajorConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("semiMinorConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_semiMinorConfidence.BER_decode_TLV(PosConfidenceEllipse_semiMinorConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("semiMajorOrientation': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_semiMajorOrientation.BER_decode_TLV(PosConfidenceEllipse_semiMajorOrientation_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int PosConfidenceEllipse::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.PosConfidenceEllipse.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "semiMajorConfidence");
    enc_len += field_semiMajorConfidence.JSON_encode(PosConfidenceEllipse_semiMajorConfidence_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "semiMinorConfidence");
    enc_len += field_semiMinorConfidence.JSON_encode(PosConfidenceEllipse_semiMinorConfidence_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "semiMajorOrientation");
    enc_len += field_semiMajorOrientation.JSON_encode(PosConfidenceEllipse_semiMajorOrientation_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int PosConfidenceEllipse::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (19 == name_len && 0 == strncmp(fld_name, "semiMajorConfidence", name_len)) {
         int ret_val = field_semiMajorConfidence.JSON_decode(PosConfidenceEllipse_semiMajorConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "semiMajorConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "semiMinorConfidence", name_len)) {
         int ret_val = field_semiMinorConfidence.JSON_decode(PosConfidenceEllipse_semiMinorConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "semiMinorConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "semiMajorOrientation", name_len)) {
         int ret_val = field_semiMajorOrientation.JSON_decode(PosConfidenceEllipse_semiMajorOrientation_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "semiMajorOrientation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_semiMajorConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "semiMajorConfidence");
    return JSON_ERROR_FATAL;
  }
if (!field_semiMinorConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "semiMinorConfidence");
    return JSON_ERROR_FATAL;
  }
if (!field_semiMajorOrientation.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "semiMajorOrientation");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct PosConfidenceEllipse_template::single_value_struct {
INTEGER_template field_semiMajorConfidence;
INTEGER_template field_semiMinorConfidence;
INTEGER_template field_semiMajorOrientation;
};

void PosConfidenceEllipse_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_semiMajorConfidence = ANY_VALUE;
single_value->field_semiMinorConfidence = ANY_VALUE;
single_value->field_semiMajorOrientation = ANY_VALUE;
}
}
}

void PosConfidenceEllipse_template::copy_value(const PosConfidenceEllipse& other_value)
{
single_value = new single_value_struct;
if (other_value.semiMajorConfidence().is_bound()) {
  single_value->field_semiMajorConfidence = other_value.semiMajorConfidence();
} else {
  single_value->field_semiMajorConfidence.clean_up();
}
if (other_value.semiMinorConfidence().is_bound()) {
  single_value->field_semiMinorConfidence = other_value.semiMinorConfidence();
} else {
  single_value->field_semiMinorConfidence.clean_up();
}
if (other_value.semiMajorOrientation().is_bound()) {
  single_value->field_semiMajorOrientation = other_value.semiMajorOrientation();
} else {
  single_value->field_semiMajorOrientation.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PosConfidenceEllipse_template::copy_template(const PosConfidenceEllipse_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.semiMajorConfidence().get_selection()) {
single_value->field_semiMajorConfidence = other_value.semiMajorConfidence();
} else {
single_value->field_semiMajorConfidence.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.semiMinorConfidence().get_selection()) {
single_value->field_semiMinorConfidence = other_value.semiMinorConfidence();
} else {
single_value->field_semiMinorConfidence.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.semiMajorOrientation().get_selection()) {
single_value->field_semiMajorOrientation = other_value.semiMajorOrientation();
} else {
single_value->field_semiMajorOrientation.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PosConfidenceEllipse_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.PosConfidenceEllipse.");
break;
}
set_selection(other_value);
}

PosConfidenceEllipse_template::PosConfidenceEllipse_template()
{
}

PosConfidenceEllipse_template::PosConfidenceEllipse_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PosConfidenceEllipse_template::PosConfidenceEllipse_template(const PosConfidenceEllipse& other_value)
{
copy_value(other_value);
}

PosConfidenceEllipse_template::PosConfidenceEllipse_template(const OPTIONAL<PosConfidenceEllipse>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PosConfidenceEllipse&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.PosConfidenceEllipse from an unbound optional field.");
}
}

PosConfidenceEllipse_template::PosConfidenceEllipse_template(const PosConfidenceEllipse_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PosConfidenceEllipse_template::~PosConfidenceEllipse_template()
{
clean_up();
}

PosConfidenceEllipse_template& PosConfidenceEllipse_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PosConfidenceEllipse_template& PosConfidenceEllipse_template::operator=(const PosConfidenceEllipse& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PosConfidenceEllipse_template& PosConfidenceEllipse_template::operator=(const OPTIONAL<PosConfidenceEllipse>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PosConfidenceEllipse&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.PosConfidenceEllipse.");
}
return *this;
}

PosConfidenceEllipse_template& PosConfidenceEllipse_template::operator=(const PosConfidenceEllipse_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PosConfidenceEllipse_template::match(const PosConfidenceEllipse& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.semiMajorConfidence().is_bound()) return FALSE;
if(!single_value->field_semiMajorConfidence.match(other_value.semiMajorConfidence(), legacy))return FALSE;
if(!other_value.semiMinorConfidence().is_bound()) return FALSE;
if(!single_value->field_semiMinorConfidence.match(other_value.semiMinorConfidence(), legacy))return FALSE;
if(!other_value.semiMajorOrientation().is_bound()) return FALSE;
if(!single_value->field_semiMajorOrientation.match(other_value.semiMajorOrientation(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.PosConfidenceEllipse.");
}
return FALSE;
}

boolean PosConfidenceEllipse_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_semiMajorConfidence.is_bound()) return TRUE;
if (single_value->field_semiMinorConfidence.is_bound()) return TRUE;
if (single_value->field_semiMajorOrientation.is_bound()) return TRUE;
return FALSE;
}

boolean PosConfidenceEllipse_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_semiMajorConfidence.is_value()) return FALSE;
if (!single_value->field_semiMinorConfidence.is_value()) return FALSE;
if (!single_value->field_semiMajorOrientation.is_value()) return FALSE;
return TRUE;
}

void PosConfidenceEllipse_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PosConfidenceEllipse PosConfidenceEllipse_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.PosConfidenceEllipse.");
PosConfidenceEllipse ret_val;
if (single_value->field_semiMajorConfidence.is_bound()) {
ret_val.semiMajorConfidence() = single_value->field_semiMajorConfidence.valueof();
}
if (single_value->field_semiMinorConfidence.is_bound()) {
ret_val.semiMinorConfidence() = single_value->field_semiMinorConfidence.valueof();
}
if (single_value->field_semiMajorOrientation.is_bound()) {
ret_val.semiMajorOrientation() = single_value->field_semiMajorOrientation.valueof();
}
return ret_val;
}

void PosConfidenceEllipse_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.PosConfidenceEllipse.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PosConfidenceEllipse_template[list_length];
}

PosConfidenceEllipse_template& PosConfidenceEllipse_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.PosConfidenceEllipse.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.PosConfidenceEllipse.");
return value_list.list_value[list_index];
}

INTEGER_template& PosConfidenceEllipse_template::semiMajorConfidence()
{
set_specific();
return single_value->field_semiMajorConfidence;
}

const INTEGER_template& PosConfidenceEllipse_template::semiMajorConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field semiMajorConfidence of a non-specific template of type @ITS-Container.PosConfidenceEllipse.");
return single_value->field_semiMajorConfidence;
}

INTEGER_template& PosConfidenceEllipse_template::semiMinorConfidence()
{
set_specific();
return single_value->field_semiMinorConfidence;
}

const INTEGER_template& PosConfidenceEllipse_template::semiMinorConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field semiMinorConfidence of a non-specific template of type @ITS-Container.PosConfidenceEllipse.");
return single_value->field_semiMinorConfidence;
}

INTEGER_template& PosConfidenceEllipse_template::semiMajorOrientation()
{
set_specific();
return single_value->field_semiMajorOrientation;
}

const INTEGER_template& PosConfidenceEllipse_template::semiMajorOrientation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field semiMajorOrientation of a non-specific template of type @ITS-Container.PosConfidenceEllipse.");
return single_value->field_semiMajorOrientation;
}

int PosConfidenceEllipse_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PosConfidenceEllipse which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.PosConfidenceEllipse containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PosConfidenceEllipse containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PosConfidenceEllipse containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PosConfidenceEllipse containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PosConfidenceEllipse containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.PosConfidenceEllipse.");
  }
  return 0;
}

void PosConfidenceEllipse_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ semiMajorConfidence := ");
single_value->field_semiMajorConfidence.log();
TTCN_Logger::log_event_str(", semiMinorConfidence := ");
single_value->field_semiMinorConfidence.log();
TTCN_Logger::log_event_str(", semiMajorOrientation := ");
single_value->field_semiMajorOrientation.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PosConfidenceEllipse_template::log_match(const PosConfidenceEllipse& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_semiMajorConfidence.match(match_value.semiMajorConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".semiMajorConfidence");
single_value->field_semiMajorConfidence.log_match(match_value.semiMajorConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_semiMinorConfidence.match(match_value.semiMinorConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".semiMinorConfidence");
single_value->field_semiMinorConfidence.log_match(match_value.semiMinorConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_semiMajorOrientation.match(match_value.semiMajorOrientation(), legacy)){
TTCN_Logger::log_logmatch_info(".semiMajorOrientation");
single_value->field_semiMajorOrientation.log_match(match_value.semiMajorOrientation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ semiMajorConfidence := ");
single_value->field_semiMajorConfidence.log_match(match_value.semiMajorConfidence(), legacy);
TTCN_Logger::log_event_str(", semiMinorConfidence := ");
single_value->field_semiMinorConfidence.log_match(match_value.semiMinorConfidence(), legacy);
TTCN_Logger::log_event_str(", semiMajorOrientation := ");
single_value->field_semiMajorOrientation.log_match(match_value.semiMajorOrientation(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PosConfidenceEllipse_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_semiMajorConfidence.encode_text(text_buf);
single_value->field_semiMinorConfidence.encode_text(text_buf);
single_value->field_semiMajorOrientation.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.PosConfidenceEllipse.");
}
}

void PosConfidenceEllipse_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_semiMajorConfidence.decode_text(text_buf);
single_value->field_semiMinorConfidence.decode_text(text_buf);
single_value->field_semiMajorOrientation.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PosConfidenceEllipse_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.PosConfidenceEllipse.");
}
}

void PosConfidenceEllipse_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.PosConfidenceEllipse'");
    }
    if (strcmp("semiMajorConfidence", param_field) == 0) {
      semiMajorConfidence().set_param(param);
      return;
    } else if (strcmp("semiMinorConfidence", param_field) == 0) {
      semiMinorConfidence().set_param(param);
      return;
    } else if (strcmp("semiMajorOrientation", param_field) == 0) {
      semiMajorOrientation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.PosConfidenceEllipse'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PosConfidenceEllipse_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @ITS-Container.PosConfidenceEllipse has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) semiMajorConfidence().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) semiMinorConfidence().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) semiMajorOrientation().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "semiMajorConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          semiMajorConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "semiMinorConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          semiMinorConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "semiMajorOrientation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          semiMajorOrientation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.PosConfidenceEllipse: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.PosConfidenceEllipse");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PosConfidenceEllipse_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.PosConfidenceEllipse'");
    }
    if (strcmp("semiMajorConfidence", param_field) == 0) {
      return semiMajorConfidence().get_param(param_name);
    } else if (strcmp("semiMinorConfidence", param_field) == 0) {
      return semiMinorConfidence().get_param(param_name);
    } else if (strcmp("semiMajorOrientation", param_field) == 0) {
      return semiMajorOrientation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.PosConfidenceEllipse'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_semiMajorConfidence = single_value->field_semiMajorConfidence.get_param(param_name);
    mp_field_semiMajorConfidence->set_id(new Module_Param_FieldName(mcopystr("semiMajorConfidence")));
    mp->add_elem(mp_field_semiMajorConfidence);
    Module_Param* mp_field_semiMinorConfidence = single_value->field_semiMinorConfidence.get_param(param_name);
    mp_field_semiMinorConfidence->set_id(new Module_Param_FieldName(mcopystr("semiMinorConfidence")));
    mp->add_elem(mp_field_semiMinorConfidence);
    Module_Param* mp_field_semiMajorOrientation = single_value->field_semiMajorOrientation.get_param(param_name);
    mp_field_semiMajorOrientation->set_id(new Module_Param_FieldName(mcopystr("semiMajorOrientation")));
    mp->add_elem(mp_field_semiMajorOrientation);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PosConfidenceEllipse_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_semiMajorConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.PosConfidenceEllipse");
single_value->field_semiMinorConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.PosConfidenceEllipse");
single_value->field_semiMajorOrientation.check_restriction(t_res, t_name ? t_name : "@ITS-Container.PosConfidenceEllipse");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.PosConfidenceEllipse");
}

boolean PosConfidenceEllipse_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PosConfidenceEllipse_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AltitudeConfidence::AltitudeConfidence()
{
enum_value = UNBOUND_VALUE;
}

AltitudeConfidence::AltitudeConfidence(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.AltitudeConfidence with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

AltitudeConfidence::AltitudeConfidence(enum_type other_value)
{
enum_value = other_value;
}

AltitudeConfidence::AltitudeConfidence(const AltitudeConfidence& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
enum_value = other_value.enum_value;
}

AltitudeConfidence& AltitudeConfidence::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.AltitudeConfidence.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

AltitudeConfidence& AltitudeConfidence::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

AltitudeConfidence& AltitudeConfidence::operator=(const AltitudeConfidence& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
enum_value = other_value.enum_value;
return *this;
}

boolean AltitudeConfidence::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
return enum_value == other_value;
}

boolean AltitudeConfidence::operator==(const AltitudeConfidence& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
return enum_value == other_value.enum_value;
}

boolean AltitudeConfidence::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
return enum_value < other_value;
}

boolean AltitudeConfidence::operator<(const AltitudeConfidence& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
return enum_value < other_value.enum_value;
}

boolean AltitudeConfidence::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
return enum_value > other_value;
}

boolean AltitudeConfidence::operator>(const AltitudeConfidence& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
return enum_value > other_value.enum_value;
}

const char *AltitudeConfidence::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case alt__000__01: return "alt_000_01";
case alt__000__02: return "alt_000_02";
case alt__000__05: return "alt_000_05";
case alt__000__10: return "alt_000_10";
case alt__000__20: return "alt_000_20";
case alt__000__50: return "alt_000_50";
case alt__001__00: return "alt_001_00";
case alt__002__00: return "alt_002_00";
case alt__005__00: return "alt_005_00";
case alt__010__00: return "alt_010_00";
case alt__020__00: return "alt_020_00";
case alt__050__00: return "alt_050_00";
case alt__100__00: return "alt_100_00";
case alt__200__00: return "alt_200_00";
case outOfRange: return "outOfRange";
case unavailable: return "unavailable";
default: return "<unknown>";
}
}

AltitudeConfidence::enum_type AltitudeConfidence::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "alt_000_01")) return alt__000__01;
else if (!strcmp(str_par, "alt_000_02")) return alt__000__02;
else if (!strcmp(str_par, "alt_000_05")) return alt__000__05;
else if (!strcmp(str_par, "alt_000_10")) return alt__000__10;
else if (!strcmp(str_par, "alt_000_20")) return alt__000__20;
else if (!strcmp(str_par, "alt_000_50")) return alt__000__50;
else if (!strcmp(str_par, "alt_001_00")) return alt__001__00;
else if (!strcmp(str_par, "alt_002_00")) return alt__002__00;
else if (!strcmp(str_par, "alt_005_00")) return alt__005__00;
else if (!strcmp(str_par, "alt_010_00")) return alt__010__00;
else if (!strcmp(str_par, "alt_020_00")) return alt__020__00;
else if (!strcmp(str_par, "alt_050_00")) return alt__050__00;
else if (!strcmp(str_par, "alt_100_00")) return alt__100__00;
else if (!strcmp(str_par, "alt_200_00")) return alt__200__00;
else if (!strcmp(str_par, "outOfRange")) return outOfRange;
else if (!strcmp(str_par, "unavailable")) return unavailable;
else return UNKNOWN_VALUE;
}

boolean AltitudeConfidence::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
return TRUE;
default:
return FALSE;
}
}

int AltitudeConfidence::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.AltitudeConfidence.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int AltitudeConfidence::enum2int(const AltitudeConfidence& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.AltitudeConfidence.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void AltitudeConfidence::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.AltitudeConfidence.", int_val);
enum_value = (enum_type)int_val;
}

AltitudeConfidence::operator AltitudeConfidence::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.AltitudeConfidence.");
return enum_value;
}

void AltitudeConfidence::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void AltitudeConfidence::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.AltitudeConfidence");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.AltitudeConfidence.");
  }
}

Module_Param* AltitudeConfidence::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void AltitudeConfidence::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
text_buf.push_int(enum_value);
}

void AltitudeConfidence::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.AltitudeConfidence.", enum_value);
}

void AltitudeConfidence::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AltitudeConfidence::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* AltitudeConfidence::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean AltitudeConfidence::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.AltitudeConfidence: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int AltitudeConfidence::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int AltitudeConfidence::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void AltitudeConfidence_template::copy_template(const AltitudeConfidence_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AltitudeConfidence_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.AltitudeConfidence.");
}
}

AltitudeConfidence_template::AltitudeConfidence_template()
{
}

AltitudeConfidence_template::AltitudeConfidence_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AltitudeConfidence_template::AltitudeConfidence_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!AltitudeConfidence::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.AltitudeConfidence with unknown numeric value %d.", other_value);
single_value = (AltitudeConfidence::enum_type)other_value;
}

AltitudeConfidence_template::AltitudeConfidence_template(AltitudeConfidence::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

AltitudeConfidence_template::AltitudeConfidence_template(const AltitudeConfidence& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == AltitudeConfidence::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.AltitudeConfidence.");
single_value = other_value.enum_value;
}

AltitudeConfidence_template::AltitudeConfidence_template(const OPTIONAL<AltitudeConfidence>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (AltitudeConfidence::enum_type)(const AltitudeConfidence&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.AltitudeConfidence from an unbound optional field.");
}
}

AltitudeConfidence_template::AltitudeConfidence_template(const AltitudeConfidence_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

AltitudeConfidence_template::~AltitudeConfidence_template()
{
clean_up();
}

boolean AltitudeConfidence_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean AltitudeConfidence_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != AltitudeConfidence::UNBOUND_VALUE;
}

void AltitudeConfidence_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

AltitudeConfidence_template& AltitudeConfidence_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AltitudeConfidence_template& AltitudeConfidence_template::operator=(int other_value)
{
if (!AltitudeConfidence::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.AltitudeConfidence.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (AltitudeConfidence::enum_type)other_value;
return *this;
}

AltitudeConfidence_template& AltitudeConfidence_template::operator=(AltitudeConfidence::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

AltitudeConfidence_template& AltitudeConfidence_template::operator=(const AltitudeConfidence& other_value)
{
if (other_value.enum_value == AltitudeConfidence::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.AltitudeConfidence to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

AltitudeConfidence_template& AltitudeConfidence_template::operator=(const OPTIONAL<AltitudeConfidence>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (AltitudeConfidence::enum_type)(const AltitudeConfidence&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.AltitudeConfidence.");
}
return *this;
}

AltitudeConfidence_template& AltitudeConfidence_template::operator=(const AltitudeConfidence_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AltitudeConfidence_template::match(AltitudeConfidence::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.AltitudeConfidence.");
}
return FALSE;
}

boolean AltitudeConfidence_template::match(const AltitudeConfidence& other_value, boolean) const
{
if (other_value.enum_value == AltitudeConfidence::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.AltitudeConfidence with an unbound value.");
return match(other_value.enum_value);
}

AltitudeConfidence::enum_type AltitudeConfidence_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.AltitudeConfidence.");
return single_value;
}

void AltitudeConfidence_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.AltitudeConfidence.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AltitudeConfidence_template[list_length];
}

AltitudeConfidence_template& AltitudeConfidence_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.AltitudeConfidence.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.AltitudeConfidence.");
return value_list.list_value[list_index];
}

void AltitudeConfidence_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(AltitudeConfidence::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AltitudeConfidence_template::log_match(const AltitudeConfidence& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void AltitudeConfidence_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.AltitudeConfidence.");
}
}

void AltitudeConfidence_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (AltitudeConfidence::enum_type)text_buf.pull_int().get_val();
if (!AltitudeConfidence::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.AltitudeConfidence.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AltitudeConfidence_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.AltitudeConfidence.");
}
}

boolean AltitudeConfidence_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AltitudeConfidence_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AltitudeConfidence_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    AltitudeConfidence::enum_type enum_val = (enum_name != NULL) ? AltitudeConfidence::str_to_enum(enum_name) : AltitudeConfidence::UNKNOWN_VALUE;
    if (AltitudeConfidence::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AltitudeConfidence_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    AltitudeConfidence::enum_type enum_val = AltitudeConfidence::str_to_enum(mp->get_enumerated());
    if (!AltitudeConfidence::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.AltitudeConfidence.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.AltitudeConfidence");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AltitudeConfidence_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(AltitudeConfidence::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AltitudeConfidence_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.AltitudeConfidence");
}

Altitude::Altitude()
{
  bound_flag = FALSE;
}

Altitude::Altitude(const INTEGER& par_altitudeValue,
    const AltitudeConfidence& par_altitudeConfidence)
  :   field_altitudeValue(par_altitudeValue),
  field_altitudeConfidence(par_altitudeConfidence)
{
  bound_flag = TRUE;
}

Altitude::Altitude(const Altitude& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.Altitude.");
bound_flag = TRUE;
if (other_value.altitudeValue().is_bound()) field_altitudeValue = other_value.altitudeValue();
else field_altitudeValue.clean_up();
if (other_value.altitudeConfidence().is_bound()) field_altitudeConfidence = other_value.altitudeConfidence();
else field_altitudeConfidence.clean_up();
}

void Altitude::clean_up()
{
field_altitudeValue.clean_up();
field_altitudeConfidence.clean_up();
bound_flag = FALSE;
}

Altitude& Altitude::operator=(const Altitude& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.Altitude.");
  bound_flag = TRUE;
  if (other_value.altitudeValue().is_bound()) field_altitudeValue = other_value.altitudeValue();
  else field_altitudeValue.clean_up();
  if (other_value.altitudeConfidence().is_bound()) field_altitudeConfidence = other_value.altitudeConfidence();
  else field_altitudeConfidence.clean_up();
}
return *this;
}

boolean Altitude::operator==(const Altitude& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_altitudeValue==other_value.field_altitudeValue
  && field_altitudeConfidence==other_value.field_altitudeConfidence;
}

boolean Altitude::is_bound() const
{
if (bound_flag) return TRUE;
if(field_altitudeValue.is_bound()) return TRUE;
if(field_altitudeConfidence.is_bound()) return TRUE;
return FALSE;
}
boolean Altitude::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_altitudeValue.is_value()) return FALSE;
if(!field_altitudeConfidence.is_value()) return FALSE;
return TRUE;
}
int Altitude::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.Altitude");
  return 2;
}

void Altitude::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ altitudeValue := ");
field_altitudeValue.log();
TTCN_Logger::log_event_str(", altitudeConfidence := ");
field_altitudeConfidence.log();
TTCN_Logger::log_event_str(" }");
}

void Altitude::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.Altitude'");
    }
    if (strcmp("altitudeValue", param_field) == 0) {
      altitudeValue().set_param(param);
      return;
    } else if (strcmp("altitudeConfidence", param_field) == 0) {
      altitudeConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.Altitude'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.Altitude has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) altitudeValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) altitudeConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "altitudeValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          altitudeValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "altitudeConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          altitudeConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.Altitude: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.Altitude");
  }
}

Module_Param* Altitude::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.Altitude'");
    }
    if (strcmp("altitudeValue", param_field) == 0) {
      return altitudeValue().get_param(param_name);
    } else if (strcmp("altitudeConfidence", param_field) == 0) {
      return altitudeConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.Altitude'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_altitudeValue = field_altitudeValue.get_param(param_name);
  mp_field_altitudeValue->set_id(new Module_Param_FieldName(mcopystr("altitudeValue")));
  mp->add_elem(mp_field_altitudeValue);
  Module_Param* mp_field_altitudeConfidence = field_altitudeConfidence.get_param(param_name);
  mp_field_altitudeConfidence->set_id(new Module_Param_FieldName(mcopystr("altitudeConfidence")));
  mp->add_elem(mp_field_altitudeConfidence);
  return mp;
  }

void Altitude::set_implicit_omit()
{
if (altitudeValue().is_bound()) altitudeValue().set_implicit_omit();
if (altitudeConfidence().is_bound()) altitudeConfidence().set_implicit_omit();
}

void Altitude::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.Altitude.");
field_altitudeValue.encode_text(text_buf);
field_altitudeConfidence.encode_text(text_buf);
}

void Altitude::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_altitudeValue.decode_text(text_buf);
field_altitudeConfidence.decode_text(text_buf);
}

void Altitude::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Altitude::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* Altitude::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("altitudeValue': ");
  new_tlv->add_TLV(field_altitudeValue.BER_encode_TLV(Altitude_altitudeValue_descr_, p_coding));
  ec_1.set_msg("altitudeConfidence': ");
  new_tlv->add_TLV(field_altitudeConfidence.BER_encode_TLV(Altitude_altitudeConfidence_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean Altitude::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.Altitude' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("altitudeValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_altitudeValue.BER_decode_TLV(Altitude_altitudeValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("altitudeConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_altitudeConfidence.BER_decode_TLV(Altitude_altitudeConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int Altitude::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.Altitude.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "altitudeValue");
    enc_len += field_altitudeValue.JSON_encode(Altitude_altitudeValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "altitudeConfidence");
    enc_len += field_altitudeConfidence.JSON_encode(Altitude_altitudeConfidence_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Altitude::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (13 == name_len && 0 == strncmp(fld_name, "altitudeValue", name_len)) {
         int ret_val = field_altitudeValue.JSON_decode(Altitude_altitudeValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "altitudeValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "altitudeConfidence", name_len)) {
         int ret_val = field_altitudeConfidence.JSON_decode(Altitude_altitudeConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "altitudeConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_altitudeValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "altitudeValue");
    return JSON_ERROR_FATAL;
  }
if (!field_altitudeConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "altitudeConfidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Altitude_template::single_value_struct {
INTEGER_template field_altitudeValue;
AltitudeConfidence_template field_altitudeConfidence;
};

void Altitude_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_altitudeValue = ANY_VALUE;
single_value->field_altitudeConfidence = ANY_VALUE;
}
}
}

void Altitude_template::copy_value(const Altitude& other_value)
{
single_value = new single_value_struct;
if (other_value.altitudeValue().is_bound()) {
  single_value->field_altitudeValue = other_value.altitudeValue();
} else {
  single_value->field_altitudeValue.clean_up();
}
if (other_value.altitudeConfidence().is_bound()) {
  single_value->field_altitudeConfidence = other_value.altitudeConfidence();
} else {
  single_value->field_altitudeConfidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Altitude_template::copy_template(const Altitude_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.altitudeValue().get_selection()) {
single_value->field_altitudeValue = other_value.altitudeValue();
} else {
single_value->field_altitudeValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.altitudeConfidence().get_selection()) {
single_value->field_altitudeConfidence = other_value.altitudeConfidence();
} else {
single_value->field_altitudeConfidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Altitude_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.Altitude.");
break;
}
set_selection(other_value);
}

Altitude_template::Altitude_template()
{
}

Altitude_template::Altitude_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Altitude_template::Altitude_template(const Altitude& other_value)
{
copy_value(other_value);
}

Altitude_template::Altitude_template(const OPTIONAL<Altitude>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Altitude&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.Altitude from an unbound optional field.");
}
}

Altitude_template::Altitude_template(const Altitude_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Altitude_template::~Altitude_template()
{
clean_up();
}

Altitude_template& Altitude_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Altitude_template& Altitude_template::operator=(const Altitude& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Altitude_template& Altitude_template::operator=(const OPTIONAL<Altitude>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Altitude&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.Altitude.");
}
return *this;
}

Altitude_template& Altitude_template::operator=(const Altitude_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Altitude_template::match(const Altitude& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.altitudeValue().is_bound()) return FALSE;
if(!single_value->field_altitudeValue.match(other_value.altitudeValue(), legacy))return FALSE;
if(!other_value.altitudeConfidence().is_bound()) return FALSE;
if(!single_value->field_altitudeConfidence.match(other_value.altitudeConfidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.Altitude.");
}
return FALSE;
}

boolean Altitude_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_altitudeValue.is_bound()) return TRUE;
if (single_value->field_altitudeConfidence.is_bound()) return TRUE;
return FALSE;
}

boolean Altitude_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_altitudeValue.is_value()) return FALSE;
if (!single_value->field_altitudeConfidence.is_value()) return FALSE;
return TRUE;
}

void Altitude_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Altitude Altitude_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.Altitude.");
Altitude ret_val;
if (single_value->field_altitudeValue.is_bound()) {
ret_val.altitudeValue() = single_value->field_altitudeValue.valueof();
}
if (single_value->field_altitudeConfidence.is_bound()) {
ret_val.altitudeConfidence() = single_value->field_altitudeConfidence.valueof();
}
return ret_val;
}

void Altitude_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.Altitude.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Altitude_template[list_length];
}

Altitude_template& Altitude_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.Altitude.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.Altitude.");
return value_list.list_value[list_index];
}

INTEGER_template& Altitude_template::altitudeValue()
{
set_specific();
return single_value->field_altitudeValue;
}

const INTEGER_template& Altitude_template::altitudeValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field altitudeValue of a non-specific template of type @ITS-Container.Altitude.");
return single_value->field_altitudeValue;
}

AltitudeConfidence_template& Altitude_template::altitudeConfidence()
{
set_specific();
return single_value->field_altitudeConfidence;
}

const AltitudeConfidence_template& Altitude_template::altitudeConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field altitudeConfidence of a non-specific template of type @ITS-Container.Altitude.");
return single_value->field_altitudeConfidence;
}

int Altitude_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Altitude which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.Altitude containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Altitude containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Altitude containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Altitude containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Altitude containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.Altitude.");
  }
  return 0;
}

void Altitude_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ altitudeValue := ");
single_value->field_altitudeValue.log();
TTCN_Logger::log_event_str(", altitudeConfidence := ");
single_value->field_altitudeConfidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Altitude_template::log_match(const Altitude& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_altitudeValue.match(match_value.altitudeValue(), legacy)){
TTCN_Logger::log_logmatch_info(".altitudeValue");
single_value->field_altitudeValue.log_match(match_value.altitudeValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_altitudeConfidence.match(match_value.altitudeConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".altitudeConfidence");
single_value->field_altitudeConfidence.log_match(match_value.altitudeConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ altitudeValue := ");
single_value->field_altitudeValue.log_match(match_value.altitudeValue(), legacy);
TTCN_Logger::log_event_str(", altitudeConfidence := ");
single_value->field_altitudeConfidence.log_match(match_value.altitudeConfidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Altitude_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_altitudeValue.encode_text(text_buf);
single_value->field_altitudeConfidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.Altitude.");
}
}

void Altitude_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_altitudeValue.decode_text(text_buf);
single_value->field_altitudeConfidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Altitude_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.Altitude.");
}
}

void Altitude_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.Altitude'");
    }
    if (strcmp("altitudeValue", param_field) == 0) {
      altitudeValue().set_param(param);
      return;
    } else if (strcmp("altitudeConfidence", param_field) == 0) {
      altitudeConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.Altitude'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Altitude_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.Altitude has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) altitudeValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) altitudeConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "altitudeValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          altitudeValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "altitudeConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          altitudeConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.Altitude: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.Altitude");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Altitude_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.Altitude'");
    }
    if (strcmp("altitudeValue", param_field) == 0) {
      return altitudeValue().get_param(param_name);
    } else if (strcmp("altitudeConfidence", param_field) == 0) {
      return altitudeConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.Altitude'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_altitudeValue = single_value->field_altitudeValue.get_param(param_name);
    mp_field_altitudeValue->set_id(new Module_Param_FieldName(mcopystr("altitudeValue")));
    mp->add_elem(mp_field_altitudeValue);
    Module_Param* mp_field_altitudeConfidence = single_value->field_altitudeConfidence.get_param(param_name);
    mp_field_altitudeConfidence->set_id(new Module_Param_FieldName(mcopystr("altitudeConfidence")));
    mp->add_elem(mp_field_altitudeConfidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Altitude_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_altitudeValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.Altitude");
single_value->field_altitudeConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.Altitude");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.Altitude");
}

boolean Altitude_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Altitude_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ReferencePosition::ReferencePosition()
{
  bound_flag = FALSE;
}

ReferencePosition::ReferencePosition(const INTEGER& par_latitude,
    const INTEGER& par_longitude,
    const PosConfidenceEllipse& par_positionConfidenceEllipse,
    const Altitude& par_altitude)
  :   field_latitude(par_latitude),
  field_longitude(par_longitude),
  field_positionConfidenceEllipse(par_positionConfidenceEllipse),
  field_altitude(par_altitude)
{
  bound_flag = TRUE;
}

ReferencePosition::ReferencePosition(const ReferencePosition& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.ReferencePosition.");
bound_flag = TRUE;
if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
else field_latitude.clean_up();
if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
else field_longitude.clean_up();
if (other_value.positionConfidenceEllipse().is_bound()) field_positionConfidenceEllipse = other_value.positionConfidenceEllipse();
else field_positionConfidenceEllipse.clean_up();
if (other_value.altitude().is_bound()) field_altitude = other_value.altitude();
else field_altitude.clean_up();
}

void ReferencePosition::clean_up()
{
field_latitude.clean_up();
field_longitude.clean_up();
field_positionConfidenceEllipse.clean_up();
field_altitude.clean_up();
bound_flag = FALSE;
}

ReferencePosition& ReferencePosition::operator=(const ReferencePosition& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.ReferencePosition.");
  bound_flag = TRUE;
  if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
  else field_latitude.clean_up();
  if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
  else field_longitude.clean_up();
  if (other_value.positionConfidenceEllipse().is_bound()) field_positionConfidenceEllipse = other_value.positionConfidenceEllipse();
  else field_positionConfidenceEllipse.clean_up();
  if (other_value.altitude().is_bound()) field_altitude = other_value.altitude();
  else field_altitude.clean_up();
}
return *this;
}

boolean ReferencePosition::operator==(const ReferencePosition& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_latitude==other_value.field_latitude
  && field_longitude==other_value.field_longitude
  && field_positionConfidenceEllipse==other_value.field_positionConfidenceEllipse
  && field_altitude==other_value.field_altitude;
}

boolean ReferencePosition::is_bound() const
{
if (bound_flag) return TRUE;
if(field_latitude.is_bound()) return TRUE;
if(field_longitude.is_bound()) return TRUE;
if(field_positionConfidenceEllipse.is_bound()) return TRUE;
if(field_altitude.is_bound()) return TRUE;
return FALSE;
}
boolean ReferencePosition::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_latitude.is_value()) return FALSE;
if(!field_longitude.is_value()) return FALSE;
if(!field_positionConfidenceEllipse.is_value()) return FALSE;
if(!field_altitude.is_value()) return FALSE;
return TRUE;
}
int ReferencePosition::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.ReferencePosition");
  return 4;
}

void ReferencePosition::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ latitude := ");
field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
field_longitude.log();
TTCN_Logger::log_event_str(", positionConfidenceEllipse := ");
field_positionConfidenceEllipse.log();
TTCN_Logger::log_event_str(", altitude := ");
field_altitude.log();
TTCN_Logger::log_event_str(" }");
}

void ReferencePosition::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.ReferencePosition'");
    }
    if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else if (strcmp("positionConfidenceEllipse", param_field) == 0) {
      positionConfidenceEllipse().set_param(param);
      return;
    } else if (strcmp("altitude", param_field) == 0) {
      altitude().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.ReferencePosition'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @ITS-Container.ReferencePosition has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) positionConfidenceEllipse().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) altitude().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "positionConfidenceEllipse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          positionConfidenceEllipse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "altitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          altitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ReferencePosition: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.ReferencePosition");
  }
}

Module_Param* ReferencePosition::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.ReferencePosition'");
    }
    if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else if (strcmp("positionConfidenceEllipse", param_field) == 0) {
      return positionConfidenceEllipse().get_param(param_name);
    } else if (strcmp("altitude", param_field) == 0) {
      return altitude().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ReferencePosition'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_latitude = field_latitude.get_param(param_name);
  mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
  mp->add_elem(mp_field_latitude);
  Module_Param* mp_field_longitude = field_longitude.get_param(param_name);
  mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
  mp->add_elem(mp_field_longitude);
  Module_Param* mp_field_positionConfidenceEllipse = field_positionConfidenceEllipse.get_param(param_name);
  mp_field_positionConfidenceEllipse->set_id(new Module_Param_FieldName(mcopystr("positionConfidenceEllipse")));
  mp->add_elem(mp_field_positionConfidenceEllipse);
  Module_Param* mp_field_altitude = field_altitude.get_param(param_name);
  mp_field_altitude->set_id(new Module_Param_FieldName(mcopystr("altitude")));
  mp->add_elem(mp_field_altitude);
  return mp;
  }

void ReferencePosition::set_implicit_omit()
{
if (latitude().is_bound()) latitude().set_implicit_omit();
if (longitude().is_bound()) longitude().set_implicit_omit();
if (positionConfidenceEllipse().is_bound()) positionConfidenceEllipse().set_implicit_omit();
if (altitude().is_bound()) altitude().set_implicit_omit();
}

void ReferencePosition::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.ReferencePosition.");
field_latitude.encode_text(text_buf);
field_longitude.encode_text(text_buf);
field_positionConfidenceEllipse.encode_text(text_buf);
field_altitude.encode_text(text_buf);
}

void ReferencePosition::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_latitude.decode_text(text_buf);
field_longitude.decode_text(text_buf);
field_positionConfidenceEllipse.decode_text(text_buf);
field_altitude.decode_text(text_buf);
}

void ReferencePosition::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ReferencePosition::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ReferencePosition::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("latitude': ");
  new_tlv->add_TLV(field_latitude.BER_encode_TLV(ReferencePosition_latitude_descr_, p_coding));
  ec_1.set_msg("longitude': ");
  new_tlv->add_TLV(field_longitude.BER_encode_TLV(ReferencePosition_longitude_descr_, p_coding));
  ec_1.set_msg("positionConfidenceEllipse': ");
  new_tlv->add_TLV(field_positionConfidenceEllipse.BER_encode_TLV(ReferencePosition_positionConfidenceEllipse_descr_, p_coding));
  ec_1.set_msg("altitude': ");
  new_tlv->add_TLV(field_altitude.BER_encode_TLV(ReferencePosition_altitude_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ReferencePosition::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.ReferencePosition' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("latitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_latitude.BER_decode_TLV(ReferencePosition_latitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("longitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_longitude.BER_decode_TLV(ReferencePosition_longitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("positionConfidenceEllipse': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_positionConfidenceEllipse.BER_decode_TLV(ReferencePosition_positionConfidenceEllipse_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("altitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_altitude.BER_decode_TLV(ReferencePosition_altitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ReferencePosition::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.ReferencePosition.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "latitude");
    enc_len += field_latitude.JSON_encode(ReferencePosition_latitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "longitude");
    enc_len += field_longitude.JSON_encode(ReferencePosition_longitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "positionConfidenceEllipse");
    enc_len += field_positionConfidenceEllipse.JSON_encode(ReferencePosition_positionConfidenceEllipse_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "altitude");
    enc_len += field_altitude.JSON_encode(ReferencePosition_altitude_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ReferencePosition::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "latitude", name_len)) {
         int ret_val = field_latitude.JSON_decode(ReferencePosition_latitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "latitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "longitude", name_len)) {
         int ret_val = field_longitude.JSON_decode(ReferencePosition_longitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "longitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (25 == name_len && 0 == strncmp(fld_name, "positionConfidenceEllipse", name_len)) {
         int ret_val = field_positionConfidenceEllipse.JSON_decode(ReferencePosition_positionConfidenceEllipse_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "positionConfidenceEllipse");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "altitude", name_len)) {
         int ret_val = field_altitude.JSON_decode(ReferencePosition_altitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "altitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_latitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "latitude");
    return JSON_ERROR_FATAL;
  }
if (!field_longitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "longitude");
    return JSON_ERROR_FATAL;
  }
if (!field_positionConfidenceEllipse.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "positionConfidenceEllipse");
    return JSON_ERROR_FATAL;
  }
if (!field_altitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "altitude");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ReferencePosition_template::single_value_struct {
INTEGER_template field_latitude;
INTEGER_template field_longitude;
PosConfidenceEllipse_template field_positionConfidenceEllipse;
Altitude_template field_altitude;
};

void ReferencePosition_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_latitude = ANY_VALUE;
single_value->field_longitude = ANY_VALUE;
single_value->field_positionConfidenceEllipse = ANY_VALUE;
single_value->field_altitude = ANY_VALUE;
}
}
}

void ReferencePosition_template::copy_value(const ReferencePosition& other_value)
{
single_value = new single_value_struct;
if (other_value.latitude().is_bound()) {
  single_value->field_latitude = other_value.latitude();
} else {
  single_value->field_latitude.clean_up();
}
if (other_value.longitude().is_bound()) {
  single_value->field_longitude = other_value.longitude();
} else {
  single_value->field_longitude.clean_up();
}
if (other_value.positionConfidenceEllipse().is_bound()) {
  single_value->field_positionConfidenceEllipse = other_value.positionConfidenceEllipse();
} else {
  single_value->field_positionConfidenceEllipse.clean_up();
}
if (other_value.altitude().is_bound()) {
  single_value->field_altitude = other_value.altitude();
} else {
  single_value->field_altitude.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ReferencePosition_template::copy_template(const ReferencePosition_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.latitude().get_selection()) {
single_value->field_latitude = other_value.latitude();
} else {
single_value->field_latitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.longitude().get_selection()) {
single_value->field_longitude = other_value.longitude();
} else {
single_value->field_longitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.positionConfidenceEllipse().get_selection()) {
single_value->field_positionConfidenceEllipse = other_value.positionConfidenceEllipse();
} else {
single_value->field_positionConfidenceEllipse.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.altitude().get_selection()) {
single_value->field_altitude = other_value.altitude();
} else {
single_value->field_altitude.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ReferencePosition_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.ReferencePosition.");
break;
}
set_selection(other_value);
}

ReferencePosition_template::ReferencePosition_template()
{
}

ReferencePosition_template::ReferencePosition_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ReferencePosition_template::ReferencePosition_template(const ReferencePosition& other_value)
{
copy_value(other_value);
}

ReferencePosition_template::ReferencePosition_template(const OPTIONAL<ReferencePosition>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ReferencePosition&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.ReferencePosition from an unbound optional field.");
}
}

ReferencePosition_template::ReferencePosition_template(const ReferencePosition_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ReferencePosition_template::~ReferencePosition_template()
{
clean_up();
}

ReferencePosition_template& ReferencePosition_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ReferencePosition_template& ReferencePosition_template::operator=(const ReferencePosition& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ReferencePosition_template& ReferencePosition_template::operator=(const OPTIONAL<ReferencePosition>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ReferencePosition&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.ReferencePosition.");
}
return *this;
}

ReferencePosition_template& ReferencePosition_template::operator=(const ReferencePosition_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ReferencePosition_template::match(const ReferencePosition& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.latitude().is_bound()) return FALSE;
if(!single_value->field_latitude.match(other_value.latitude(), legacy))return FALSE;
if(!other_value.longitude().is_bound()) return FALSE;
if(!single_value->field_longitude.match(other_value.longitude(), legacy))return FALSE;
if(!other_value.positionConfidenceEllipse().is_bound()) return FALSE;
if(!single_value->field_positionConfidenceEllipse.match(other_value.positionConfidenceEllipse(), legacy))return FALSE;
if(!other_value.altitude().is_bound()) return FALSE;
if(!single_value->field_altitude.match(other_value.altitude(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.ReferencePosition.");
}
return FALSE;
}

boolean ReferencePosition_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_latitude.is_bound()) return TRUE;
if (single_value->field_longitude.is_bound()) return TRUE;
if (single_value->field_positionConfidenceEllipse.is_bound()) return TRUE;
if (single_value->field_altitude.is_bound()) return TRUE;
return FALSE;
}

boolean ReferencePosition_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_latitude.is_value()) return FALSE;
if (!single_value->field_longitude.is_value()) return FALSE;
if (!single_value->field_positionConfidenceEllipse.is_value()) return FALSE;
if (!single_value->field_altitude.is_value()) return FALSE;
return TRUE;
}

void ReferencePosition_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ReferencePosition ReferencePosition_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.ReferencePosition.");
ReferencePosition ret_val;
if (single_value->field_latitude.is_bound()) {
ret_val.latitude() = single_value->field_latitude.valueof();
}
if (single_value->field_longitude.is_bound()) {
ret_val.longitude() = single_value->field_longitude.valueof();
}
if (single_value->field_positionConfidenceEllipse.is_bound()) {
ret_val.positionConfidenceEllipse() = single_value->field_positionConfidenceEllipse.valueof();
}
if (single_value->field_altitude.is_bound()) {
ret_val.altitude() = single_value->field_altitude.valueof();
}
return ret_val;
}

void ReferencePosition_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.ReferencePosition.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ReferencePosition_template[list_length];
}

ReferencePosition_template& ReferencePosition_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.ReferencePosition.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.ReferencePosition.");
return value_list.list_value[list_index];
}

INTEGER_template& ReferencePosition_template::latitude()
{
set_specific();
return single_value->field_latitude;
}

const INTEGER_template& ReferencePosition_template::latitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field latitude of a non-specific template of type @ITS-Container.ReferencePosition.");
return single_value->field_latitude;
}

INTEGER_template& ReferencePosition_template::longitude()
{
set_specific();
return single_value->field_longitude;
}

const INTEGER_template& ReferencePosition_template::longitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field longitude of a non-specific template of type @ITS-Container.ReferencePosition.");
return single_value->field_longitude;
}

PosConfidenceEllipse_template& ReferencePosition_template::positionConfidenceEllipse()
{
set_specific();
return single_value->field_positionConfidenceEllipse;
}

const PosConfidenceEllipse_template& ReferencePosition_template::positionConfidenceEllipse() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field positionConfidenceEllipse of a non-specific template of type @ITS-Container.ReferencePosition.");
return single_value->field_positionConfidenceEllipse;
}

Altitude_template& ReferencePosition_template::altitude()
{
set_specific();
return single_value->field_altitude;
}

const Altitude_template& ReferencePosition_template::altitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field altitude of a non-specific template of type @ITS-Container.ReferencePosition.");
return single_value->field_altitude;
}

int ReferencePosition_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ReferencePosition which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.ReferencePosition containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ReferencePosition containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ReferencePosition containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ReferencePosition containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ReferencePosition containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.ReferencePosition.");
  }
  return 0;
}

void ReferencePosition_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ latitude := ");
single_value->field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log();
TTCN_Logger::log_event_str(", positionConfidenceEllipse := ");
single_value->field_positionConfidenceEllipse.log();
TTCN_Logger::log_event_str(", altitude := ");
single_value->field_altitude.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ReferencePosition_template::log_match(const ReferencePosition& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_latitude.match(match_value.latitude(), legacy)){
TTCN_Logger::log_logmatch_info(".latitude");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_longitude.match(match_value.longitude(), legacy)){
TTCN_Logger::log_logmatch_info(".longitude");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_positionConfidenceEllipse.match(match_value.positionConfidenceEllipse(), legacy)){
TTCN_Logger::log_logmatch_info(".positionConfidenceEllipse");
single_value->field_positionConfidenceEllipse.log_match(match_value.positionConfidenceEllipse(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_altitude.match(match_value.altitude(), legacy)){
TTCN_Logger::log_logmatch_info(".altitude");
single_value->field_altitude.log_match(match_value.altitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ latitude := ");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::log_event_str(", positionConfidenceEllipse := ");
single_value->field_positionConfidenceEllipse.log_match(match_value.positionConfidenceEllipse(), legacy);
TTCN_Logger::log_event_str(", altitude := ");
single_value->field_altitude.log_match(match_value.altitude(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ReferencePosition_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_latitude.encode_text(text_buf);
single_value->field_longitude.encode_text(text_buf);
single_value->field_positionConfidenceEllipse.encode_text(text_buf);
single_value->field_altitude.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.ReferencePosition.");
}
}

void ReferencePosition_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_latitude.decode_text(text_buf);
single_value->field_longitude.decode_text(text_buf);
single_value->field_positionConfidenceEllipse.decode_text(text_buf);
single_value->field_altitude.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ReferencePosition_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.ReferencePosition.");
}
}

void ReferencePosition_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.ReferencePosition'");
    }
    if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else if (strcmp("positionConfidenceEllipse", param_field) == 0) {
      positionConfidenceEllipse().set_param(param);
      return;
    } else if (strcmp("altitude", param_field) == 0) {
      altitude().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.ReferencePosition'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ReferencePosition_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @ITS-Container.ReferencePosition has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) positionConfidenceEllipse().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) altitude().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "positionConfidenceEllipse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          positionConfidenceEllipse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "altitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          altitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ReferencePosition: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.ReferencePosition");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ReferencePosition_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.ReferencePosition'");
    }
    if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else if (strcmp("positionConfidenceEllipse", param_field) == 0) {
      return positionConfidenceEllipse().get_param(param_name);
    } else if (strcmp("altitude", param_field) == 0) {
      return altitude().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ReferencePosition'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_latitude = single_value->field_latitude.get_param(param_name);
    mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
    mp->add_elem(mp_field_latitude);
    Module_Param* mp_field_longitude = single_value->field_longitude.get_param(param_name);
    mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
    mp->add_elem(mp_field_longitude);
    Module_Param* mp_field_positionConfidenceEllipse = single_value->field_positionConfidenceEllipse.get_param(param_name);
    mp_field_positionConfidenceEllipse->set_id(new Module_Param_FieldName(mcopystr("positionConfidenceEllipse")));
    mp->add_elem(mp_field_positionConfidenceEllipse);
    Module_Param* mp_field_altitude = single_value->field_altitude.get_param(param_name);
    mp_field_altitude->set_id(new Module_Param_FieldName(mcopystr("altitude")));
    mp->add_elem(mp_field_altitude);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ReferencePosition_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_latitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ReferencePosition");
single_value->field_longitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ReferencePosition");
single_value->field_positionConfidenceEllipse.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ReferencePosition");
single_value->field_altitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ReferencePosition");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.ReferencePosition");
}

boolean ReferencePosition_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ReferencePosition_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

DeltaReferencePosition::DeltaReferencePosition()
{
  bound_flag = FALSE;
}

DeltaReferencePosition::DeltaReferencePosition(const INTEGER& par_deltaLatitude,
    const INTEGER& par_deltaLongitude,
    const INTEGER& par_deltaAltitude)
  :   field_deltaLatitude(par_deltaLatitude),
  field_deltaLongitude(par_deltaLongitude),
  field_deltaAltitude(par_deltaAltitude)
{
  bound_flag = TRUE;
}

DeltaReferencePosition::DeltaReferencePosition(const DeltaReferencePosition& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.DeltaReferencePosition.");
bound_flag = TRUE;
if (other_value.deltaLatitude().is_bound()) field_deltaLatitude = other_value.deltaLatitude();
else field_deltaLatitude.clean_up();
if (other_value.deltaLongitude().is_bound()) field_deltaLongitude = other_value.deltaLongitude();
else field_deltaLongitude.clean_up();
if (other_value.deltaAltitude().is_bound()) field_deltaAltitude = other_value.deltaAltitude();
else field_deltaAltitude.clean_up();
}

void DeltaReferencePosition::clean_up()
{
field_deltaLatitude.clean_up();
field_deltaLongitude.clean_up();
field_deltaAltitude.clean_up();
bound_flag = FALSE;
}

DeltaReferencePosition& DeltaReferencePosition::operator=(const DeltaReferencePosition& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.DeltaReferencePosition.");
  bound_flag = TRUE;
  if (other_value.deltaLatitude().is_bound()) field_deltaLatitude = other_value.deltaLatitude();
  else field_deltaLatitude.clean_up();
  if (other_value.deltaLongitude().is_bound()) field_deltaLongitude = other_value.deltaLongitude();
  else field_deltaLongitude.clean_up();
  if (other_value.deltaAltitude().is_bound()) field_deltaAltitude = other_value.deltaAltitude();
  else field_deltaAltitude.clean_up();
}
return *this;
}

boolean DeltaReferencePosition::operator==(const DeltaReferencePosition& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_deltaLatitude==other_value.field_deltaLatitude
  && field_deltaLongitude==other_value.field_deltaLongitude
  && field_deltaAltitude==other_value.field_deltaAltitude;
}

boolean DeltaReferencePosition::is_bound() const
{
if (bound_flag) return TRUE;
if(field_deltaLatitude.is_bound()) return TRUE;
if(field_deltaLongitude.is_bound()) return TRUE;
if(field_deltaAltitude.is_bound()) return TRUE;
return FALSE;
}
boolean DeltaReferencePosition::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_deltaLatitude.is_value()) return FALSE;
if(!field_deltaLongitude.is_value()) return FALSE;
if(!field_deltaAltitude.is_value()) return FALSE;
return TRUE;
}
int DeltaReferencePosition::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.DeltaReferencePosition");
  return 3;
}

void DeltaReferencePosition::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ deltaLatitude := ");
field_deltaLatitude.log();
TTCN_Logger::log_event_str(", deltaLongitude := ");
field_deltaLongitude.log();
TTCN_Logger::log_event_str(", deltaAltitude := ");
field_deltaAltitude.log();
TTCN_Logger::log_event_str(" }");
}

void DeltaReferencePosition::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.DeltaReferencePosition'");
    }
    if (strcmp("deltaLatitude", param_field) == 0) {
      deltaLatitude().set_param(param);
      return;
    } else if (strcmp("deltaLongitude", param_field) == 0) {
      deltaLongitude().set_param(param);
      return;
    } else if (strcmp("deltaAltitude", param_field) == 0) {
      deltaAltitude().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.DeltaReferencePosition'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @ITS-Container.DeltaReferencePosition has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) deltaLatitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) deltaLongitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) deltaAltitude().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "deltaLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          deltaLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "deltaLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          deltaLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "deltaAltitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          deltaAltitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.DeltaReferencePosition: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.DeltaReferencePosition");
  }
}

Module_Param* DeltaReferencePosition::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.DeltaReferencePosition'");
    }
    if (strcmp("deltaLatitude", param_field) == 0) {
      return deltaLatitude().get_param(param_name);
    } else if (strcmp("deltaLongitude", param_field) == 0) {
      return deltaLongitude().get_param(param_name);
    } else if (strcmp("deltaAltitude", param_field) == 0) {
      return deltaAltitude().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.DeltaReferencePosition'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_deltaLatitude = field_deltaLatitude.get_param(param_name);
  mp_field_deltaLatitude->set_id(new Module_Param_FieldName(mcopystr("deltaLatitude")));
  mp->add_elem(mp_field_deltaLatitude);
  Module_Param* mp_field_deltaLongitude = field_deltaLongitude.get_param(param_name);
  mp_field_deltaLongitude->set_id(new Module_Param_FieldName(mcopystr("deltaLongitude")));
  mp->add_elem(mp_field_deltaLongitude);
  Module_Param* mp_field_deltaAltitude = field_deltaAltitude.get_param(param_name);
  mp_field_deltaAltitude->set_id(new Module_Param_FieldName(mcopystr("deltaAltitude")));
  mp->add_elem(mp_field_deltaAltitude);
  return mp;
  }

void DeltaReferencePosition::set_implicit_omit()
{
if (deltaLatitude().is_bound()) deltaLatitude().set_implicit_omit();
if (deltaLongitude().is_bound()) deltaLongitude().set_implicit_omit();
if (deltaAltitude().is_bound()) deltaAltitude().set_implicit_omit();
}

void DeltaReferencePosition::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.DeltaReferencePosition.");
field_deltaLatitude.encode_text(text_buf);
field_deltaLongitude.encode_text(text_buf);
field_deltaAltitude.encode_text(text_buf);
}

void DeltaReferencePosition::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_deltaLatitude.decode_text(text_buf);
field_deltaLongitude.decode_text(text_buf);
field_deltaAltitude.decode_text(text_buf);
}

void DeltaReferencePosition::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DeltaReferencePosition::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* DeltaReferencePosition::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("deltaLatitude': ");
  new_tlv->add_TLV(field_deltaLatitude.BER_encode_TLV(DeltaReferencePosition_deltaLatitude_descr_, p_coding));
  ec_1.set_msg("deltaLongitude': ");
  new_tlv->add_TLV(field_deltaLongitude.BER_encode_TLV(DeltaReferencePosition_deltaLongitude_descr_, p_coding));
  ec_1.set_msg("deltaAltitude': ");
  new_tlv->add_TLV(field_deltaAltitude.BER_encode_TLV(DeltaReferencePosition_deltaAltitude_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean DeltaReferencePosition::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.DeltaReferencePosition' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("deltaLatitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_deltaLatitude.BER_decode_TLV(DeltaReferencePosition_deltaLatitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("deltaLongitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_deltaLongitude.BER_decode_TLV(DeltaReferencePosition_deltaLongitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("deltaAltitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_deltaAltitude.BER_decode_TLV(DeltaReferencePosition_deltaAltitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int DeltaReferencePosition::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.DeltaReferencePosition.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "deltaLatitude");
    enc_len += field_deltaLatitude.JSON_encode(DeltaReferencePosition_deltaLatitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "deltaLongitude");
    enc_len += field_deltaLongitude.JSON_encode(DeltaReferencePosition_deltaLongitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "deltaAltitude");
    enc_len += field_deltaAltitude.JSON_encode(DeltaReferencePosition_deltaAltitude_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DeltaReferencePosition::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (13 == name_len && 0 == strncmp(fld_name, "deltaLatitude", name_len)) {
         int ret_val = field_deltaLatitude.JSON_decode(DeltaReferencePosition_deltaLatitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "deltaLatitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "deltaLongitude", name_len)) {
         int ret_val = field_deltaLongitude.JSON_decode(DeltaReferencePosition_deltaLongitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "deltaLongitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "deltaAltitude", name_len)) {
         int ret_val = field_deltaAltitude.JSON_decode(DeltaReferencePosition_deltaAltitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "deltaAltitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_deltaLatitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "deltaLatitude");
    return JSON_ERROR_FATAL;
  }
if (!field_deltaLongitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "deltaLongitude");
    return JSON_ERROR_FATAL;
  }
if (!field_deltaAltitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "deltaAltitude");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct DeltaReferencePosition_template::single_value_struct {
INTEGER_template field_deltaLatitude;
INTEGER_template field_deltaLongitude;
INTEGER_template field_deltaAltitude;
};

void DeltaReferencePosition_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_deltaLatitude = ANY_VALUE;
single_value->field_deltaLongitude = ANY_VALUE;
single_value->field_deltaAltitude = ANY_VALUE;
}
}
}

void DeltaReferencePosition_template::copy_value(const DeltaReferencePosition& other_value)
{
single_value = new single_value_struct;
if (other_value.deltaLatitude().is_bound()) {
  single_value->field_deltaLatitude = other_value.deltaLatitude();
} else {
  single_value->field_deltaLatitude.clean_up();
}
if (other_value.deltaLongitude().is_bound()) {
  single_value->field_deltaLongitude = other_value.deltaLongitude();
} else {
  single_value->field_deltaLongitude.clean_up();
}
if (other_value.deltaAltitude().is_bound()) {
  single_value->field_deltaAltitude = other_value.deltaAltitude();
} else {
  single_value->field_deltaAltitude.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void DeltaReferencePosition_template::copy_template(const DeltaReferencePosition_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.deltaLatitude().get_selection()) {
single_value->field_deltaLatitude = other_value.deltaLatitude();
} else {
single_value->field_deltaLatitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.deltaLongitude().get_selection()) {
single_value->field_deltaLongitude = other_value.deltaLongitude();
} else {
single_value->field_deltaLongitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.deltaAltitude().get_selection()) {
single_value->field_deltaAltitude = other_value.deltaAltitude();
} else {
single_value->field_deltaAltitude.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DeltaReferencePosition_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.DeltaReferencePosition.");
break;
}
set_selection(other_value);
}

DeltaReferencePosition_template::DeltaReferencePosition_template()
{
}

DeltaReferencePosition_template::DeltaReferencePosition_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DeltaReferencePosition_template::DeltaReferencePosition_template(const DeltaReferencePosition& other_value)
{
copy_value(other_value);
}

DeltaReferencePosition_template::DeltaReferencePosition_template(const OPTIONAL<DeltaReferencePosition>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DeltaReferencePosition&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.DeltaReferencePosition from an unbound optional field.");
}
}

DeltaReferencePosition_template::DeltaReferencePosition_template(const DeltaReferencePosition_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

DeltaReferencePosition_template::~DeltaReferencePosition_template()
{
clean_up();
}

DeltaReferencePosition_template& DeltaReferencePosition_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DeltaReferencePosition_template& DeltaReferencePosition_template::operator=(const DeltaReferencePosition& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DeltaReferencePosition_template& DeltaReferencePosition_template::operator=(const OPTIONAL<DeltaReferencePosition>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DeltaReferencePosition&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.DeltaReferencePosition.");
}
return *this;
}

DeltaReferencePosition_template& DeltaReferencePosition_template::operator=(const DeltaReferencePosition_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DeltaReferencePosition_template::match(const DeltaReferencePosition& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.deltaLatitude().is_bound()) return FALSE;
if(!single_value->field_deltaLatitude.match(other_value.deltaLatitude(), legacy))return FALSE;
if(!other_value.deltaLongitude().is_bound()) return FALSE;
if(!single_value->field_deltaLongitude.match(other_value.deltaLongitude(), legacy))return FALSE;
if(!other_value.deltaAltitude().is_bound()) return FALSE;
if(!single_value->field_deltaAltitude.match(other_value.deltaAltitude(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.DeltaReferencePosition.");
}
return FALSE;
}

boolean DeltaReferencePosition_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_deltaLatitude.is_bound()) return TRUE;
if (single_value->field_deltaLongitude.is_bound()) return TRUE;
if (single_value->field_deltaAltitude.is_bound()) return TRUE;
return FALSE;
}

boolean DeltaReferencePosition_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_deltaLatitude.is_value()) return FALSE;
if (!single_value->field_deltaLongitude.is_value()) return FALSE;
if (!single_value->field_deltaAltitude.is_value()) return FALSE;
return TRUE;
}

void DeltaReferencePosition_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DeltaReferencePosition DeltaReferencePosition_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.DeltaReferencePosition.");
DeltaReferencePosition ret_val;
if (single_value->field_deltaLatitude.is_bound()) {
ret_val.deltaLatitude() = single_value->field_deltaLatitude.valueof();
}
if (single_value->field_deltaLongitude.is_bound()) {
ret_val.deltaLongitude() = single_value->field_deltaLongitude.valueof();
}
if (single_value->field_deltaAltitude.is_bound()) {
ret_val.deltaAltitude() = single_value->field_deltaAltitude.valueof();
}
return ret_val;
}

void DeltaReferencePosition_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.DeltaReferencePosition.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DeltaReferencePosition_template[list_length];
}

DeltaReferencePosition_template& DeltaReferencePosition_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.DeltaReferencePosition.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.DeltaReferencePosition.");
return value_list.list_value[list_index];
}

INTEGER_template& DeltaReferencePosition_template::deltaLatitude()
{
set_specific();
return single_value->field_deltaLatitude;
}

const INTEGER_template& DeltaReferencePosition_template::deltaLatitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field deltaLatitude of a non-specific template of type @ITS-Container.DeltaReferencePosition.");
return single_value->field_deltaLatitude;
}

INTEGER_template& DeltaReferencePosition_template::deltaLongitude()
{
set_specific();
return single_value->field_deltaLongitude;
}

const INTEGER_template& DeltaReferencePosition_template::deltaLongitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field deltaLongitude of a non-specific template of type @ITS-Container.DeltaReferencePosition.");
return single_value->field_deltaLongitude;
}

INTEGER_template& DeltaReferencePosition_template::deltaAltitude()
{
set_specific();
return single_value->field_deltaAltitude;
}

const INTEGER_template& DeltaReferencePosition_template::deltaAltitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field deltaAltitude of a non-specific template of type @ITS-Container.DeltaReferencePosition.");
return single_value->field_deltaAltitude;
}

int DeltaReferencePosition_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DeltaReferencePosition which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.DeltaReferencePosition containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DeltaReferencePosition containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DeltaReferencePosition containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DeltaReferencePosition containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DeltaReferencePosition containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.DeltaReferencePosition.");
  }
  return 0;
}

void DeltaReferencePosition_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ deltaLatitude := ");
single_value->field_deltaLatitude.log();
TTCN_Logger::log_event_str(", deltaLongitude := ");
single_value->field_deltaLongitude.log();
TTCN_Logger::log_event_str(", deltaAltitude := ");
single_value->field_deltaAltitude.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DeltaReferencePosition_template::log_match(const DeltaReferencePosition& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_deltaLatitude.match(match_value.deltaLatitude(), legacy)){
TTCN_Logger::log_logmatch_info(".deltaLatitude");
single_value->field_deltaLatitude.log_match(match_value.deltaLatitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_deltaLongitude.match(match_value.deltaLongitude(), legacy)){
TTCN_Logger::log_logmatch_info(".deltaLongitude");
single_value->field_deltaLongitude.log_match(match_value.deltaLongitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_deltaAltitude.match(match_value.deltaAltitude(), legacy)){
TTCN_Logger::log_logmatch_info(".deltaAltitude");
single_value->field_deltaAltitude.log_match(match_value.deltaAltitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ deltaLatitude := ");
single_value->field_deltaLatitude.log_match(match_value.deltaLatitude(), legacy);
TTCN_Logger::log_event_str(", deltaLongitude := ");
single_value->field_deltaLongitude.log_match(match_value.deltaLongitude(), legacy);
TTCN_Logger::log_event_str(", deltaAltitude := ");
single_value->field_deltaAltitude.log_match(match_value.deltaAltitude(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DeltaReferencePosition_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_deltaLatitude.encode_text(text_buf);
single_value->field_deltaLongitude.encode_text(text_buf);
single_value->field_deltaAltitude.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.DeltaReferencePosition.");
}
}

void DeltaReferencePosition_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_deltaLatitude.decode_text(text_buf);
single_value->field_deltaLongitude.decode_text(text_buf);
single_value->field_deltaAltitude.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DeltaReferencePosition_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.DeltaReferencePosition.");
}
}

void DeltaReferencePosition_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.DeltaReferencePosition'");
    }
    if (strcmp("deltaLatitude", param_field) == 0) {
      deltaLatitude().set_param(param);
      return;
    } else if (strcmp("deltaLongitude", param_field) == 0) {
      deltaLongitude().set_param(param);
      return;
    } else if (strcmp("deltaAltitude", param_field) == 0) {
      deltaAltitude().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.DeltaReferencePosition'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DeltaReferencePosition_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @ITS-Container.DeltaReferencePosition has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) deltaLatitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) deltaLongitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) deltaAltitude().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "deltaLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          deltaLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "deltaLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          deltaLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "deltaAltitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          deltaAltitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.DeltaReferencePosition: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.DeltaReferencePosition");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DeltaReferencePosition_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.DeltaReferencePosition'");
    }
    if (strcmp("deltaLatitude", param_field) == 0) {
      return deltaLatitude().get_param(param_name);
    } else if (strcmp("deltaLongitude", param_field) == 0) {
      return deltaLongitude().get_param(param_name);
    } else if (strcmp("deltaAltitude", param_field) == 0) {
      return deltaAltitude().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.DeltaReferencePosition'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_deltaLatitude = single_value->field_deltaLatitude.get_param(param_name);
    mp_field_deltaLatitude->set_id(new Module_Param_FieldName(mcopystr("deltaLatitude")));
    mp->add_elem(mp_field_deltaLatitude);
    Module_Param* mp_field_deltaLongitude = single_value->field_deltaLongitude.get_param(param_name);
    mp_field_deltaLongitude->set_id(new Module_Param_FieldName(mcopystr("deltaLongitude")));
    mp->add_elem(mp_field_deltaLongitude);
    Module_Param* mp_field_deltaAltitude = single_value->field_deltaAltitude.get_param(param_name);
    mp_field_deltaAltitude->set_id(new Module_Param_FieldName(mcopystr("deltaAltitude")));
    mp->add_elem(mp_field_deltaAltitude);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DeltaReferencePosition_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_deltaLatitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DeltaReferencePosition");
single_value->field_deltaLongitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DeltaReferencePosition");
single_value->field_deltaAltitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DeltaReferencePosition");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.DeltaReferencePosition");
}

boolean DeltaReferencePosition_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DeltaReferencePosition_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PathPoint::PathPoint()
{
  bound_flag = FALSE;
}

PathPoint::PathPoint(const DeltaReferencePosition& par_pathPosition,
    const OPTIONAL<INTEGER>& par_pathDeltaTime)
  :   field_pathPosition(par_pathPosition),
  field_pathDeltaTime(par_pathDeltaTime)
{
  bound_flag = TRUE;
}

PathPoint::PathPoint(const PathPoint& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.PathPoint.");
bound_flag = TRUE;
if (other_value.pathPosition().is_bound()) field_pathPosition = other_value.pathPosition();
else field_pathPosition.clean_up();
if (other_value.pathDeltaTime().is_bound()) field_pathDeltaTime = other_value.pathDeltaTime();
else field_pathDeltaTime.clean_up();
}

void PathPoint::clean_up()
{
field_pathPosition.clean_up();
field_pathDeltaTime.clean_up();
bound_flag = FALSE;
}

PathPoint& PathPoint::operator=(const PathPoint& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.PathPoint.");
  bound_flag = TRUE;
  if (other_value.pathPosition().is_bound()) field_pathPosition = other_value.pathPosition();
  else field_pathPosition.clean_up();
  if (other_value.pathDeltaTime().is_bound()) field_pathDeltaTime = other_value.pathDeltaTime();
  else field_pathDeltaTime.clean_up();
}
return *this;
}

boolean PathPoint::operator==(const PathPoint& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_pathPosition==other_value.field_pathPosition
  && field_pathDeltaTime==other_value.field_pathDeltaTime;
}

boolean PathPoint::is_bound() const
{
if (bound_flag) return TRUE;
if(field_pathPosition.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_pathDeltaTime.get_selection() || field_pathDeltaTime.is_bound()) return TRUE;
return FALSE;
}
boolean PathPoint::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_pathPosition.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_pathDeltaTime.get_selection() && !field_pathDeltaTime.is_value()) return FALSE;
return TRUE;
}
int PathPoint::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.PathPoint");
  int ret_val = 1;
  if (field_pathDeltaTime.ispresent()) ret_val++;
  return ret_val;
}

void PathPoint::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ pathPosition := ");
field_pathPosition.log();
TTCN_Logger::log_event_str(", pathDeltaTime := ");
field_pathDeltaTime.log();
TTCN_Logger::log_event_str(" }");
}

void PathPoint::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.PathPoint'");
    }
    if (strcmp("pathPosition", param_field) == 0) {
      pathPosition().set_param(param);
      return;
    } else if (strcmp("pathDeltaTime", param_field) == 0) {
      pathDeltaTime().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.PathPoint'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.PathPoint has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) pathPosition().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pathDeltaTime().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pathPosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pathPosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pathDeltaTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pathDeltaTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.PathPoint: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.PathPoint");
  }
}

Module_Param* PathPoint::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.PathPoint'");
    }
    if (strcmp("pathPosition", param_field) == 0) {
      return pathPosition().get_param(param_name);
    } else if (strcmp("pathDeltaTime", param_field) == 0) {
      return pathDeltaTime().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.PathPoint'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_pathPosition = field_pathPosition.get_param(param_name);
  mp_field_pathPosition->set_id(new Module_Param_FieldName(mcopystr("pathPosition")));
  mp->add_elem(mp_field_pathPosition);
  Module_Param* mp_field_pathDeltaTime = field_pathDeltaTime.get_param(param_name);
  mp_field_pathDeltaTime->set_id(new Module_Param_FieldName(mcopystr("pathDeltaTime")));
  mp->add_elem(mp_field_pathDeltaTime);
  return mp;
  }

void PathPoint::set_implicit_omit()
{
if (pathPosition().is_bound()) pathPosition().set_implicit_omit();
if (!pathDeltaTime().is_bound()) pathDeltaTime() = OMIT_VALUE;
else pathDeltaTime().set_implicit_omit();
}

void PathPoint::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.PathPoint.");
field_pathPosition.encode_text(text_buf);
field_pathDeltaTime.encode_text(text_buf);
}

void PathPoint::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_pathPosition.decode_text(text_buf);
field_pathDeltaTime.decode_text(text_buf);
}

void PathPoint::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PathPoint::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* PathPoint::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("pathPosition': ");
  new_tlv->add_TLV(field_pathPosition.BER_encode_TLV(PathPoint_pathPosition_descr_, p_coding));
  ec_1.set_msg("pathDeltaTime': ");
  new_tlv->add_TLV(field_pathDeltaTime.BER_encode_TLV(PathPoint_pathDeltaTime_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean PathPoint::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.PathPoint' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("pathPosition': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_pathPosition.BER_decode_TLV(PathPoint_pathPosition_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("pathDeltaTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_pathDeltaTime=OMIT_VALUE;
    else {
      field_pathDeltaTime.BER_decode_TLV(PathPoint_pathDeltaTime_descr_, tmp_tlv, L_form);
      if(field_pathDeltaTime.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int PathPoint::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.PathPoint.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "pathPosition");
    enc_len += field_pathPosition.JSON_encode(PathPoint_pathPosition_descr_, p_tok);
  }

  if (field_pathDeltaTime.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "pathDeltaTime");
    enc_len += field_pathDeltaTime.JSON_encode(PathPoint_pathDeltaTime_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int PathPoint::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "pathPosition", name_len)) {
         int ret_val = field_pathPosition.JSON_decode(PathPoint_pathPosition_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "pathPosition");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "pathDeltaTime", name_len)) {
         int ret_val = field_pathDeltaTime.JSON_decode(PathPoint_pathDeltaTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "pathDeltaTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_pathPosition.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "pathPosition");
    return JSON_ERROR_FATAL;
  }
if (!field_pathDeltaTime.is_bound()) {
    field_pathDeltaTime = OMIT_VALUE;
  }

  return dec_len;
}

struct PathPoint_template::single_value_struct {
DeltaReferencePosition_template field_pathPosition;
INTEGER_template field_pathDeltaTime;
};

void PathPoint_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_pathPosition = ANY_VALUE;
single_value->field_pathDeltaTime = ANY_OR_OMIT;
}
}
}

void PathPoint_template::copy_value(const PathPoint& other_value)
{
single_value = new single_value_struct;
if (other_value.pathPosition().is_bound()) {
  single_value->field_pathPosition = other_value.pathPosition();
} else {
  single_value->field_pathPosition.clean_up();
}
if (other_value.pathDeltaTime().is_bound()) {
  if (other_value.pathDeltaTime().ispresent()) single_value->field_pathDeltaTime = other_value.pathDeltaTime()();
  else single_value->field_pathDeltaTime = OMIT_VALUE;
} else {
  single_value->field_pathDeltaTime.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PathPoint_template::copy_template(const PathPoint_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.pathPosition().get_selection()) {
single_value->field_pathPosition = other_value.pathPosition();
} else {
single_value->field_pathPosition.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.pathDeltaTime().get_selection()) {
single_value->field_pathDeltaTime = other_value.pathDeltaTime();
} else {
single_value->field_pathDeltaTime.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PathPoint_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.PathPoint.");
break;
}
set_selection(other_value);
}

PathPoint_template::PathPoint_template()
{
}

PathPoint_template::PathPoint_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PathPoint_template::PathPoint_template(const PathPoint& other_value)
{
copy_value(other_value);
}

PathPoint_template::PathPoint_template(const OPTIONAL<PathPoint>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PathPoint&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.PathPoint from an unbound optional field.");
}
}

PathPoint_template::PathPoint_template(const PathPoint_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PathPoint_template::~PathPoint_template()
{
clean_up();
}

PathPoint_template& PathPoint_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PathPoint_template& PathPoint_template::operator=(const PathPoint& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PathPoint_template& PathPoint_template::operator=(const OPTIONAL<PathPoint>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PathPoint&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.PathPoint.");
}
return *this;
}

PathPoint_template& PathPoint_template::operator=(const PathPoint_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PathPoint_template::match(const PathPoint& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.pathPosition().is_bound()) return FALSE;
if(!single_value->field_pathPosition.match(other_value.pathPosition(), legacy))return FALSE;
if(!other_value.pathDeltaTime().is_bound()) return FALSE;
if((other_value.pathDeltaTime().ispresent() ? !single_value->field_pathDeltaTime.match((const INTEGER&)other_value.pathDeltaTime(), legacy) : !single_value->field_pathDeltaTime.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.PathPoint.");
}
return FALSE;
}

boolean PathPoint_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_pathPosition.is_bound()) return TRUE;
if (single_value->field_pathDeltaTime.is_omit() || single_value->field_pathDeltaTime.is_bound()) return TRUE;
return FALSE;
}

boolean PathPoint_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_pathPosition.is_value()) return FALSE;
if (!single_value->field_pathDeltaTime.is_omit() && !single_value->field_pathDeltaTime.is_value()) return FALSE;
return TRUE;
}

void PathPoint_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PathPoint PathPoint_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.PathPoint.");
PathPoint ret_val;
if (single_value->field_pathPosition.is_bound()) {
ret_val.pathPosition() = single_value->field_pathPosition.valueof();
}
if (single_value->field_pathDeltaTime.is_omit()) ret_val.pathDeltaTime() = OMIT_VALUE;
else if (single_value->field_pathDeltaTime.is_bound()) {
ret_val.pathDeltaTime() = single_value->field_pathDeltaTime.valueof();
}
return ret_val;
}

void PathPoint_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.PathPoint.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PathPoint_template[list_length];
}

PathPoint_template& PathPoint_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.PathPoint.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.PathPoint.");
return value_list.list_value[list_index];
}

DeltaReferencePosition_template& PathPoint_template::pathPosition()
{
set_specific();
return single_value->field_pathPosition;
}

const DeltaReferencePosition_template& PathPoint_template::pathPosition() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field pathPosition of a non-specific template of type @ITS-Container.PathPoint.");
return single_value->field_pathPosition;
}

INTEGER_template& PathPoint_template::pathDeltaTime()
{
set_specific();
return single_value->field_pathDeltaTime;
}

const INTEGER_template& PathPoint_template::pathDeltaTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field pathDeltaTime of a non-specific template of type @ITS-Container.PathPoint.");
return single_value->field_pathDeltaTime;
}

int PathPoint_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PathPoint which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_pathDeltaTime.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.PathPoint containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PathPoint containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PathPoint containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PathPoint containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PathPoint containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.PathPoint.");
  }
  return 0;
}

void PathPoint_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ pathPosition := ");
single_value->field_pathPosition.log();
TTCN_Logger::log_event_str(", pathDeltaTime := ");
single_value->field_pathDeltaTime.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PathPoint_template::log_match(const PathPoint& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_pathPosition.match(match_value.pathPosition(), legacy)){
TTCN_Logger::log_logmatch_info(".pathPosition");
single_value->field_pathPosition.log_match(match_value.pathPosition(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.pathDeltaTime().ispresent()){
if(!single_value->field_pathDeltaTime.match(match_value.pathDeltaTime(), legacy)){
TTCN_Logger::log_logmatch_info(".pathDeltaTime");
single_value->field_pathDeltaTime.log_match(match_value.pathDeltaTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_pathDeltaTime.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".pathDeltaTime := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_pathDeltaTime.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ pathPosition := ");
single_value->field_pathPosition.log_match(match_value.pathPosition(), legacy);
TTCN_Logger::log_event_str(", pathDeltaTime := ");
if (match_value.pathDeltaTime().ispresent()) single_value->field_pathDeltaTime.log_match(match_value.pathDeltaTime(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_pathDeltaTime.log();
if (single_value->field_pathDeltaTime.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PathPoint_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_pathPosition.encode_text(text_buf);
single_value->field_pathDeltaTime.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.PathPoint.");
}
}

void PathPoint_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_pathPosition.decode_text(text_buf);
single_value->field_pathDeltaTime.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PathPoint_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.PathPoint.");
}
}

void PathPoint_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.PathPoint'");
    }
    if (strcmp("pathPosition", param_field) == 0) {
      pathPosition().set_param(param);
      return;
    } else if (strcmp("pathDeltaTime", param_field) == 0) {
      pathDeltaTime().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.PathPoint'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PathPoint_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.PathPoint has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) pathPosition().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pathDeltaTime().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pathPosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pathPosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pathDeltaTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pathDeltaTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.PathPoint: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.PathPoint");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PathPoint_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.PathPoint'");
    }
    if (strcmp("pathPosition", param_field) == 0) {
      return pathPosition().get_param(param_name);
    } else if (strcmp("pathDeltaTime", param_field) == 0) {
      return pathDeltaTime().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.PathPoint'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_pathPosition = single_value->field_pathPosition.get_param(param_name);
    mp_field_pathPosition->set_id(new Module_Param_FieldName(mcopystr("pathPosition")));
    mp->add_elem(mp_field_pathPosition);
    Module_Param* mp_field_pathDeltaTime = single_value->field_pathDeltaTime.get_param(param_name);
    mp_field_pathDeltaTime->set_id(new Module_Param_FieldName(mcopystr("pathDeltaTime")));
    mp->add_elem(mp_field_pathDeltaTime);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PathPoint_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_pathPosition.check_restriction(t_res, t_name ? t_name : "@ITS-Container.PathPoint");
single_value->field_pathDeltaTime.check_restriction(t_res, t_name ? t_name : "@ITS-Container.PathPoint");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.PathPoint");
}

boolean PathPoint_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PathPoint_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PtActivation::PtActivation()
{
  bound_flag = FALSE;
}

PtActivation::PtActivation(const INTEGER& par_ptActivationType,
    const OCTETSTRING& par_ptActivationData)
  :   field_ptActivationType(par_ptActivationType),
  field_ptActivationData(par_ptActivationData)
{
  bound_flag = TRUE;
}

PtActivation::PtActivation(const PtActivation& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.PtActivation.");
bound_flag = TRUE;
if (other_value.ptActivationType().is_bound()) field_ptActivationType = other_value.ptActivationType();
else field_ptActivationType.clean_up();
if (other_value.ptActivationData().is_bound()) field_ptActivationData = other_value.ptActivationData();
else field_ptActivationData.clean_up();
}

void PtActivation::clean_up()
{
field_ptActivationType.clean_up();
field_ptActivationData.clean_up();
bound_flag = FALSE;
}

PtActivation& PtActivation::operator=(const PtActivation& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.PtActivation.");
  bound_flag = TRUE;
  if (other_value.ptActivationType().is_bound()) field_ptActivationType = other_value.ptActivationType();
  else field_ptActivationType.clean_up();
  if (other_value.ptActivationData().is_bound()) field_ptActivationData = other_value.ptActivationData();
  else field_ptActivationData.clean_up();
}
return *this;
}

boolean PtActivation::operator==(const PtActivation& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_ptActivationType==other_value.field_ptActivationType
  && field_ptActivationData==other_value.field_ptActivationData;
}

boolean PtActivation::is_bound() const
{
if (bound_flag) return TRUE;
if(field_ptActivationType.is_bound()) return TRUE;
if(field_ptActivationData.is_bound()) return TRUE;
return FALSE;
}
boolean PtActivation::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_ptActivationType.is_value()) return FALSE;
if(!field_ptActivationData.is_value()) return FALSE;
return TRUE;
}
int PtActivation::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.PtActivation");
  return 2;
}

void PtActivation::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ ptActivationType := ");
field_ptActivationType.log();
TTCN_Logger::log_event_str(", ptActivationData := ");
field_ptActivationData.log();
TTCN_Logger::log_event_str(" }");
}

void PtActivation::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.PtActivation'");
    }
    if (strcmp("ptActivationType", param_field) == 0) {
      ptActivationType().set_param(param);
      return;
    } else if (strcmp("ptActivationData", param_field) == 0) {
      ptActivationData().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.PtActivation'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.PtActivation has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ptActivationType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ptActivationData().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.PtActivation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.PtActivation");
  }
}

Module_Param* PtActivation::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.PtActivation'");
    }
    if (strcmp("ptActivationType", param_field) == 0) {
      return ptActivationType().get_param(param_name);
    } else if (strcmp("ptActivationData", param_field) == 0) {
      return ptActivationData().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.PtActivation'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_ptActivationType = field_ptActivationType.get_param(param_name);
  mp_field_ptActivationType->set_id(new Module_Param_FieldName(mcopystr("ptActivationType")));
  mp->add_elem(mp_field_ptActivationType);
  Module_Param* mp_field_ptActivationData = field_ptActivationData.get_param(param_name);
  mp_field_ptActivationData->set_id(new Module_Param_FieldName(mcopystr("ptActivationData")));
  mp->add_elem(mp_field_ptActivationData);
  return mp;
  }

void PtActivation::set_implicit_omit()
{
if (ptActivationType().is_bound()) ptActivationType().set_implicit_omit();
if (ptActivationData().is_bound()) ptActivationData().set_implicit_omit();
}

void PtActivation::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.PtActivation.");
field_ptActivationType.encode_text(text_buf);
field_ptActivationData.encode_text(text_buf);
}

void PtActivation::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_ptActivationType.decode_text(text_buf);
field_ptActivationData.decode_text(text_buf);
}

void PtActivation::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PtActivation::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* PtActivation::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("ptActivationType': ");
  new_tlv->add_TLV(field_ptActivationType.BER_encode_TLV(PtActivation_ptActivationType_descr_, p_coding));
  ec_1.set_msg("ptActivationData': ");
  new_tlv->add_TLV(field_ptActivationData.BER_encode_TLV(PtActivation_ptActivationData_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean PtActivation::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.PtActivation' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("ptActivationType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_ptActivationType.BER_decode_TLV(PtActivation_ptActivationType_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("ptActivationData': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_ptActivationData.BER_decode_TLV(PtActivation_ptActivationData_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int PtActivation::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.PtActivation.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ptActivationType");
    enc_len += field_ptActivationType.JSON_encode(PtActivation_ptActivationType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ptActivationData");
    enc_len += field_ptActivationData.JSON_encode(PtActivation_ptActivationData_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int PtActivation::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (16 == name_len && 0 == strncmp(fld_name, "ptActivationType", name_len)) {
         int ret_val = field_ptActivationType.JSON_decode(PtActivation_ptActivationType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ptActivationType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "ptActivationData", name_len)) {
         int ret_val = field_ptActivationData.JSON_decode(PtActivation_ptActivationData_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ptActivationData");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_ptActivationType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ptActivationType");
    return JSON_ERROR_FATAL;
  }
if (!field_ptActivationData.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ptActivationData");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct PtActivation_template::single_value_struct {
INTEGER_template field_ptActivationType;
OCTETSTRING_template field_ptActivationData;
};

void PtActivation_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_ptActivationType = ANY_VALUE;
single_value->field_ptActivationData = ANY_VALUE;
}
}
}

void PtActivation_template::copy_value(const PtActivation& other_value)
{
single_value = new single_value_struct;
if (other_value.ptActivationType().is_bound()) {
  single_value->field_ptActivationType = other_value.ptActivationType();
} else {
  single_value->field_ptActivationType.clean_up();
}
if (other_value.ptActivationData().is_bound()) {
  single_value->field_ptActivationData = other_value.ptActivationData();
} else {
  single_value->field_ptActivationData.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PtActivation_template::copy_template(const PtActivation_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.ptActivationType().get_selection()) {
single_value->field_ptActivationType = other_value.ptActivationType();
} else {
single_value->field_ptActivationType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ptActivationData().get_selection()) {
single_value->field_ptActivationData = other_value.ptActivationData();
} else {
single_value->field_ptActivationData.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PtActivation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.PtActivation.");
break;
}
set_selection(other_value);
}

PtActivation_template::PtActivation_template()
{
}

PtActivation_template::PtActivation_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PtActivation_template::PtActivation_template(const PtActivation& other_value)
{
copy_value(other_value);
}

PtActivation_template::PtActivation_template(const OPTIONAL<PtActivation>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PtActivation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.PtActivation from an unbound optional field.");
}
}

PtActivation_template::PtActivation_template(const PtActivation_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PtActivation_template::~PtActivation_template()
{
clean_up();
}

PtActivation_template& PtActivation_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PtActivation_template& PtActivation_template::operator=(const PtActivation& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PtActivation_template& PtActivation_template::operator=(const OPTIONAL<PtActivation>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PtActivation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.PtActivation.");
}
return *this;
}

PtActivation_template& PtActivation_template::operator=(const PtActivation_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PtActivation_template::match(const PtActivation& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.ptActivationType().is_bound()) return FALSE;
if(!single_value->field_ptActivationType.match(other_value.ptActivationType(), legacy))return FALSE;
if(!other_value.ptActivationData().is_bound()) return FALSE;
if(!single_value->field_ptActivationData.match(other_value.ptActivationData(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.PtActivation.");
}
return FALSE;
}

boolean PtActivation_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_ptActivationType.is_bound()) return TRUE;
if (single_value->field_ptActivationData.is_bound()) return TRUE;
return FALSE;
}

boolean PtActivation_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_ptActivationType.is_value()) return FALSE;
if (!single_value->field_ptActivationData.is_value()) return FALSE;
return TRUE;
}

void PtActivation_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PtActivation PtActivation_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.PtActivation.");
PtActivation ret_val;
if (single_value->field_ptActivationType.is_bound()) {
ret_val.ptActivationType() = single_value->field_ptActivationType.valueof();
}
if (single_value->field_ptActivationData.is_bound()) {
ret_val.ptActivationData() = single_value->field_ptActivationData.valueof();
}
return ret_val;
}

void PtActivation_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.PtActivation.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PtActivation_template[list_length];
}

PtActivation_template& PtActivation_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.PtActivation.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.PtActivation.");
return value_list.list_value[list_index];
}

INTEGER_template& PtActivation_template::ptActivationType()
{
set_specific();
return single_value->field_ptActivationType;
}

const INTEGER_template& PtActivation_template::ptActivationType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ptActivationType of a non-specific template of type @ITS-Container.PtActivation.");
return single_value->field_ptActivationType;
}

OCTETSTRING_template& PtActivation_template::ptActivationData()
{
set_specific();
return single_value->field_ptActivationData;
}

const OCTETSTRING_template& PtActivation_template::ptActivationData() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ptActivationData of a non-specific template of type @ITS-Container.PtActivation.");
return single_value->field_ptActivationData;
}

int PtActivation_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PtActivation which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.PtActivation containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PtActivation containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PtActivation containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PtActivation containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.PtActivation containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.PtActivation.");
  }
  return 0;
}

void PtActivation_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ ptActivationType := ");
single_value->field_ptActivationType.log();
TTCN_Logger::log_event_str(", ptActivationData := ");
single_value->field_ptActivationData.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PtActivation_template::log_match(const PtActivation& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_ptActivationType.match(match_value.ptActivationType(), legacy)){
TTCN_Logger::log_logmatch_info(".ptActivationType");
single_value->field_ptActivationType.log_match(match_value.ptActivationType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ptActivationData.match(match_value.ptActivationData(), legacy)){
TTCN_Logger::log_logmatch_info(".ptActivationData");
single_value->field_ptActivationData.log_match(match_value.ptActivationData(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ ptActivationType := ");
single_value->field_ptActivationType.log_match(match_value.ptActivationType(), legacy);
TTCN_Logger::log_event_str(", ptActivationData := ");
single_value->field_ptActivationData.log_match(match_value.ptActivationData(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PtActivation_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_ptActivationType.encode_text(text_buf);
single_value->field_ptActivationData.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.PtActivation.");
}
}

void PtActivation_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_ptActivationType.decode_text(text_buf);
single_value->field_ptActivationData.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PtActivation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.PtActivation.");
}
}

void PtActivation_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.PtActivation'");
    }
    if (strcmp("ptActivationType", param_field) == 0) {
      ptActivationType().set_param(param);
      return;
    } else if (strcmp("ptActivationData", param_field) == 0) {
      ptActivationData().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.PtActivation'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PtActivation_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.PtActivation has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ptActivationType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ptActivationData().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ptActivationData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ptActivationData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.PtActivation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.PtActivation");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PtActivation_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.PtActivation'");
    }
    if (strcmp("ptActivationType", param_field) == 0) {
      return ptActivationType().get_param(param_name);
    } else if (strcmp("ptActivationData", param_field) == 0) {
      return ptActivationData().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.PtActivation'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_ptActivationType = single_value->field_ptActivationType.get_param(param_name);
    mp_field_ptActivationType->set_id(new Module_Param_FieldName(mcopystr("ptActivationType")));
    mp->add_elem(mp_field_ptActivationType);
    Module_Param* mp_field_ptActivationData = single_value->field_ptActivationData.get_param(param_name);
    mp_field_ptActivationData->set_id(new Module_Param_FieldName(mcopystr("ptActivationData")));
    mp->add_elem(mp_field_ptActivationData);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PtActivation_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_ptActivationType.check_restriction(t_res, t_name ? t_name : "@ITS-Container.PtActivation");
single_value->field_ptActivationData.check_restriction(t_res, t_name ? t_name : "@ITS-Container.PtActivation");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.PtActivation");
}

boolean PtActivation_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PtActivation_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

CauseCode::CauseCode()
{
  bound_flag = FALSE;
}

CauseCode::CauseCode(const INTEGER& par_causeCode,
    const INTEGER& par_subCauseCode)
  :   field_causeCode(par_causeCode),
  field_subCauseCode(par_subCauseCode)
{
  bound_flag = TRUE;
}

CauseCode::CauseCode(const CauseCode& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.CauseCode.");
bound_flag = TRUE;
if (other_value.causeCode().is_bound()) field_causeCode = other_value.causeCode();
else field_causeCode.clean_up();
if (other_value.subCauseCode().is_bound()) field_subCauseCode = other_value.subCauseCode();
else field_subCauseCode.clean_up();
}

void CauseCode::clean_up()
{
field_causeCode.clean_up();
field_subCauseCode.clean_up();
bound_flag = FALSE;
}

CauseCode& CauseCode::operator=(const CauseCode& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.CauseCode.");
  bound_flag = TRUE;
  if (other_value.causeCode().is_bound()) field_causeCode = other_value.causeCode();
  else field_causeCode.clean_up();
  if (other_value.subCauseCode().is_bound()) field_subCauseCode = other_value.subCauseCode();
  else field_subCauseCode.clean_up();
}
return *this;
}

boolean CauseCode::operator==(const CauseCode& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_causeCode==other_value.field_causeCode
  && field_subCauseCode==other_value.field_subCauseCode;
}

boolean CauseCode::is_bound() const
{
if (bound_flag) return TRUE;
if(field_causeCode.is_bound()) return TRUE;
if(field_subCauseCode.is_bound()) return TRUE;
return FALSE;
}
boolean CauseCode::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_causeCode.is_value()) return FALSE;
if(!field_subCauseCode.is_value()) return FALSE;
return TRUE;
}
int CauseCode::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.CauseCode");
  return 2;
}

void CauseCode::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ causeCode := ");
field_causeCode.log();
TTCN_Logger::log_event_str(", subCauseCode := ");
field_subCauseCode.log();
TTCN_Logger::log_event_str(" }");
}

void CauseCode::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.CauseCode'");
    }
    if (strcmp("causeCode", param_field) == 0) {
      causeCode().set_param(param);
      return;
    } else if (strcmp("subCauseCode", param_field) == 0) {
      subCauseCode().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.CauseCode'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.CauseCode has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) causeCode().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) subCauseCode().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "causeCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          causeCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subCauseCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subCauseCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.CauseCode: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.CauseCode");
  }
}

Module_Param* CauseCode::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.CauseCode'");
    }
    if (strcmp("causeCode", param_field) == 0) {
      return causeCode().get_param(param_name);
    } else if (strcmp("subCauseCode", param_field) == 0) {
      return subCauseCode().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.CauseCode'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_causeCode = field_causeCode.get_param(param_name);
  mp_field_causeCode->set_id(new Module_Param_FieldName(mcopystr("causeCode")));
  mp->add_elem(mp_field_causeCode);
  Module_Param* mp_field_subCauseCode = field_subCauseCode.get_param(param_name);
  mp_field_subCauseCode->set_id(new Module_Param_FieldName(mcopystr("subCauseCode")));
  mp->add_elem(mp_field_subCauseCode);
  return mp;
  }

void CauseCode::set_implicit_omit()
{
if (causeCode().is_bound()) causeCode().set_implicit_omit();
if (subCauseCode().is_bound()) subCauseCode().set_implicit_omit();
}

void CauseCode::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.CauseCode.");
field_causeCode.encode_text(text_buf);
field_subCauseCode.encode_text(text_buf);
}

void CauseCode::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_causeCode.decode_text(text_buf);
field_subCauseCode.decode_text(text_buf);
}

void CauseCode::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CauseCode::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* CauseCode::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("causeCode': ");
  new_tlv->add_TLV(field_causeCode.BER_encode_TLV(CauseCode_causeCode_descr_, p_coding));
  ec_1.set_msg("subCauseCode': ");
  new_tlv->add_TLV(field_subCauseCode.BER_encode_TLV(CauseCode_subCauseCode_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean CauseCode::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.CauseCode' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("causeCode': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_causeCode.BER_decode_TLV(CauseCode_causeCode_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("subCauseCode': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_subCauseCode.BER_decode_TLV(CauseCode_subCauseCode_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int CauseCode::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.CauseCode.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "causeCode");
    enc_len += field_causeCode.JSON_encode(CauseCode_causeCode_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "subCauseCode");
    enc_len += field_subCauseCode.JSON_encode(CauseCode_subCauseCode_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CauseCode::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "causeCode", name_len)) {
         int ret_val = field_causeCode.JSON_decode(CauseCode_causeCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "causeCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "subCauseCode", name_len)) {
         int ret_val = field_subCauseCode.JSON_decode(CauseCode_subCauseCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "subCauseCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_causeCode.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "causeCode");
    return JSON_ERROR_FATAL;
  }
if (!field_subCauseCode.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "subCauseCode");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct CauseCode_template::single_value_struct {
INTEGER_template field_causeCode;
INTEGER_template field_subCauseCode;
};

void CauseCode_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_causeCode = ANY_VALUE;
single_value->field_subCauseCode = ANY_VALUE;
}
}
}

void CauseCode_template::copy_value(const CauseCode& other_value)
{
single_value = new single_value_struct;
if (other_value.causeCode().is_bound()) {
  single_value->field_causeCode = other_value.causeCode();
} else {
  single_value->field_causeCode.clean_up();
}
if (other_value.subCauseCode().is_bound()) {
  single_value->field_subCauseCode = other_value.subCauseCode();
} else {
  single_value->field_subCauseCode.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CauseCode_template::copy_template(const CauseCode_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.causeCode().get_selection()) {
single_value->field_causeCode = other_value.causeCode();
} else {
single_value->field_causeCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.subCauseCode().get_selection()) {
single_value->field_subCauseCode = other_value.subCauseCode();
} else {
single_value->field_subCauseCode.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CauseCode_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.CauseCode.");
break;
}
set_selection(other_value);
}

CauseCode_template::CauseCode_template()
{
}

CauseCode_template::CauseCode_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CauseCode_template::CauseCode_template(const CauseCode& other_value)
{
copy_value(other_value);
}

CauseCode_template::CauseCode_template(const OPTIONAL<CauseCode>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CauseCode&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.CauseCode from an unbound optional field.");
}
}

CauseCode_template::CauseCode_template(const CauseCode_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CauseCode_template::~CauseCode_template()
{
clean_up();
}

CauseCode_template& CauseCode_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CauseCode_template& CauseCode_template::operator=(const CauseCode& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CauseCode_template& CauseCode_template::operator=(const OPTIONAL<CauseCode>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CauseCode&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.CauseCode.");
}
return *this;
}

CauseCode_template& CauseCode_template::operator=(const CauseCode_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CauseCode_template::match(const CauseCode& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.causeCode().is_bound()) return FALSE;
if(!single_value->field_causeCode.match(other_value.causeCode(), legacy))return FALSE;
if(!other_value.subCauseCode().is_bound()) return FALSE;
if(!single_value->field_subCauseCode.match(other_value.subCauseCode(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.CauseCode.");
}
return FALSE;
}

boolean CauseCode_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_causeCode.is_bound()) return TRUE;
if (single_value->field_subCauseCode.is_bound()) return TRUE;
return FALSE;
}

boolean CauseCode_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_causeCode.is_value()) return FALSE;
if (!single_value->field_subCauseCode.is_value()) return FALSE;
return TRUE;
}

void CauseCode_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CauseCode CauseCode_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.CauseCode.");
CauseCode ret_val;
if (single_value->field_causeCode.is_bound()) {
ret_val.causeCode() = single_value->field_causeCode.valueof();
}
if (single_value->field_subCauseCode.is_bound()) {
ret_val.subCauseCode() = single_value->field_subCauseCode.valueof();
}
return ret_val;
}

void CauseCode_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.CauseCode.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CauseCode_template[list_length];
}

CauseCode_template& CauseCode_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.CauseCode.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.CauseCode.");
return value_list.list_value[list_index];
}

INTEGER_template& CauseCode_template::causeCode()
{
set_specific();
return single_value->field_causeCode;
}

const INTEGER_template& CauseCode_template::causeCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field causeCode of a non-specific template of type @ITS-Container.CauseCode.");
return single_value->field_causeCode;
}

INTEGER_template& CauseCode_template::subCauseCode()
{
set_specific();
return single_value->field_subCauseCode;
}

const INTEGER_template& CauseCode_template::subCauseCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field subCauseCode of a non-specific template of type @ITS-Container.CauseCode.");
return single_value->field_subCauseCode;
}

int CauseCode_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CauseCode which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.CauseCode containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CauseCode containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CauseCode containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CauseCode containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CauseCode containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.CauseCode.");
  }
  return 0;
}

void CauseCode_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ causeCode := ");
single_value->field_causeCode.log();
TTCN_Logger::log_event_str(", subCauseCode := ");
single_value->field_subCauseCode.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CauseCode_template::log_match(const CauseCode& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_causeCode.match(match_value.causeCode(), legacy)){
TTCN_Logger::log_logmatch_info(".causeCode");
single_value->field_causeCode.log_match(match_value.causeCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_subCauseCode.match(match_value.subCauseCode(), legacy)){
TTCN_Logger::log_logmatch_info(".subCauseCode");
single_value->field_subCauseCode.log_match(match_value.subCauseCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ causeCode := ");
single_value->field_causeCode.log_match(match_value.causeCode(), legacy);
TTCN_Logger::log_event_str(", subCauseCode := ");
single_value->field_subCauseCode.log_match(match_value.subCauseCode(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CauseCode_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_causeCode.encode_text(text_buf);
single_value->field_subCauseCode.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.CauseCode.");
}
}

void CauseCode_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_causeCode.decode_text(text_buf);
single_value->field_subCauseCode.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CauseCode_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.CauseCode.");
}
}

void CauseCode_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.CauseCode'");
    }
    if (strcmp("causeCode", param_field) == 0) {
      causeCode().set_param(param);
      return;
    } else if (strcmp("subCauseCode", param_field) == 0) {
      subCauseCode().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.CauseCode'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CauseCode_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.CauseCode has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) causeCode().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) subCauseCode().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "causeCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          causeCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subCauseCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subCauseCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.CauseCode: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.CauseCode");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CauseCode_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.CauseCode'");
    }
    if (strcmp("causeCode", param_field) == 0) {
      return causeCode().get_param(param_name);
    } else if (strcmp("subCauseCode", param_field) == 0) {
      return subCauseCode().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.CauseCode'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_causeCode = single_value->field_causeCode.get_param(param_name);
    mp_field_causeCode->set_id(new Module_Param_FieldName(mcopystr("causeCode")));
    mp->add_elem(mp_field_causeCode);
    Module_Param* mp_field_subCauseCode = single_value->field_subCauseCode.get_param(param_name);
    mp_field_subCauseCode->set_id(new Module_Param_FieldName(mcopystr("subCauseCode")));
    mp->add_elem(mp_field_subCauseCode);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CauseCode_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_causeCode.check_restriction(t_res, t_name ? t_name : "@ITS-Container.CauseCode");
single_value->field_subCauseCode.check_restriction(t_res, t_name ? t_name : "@ITS-Container.CauseCode");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.CauseCode");
}

boolean CauseCode_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CauseCode_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

CurvatureConfidence::CurvatureConfidence()
{
enum_value = UNBOUND_VALUE;
}

CurvatureConfidence::CurvatureConfidence(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.CurvatureConfidence with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

CurvatureConfidence::CurvatureConfidence(enum_type other_value)
{
enum_value = other_value;
}

CurvatureConfidence::CurvatureConfidence(const CurvatureConfidence& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
enum_value = other_value.enum_value;
}

CurvatureConfidence& CurvatureConfidence::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.CurvatureConfidence.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

CurvatureConfidence& CurvatureConfidence::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

CurvatureConfidence& CurvatureConfidence::operator=(const CurvatureConfidence& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
enum_value = other_value.enum_value;
return *this;
}

boolean CurvatureConfidence::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
return enum_value == other_value;
}

boolean CurvatureConfidence::operator==(const CurvatureConfidence& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
return enum_value == other_value.enum_value;
}

boolean CurvatureConfidence::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
return enum_value < other_value;
}

boolean CurvatureConfidence::operator<(const CurvatureConfidence& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
return enum_value < other_value.enum_value;
}

boolean CurvatureConfidence::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
return enum_value > other_value;
}

boolean CurvatureConfidence::operator>(const CurvatureConfidence& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
return enum_value > other_value.enum_value;
}

const char *CurvatureConfidence::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case onePerMeter__0__00002: return "onePerMeter_0_00002";
case onePerMeter__0__0001: return "onePerMeter_0_0001";
case onePerMeter__0__0005: return "onePerMeter_0_0005";
case onePerMeter__0__002: return "onePerMeter_0_002";
case onePerMeter__0__01: return "onePerMeter_0_01";
case onePerMeter__0__1: return "onePerMeter_0_1";
case outOfRange: return "outOfRange";
case unavailable: return "unavailable";
default: return "<unknown>";
}
}

CurvatureConfidence::enum_type CurvatureConfidence::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "onePerMeter_0_00002")) return onePerMeter__0__00002;
else if (!strcmp(str_par, "onePerMeter_0_0001")) return onePerMeter__0__0001;
else if (!strcmp(str_par, "onePerMeter_0_0005")) return onePerMeter__0__0005;
else if (!strcmp(str_par, "onePerMeter_0_002")) return onePerMeter__0__002;
else if (!strcmp(str_par, "onePerMeter_0_01")) return onePerMeter__0__01;
else if (!strcmp(str_par, "onePerMeter_0_1")) return onePerMeter__0__1;
else if (!strcmp(str_par, "outOfRange")) return outOfRange;
else if (!strcmp(str_par, "unavailable")) return unavailable;
else return UNKNOWN_VALUE;
}

boolean CurvatureConfidence::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
return TRUE;
default:
return FALSE;
}
}

int CurvatureConfidence::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.CurvatureConfidence.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int CurvatureConfidence::enum2int(const CurvatureConfidence& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.CurvatureConfidence.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void CurvatureConfidence::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.CurvatureConfidence.", int_val);
enum_value = (enum_type)int_val;
}

CurvatureConfidence::operator CurvatureConfidence::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.CurvatureConfidence.");
return enum_value;
}

void CurvatureConfidence::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void CurvatureConfidence::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.CurvatureConfidence");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.CurvatureConfidence.");
  }
}

Module_Param* CurvatureConfidence::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void CurvatureConfidence::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
text_buf.push_int(enum_value);
}

void CurvatureConfidence::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.CurvatureConfidence.", enum_value);
}

void CurvatureConfidence::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CurvatureConfidence::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* CurvatureConfidence::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean CurvatureConfidence::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.CurvatureConfidence: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int CurvatureConfidence::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int CurvatureConfidence::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void CurvatureConfidence_template::copy_template(const CurvatureConfidence_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CurvatureConfidence_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.CurvatureConfidence.");
}
}

CurvatureConfidence_template::CurvatureConfidence_template()
{
}

CurvatureConfidence_template::CurvatureConfidence_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CurvatureConfidence_template::CurvatureConfidence_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!CurvatureConfidence::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.CurvatureConfidence with unknown numeric value %d.", other_value);
single_value = (CurvatureConfidence::enum_type)other_value;
}

CurvatureConfidence_template::CurvatureConfidence_template(CurvatureConfidence::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

CurvatureConfidence_template::CurvatureConfidence_template(const CurvatureConfidence& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == CurvatureConfidence::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.CurvatureConfidence.");
single_value = other_value.enum_value;
}

CurvatureConfidence_template::CurvatureConfidence_template(const OPTIONAL<CurvatureConfidence>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (CurvatureConfidence::enum_type)(const CurvatureConfidence&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.CurvatureConfidence from an unbound optional field.");
}
}

CurvatureConfidence_template::CurvatureConfidence_template(const CurvatureConfidence_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

CurvatureConfidence_template::~CurvatureConfidence_template()
{
clean_up();
}

boolean CurvatureConfidence_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean CurvatureConfidence_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != CurvatureConfidence::UNBOUND_VALUE;
}

void CurvatureConfidence_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

CurvatureConfidence_template& CurvatureConfidence_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CurvatureConfidence_template& CurvatureConfidence_template::operator=(int other_value)
{
if (!CurvatureConfidence::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.CurvatureConfidence.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (CurvatureConfidence::enum_type)other_value;
return *this;
}

CurvatureConfidence_template& CurvatureConfidence_template::operator=(CurvatureConfidence::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

CurvatureConfidence_template& CurvatureConfidence_template::operator=(const CurvatureConfidence& other_value)
{
if (other_value.enum_value == CurvatureConfidence::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.CurvatureConfidence to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

CurvatureConfidence_template& CurvatureConfidence_template::operator=(const OPTIONAL<CurvatureConfidence>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (CurvatureConfidence::enum_type)(const CurvatureConfidence&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.CurvatureConfidence.");
}
return *this;
}

CurvatureConfidence_template& CurvatureConfidence_template::operator=(const CurvatureConfidence_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CurvatureConfidence_template::match(CurvatureConfidence::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.CurvatureConfidence.");
}
return FALSE;
}

boolean CurvatureConfidence_template::match(const CurvatureConfidence& other_value, boolean) const
{
if (other_value.enum_value == CurvatureConfidence::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.CurvatureConfidence with an unbound value.");
return match(other_value.enum_value);
}

CurvatureConfidence::enum_type CurvatureConfidence_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.CurvatureConfidence.");
return single_value;
}

void CurvatureConfidence_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.CurvatureConfidence.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CurvatureConfidence_template[list_length];
}

CurvatureConfidence_template& CurvatureConfidence_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.CurvatureConfidence.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.CurvatureConfidence.");
return value_list.list_value[list_index];
}

void CurvatureConfidence_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(CurvatureConfidence::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CurvatureConfidence_template::log_match(const CurvatureConfidence& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void CurvatureConfidence_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.CurvatureConfidence.");
}
}

void CurvatureConfidence_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (CurvatureConfidence::enum_type)text_buf.pull_int().get_val();
if (!CurvatureConfidence::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.CurvatureConfidence.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CurvatureConfidence_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.CurvatureConfidence.");
}
}

boolean CurvatureConfidence_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CurvatureConfidence_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CurvatureConfidence_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    CurvatureConfidence::enum_type enum_val = (enum_name != NULL) ? CurvatureConfidence::str_to_enum(enum_name) : CurvatureConfidence::UNKNOWN_VALUE;
    if (CurvatureConfidence::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CurvatureConfidence_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    CurvatureConfidence::enum_type enum_val = CurvatureConfidence::str_to_enum(mp->get_enumerated());
    if (!CurvatureConfidence::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.CurvatureConfidence.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.CurvatureConfidence");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CurvatureConfidence_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(CurvatureConfidence::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CurvatureConfidence_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.CurvatureConfidence");
}

Curvature::Curvature()
{
  bound_flag = FALSE;
}

Curvature::Curvature(const INTEGER& par_curvatureValue,
    const CurvatureConfidence& par_curvatureConfidence)
  :   field_curvatureValue(par_curvatureValue),
  field_curvatureConfidence(par_curvatureConfidence)
{
  bound_flag = TRUE;
}

Curvature::Curvature(const Curvature& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.Curvature.");
bound_flag = TRUE;
if (other_value.curvatureValue().is_bound()) field_curvatureValue = other_value.curvatureValue();
else field_curvatureValue.clean_up();
if (other_value.curvatureConfidence().is_bound()) field_curvatureConfidence = other_value.curvatureConfidence();
else field_curvatureConfidence.clean_up();
}

void Curvature::clean_up()
{
field_curvatureValue.clean_up();
field_curvatureConfidence.clean_up();
bound_flag = FALSE;
}

Curvature& Curvature::operator=(const Curvature& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.Curvature.");
  bound_flag = TRUE;
  if (other_value.curvatureValue().is_bound()) field_curvatureValue = other_value.curvatureValue();
  else field_curvatureValue.clean_up();
  if (other_value.curvatureConfidence().is_bound()) field_curvatureConfidence = other_value.curvatureConfidence();
  else field_curvatureConfidence.clean_up();
}
return *this;
}

boolean Curvature::operator==(const Curvature& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_curvatureValue==other_value.field_curvatureValue
  && field_curvatureConfidence==other_value.field_curvatureConfidence;
}

boolean Curvature::is_bound() const
{
if (bound_flag) return TRUE;
if(field_curvatureValue.is_bound()) return TRUE;
if(field_curvatureConfidence.is_bound()) return TRUE;
return FALSE;
}
boolean Curvature::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_curvatureValue.is_value()) return FALSE;
if(!field_curvatureConfidence.is_value()) return FALSE;
return TRUE;
}
int Curvature::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.Curvature");
  return 2;
}

void Curvature::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ curvatureValue := ");
field_curvatureValue.log();
TTCN_Logger::log_event_str(", curvatureConfidence := ");
field_curvatureConfidence.log();
TTCN_Logger::log_event_str(" }");
}

void Curvature::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.Curvature'");
    }
    if (strcmp("curvatureValue", param_field) == 0) {
      curvatureValue().set_param(param);
      return;
    } else if (strcmp("curvatureConfidence", param_field) == 0) {
      curvatureConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.Curvature'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.Curvature has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) curvatureValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) curvatureConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curvatureValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curvatureValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curvatureConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curvatureConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.Curvature: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.Curvature");
  }
}

Module_Param* Curvature::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.Curvature'");
    }
    if (strcmp("curvatureValue", param_field) == 0) {
      return curvatureValue().get_param(param_name);
    } else if (strcmp("curvatureConfidence", param_field) == 0) {
      return curvatureConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.Curvature'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_curvatureValue = field_curvatureValue.get_param(param_name);
  mp_field_curvatureValue->set_id(new Module_Param_FieldName(mcopystr("curvatureValue")));
  mp->add_elem(mp_field_curvatureValue);
  Module_Param* mp_field_curvatureConfidence = field_curvatureConfidence.get_param(param_name);
  mp_field_curvatureConfidence->set_id(new Module_Param_FieldName(mcopystr("curvatureConfidence")));
  mp->add_elem(mp_field_curvatureConfidence);
  return mp;
  }

void Curvature::set_implicit_omit()
{
if (curvatureValue().is_bound()) curvatureValue().set_implicit_omit();
if (curvatureConfidence().is_bound()) curvatureConfidence().set_implicit_omit();
}

void Curvature::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.Curvature.");
field_curvatureValue.encode_text(text_buf);
field_curvatureConfidence.encode_text(text_buf);
}

void Curvature::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_curvatureValue.decode_text(text_buf);
field_curvatureConfidence.decode_text(text_buf);
}

void Curvature::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Curvature::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* Curvature::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("curvatureValue': ");
  new_tlv->add_TLV(field_curvatureValue.BER_encode_TLV(Curvature_curvatureValue_descr_, p_coding));
  ec_1.set_msg("curvatureConfidence': ");
  new_tlv->add_TLV(field_curvatureConfidence.BER_encode_TLV(Curvature_curvatureConfidence_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean Curvature::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.Curvature' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("curvatureValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_curvatureValue.BER_decode_TLV(Curvature_curvatureValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("curvatureConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_curvatureConfidence.BER_decode_TLV(Curvature_curvatureConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int Curvature::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.Curvature.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "curvatureValue");
    enc_len += field_curvatureValue.JSON_encode(Curvature_curvatureValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "curvatureConfidence");
    enc_len += field_curvatureConfidence.JSON_encode(Curvature_curvatureConfidence_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Curvature::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (14 == name_len && 0 == strncmp(fld_name, "curvatureValue", name_len)) {
         int ret_val = field_curvatureValue.JSON_decode(Curvature_curvatureValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "curvatureValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "curvatureConfidence", name_len)) {
         int ret_val = field_curvatureConfidence.JSON_decode(Curvature_curvatureConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "curvatureConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_curvatureValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "curvatureValue");
    return JSON_ERROR_FATAL;
  }
if (!field_curvatureConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "curvatureConfidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Curvature_template::single_value_struct {
INTEGER_template field_curvatureValue;
CurvatureConfidence_template field_curvatureConfidence;
};

void Curvature_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_curvatureValue = ANY_VALUE;
single_value->field_curvatureConfidence = ANY_VALUE;
}
}
}

void Curvature_template::copy_value(const Curvature& other_value)
{
single_value = new single_value_struct;
if (other_value.curvatureValue().is_bound()) {
  single_value->field_curvatureValue = other_value.curvatureValue();
} else {
  single_value->field_curvatureValue.clean_up();
}
if (other_value.curvatureConfidence().is_bound()) {
  single_value->field_curvatureConfidence = other_value.curvatureConfidence();
} else {
  single_value->field_curvatureConfidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Curvature_template::copy_template(const Curvature_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.curvatureValue().get_selection()) {
single_value->field_curvatureValue = other_value.curvatureValue();
} else {
single_value->field_curvatureValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.curvatureConfidence().get_selection()) {
single_value->field_curvatureConfidence = other_value.curvatureConfidence();
} else {
single_value->field_curvatureConfidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Curvature_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.Curvature.");
break;
}
set_selection(other_value);
}

Curvature_template::Curvature_template()
{
}

Curvature_template::Curvature_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Curvature_template::Curvature_template(const Curvature& other_value)
{
copy_value(other_value);
}

Curvature_template::Curvature_template(const OPTIONAL<Curvature>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Curvature&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.Curvature from an unbound optional field.");
}
}

Curvature_template::Curvature_template(const Curvature_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Curvature_template::~Curvature_template()
{
clean_up();
}

Curvature_template& Curvature_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Curvature_template& Curvature_template::operator=(const Curvature& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Curvature_template& Curvature_template::operator=(const OPTIONAL<Curvature>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Curvature&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.Curvature.");
}
return *this;
}

Curvature_template& Curvature_template::operator=(const Curvature_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Curvature_template::match(const Curvature& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.curvatureValue().is_bound()) return FALSE;
if(!single_value->field_curvatureValue.match(other_value.curvatureValue(), legacy))return FALSE;
if(!other_value.curvatureConfidence().is_bound()) return FALSE;
if(!single_value->field_curvatureConfidence.match(other_value.curvatureConfidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.Curvature.");
}
return FALSE;
}

boolean Curvature_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_curvatureValue.is_bound()) return TRUE;
if (single_value->field_curvatureConfidence.is_bound()) return TRUE;
return FALSE;
}

boolean Curvature_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_curvatureValue.is_value()) return FALSE;
if (!single_value->field_curvatureConfidence.is_value()) return FALSE;
return TRUE;
}

void Curvature_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Curvature Curvature_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.Curvature.");
Curvature ret_val;
if (single_value->field_curvatureValue.is_bound()) {
ret_val.curvatureValue() = single_value->field_curvatureValue.valueof();
}
if (single_value->field_curvatureConfidence.is_bound()) {
ret_val.curvatureConfidence() = single_value->field_curvatureConfidence.valueof();
}
return ret_val;
}

void Curvature_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.Curvature.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Curvature_template[list_length];
}

Curvature_template& Curvature_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.Curvature.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.Curvature.");
return value_list.list_value[list_index];
}

INTEGER_template& Curvature_template::curvatureValue()
{
set_specific();
return single_value->field_curvatureValue;
}

const INTEGER_template& Curvature_template::curvatureValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field curvatureValue of a non-specific template of type @ITS-Container.Curvature.");
return single_value->field_curvatureValue;
}

CurvatureConfidence_template& Curvature_template::curvatureConfidence()
{
set_specific();
return single_value->field_curvatureConfidence;
}

const CurvatureConfidence_template& Curvature_template::curvatureConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field curvatureConfidence of a non-specific template of type @ITS-Container.Curvature.");
return single_value->field_curvatureConfidence;
}

int Curvature_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Curvature which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.Curvature containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Curvature containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Curvature containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Curvature containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Curvature containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.Curvature.");
  }
  return 0;
}

void Curvature_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ curvatureValue := ");
single_value->field_curvatureValue.log();
TTCN_Logger::log_event_str(", curvatureConfidence := ");
single_value->field_curvatureConfidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Curvature_template::log_match(const Curvature& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_curvatureValue.match(match_value.curvatureValue(), legacy)){
TTCN_Logger::log_logmatch_info(".curvatureValue");
single_value->field_curvatureValue.log_match(match_value.curvatureValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_curvatureConfidence.match(match_value.curvatureConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".curvatureConfidence");
single_value->field_curvatureConfidence.log_match(match_value.curvatureConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ curvatureValue := ");
single_value->field_curvatureValue.log_match(match_value.curvatureValue(), legacy);
TTCN_Logger::log_event_str(", curvatureConfidence := ");
single_value->field_curvatureConfidence.log_match(match_value.curvatureConfidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Curvature_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_curvatureValue.encode_text(text_buf);
single_value->field_curvatureConfidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.Curvature.");
}
}

void Curvature_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_curvatureValue.decode_text(text_buf);
single_value->field_curvatureConfidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Curvature_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.Curvature.");
}
}

void Curvature_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.Curvature'");
    }
    if (strcmp("curvatureValue", param_field) == 0) {
      curvatureValue().set_param(param);
      return;
    } else if (strcmp("curvatureConfidence", param_field) == 0) {
      curvatureConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.Curvature'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Curvature_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.Curvature has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) curvatureValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) curvatureConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curvatureValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curvatureValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curvatureConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curvatureConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.Curvature: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.Curvature");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Curvature_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.Curvature'");
    }
    if (strcmp("curvatureValue", param_field) == 0) {
      return curvatureValue().get_param(param_name);
    } else if (strcmp("curvatureConfidence", param_field) == 0) {
      return curvatureConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.Curvature'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_curvatureValue = single_value->field_curvatureValue.get_param(param_name);
    mp_field_curvatureValue->set_id(new Module_Param_FieldName(mcopystr("curvatureValue")));
    mp->add_elem(mp_field_curvatureValue);
    Module_Param* mp_field_curvatureConfidence = single_value->field_curvatureConfidence.get_param(param_name);
    mp_field_curvatureConfidence->set_id(new Module_Param_FieldName(mcopystr("curvatureConfidence")));
    mp->add_elem(mp_field_curvatureConfidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Curvature_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_curvatureValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.Curvature");
single_value->field_curvatureConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.Curvature");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.Curvature");
}

boolean Curvature_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Curvature_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

CurvatureCalculationMode::CurvatureCalculationMode()
{
enum_value = UNBOUND_VALUE;
}

CurvatureCalculationMode::CurvatureCalculationMode(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.CurvatureCalculationMode with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

CurvatureCalculationMode::CurvatureCalculationMode(enum_type other_value)
{
enum_value = other_value;
}

CurvatureCalculationMode::CurvatureCalculationMode(const CurvatureCalculationMode& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
enum_value = other_value.enum_value;
}

CurvatureCalculationMode& CurvatureCalculationMode::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.CurvatureCalculationMode.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

CurvatureCalculationMode& CurvatureCalculationMode::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

CurvatureCalculationMode& CurvatureCalculationMode::operator=(const CurvatureCalculationMode& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
enum_value = other_value.enum_value;
return *this;
}

boolean CurvatureCalculationMode::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
return enum_value == other_value;
}

boolean CurvatureCalculationMode::operator==(const CurvatureCalculationMode& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
return enum_value == other_value.enum_value;
}

boolean CurvatureCalculationMode::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
return enum_value < other_value;
}

boolean CurvatureCalculationMode::operator<(const CurvatureCalculationMode& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
return enum_value < other_value.enum_value;
}

boolean CurvatureCalculationMode::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
return enum_value > other_value;
}

boolean CurvatureCalculationMode::operator>(const CurvatureCalculationMode& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
return enum_value > other_value.enum_value;
}

const char *CurvatureCalculationMode::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case yawRateUsed: return "yawRateUsed";
case yawRateNotUsed: return "yawRateNotUsed";
case unavailable: return "unavailable";
default: return "<unknown>";
}
}

CurvatureCalculationMode::enum_type CurvatureCalculationMode::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "yawRateUsed")) return yawRateUsed;
else if (!strcmp(str_par, "yawRateNotUsed")) return yawRateNotUsed;
else if (!strcmp(str_par, "unavailable")) return unavailable;
else return UNKNOWN_VALUE;
}

boolean CurvatureCalculationMode::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int CurvatureCalculationMode::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.CurvatureCalculationMode.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int CurvatureCalculationMode::enum2int(const CurvatureCalculationMode& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.CurvatureCalculationMode.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void CurvatureCalculationMode::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.CurvatureCalculationMode.", int_val);
enum_value = (enum_type)int_val;
}

CurvatureCalculationMode::operator CurvatureCalculationMode::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.CurvatureCalculationMode.");
return enum_value;
}

void CurvatureCalculationMode::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void CurvatureCalculationMode::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.CurvatureCalculationMode");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.CurvatureCalculationMode.");
  }
}

Module_Param* CurvatureCalculationMode::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void CurvatureCalculationMode::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
text_buf.push_int(enum_value);
}

void CurvatureCalculationMode::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.CurvatureCalculationMode.", enum_value);
}

void CurvatureCalculationMode::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CurvatureCalculationMode::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* CurvatureCalculationMode::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean CurvatureCalculationMode::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.CurvatureCalculationMode: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int CurvatureCalculationMode::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int CurvatureCalculationMode::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void CurvatureCalculationMode_template::copy_template(const CurvatureCalculationMode_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CurvatureCalculationMode_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.CurvatureCalculationMode.");
}
}

CurvatureCalculationMode_template::CurvatureCalculationMode_template()
{
}

CurvatureCalculationMode_template::CurvatureCalculationMode_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CurvatureCalculationMode_template::CurvatureCalculationMode_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!CurvatureCalculationMode::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.CurvatureCalculationMode with unknown numeric value %d.", other_value);
single_value = (CurvatureCalculationMode::enum_type)other_value;
}

CurvatureCalculationMode_template::CurvatureCalculationMode_template(CurvatureCalculationMode::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

CurvatureCalculationMode_template::CurvatureCalculationMode_template(const CurvatureCalculationMode& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == CurvatureCalculationMode::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode.");
single_value = other_value.enum_value;
}

CurvatureCalculationMode_template::CurvatureCalculationMode_template(const OPTIONAL<CurvatureCalculationMode>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (CurvatureCalculationMode::enum_type)(const CurvatureCalculationMode&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.CurvatureCalculationMode from an unbound optional field.");
}
}

CurvatureCalculationMode_template::CurvatureCalculationMode_template(const CurvatureCalculationMode_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

CurvatureCalculationMode_template::~CurvatureCalculationMode_template()
{
clean_up();
}

boolean CurvatureCalculationMode_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean CurvatureCalculationMode_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != CurvatureCalculationMode::UNBOUND_VALUE;
}

void CurvatureCalculationMode_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

CurvatureCalculationMode_template& CurvatureCalculationMode_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CurvatureCalculationMode_template& CurvatureCalculationMode_template::operator=(int other_value)
{
if (!CurvatureCalculationMode::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.CurvatureCalculationMode.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (CurvatureCalculationMode::enum_type)other_value;
return *this;
}

CurvatureCalculationMode_template& CurvatureCalculationMode_template::operator=(CurvatureCalculationMode::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

CurvatureCalculationMode_template& CurvatureCalculationMode_template::operator=(const CurvatureCalculationMode& other_value)
{
if (other_value.enum_value == CurvatureCalculationMode::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.CurvatureCalculationMode to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

CurvatureCalculationMode_template& CurvatureCalculationMode_template::operator=(const OPTIONAL<CurvatureCalculationMode>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (CurvatureCalculationMode::enum_type)(const CurvatureCalculationMode&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.CurvatureCalculationMode.");
}
return *this;
}

CurvatureCalculationMode_template& CurvatureCalculationMode_template::operator=(const CurvatureCalculationMode_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CurvatureCalculationMode_template::match(CurvatureCalculationMode::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.CurvatureCalculationMode.");
}
return FALSE;
}

boolean CurvatureCalculationMode_template::match(const CurvatureCalculationMode& other_value, boolean) const
{
if (other_value.enum_value == CurvatureCalculationMode::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.CurvatureCalculationMode with an unbound value.");
return match(other_value.enum_value);
}

CurvatureCalculationMode::enum_type CurvatureCalculationMode_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.CurvatureCalculationMode.");
return single_value;
}

void CurvatureCalculationMode_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.CurvatureCalculationMode.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CurvatureCalculationMode_template[list_length];
}

CurvatureCalculationMode_template& CurvatureCalculationMode_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.CurvatureCalculationMode.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.CurvatureCalculationMode.");
return value_list.list_value[list_index];
}

void CurvatureCalculationMode_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(CurvatureCalculationMode::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CurvatureCalculationMode_template::log_match(const CurvatureCalculationMode& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void CurvatureCalculationMode_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.CurvatureCalculationMode.");
}
}

void CurvatureCalculationMode_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (CurvatureCalculationMode::enum_type)text_buf.pull_int().get_val();
if (!CurvatureCalculationMode::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.CurvatureCalculationMode.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CurvatureCalculationMode_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.CurvatureCalculationMode.");
}
}

boolean CurvatureCalculationMode_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CurvatureCalculationMode_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CurvatureCalculationMode_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    CurvatureCalculationMode::enum_type enum_val = (enum_name != NULL) ? CurvatureCalculationMode::str_to_enum(enum_name) : CurvatureCalculationMode::UNKNOWN_VALUE;
    if (CurvatureCalculationMode::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CurvatureCalculationMode_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    CurvatureCalculationMode::enum_type enum_val = CurvatureCalculationMode::str_to_enum(mp->get_enumerated());
    if (!CurvatureCalculationMode::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.CurvatureCalculationMode.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.CurvatureCalculationMode");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CurvatureCalculationMode_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(CurvatureCalculationMode::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CurvatureCalculationMode_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.CurvatureCalculationMode");
}

Heading::Heading()
{
  bound_flag = FALSE;
}

Heading::Heading(const INTEGER& par_headingValue,
    const INTEGER& par_headingConfidence)
  :   field_headingValue(par_headingValue),
  field_headingConfidence(par_headingConfidence)
{
  bound_flag = TRUE;
}

Heading::Heading(const Heading& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.Heading.");
bound_flag = TRUE;
if (other_value.headingValue().is_bound()) field_headingValue = other_value.headingValue();
else field_headingValue.clean_up();
if (other_value.headingConfidence().is_bound()) field_headingConfidence = other_value.headingConfidence();
else field_headingConfidence.clean_up();
}

void Heading::clean_up()
{
field_headingValue.clean_up();
field_headingConfidence.clean_up();
bound_flag = FALSE;
}

Heading& Heading::operator=(const Heading& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.Heading.");
  bound_flag = TRUE;
  if (other_value.headingValue().is_bound()) field_headingValue = other_value.headingValue();
  else field_headingValue.clean_up();
  if (other_value.headingConfidence().is_bound()) field_headingConfidence = other_value.headingConfidence();
  else field_headingConfidence.clean_up();
}
return *this;
}

boolean Heading::operator==(const Heading& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_headingValue==other_value.field_headingValue
  && field_headingConfidence==other_value.field_headingConfidence;
}

boolean Heading::is_bound() const
{
if (bound_flag) return TRUE;
if(field_headingValue.is_bound()) return TRUE;
if(field_headingConfidence.is_bound()) return TRUE;
return FALSE;
}
boolean Heading::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_headingValue.is_value()) return FALSE;
if(!field_headingConfidence.is_value()) return FALSE;
return TRUE;
}
int Heading::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.Heading");
  return 2;
}

void Heading::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ headingValue := ");
field_headingValue.log();
TTCN_Logger::log_event_str(", headingConfidence := ");
field_headingConfidence.log();
TTCN_Logger::log_event_str(" }");
}

void Heading::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.Heading'");
    }
    if (strcmp("headingValue", param_field) == 0) {
      headingValue().set_param(param);
      return;
    } else if (strcmp("headingConfidence", param_field) == 0) {
      headingConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.Heading'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.Heading has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headingValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headingConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headingValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headingValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headingConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headingConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.Heading: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.Heading");
  }
}

Module_Param* Heading::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.Heading'");
    }
    if (strcmp("headingValue", param_field) == 0) {
      return headingValue().get_param(param_name);
    } else if (strcmp("headingConfidence", param_field) == 0) {
      return headingConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.Heading'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_headingValue = field_headingValue.get_param(param_name);
  mp_field_headingValue->set_id(new Module_Param_FieldName(mcopystr("headingValue")));
  mp->add_elem(mp_field_headingValue);
  Module_Param* mp_field_headingConfidence = field_headingConfidence.get_param(param_name);
  mp_field_headingConfidence->set_id(new Module_Param_FieldName(mcopystr("headingConfidence")));
  mp->add_elem(mp_field_headingConfidence);
  return mp;
  }

void Heading::set_implicit_omit()
{
if (headingValue().is_bound()) headingValue().set_implicit_omit();
if (headingConfidence().is_bound()) headingConfidence().set_implicit_omit();
}

void Heading::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.Heading.");
field_headingValue.encode_text(text_buf);
field_headingConfidence.encode_text(text_buf);
}

void Heading::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_headingValue.decode_text(text_buf);
field_headingConfidence.decode_text(text_buf);
}

void Heading::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Heading::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* Heading::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("headingValue': ");
  new_tlv->add_TLV(field_headingValue.BER_encode_TLV(Heading_headingValue_descr_, p_coding));
  ec_1.set_msg("headingConfidence': ");
  new_tlv->add_TLV(field_headingConfidence.BER_encode_TLV(Heading_headingConfidence_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean Heading::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.Heading' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("headingValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_headingValue.BER_decode_TLV(Heading_headingValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("headingConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_headingConfidence.BER_decode_TLV(Heading_headingConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int Heading::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.Heading.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headingValue");
    enc_len += field_headingValue.JSON_encode(Heading_headingValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headingConfidence");
    enc_len += field_headingConfidence.JSON_encode(Heading_headingConfidence_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Heading::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "headingValue", name_len)) {
         int ret_val = field_headingValue.JSON_decode(Heading_headingValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headingValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "headingConfidence", name_len)) {
         int ret_val = field_headingConfidence.JSON_decode(Heading_headingConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headingConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_headingValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headingValue");
    return JSON_ERROR_FATAL;
  }
if (!field_headingConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headingConfidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Heading_template::single_value_struct {
INTEGER_template field_headingValue;
INTEGER_template field_headingConfidence;
};

void Heading_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_headingValue = ANY_VALUE;
single_value->field_headingConfidence = ANY_VALUE;
}
}
}

void Heading_template::copy_value(const Heading& other_value)
{
single_value = new single_value_struct;
if (other_value.headingValue().is_bound()) {
  single_value->field_headingValue = other_value.headingValue();
} else {
  single_value->field_headingValue.clean_up();
}
if (other_value.headingConfidence().is_bound()) {
  single_value->field_headingConfidence = other_value.headingConfidence();
} else {
  single_value->field_headingConfidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Heading_template::copy_template(const Heading_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.headingValue().get_selection()) {
single_value->field_headingValue = other_value.headingValue();
} else {
single_value->field_headingValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headingConfidence().get_selection()) {
single_value->field_headingConfidence = other_value.headingConfidence();
} else {
single_value->field_headingConfidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Heading_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.Heading.");
break;
}
set_selection(other_value);
}

Heading_template::Heading_template()
{
}

Heading_template::Heading_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Heading_template::Heading_template(const Heading& other_value)
{
copy_value(other_value);
}

Heading_template::Heading_template(const OPTIONAL<Heading>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Heading&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.Heading from an unbound optional field.");
}
}

Heading_template::Heading_template(const Heading_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Heading_template::~Heading_template()
{
clean_up();
}

Heading_template& Heading_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Heading_template& Heading_template::operator=(const Heading& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Heading_template& Heading_template::operator=(const OPTIONAL<Heading>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Heading&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.Heading.");
}
return *this;
}

Heading_template& Heading_template::operator=(const Heading_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Heading_template::match(const Heading& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.headingValue().is_bound()) return FALSE;
if(!single_value->field_headingValue.match(other_value.headingValue(), legacy))return FALSE;
if(!other_value.headingConfidence().is_bound()) return FALSE;
if(!single_value->field_headingConfidence.match(other_value.headingConfidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.Heading.");
}
return FALSE;
}

boolean Heading_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_headingValue.is_bound()) return TRUE;
if (single_value->field_headingConfidence.is_bound()) return TRUE;
return FALSE;
}

boolean Heading_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_headingValue.is_value()) return FALSE;
if (!single_value->field_headingConfidence.is_value()) return FALSE;
return TRUE;
}

void Heading_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Heading Heading_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.Heading.");
Heading ret_val;
if (single_value->field_headingValue.is_bound()) {
ret_val.headingValue() = single_value->field_headingValue.valueof();
}
if (single_value->field_headingConfidence.is_bound()) {
ret_val.headingConfidence() = single_value->field_headingConfidence.valueof();
}
return ret_val;
}

void Heading_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.Heading.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Heading_template[list_length];
}

Heading_template& Heading_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.Heading.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.Heading.");
return value_list.list_value[list_index];
}

INTEGER_template& Heading_template::headingValue()
{
set_specific();
return single_value->field_headingValue;
}

const INTEGER_template& Heading_template::headingValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headingValue of a non-specific template of type @ITS-Container.Heading.");
return single_value->field_headingValue;
}

INTEGER_template& Heading_template::headingConfidence()
{
set_specific();
return single_value->field_headingConfidence;
}

const INTEGER_template& Heading_template::headingConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headingConfidence of a non-specific template of type @ITS-Container.Heading.");
return single_value->field_headingConfidence;
}

int Heading_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Heading which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.Heading containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Heading containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Heading containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Heading containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Heading containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.Heading.");
  }
  return 0;
}

void Heading_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ headingValue := ");
single_value->field_headingValue.log();
TTCN_Logger::log_event_str(", headingConfidence := ");
single_value->field_headingConfidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Heading_template::log_match(const Heading& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_headingValue.match(match_value.headingValue(), legacy)){
TTCN_Logger::log_logmatch_info(".headingValue");
single_value->field_headingValue.log_match(match_value.headingValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headingConfidence.match(match_value.headingConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".headingConfidence");
single_value->field_headingConfidence.log_match(match_value.headingConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ headingValue := ");
single_value->field_headingValue.log_match(match_value.headingValue(), legacy);
TTCN_Logger::log_event_str(", headingConfidence := ");
single_value->field_headingConfidence.log_match(match_value.headingConfidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Heading_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_headingValue.encode_text(text_buf);
single_value->field_headingConfidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.Heading.");
}
}

void Heading_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_headingValue.decode_text(text_buf);
single_value->field_headingConfidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Heading_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.Heading.");
}
}

void Heading_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.Heading'");
    }
    if (strcmp("headingValue", param_field) == 0) {
      headingValue().set_param(param);
      return;
    } else if (strcmp("headingConfidence", param_field) == 0) {
      headingConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.Heading'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Heading_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.Heading has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headingValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headingConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headingValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headingValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headingConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headingConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.Heading: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.Heading");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Heading_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.Heading'");
    }
    if (strcmp("headingValue", param_field) == 0) {
      return headingValue().get_param(param_name);
    } else if (strcmp("headingConfidence", param_field) == 0) {
      return headingConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.Heading'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_headingValue = single_value->field_headingValue.get_param(param_name);
    mp_field_headingValue->set_id(new Module_Param_FieldName(mcopystr("headingValue")));
    mp->add_elem(mp_field_headingValue);
    Module_Param* mp_field_headingConfidence = single_value->field_headingConfidence.get_param(param_name);
    mp_field_headingConfidence->set_id(new Module_Param_FieldName(mcopystr("headingConfidence")));
    mp->add_elem(mp_field_headingConfidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Heading_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_headingValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.Heading");
single_value->field_headingConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.Heading");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.Heading");
}

boolean Heading_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Heading_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ClosedLanes::ClosedLanes()
{
  bound_flag = FALSE;
}

ClosedLanes::ClosedLanes(const OPTIONAL<HardShoulderStatus>& par_hardShoulderStatus,
    const BITSTRING& par_drivingLaneStatus)
  :   field_hardShoulderStatus(par_hardShoulderStatus),
  field_drivingLaneStatus(par_drivingLaneStatus)
{
  bound_flag = TRUE;
}

ClosedLanes::ClosedLanes(const ClosedLanes& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.ClosedLanes.");
bound_flag = TRUE;
if (other_value.hardShoulderStatus().is_bound()) field_hardShoulderStatus = other_value.hardShoulderStatus();
else field_hardShoulderStatus.clean_up();
if (other_value.drivingLaneStatus().is_bound()) field_drivingLaneStatus = other_value.drivingLaneStatus();
else field_drivingLaneStatus.clean_up();
}

void ClosedLanes::clean_up()
{
field_hardShoulderStatus.clean_up();
field_drivingLaneStatus.clean_up();
bound_flag = FALSE;
}

ClosedLanes& ClosedLanes::operator=(const ClosedLanes& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.ClosedLanes.");
  bound_flag = TRUE;
  if (other_value.hardShoulderStatus().is_bound()) field_hardShoulderStatus = other_value.hardShoulderStatus();
  else field_hardShoulderStatus.clean_up();
  if (other_value.drivingLaneStatus().is_bound()) field_drivingLaneStatus = other_value.drivingLaneStatus();
  else field_drivingLaneStatus.clean_up();
}
return *this;
}

boolean ClosedLanes::operator==(const ClosedLanes& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_hardShoulderStatus==other_value.field_hardShoulderStatus
  && field_drivingLaneStatus==other_value.field_drivingLaneStatus;
}

boolean ClosedLanes::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_hardShoulderStatus.get_selection() || field_hardShoulderStatus.is_bound()) return TRUE;
if(field_drivingLaneStatus.is_bound()) return TRUE;
return FALSE;
}
boolean ClosedLanes::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_hardShoulderStatus.get_selection() && !field_hardShoulderStatus.is_value()) return FALSE;
if(!field_drivingLaneStatus.is_value()) return FALSE;
return TRUE;
}
int ClosedLanes::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.ClosedLanes");
  int ret_val = 1;
  if (field_hardShoulderStatus.ispresent()) ret_val++;
  return ret_val;
}

void ClosedLanes::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ hardShoulderStatus := ");
field_hardShoulderStatus.log();
TTCN_Logger::log_event_str(", drivingLaneStatus := ");
field_drivingLaneStatus.log();
TTCN_Logger::log_event_str(" }");
}

void ClosedLanes::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.ClosedLanes'");
    }
    if (strcmp("hardShoulderStatus", param_field) == 0) {
      hardShoulderStatus().set_param(param);
      return;
    } else if (strcmp("drivingLaneStatus", param_field) == 0) {
      drivingLaneStatus().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.ClosedLanes'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.ClosedLanes has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) hardShoulderStatus().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) drivingLaneStatus().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hardShoulderStatus")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hardShoulderStatus().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "drivingLaneStatus")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          drivingLaneStatus().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ClosedLanes: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.ClosedLanes");
  }
}

Module_Param* ClosedLanes::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.ClosedLanes'");
    }
    if (strcmp("hardShoulderStatus", param_field) == 0) {
      return hardShoulderStatus().get_param(param_name);
    } else if (strcmp("drivingLaneStatus", param_field) == 0) {
      return drivingLaneStatus().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ClosedLanes'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_hardShoulderStatus = field_hardShoulderStatus.get_param(param_name);
  mp_field_hardShoulderStatus->set_id(new Module_Param_FieldName(mcopystr("hardShoulderStatus")));
  mp->add_elem(mp_field_hardShoulderStatus);
  Module_Param* mp_field_drivingLaneStatus = field_drivingLaneStatus.get_param(param_name);
  mp_field_drivingLaneStatus->set_id(new Module_Param_FieldName(mcopystr("drivingLaneStatus")));
  mp->add_elem(mp_field_drivingLaneStatus);
  return mp;
  }

void ClosedLanes::set_implicit_omit()
{
if (!hardShoulderStatus().is_bound()) hardShoulderStatus() = OMIT_VALUE;
else hardShoulderStatus().set_implicit_omit();
if (drivingLaneStatus().is_bound()) drivingLaneStatus().set_implicit_omit();
}

void ClosedLanes::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.ClosedLanes.");
field_hardShoulderStatus.encode_text(text_buf);
field_drivingLaneStatus.encode_text(text_buf);
}

void ClosedLanes::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_hardShoulderStatus.decode_text(text_buf);
field_drivingLaneStatus.decode_text(text_buf);
}

void ClosedLanes::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ClosedLanes::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ClosedLanes::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("hardShoulderStatus': ");
  new_tlv->add_TLV(field_hardShoulderStatus.BER_encode_TLV(ClosedLanes_hardShoulderStatus_descr_, p_coding));
  ec_1.set_msg("drivingLaneStatus': ");
  new_tlv->add_TLV(field_drivingLaneStatus.BER_encode_TLV(ClosedLanes_drivingLaneStatus_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ClosedLanes::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.ClosedLanes' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("hardShoulderStatus': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_hardShoulderStatus=OMIT_VALUE;
    else {
      field_hardShoulderStatus.BER_decode_TLV(ClosedLanes_hardShoulderStatus_descr_, tmp_tlv, L_form);
      if(field_hardShoulderStatus.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("drivingLaneStatus': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_drivingLaneStatus.BER_decode_TLV(ClosedLanes_drivingLaneStatus_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ClosedLanes::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.ClosedLanes.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_hardShoulderStatus.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "hardShoulderStatus");
    enc_len += field_hardShoulderStatus.JSON_encode(ClosedLanes_hardShoulderStatus_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "drivingLaneStatus");
    enc_len += field_drivingLaneStatus.JSON_encode(ClosedLanes_drivingLaneStatus_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ClosedLanes::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "hardShoulderStatus", name_len)) {
         int ret_val = field_hardShoulderStatus.JSON_decode(ClosedLanes_hardShoulderStatus_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "hardShoulderStatus");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "drivingLaneStatus", name_len)) {
         int ret_val = field_drivingLaneStatus.JSON_decode(ClosedLanes_drivingLaneStatus_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "drivingLaneStatus");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_hardShoulderStatus.is_bound()) {
    field_hardShoulderStatus = OMIT_VALUE;
  }
if (!field_drivingLaneStatus.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "drivingLaneStatus");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ClosedLanes_template::single_value_struct {
HardShoulderStatus_template field_hardShoulderStatus;
BITSTRING_template field_drivingLaneStatus;
};

void ClosedLanes_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_hardShoulderStatus = ANY_OR_OMIT;
single_value->field_drivingLaneStatus = ANY_VALUE;
}
}
}

void ClosedLanes_template::copy_value(const ClosedLanes& other_value)
{
single_value = new single_value_struct;
if (other_value.hardShoulderStatus().is_bound()) {
  if (other_value.hardShoulderStatus().ispresent()) single_value->field_hardShoulderStatus = other_value.hardShoulderStatus()();
  else single_value->field_hardShoulderStatus = OMIT_VALUE;
} else {
  single_value->field_hardShoulderStatus.clean_up();
}
if (other_value.drivingLaneStatus().is_bound()) {
  single_value->field_drivingLaneStatus = other_value.drivingLaneStatus();
} else {
  single_value->field_drivingLaneStatus.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ClosedLanes_template::copy_template(const ClosedLanes_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.hardShoulderStatus().get_selection()) {
single_value->field_hardShoulderStatus = other_value.hardShoulderStatus();
} else {
single_value->field_hardShoulderStatus.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.drivingLaneStatus().get_selection()) {
single_value->field_drivingLaneStatus = other_value.drivingLaneStatus();
} else {
single_value->field_drivingLaneStatus.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ClosedLanes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.ClosedLanes.");
break;
}
set_selection(other_value);
}

ClosedLanes_template::ClosedLanes_template()
{
}

ClosedLanes_template::ClosedLanes_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ClosedLanes_template::ClosedLanes_template(const ClosedLanes& other_value)
{
copy_value(other_value);
}

ClosedLanes_template::ClosedLanes_template(const OPTIONAL<ClosedLanes>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ClosedLanes&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.ClosedLanes from an unbound optional field.");
}
}

ClosedLanes_template::ClosedLanes_template(const ClosedLanes_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ClosedLanes_template::~ClosedLanes_template()
{
clean_up();
}

ClosedLanes_template& ClosedLanes_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ClosedLanes_template& ClosedLanes_template::operator=(const ClosedLanes& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ClosedLanes_template& ClosedLanes_template::operator=(const OPTIONAL<ClosedLanes>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ClosedLanes&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.ClosedLanes.");
}
return *this;
}

ClosedLanes_template& ClosedLanes_template::operator=(const ClosedLanes_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ClosedLanes_template::match(const ClosedLanes& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.hardShoulderStatus().is_bound()) return FALSE;
if((other_value.hardShoulderStatus().ispresent() ? !single_value->field_hardShoulderStatus.match((const HardShoulderStatus&)other_value.hardShoulderStatus(), legacy) : !single_value->field_hardShoulderStatus.match_omit(legacy)))return FALSE;
if(!other_value.drivingLaneStatus().is_bound()) return FALSE;
if(!single_value->field_drivingLaneStatus.match(other_value.drivingLaneStatus(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.ClosedLanes.");
}
return FALSE;
}

boolean ClosedLanes_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_hardShoulderStatus.is_omit() || single_value->field_hardShoulderStatus.is_bound()) return TRUE;
if (single_value->field_drivingLaneStatus.is_bound()) return TRUE;
return FALSE;
}

boolean ClosedLanes_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_hardShoulderStatus.is_omit() && !single_value->field_hardShoulderStatus.is_value()) return FALSE;
if (!single_value->field_drivingLaneStatus.is_value()) return FALSE;
return TRUE;
}

void ClosedLanes_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ClosedLanes ClosedLanes_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.ClosedLanes.");
ClosedLanes ret_val;
if (single_value->field_hardShoulderStatus.is_omit()) ret_val.hardShoulderStatus() = OMIT_VALUE;
else if (single_value->field_hardShoulderStatus.is_bound()) {
ret_val.hardShoulderStatus() = single_value->field_hardShoulderStatus.valueof();
}
if (single_value->field_drivingLaneStatus.is_bound()) {
ret_val.drivingLaneStatus() = single_value->field_drivingLaneStatus.valueof();
}
return ret_val;
}

void ClosedLanes_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.ClosedLanes.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ClosedLanes_template[list_length];
}

ClosedLanes_template& ClosedLanes_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.ClosedLanes.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.ClosedLanes.");
return value_list.list_value[list_index];
}

HardShoulderStatus_template& ClosedLanes_template::hardShoulderStatus()
{
set_specific();
return single_value->field_hardShoulderStatus;
}

const HardShoulderStatus_template& ClosedLanes_template::hardShoulderStatus() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hardShoulderStatus of a non-specific template of type @ITS-Container.ClosedLanes.");
return single_value->field_hardShoulderStatus;
}

BITSTRING_template& ClosedLanes_template::drivingLaneStatus()
{
set_specific();
return single_value->field_drivingLaneStatus;
}

const BITSTRING_template& ClosedLanes_template::drivingLaneStatus() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field drivingLaneStatus of a non-specific template of type @ITS-Container.ClosedLanes.");
return single_value->field_drivingLaneStatus;
}

int ClosedLanes_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ClosedLanes which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_hardShoulderStatus.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.ClosedLanes containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ClosedLanes containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ClosedLanes containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ClosedLanes containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ClosedLanes containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.ClosedLanes.");
  }
  return 0;
}

void ClosedLanes_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ hardShoulderStatus := ");
single_value->field_hardShoulderStatus.log();
TTCN_Logger::log_event_str(", drivingLaneStatus := ");
single_value->field_drivingLaneStatus.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ClosedLanes_template::log_match(const ClosedLanes& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.hardShoulderStatus().ispresent()){
if(!single_value->field_hardShoulderStatus.match(match_value.hardShoulderStatus(), legacy)){
TTCN_Logger::log_logmatch_info(".hardShoulderStatus");
single_value->field_hardShoulderStatus.log_match(match_value.hardShoulderStatus(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_hardShoulderStatus.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".hardShoulderStatus := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_hardShoulderStatus.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_drivingLaneStatus.match(match_value.drivingLaneStatus(), legacy)){
TTCN_Logger::log_logmatch_info(".drivingLaneStatus");
single_value->field_drivingLaneStatus.log_match(match_value.drivingLaneStatus(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ hardShoulderStatus := ");
if (match_value.hardShoulderStatus().ispresent()) single_value->field_hardShoulderStatus.log_match(match_value.hardShoulderStatus(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_hardShoulderStatus.log();
if (single_value->field_hardShoulderStatus.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", drivingLaneStatus := ");
single_value->field_drivingLaneStatus.log_match(match_value.drivingLaneStatus(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ClosedLanes_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_hardShoulderStatus.encode_text(text_buf);
single_value->field_drivingLaneStatus.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.ClosedLanes.");
}
}

void ClosedLanes_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_hardShoulderStatus.decode_text(text_buf);
single_value->field_drivingLaneStatus.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ClosedLanes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.ClosedLanes.");
}
}

void ClosedLanes_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.ClosedLanes'");
    }
    if (strcmp("hardShoulderStatus", param_field) == 0) {
      hardShoulderStatus().set_param(param);
      return;
    } else if (strcmp("drivingLaneStatus", param_field) == 0) {
      drivingLaneStatus().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.ClosedLanes'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ClosedLanes_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.ClosedLanes has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) hardShoulderStatus().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) drivingLaneStatus().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hardShoulderStatus")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hardShoulderStatus().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "drivingLaneStatus")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          drivingLaneStatus().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ClosedLanes: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.ClosedLanes");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ClosedLanes_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.ClosedLanes'");
    }
    if (strcmp("hardShoulderStatus", param_field) == 0) {
      return hardShoulderStatus().get_param(param_name);
    } else if (strcmp("drivingLaneStatus", param_field) == 0) {
      return drivingLaneStatus().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ClosedLanes'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_hardShoulderStatus = single_value->field_hardShoulderStatus.get_param(param_name);
    mp_field_hardShoulderStatus->set_id(new Module_Param_FieldName(mcopystr("hardShoulderStatus")));
    mp->add_elem(mp_field_hardShoulderStatus);
    Module_Param* mp_field_drivingLaneStatus = single_value->field_drivingLaneStatus.get_param(param_name);
    mp_field_drivingLaneStatus->set_id(new Module_Param_FieldName(mcopystr("drivingLaneStatus")));
    mp->add_elem(mp_field_drivingLaneStatus);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ClosedLanes_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_hardShoulderStatus.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ClosedLanes");
single_value->field_drivingLaneStatus.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ClosedLanes");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.ClosedLanes");
}

boolean ClosedLanes_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ClosedLanes_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

HardShoulderStatus::HardShoulderStatus()
{
enum_value = UNBOUND_VALUE;
}

HardShoulderStatus::HardShoulderStatus(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.HardShoulderStatus with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

HardShoulderStatus::HardShoulderStatus(enum_type other_value)
{
enum_value = other_value;
}

HardShoulderStatus::HardShoulderStatus(const HardShoulderStatus& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
enum_value = other_value.enum_value;
}

HardShoulderStatus& HardShoulderStatus::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.HardShoulderStatus.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

HardShoulderStatus& HardShoulderStatus::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

HardShoulderStatus& HardShoulderStatus::operator=(const HardShoulderStatus& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
enum_value = other_value.enum_value;
return *this;
}

boolean HardShoulderStatus::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
return enum_value == other_value;
}

boolean HardShoulderStatus::operator==(const HardShoulderStatus& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
return enum_value == other_value.enum_value;
}

boolean HardShoulderStatus::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
return enum_value < other_value;
}

boolean HardShoulderStatus::operator<(const HardShoulderStatus& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
return enum_value < other_value.enum_value;
}

boolean HardShoulderStatus::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
return enum_value > other_value;
}

boolean HardShoulderStatus::operator>(const HardShoulderStatus& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
return enum_value > other_value.enum_value;
}

const char *HardShoulderStatus::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case availableForStopping: return "availableForStopping";
case closed: return "closed";
case availableForDriving: return "availableForDriving";
default: return "<unknown>";
}
}

HardShoulderStatus::enum_type HardShoulderStatus::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "availableForStopping")) return availableForStopping;
else if (!strcmp(str_par, "closed")) return closed;
else if (!strcmp(str_par, "availableForDriving")) return availableForDriving;
else return UNKNOWN_VALUE;
}

boolean HardShoulderStatus::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int HardShoulderStatus::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.HardShoulderStatus.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int HardShoulderStatus::enum2int(const HardShoulderStatus& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.HardShoulderStatus.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void HardShoulderStatus::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.HardShoulderStatus.", int_val);
enum_value = (enum_type)int_val;
}

HardShoulderStatus::operator HardShoulderStatus::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.HardShoulderStatus.");
return enum_value;
}

void HardShoulderStatus::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void HardShoulderStatus::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.HardShoulderStatus");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.HardShoulderStatus.");
  }
}

Module_Param* HardShoulderStatus::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void HardShoulderStatus::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
text_buf.push_int(enum_value);
}

void HardShoulderStatus::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.HardShoulderStatus.", enum_value);
}

void HardShoulderStatus::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HardShoulderStatus::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* HardShoulderStatus::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean HardShoulderStatus::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.HardShoulderStatus: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int HardShoulderStatus::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int HardShoulderStatus::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void HardShoulderStatus_template::copy_template(const HardShoulderStatus_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HardShoulderStatus_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.HardShoulderStatus.");
}
}

HardShoulderStatus_template::HardShoulderStatus_template()
{
}

HardShoulderStatus_template::HardShoulderStatus_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HardShoulderStatus_template::HardShoulderStatus_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!HardShoulderStatus::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.HardShoulderStatus with unknown numeric value %d.", other_value);
single_value = (HardShoulderStatus::enum_type)other_value;
}

HardShoulderStatus_template::HardShoulderStatus_template(HardShoulderStatus::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

HardShoulderStatus_template::HardShoulderStatus_template(const HardShoulderStatus& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == HardShoulderStatus::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.HardShoulderStatus.");
single_value = other_value.enum_value;
}

HardShoulderStatus_template::HardShoulderStatus_template(const OPTIONAL<HardShoulderStatus>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HardShoulderStatus::enum_type)(const HardShoulderStatus&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.HardShoulderStatus from an unbound optional field.");
}
}

HardShoulderStatus_template::HardShoulderStatus_template(const HardShoulderStatus_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

HardShoulderStatus_template::~HardShoulderStatus_template()
{
clean_up();
}

boolean HardShoulderStatus_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean HardShoulderStatus_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != HardShoulderStatus::UNBOUND_VALUE;
}

void HardShoulderStatus_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

HardShoulderStatus_template& HardShoulderStatus_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HardShoulderStatus_template& HardShoulderStatus_template::operator=(int other_value)
{
if (!HardShoulderStatus::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.HardShoulderStatus.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (HardShoulderStatus::enum_type)other_value;
return *this;
}

HardShoulderStatus_template& HardShoulderStatus_template::operator=(HardShoulderStatus::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

HardShoulderStatus_template& HardShoulderStatus_template::operator=(const HardShoulderStatus& other_value)
{
if (other_value.enum_value == HardShoulderStatus::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.HardShoulderStatus to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

HardShoulderStatus_template& HardShoulderStatus_template::operator=(const OPTIONAL<HardShoulderStatus>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HardShoulderStatus::enum_type)(const HardShoulderStatus&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.HardShoulderStatus.");
}
return *this;
}

HardShoulderStatus_template& HardShoulderStatus_template::operator=(const HardShoulderStatus_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HardShoulderStatus_template::match(HardShoulderStatus::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.HardShoulderStatus.");
}
return FALSE;
}

boolean HardShoulderStatus_template::match(const HardShoulderStatus& other_value, boolean) const
{
if (other_value.enum_value == HardShoulderStatus::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.HardShoulderStatus with an unbound value.");
return match(other_value.enum_value);
}

HardShoulderStatus::enum_type HardShoulderStatus_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.HardShoulderStatus.");
return single_value;
}

void HardShoulderStatus_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.HardShoulderStatus.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HardShoulderStatus_template[list_length];
}

HardShoulderStatus_template& HardShoulderStatus_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.HardShoulderStatus.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.HardShoulderStatus.");
return value_list.list_value[list_index];
}

void HardShoulderStatus_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(HardShoulderStatus::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HardShoulderStatus_template::log_match(const HardShoulderStatus& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void HardShoulderStatus_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.HardShoulderStatus.");
}
}

void HardShoulderStatus_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (HardShoulderStatus::enum_type)text_buf.pull_int().get_val();
if (!HardShoulderStatus::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.HardShoulderStatus.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HardShoulderStatus_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.HardShoulderStatus.");
}
}

boolean HardShoulderStatus_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HardShoulderStatus_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HardShoulderStatus_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    HardShoulderStatus::enum_type enum_val = (enum_name != NULL) ? HardShoulderStatus::str_to_enum(enum_name) : HardShoulderStatus::UNKNOWN_VALUE;
    if (HardShoulderStatus::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HardShoulderStatus_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    HardShoulderStatus::enum_type enum_val = HardShoulderStatus::str_to_enum(mp->get_enumerated());
    if (!HardShoulderStatus::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.HardShoulderStatus.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.HardShoulderStatus");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HardShoulderStatus_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(HardShoulderStatus::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HardShoulderStatus_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.HardShoulderStatus");
}

Speed::Speed()
{
  bound_flag = FALSE;
}

Speed::Speed(const INTEGER& par_speedValue,
    const INTEGER& par_speedConfidence)
  :   field_speedValue(par_speedValue),
  field_speedConfidence(par_speedConfidence)
{
  bound_flag = TRUE;
}

Speed::Speed(const Speed& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.Speed.");
bound_flag = TRUE;
if (other_value.speedValue().is_bound()) field_speedValue = other_value.speedValue();
else field_speedValue.clean_up();
if (other_value.speedConfidence().is_bound()) field_speedConfidence = other_value.speedConfidence();
else field_speedConfidence.clean_up();
}

void Speed::clean_up()
{
field_speedValue.clean_up();
field_speedConfidence.clean_up();
bound_flag = FALSE;
}

Speed& Speed::operator=(const Speed& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.Speed.");
  bound_flag = TRUE;
  if (other_value.speedValue().is_bound()) field_speedValue = other_value.speedValue();
  else field_speedValue.clean_up();
  if (other_value.speedConfidence().is_bound()) field_speedConfidence = other_value.speedConfidence();
  else field_speedConfidence.clean_up();
}
return *this;
}

boolean Speed::operator==(const Speed& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_speedValue==other_value.field_speedValue
  && field_speedConfidence==other_value.field_speedConfidence;
}

boolean Speed::is_bound() const
{
if (bound_flag) return TRUE;
if(field_speedValue.is_bound()) return TRUE;
if(field_speedConfidence.is_bound()) return TRUE;
return FALSE;
}
boolean Speed::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_speedValue.is_value()) return FALSE;
if(!field_speedConfidence.is_value()) return FALSE;
return TRUE;
}
int Speed::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.Speed");
  return 2;
}

void Speed::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ speedValue := ");
field_speedValue.log();
TTCN_Logger::log_event_str(", speedConfidence := ");
field_speedConfidence.log();
TTCN_Logger::log_event_str(" }");
}

void Speed::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.Speed'");
    }
    if (strcmp("speedValue", param_field) == 0) {
      speedValue().set_param(param);
      return;
    } else if (strcmp("speedConfidence", param_field) == 0) {
      speedConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.Speed'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.Speed has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) speedValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) speedConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.Speed: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.Speed");
  }
}

Module_Param* Speed::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.Speed'");
    }
    if (strcmp("speedValue", param_field) == 0) {
      return speedValue().get_param(param_name);
    } else if (strcmp("speedConfidence", param_field) == 0) {
      return speedConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.Speed'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_speedValue = field_speedValue.get_param(param_name);
  mp_field_speedValue->set_id(new Module_Param_FieldName(mcopystr("speedValue")));
  mp->add_elem(mp_field_speedValue);
  Module_Param* mp_field_speedConfidence = field_speedConfidence.get_param(param_name);
  mp_field_speedConfidence->set_id(new Module_Param_FieldName(mcopystr("speedConfidence")));
  mp->add_elem(mp_field_speedConfidence);
  return mp;
  }

void Speed::set_implicit_omit()
{
if (speedValue().is_bound()) speedValue().set_implicit_omit();
if (speedConfidence().is_bound()) speedConfidence().set_implicit_omit();
}

void Speed::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.Speed.");
field_speedValue.encode_text(text_buf);
field_speedConfidence.encode_text(text_buf);
}

void Speed::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_speedValue.decode_text(text_buf);
field_speedConfidence.decode_text(text_buf);
}

void Speed::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Speed::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* Speed::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("speedValue': ");
  new_tlv->add_TLV(field_speedValue.BER_encode_TLV(Speed_speedValue_descr_, p_coding));
  ec_1.set_msg("speedConfidence': ");
  new_tlv->add_TLV(field_speedConfidence.BER_encode_TLV(Speed_speedConfidence_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean Speed::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.Speed' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("speedValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_speedValue.BER_decode_TLV(Speed_speedValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("speedConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_speedConfidence.BER_decode_TLV(Speed_speedConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int Speed::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.Speed.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speedValue");
    enc_len += field_speedValue.JSON_encode(Speed_speedValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speedConfidence");
    enc_len += field_speedConfidence.JSON_encode(Speed_speedConfidence_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Speed::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "speedValue", name_len)) {
         int ret_val = field_speedValue.JSON_decode(Speed_speedValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speedValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "speedConfidence", name_len)) {
         int ret_val = field_speedConfidence.JSON_decode(Speed_speedConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speedConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_speedValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "speedValue");
    return JSON_ERROR_FATAL;
  }
if (!field_speedConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "speedConfidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Speed_template::single_value_struct {
INTEGER_template field_speedValue;
INTEGER_template field_speedConfidence;
};

void Speed_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_speedValue = ANY_VALUE;
single_value->field_speedConfidence = ANY_VALUE;
}
}
}

void Speed_template::copy_value(const Speed& other_value)
{
single_value = new single_value_struct;
if (other_value.speedValue().is_bound()) {
  single_value->field_speedValue = other_value.speedValue();
} else {
  single_value->field_speedValue.clean_up();
}
if (other_value.speedConfidence().is_bound()) {
  single_value->field_speedConfidence = other_value.speedConfidence();
} else {
  single_value->field_speedConfidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Speed_template::copy_template(const Speed_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.speedValue().get_selection()) {
single_value->field_speedValue = other_value.speedValue();
} else {
single_value->field_speedValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speedConfidence().get_selection()) {
single_value->field_speedConfidence = other_value.speedConfidence();
} else {
single_value->field_speedConfidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Speed_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.Speed.");
break;
}
set_selection(other_value);
}

Speed_template::Speed_template()
{
}

Speed_template::Speed_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Speed_template::Speed_template(const Speed& other_value)
{
copy_value(other_value);
}

Speed_template::Speed_template(const OPTIONAL<Speed>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Speed&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.Speed from an unbound optional field.");
}
}

Speed_template::Speed_template(const Speed_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Speed_template::~Speed_template()
{
clean_up();
}

Speed_template& Speed_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Speed_template& Speed_template::operator=(const Speed& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Speed_template& Speed_template::operator=(const OPTIONAL<Speed>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Speed&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.Speed.");
}
return *this;
}

Speed_template& Speed_template::operator=(const Speed_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Speed_template::match(const Speed& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.speedValue().is_bound()) return FALSE;
if(!single_value->field_speedValue.match(other_value.speedValue(), legacy))return FALSE;
if(!other_value.speedConfidence().is_bound()) return FALSE;
if(!single_value->field_speedConfidence.match(other_value.speedConfidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.Speed.");
}
return FALSE;
}

boolean Speed_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_speedValue.is_bound()) return TRUE;
if (single_value->field_speedConfidence.is_bound()) return TRUE;
return FALSE;
}

boolean Speed_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_speedValue.is_value()) return FALSE;
if (!single_value->field_speedConfidence.is_value()) return FALSE;
return TRUE;
}

void Speed_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Speed Speed_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.Speed.");
Speed ret_val;
if (single_value->field_speedValue.is_bound()) {
ret_val.speedValue() = single_value->field_speedValue.valueof();
}
if (single_value->field_speedConfidence.is_bound()) {
ret_val.speedConfidence() = single_value->field_speedConfidence.valueof();
}
return ret_val;
}

void Speed_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.Speed.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Speed_template[list_length];
}

Speed_template& Speed_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.Speed.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.Speed.");
return value_list.list_value[list_index];
}

INTEGER_template& Speed_template::speedValue()
{
set_specific();
return single_value->field_speedValue;
}

const INTEGER_template& Speed_template::speedValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speedValue of a non-specific template of type @ITS-Container.Speed.");
return single_value->field_speedValue;
}

INTEGER_template& Speed_template::speedConfidence()
{
set_specific();
return single_value->field_speedConfidence;
}

const INTEGER_template& Speed_template::speedConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speedConfidence of a non-specific template of type @ITS-Container.Speed.");
return single_value->field_speedConfidence;
}

int Speed_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Speed which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.Speed containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Speed containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Speed containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Speed containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.Speed containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.Speed.");
  }
  return 0;
}

void Speed_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ speedValue := ");
single_value->field_speedValue.log();
TTCN_Logger::log_event_str(", speedConfidence := ");
single_value->field_speedConfidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Speed_template::log_match(const Speed& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_speedValue.match(match_value.speedValue(), legacy)){
TTCN_Logger::log_logmatch_info(".speedValue");
single_value->field_speedValue.log_match(match_value.speedValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_speedConfidence.match(match_value.speedConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".speedConfidence");
single_value->field_speedConfidence.log_match(match_value.speedConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ speedValue := ");
single_value->field_speedValue.log_match(match_value.speedValue(), legacy);
TTCN_Logger::log_event_str(", speedConfidence := ");
single_value->field_speedConfidence.log_match(match_value.speedConfidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Speed_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_speedValue.encode_text(text_buf);
single_value->field_speedConfidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.Speed.");
}
}

void Speed_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_speedValue.decode_text(text_buf);
single_value->field_speedConfidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Speed_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.Speed.");
}
}

void Speed_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.Speed'");
    }
    if (strcmp("speedValue", param_field) == 0) {
      speedValue().set_param(param);
      return;
    } else if (strcmp("speedConfidence", param_field) == 0) {
      speedConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.Speed'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Speed_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.Speed has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) speedValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) speedConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.Speed: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.Speed");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Speed_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.Speed'");
    }
    if (strcmp("speedValue", param_field) == 0) {
      return speedValue().get_param(param_name);
    } else if (strcmp("speedConfidence", param_field) == 0) {
      return speedConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.Speed'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_speedValue = single_value->field_speedValue.get_param(param_name);
    mp_field_speedValue->set_id(new Module_Param_FieldName(mcopystr("speedValue")));
    mp->add_elem(mp_field_speedValue);
    Module_Param* mp_field_speedConfidence = single_value->field_speedConfidence.get_param(param_name);
    mp_field_speedConfidence->set_id(new Module_Param_FieldName(mcopystr("speedConfidence")));
    mp->add_elem(mp_field_speedConfidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Speed_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_speedValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.Speed");
single_value->field_speedConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.Speed");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.Speed");
}

boolean Speed_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Speed_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

DriveDirection::DriveDirection()
{
enum_value = UNBOUND_VALUE;
}

DriveDirection::DriveDirection(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.DriveDirection with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

DriveDirection::DriveDirection(enum_type other_value)
{
enum_value = other_value;
}

DriveDirection::DriveDirection(const DriveDirection& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.DriveDirection.");
enum_value = other_value.enum_value;
}

DriveDirection& DriveDirection::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.DriveDirection.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

DriveDirection& DriveDirection::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

DriveDirection& DriveDirection::operator=(const DriveDirection& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.DriveDirection.");
enum_value = other_value.enum_value;
return *this;
}

boolean DriveDirection::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DriveDirection.");
return enum_value == other_value;
}

boolean DriveDirection::operator==(const DriveDirection& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DriveDirection.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.DriveDirection.");
return enum_value == other_value.enum_value;
}

boolean DriveDirection::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DriveDirection.");
return enum_value < other_value;
}

boolean DriveDirection::operator<(const DriveDirection& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DriveDirection.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.DriveDirection.");
return enum_value < other_value.enum_value;
}

boolean DriveDirection::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DriveDirection.");
return enum_value > other_value;
}

boolean DriveDirection::operator>(const DriveDirection& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DriveDirection.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.DriveDirection.");
return enum_value > other_value.enum_value;
}

const char *DriveDirection::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case forward: return "forward";
case backward: return "backward";
case unavailable: return "unavailable";
default: return "<unknown>";
}
}

DriveDirection::enum_type DriveDirection::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "forward")) return forward;
else if (!strcmp(str_par, "backward")) return backward;
else if (!strcmp(str_par, "unavailable")) return unavailable;
else return UNKNOWN_VALUE;
}

boolean DriveDirection::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int DriveDirection::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.DriveDirection.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int DriveDirection::enum2int(const DriveDirection& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.DriveDirection.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void DriveDirection::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.DriveDirection.", int_val);
enum_value = (enum_type)int_val;
}

DriveDirection::operator DriveDirection::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.DriveDirection.");
return enum_value;
}

void DriveDirection::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void DriveDirection::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.DriveDirection");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.DriveDirection.");
  }
}

Module_Param* DriveDirection::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void DriveDirection::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.DriveDirection.");
text_buf.push_int(enum_value);
}

void DriveDirection::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.DriveDirection.", enum_value);
}

void DriveDirection::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DriveDirection::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* DriveDirection::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean DriveDirection::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.DriveDirection: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int DriveDirection::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.DriveDirection.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int DriveDirection::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void DriveDirection_template::copy_template(const DriveDirection_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DriveDirection_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.DriveDirection.");
}
}

DriveDirection_template::DriveDirection_template()
{
}

DriveDirection_template::DriveDirection_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DriveDirection_template::DriveDirection_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!DriveDirection::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.DriveDirection with unknown numeric value %d.", other_value);
single_value = (DriveDirection::enum_type)other_value;
}

DriveDirection_template::DriveDirection_template(DriveDirection::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

DriveDirection_template::DriveDirection_template(const DriveDirection& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == DriveDirection::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.DriveDirection.");
single_value = other_value.enum_value;
}

DriveDirection_template::DriveDirection_template(const OPTIONAL<DriveDirection>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (DriveDirection::enum_type)(const DriveDirection&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.DriveDirection from an unbound optional field.");
}
}

DriveDirection_template::DriveDirection_template(const DriveDirection_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

DriveDirection_template::~DriveDirection_template()
{
clean_up();
}

boolean DriveDirection_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean DriveDirection_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != DriveDirection::UNBOUND_VALUE;
}

void DriveDirection_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

DriveDirection_template& DriveDirection_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DriveDirection_template& DriveDirection_template::operator=(int other_value)
{
if (!DriveDirection::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.DriveDirection.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (DriveDirection::enum_type)other_value;
return *this;
}

DriveDirection_template& DriveDirection_template::operator=(DriveDirection::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

DriveDirection_template& DriveDirection_template::operator=(const DriveDirection& other_value)
{
if (other_value.enum_value == DriveDirection::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.DriveDirection to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

DriveDirection_template& DriveDirection_template::operator=(const OPTIONAL<DriveDirection>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (DriveDirection::enum_type)(const DriveDirection&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.DriveDirection.");
}
return *this;
}

DriveDirection_template& DriveDirection_template::operator=(const DriveDirection_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DriveDirection_template::match(DriveDirection::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.DriveDirection.");
}
return FALSE;
}

boolean DriveDirection_template::match(const DriveDirection& other_value, boolean) const
{
if (other_value.enum_value == DriveDirection::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.DriveDirection with an unbound value.");
return match(other_value.enum_value);
}

DriveDirection::enum_type DriveDirection_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.DriveDirection.");
return single_value;
}

void DriveDirection_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.DriveDirection.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DriveDirection_template[list_length];
}

DriveDirection_template& DriveDirection_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.DriveDirection.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.DriveDirection.");
return value_list.list_value[list_index];
}

void DriveDirection_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(DriveDirection::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DriveDirection_template::log_match(const DriveDirection& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void DriveDirection_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.DriveDirection.");
}
}

void DriveDirection_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (DriveDirection::enum_type)text_buf.pull_int().get_val();
if (!DriveDirection::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.DriveDirection.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DriveDirection_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.DriveDirection.");
}
}

boolean DriveDirection_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DriveDirection_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DriveDirection_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    DriveDirection::enum_type enum_val = (enum_name != NULL) ? DriveDirection::str_to_enum(enum_name) : DriveDirection::UNKNOWN_VALUE;
    if (DriveDirection::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DriveDirection_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    DriveDirection::enum_type enum_val = DriveDirection::str_to_enum(mp->get_enumerated());
    if (!DriveDirection::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.DriveDirection.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.DriveDirection");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DriveDirection_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(DriveDirection::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DriveDirection_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.DriveDirection");
}

LongitudinalAcceleration::LongitudinalAcceleration()
{
  bound_flag = FALSE;
}

LongitudinalAcceleration::LongitudinalAcceleration(const INTEGER& par_longitudinalAccelerationValue,
    const INTEGER& par_longitudinalAccelerationConfidence)
  :   field_longitudinalAccelerationValue(par_longitudinalAccelerationValue),
  field_longitudinalAccelerationConfidence(par_longitudinalAccelerationConfidence)
{
  bound_flag = TRUE;
}

LongitudinalAcceleration::LongitudinalAcceleration(const LongitudinalAcceleration& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.LongitudinalAcceleration.");
bound_flag = TRUE;
if (other_value.longitudinalAccelerationValue().is_bound()) field_longitudinalAccelerationValue = other_value.longitudinalAccelerationValue();
else field_longitudinalAccelerationValue.clean_up();
if (other_value.longitudinalAccelerationConfidence().is_bound()) field_longitudinalAccelerationConfidence = other_value.longitudinalAccelerationConfidence();
else field_longitudinalAccelerationConfidence.clean_up();
}

void LongitudinalAcceleration::clean_up()
{
field_longitudinalAccelerationValue.clean_up();
field_longitudinalAccelerationConfidence.clean_up();
bound_flag = FALSE;
}

LongitudinalAcceleration& LongitudinalAcceleration::operator=(const LongitudinalAcceleration& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.LongitudinalAcceleration.");
  bound_flag = TRUE;
  if (other_value.longitudinalAccelerationValue().is_bound()) field_longitudinalAccelerationValue = other_value.longitudinalAccelerationValue();
  else field_longitudinalAccelerationValue.clean_up();
  if (other_value.longitudinalAccelerationConfidence().is_bound()) field_longitudinalAccelerationConfidence = other_value.longitudinalAccelerationConfidence();
  else field_longitudinalAccelerationConfidence.clean_up();
}
return *this;
}

boolean LongitudinalAcceleration::operator==(const LongitudinalAcceleration& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_longitudinalAccelerationValue==other_value.field_longitudinalAccelerationValue
  && field_longitudinalAccelerationConfidence==other_value.field_longitudinalAccelerationConfidence;
}

boolean LongitudinalAcceleration::is_bound() const
{
if (bound_flag) return TRUE;
if(field_longitudinalAccelerationValue.is_bound()) return TRUE;
if(field_longitudinalAccelerationConfidence.is_bound()) return TRUE;
return FALSE;
}
boolean LongitudinalAcceleration::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_longitudinalAccelerationValue.is_value()) return FALSE;
if(!field_longitudinalAccelerationConfidence.is_value()) return FALSE;
return TRUE;
}
int LongitudinalAcceleration::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.LongitudinalAcceleration");
  return 2;
}

void LongitudinalAcceleration::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ longitudinalAccelerationValue := ");
field_longitudinalAccelerationValue.log();
TTCN_Logger::log_event_str(", longitudinalAccelerationConfidence := ");
field_longitudinalAccelerationConfidence.log();
TTCN_Logger::log_event_str(" }");
}

void LongitudinalAcceleration::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.LongitudinalAcceleration'");
    }
    if (strcmp("longitudinalAccelerationValue", param_field) == 0) {
      longitudinalAccelerationValue().set_param(param);
      return;
    } else if (strcmp("longitudinalAccelerationConfidence", param_field) == 0) {
      longitudinalAccelerationConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.LongitudinalAcceleration'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.LongitudinalAcceleration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) longitudinalAccelerationValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) longitudinalAccelerationConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitudinalAccelerationValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitudinalAccelerationValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitudinalAccelerationConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitudinalAccelerationConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.LongitudinalAcceleration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.LongitudinalAcceleration");
  }
}

Module_Param* LongitudinalAcceleration::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.LongitudinalAcceleration'");
    }
    if (strcmp("longitudinalAccelerationValue", param_field) == 0) {
      return longitudinalAccelerationValue().get_param(param_name);
    } else if (strcmp("longitudinalAccelerationConfidence", param_field) == 0) {
      return longitudinalAccelerationConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.LongitudinalAcceleration'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_longitudinalAccelerationValue = field_longitudinalAccelerationValue.get_param(param_name);
  mp_field_longitudinalAccelerationValue->set_id(new Module_Param_FieldName(mcopystr("longitudinalAccelerationValue")));
  mp->add_elem(mp_field_longitudinalAccelerationValue);
  Module_Param* mp_field_longitudinalAccelerationConfidence = field_longitudinalAccelerationConfidence.get_param(param_name);
  mp_field_longitudinalAccelerationConfidence->set_id(new Module_Param_FieldName(mcopystr("longitudinalAccelerationConfidence")));
  mp->add_elem(mp_field_longitudinalAccelerationConfidence);
  return mp;
  }

void LongitudinalAcceleration::set_implicit_omit()
{
if (longitudinalAccelerationValue().is_bound()) longitudinalAccelerationValue().set_implicit_omit();
if (longitudinalAccelerationConfidence().is_bound()) longitudinalAccelerationConfidence().set_implicit_omit();
}

void LongitudinalAcceleration::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.LongitudinalAcceleration.");
field_longitudinalAccelerationValue.encode_text(text_buf);
field_longitudinalAccelerationConfidence.encode_text(text_buf);
}

void LongitudinalAcceleration::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_longitudinalAccelerationValue.decode_text(text_buf);
field_longitudinalAccelerationConfidence.decode_text(text_buf);
}

void LongitudinalAcceleration::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LongitudinalAcceleration::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* LongitudinalAcceleration::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("longitudinalAccelerationValue': ");
  new_tlv->add_TLV(field_longitudinalAccelerationValue.BER_encode_TLV(LongitudinalAcceleration_longitudinalAccelerationValue_descr_, p_coding));
  ec_1.set_msg("longitudinalAccelerationConfidence': ");
  new_tlv->add_TLV(field_longitudinalAccelerationConfidence.BER_encode_TLV(LongitudinalAcceleration_longitudinalAccelerationConfidence_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean LongitudinalAcceleration::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.LongitudinalAcceleration' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("longitudinalAccelerationValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_longitudinalAccelerationValue.BER_decode_TLV(LongitudinalAcceleration_longitudinalAccelerationValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("longitudinalAccelerationConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_longitudinalAccelerationConfidence.BER_decode_TLV(LongitudinalAcceleration_longitudinalAccelerationConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int LongitudinalAcceleration::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.LongitudinalAcceleration.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "longitudinalAccelerationValue");
    enc_len += field_longitudinalAccelerationValue.JSON_encode(LongitudinalAcceleration_longitudinalAccelerationValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "longitudinalAccelerationConfidence");
    enc_len += field_longitudinalAccelerationConfidence.JSON_encode(LongitudinalAcceleration_longitudinalAccelerationConfidence_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LongitudinalAcceleration::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (29 == name_len && 0 == strncmp(fld_name, "longitudinalAccelerationValue", name_len)) {
         int ret_val = field_longitudinalAccelerationValue.JSON_decode(LongitudinalAcceleration_longitudinalAccelerationValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "longitudinalAccelerationValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (34 == name_len && 0 == strncmp(fld_name, "longitudinalAccelerationConfidence", name_len)) {
         int ret_val = field_longitudinalAccelerationConfidence.JSON_decode(LongitudinalAcceleration_longitudinalAccelerationConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "longitudinalAccelerationConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_longitudinalAccelerationValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "longitudinalAccelerationValue");
    return JSON_ERROR_FATAL;
  }
if (!field_longitudinalAccelerationConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "longitudinalAccelerationConfidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct LongitudinalAcceleration_template::single_value_struct {
INTEGER_template field_longitudinalAccelerationValue;
INTEGER_template field_longitudinalAccelerationConfidence;
};

void LongitudinalAcceleration_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_longitudinalAccelerationValue = ANY_VALUE;
single_value->field_longitudinalAccelerationConfidence = ANY_VALUE;
}
}
}

void LongitudinalAcceleration_template::copy_value(const LongitudinalAcceleration& other_value)
{
single_value = new single_value_struct;
if (other_value.longitudinalAccelerationValue().is_bound()) {
  single_value->field_longitudinalAccelerationValue = other_value.longitudinalAccelerationValue();
} else {
  single_value->field_longitudinalAccelerationValue.clean_up();
}
if (other_value.longitudinalAccelerationConfidence().is_bound()) {
  single_value->field_longitudinalAccelerationConfidence = other_value.longitudinalAccelerationConfidence();
} else {
  single_value->field_longitudinalAccelerationConfidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void LongitudinalAcceleration_template::copy_template(const LongitudinalAcceleration_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.longitudinalAccelerationValue().get_selection()) {
single_value->field_longitudinalAccelerationValue = other_value.longitudinalAccelerationValue();
} else {
single_value->field_longitudinalAccelerationValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.longitudinalAccelerationConfidence().get_selection()) {
single_value->field_longitudinalAccelerationConfidence = other_value.longitudinalAccelerationConfidence();
} else {
single_value->field_longitudinalAccelerationConfidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LongitudinalAcceleration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.LongitudinalAcceleration.");
break;
}
set_selection(other_value);
}

LongitudinalAcceleration_template::LongitudinalAcceleration_template()
{
}

LongitudinalAcceleration_template::LongitudinalAcceleration_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LongitudinalAcceleration_template::LongitudinalAcceleration_template(const LongitudinalAcceleration& other_value)
{
copy_value(other_value);
}

LongitudinalAcceleration_template::LongitudinalAcceleration_template(const OPTIONAL<LongitudinalAcceleration>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LongitudinalAcceleration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.LongitudinalAcceleration from an unbound optional field.");
}
}

LongitudinalAcceleration_template::LongitudinalAcceleration_template(const LongitudinalAcceleration_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

LongitudinalAcceleration_template::~LongitudinalAcceleration_template()
{
clean_up();
}

LongitudinalAcceleration_template& LongitudinalAcceleration_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LongitudinalAcceleration_template& LongitudinalAcceleration_template::operator=(const LongitudinalAcceleration& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LongitudinalAcceleration_template& LongitudinalAcceleration_template::operator=(const OPTIONAL<LongitudinalAcceleration>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LongitudinalAcceleration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.LongitudinalAcceleration.");
}
return *this;
}

LongitudinalAcceleration_template& LongitudinalAcceleration_template::operator=(const LongitudinalAcceleration_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LongitudinalAcceleration_template::match(const LongitudinalAcceleration& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.longitudinalAccelerationValue().is_bound()) return FALSE;
if(!single_value->field_longitudinalAccelerationValue.match(other_value.longitudinalAccelerationValue(), legacy))return FALSE;
if(!other_value.longitudinalAccelerationConfidence().is_bound()) return FALSE;
if(!single_value->field_longitudinalAccelerationConfidence.match(other_value.longitudinalAccelerationConfidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.LongitudinalAcceleration.");
}
return FALSE;
}

boolean LongitudinalAcceleration_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_longitudinalAccelerationValue.is_bound()) return TRUE;
if (single_value->field_longitudinalAccelerationConfidence.is_bound()) return TRUE;
return FALSE;
}

boolean LongitudinalAcceleration_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_longitudinalAccelerationValue.is_value()) return FALSE;
if (!single_value->field_longitudinalAccelerationConfidence.is_value()) return FALSE;
return TRUE;
}

void LongitudinalAcceleration_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LongitudinalAcceleration LongitudinalAcceleration_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.LongitudinalAcceleration.");
LongitudinalAcceleration ret_val;
if (single_value->field_longitudinalAccelerationValue.is_bound()) {
ret_val.longitudinalAccelerationValue() = single_value->field_longitudinalAccelerationValue.valueof();
}
if (single_value->field_longitudinalAccelerationConfidence.is_bound()) {
ret_val.longitudinalAccelerationConfidence() = single_value->field_longitudinalAccelerationConfidence.valueof();
}
return ret_val;
}

void LongitudinalAcceleration_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.LongitudinalAcceleration.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LongitudinalAcceleration_template[list_length];
}

LongitudinalAcceleration_template& LongitudinalAcceleration_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.LongitudinalAcceleration.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.LongitudinalAcceleration.");
return value_list.list_value[list_index];
}

INTEGER_template& LongitudinalAcceleration_template::longitudinalAccelerationValue()
{
set_specific();
return single_value->field_longitudinalAccelerationValue;
}

const INTEGER_template& LongitudinalAcceleration_template::longitudinalAccelerationValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field longitudinalAccelerationValue of a non-specific template of type @ITS-Container.LongitudinalAcceleration.");
return single_value->field_longitudinalAccelerationValue;
}

INTEGER_template& LongitudinalAcceleration_template::longitudinalAccelerationConfidence()
{
set_specific();
return single_value->field_longitudinalAccelerationConfidence;
}

const INTEGER_template& LongitudinalAcceleration_template::longitudinalAccelerationConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field longitudinalAccelerationConfidence of a non-specific template of type @ITS-Container.LongitudinalAcceleration.");
return single_value->field_longitudinalAccelerationConfidence;
}

int LongitudinalAcceleration_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LongitudinalAcceleration which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.LongitudinalAcceleration containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LongitudinalAcceleration containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LongitudinalAcceleration containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LongitudinalAcceleration containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LongitudinalAcceleration containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.LongitudinalAcceleration.");
  }
  return 0;
}

void LongitudinalAcceleration_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ longitudinalAccelerationValue := ");
single_value->field_longitudinalAccelerationValue.log();
TTCN_Logger::log_event_str(", longitudinalAccelerationConfidence := ");
single_value->field_longitudinalAccelerationConfidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LongitudinalAcceleration_template::log_match(const LongitudinalAcceleration& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_longitudinalAccelerationValue.match(match_value.longitudinalAccelerationValue(), legacy)){
TTCN_Logger::log_logmatch_info(".longitudinalAccelerationValue");
single_value->field_longitudinalAccelerationValue.log_match(match_value.longitudinalAccelerationValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_longitudinalAccelerationConfidence.match(match_value.longitudinalAccelerationConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".longitudinalAccelerationConfidence");
single_value->field_longitudinalAccelerationConfidence.log_match(match_value.longitudinalAccelerationConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ longitudinalAccelerationValue := ");
single_value->field_longitudinalAccelerationValue.log_match(match_value.longitudinalAccelerationValue(), legacy);
TTCN_Logger::log_event_str(", longitudinalAccelerationConfidence := ");
single_value->field_longitudinalAccelerationConfidence.log_match(match_value.longitudinalAccelerationConfidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LongitudinalAcceleration_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_longitudinalAccelerationValue.encode_text(text_buf);
single_value->field_longitudinalAccelerationConfidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.LongitudinalAcceleration.");
}
}

void LongitudinalAcceleration_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_longitudinalAccelerationValue.decode_text(text_buf);
single_value->field_longitudinalAccelerationConfidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LongitudinalAcceleration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.LongitudinalAcceleration.");
}
}

void LongitudinalAcceleration_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.LongitudinalAcceleration'");
    }
    if (strcmp("longitudinalAccelerationValue", param_field) == 0) {
      longitudinalAccelerationValue().set_param(param);
      return;
    } else if (strcmp("longitudinalAccelerationConfidence", param_field) == 0) {
      longitudinalAccelerationConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.LongitudinalAcceleration'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LongitudinalAcceleration_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.LongitudinalAcceleration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) longitudinalAccelerationValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) longitudinalAccelerationConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitudinalAccelerationValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitudinalAccelerationValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitudinalAccelerationConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitudinalAccelerationConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.LongitudinalAcceleration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.LongitudinalAcceleration");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LongitudinalAcceleration_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.LongitudinalAcceleration'");
    }
    if (strcmp("longitudinalAccelerationValue", param_field) == 0) {
      return longitudinalAccelerationValue().get_param(param_name);
    } else if (strcmp("longitudinalAccelerationConfidence", param_field) == 0) {
      return longitudinalAccelerationConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.LongitudinalAcceleration'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_longitudinalAccelerationValue = single_value->field_longitudinalAccelerationValue.get_param(param_name);
    mp_field_longitudinalAccelerationValue->set_id(new Module_Param_FieldName(mcopystr("longitudinalAccelerationValue")));
    mp->add_elem(mp_field_longitudinalAccelerationValue);
    Module_Param* mp_field_longitudinalAccelerationConfidence = single_value->field_longitudinalAccelerationConfidence.get_param(param_name);
    mp_field_longitudinalAccelerationConfidence->set_id(new Module_Param_FieldName(mcopystr("longitudinalAccelerationConfidence")));
    mp->add_elem(mp_field_longitudinalAccelerationConfidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LongitudinalAcceleration_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_longitudinalAccelerationValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.LongitudinalAcceleration");
single_value->field_longitudinalAccelerationConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.LongitudinalAcceleration");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.LongitudinalAcceleration");
}

boolean LongitudinalAcceleration_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LongitudinalAcceleration_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

LateralAcceleration::LateralAcceleration()
{
  bound_flag = FALSE;
}

LateralAcceleration::LateralAcceleration(const INTEGER& par_lateralAccelerationValue,
    const INTEGER& par_lateralAccelerationConfidence)
  :   field_lateralAccelerationValue(par_lateralAccelerationValue),
  field_lateralAccelerationConfidence(par_lateralAccelerationConfidence)
{
  bound_flag = TRUE;
}

LateralAcceleration::LateralAcceleration(const LateralAcceleration& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.LateralAcceleration.");
bound_flag = TRUE;
if (other_value.lateralAccelerationValue().is_bound()) field_lateralAccelerationValue = other_value.lateralAccelerationValue();
else field_lateralAccelerationValue.clean_up();
if (other_value.lateralAccelerationConfidence().is_bound()) field_lateralAccelerationConfidence = other_value.lateralAccelerationConfidence();
else field_lateralAccelerationConfidence.clean_up();
}

void LateralAcceleration::clean_up()
{
field_lateralAccelerationValue.clean_up();
field_lateralAccelerationConfidence.clean_up();
bound_flag = FALSE;
}

LateralAcceleration& LateralAcceleration::operator=(const LateralAcceleration& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.LateralAcceleration.");
  bound_flag = TRUE;
  if (other_value.lateralAccelerationValue().is_bound()) field_lateralAccelerationValue = other_value.lateralAccelerationValue();
  else field_lateralAccelerationValue.clean_up();
  if (other_value.lateralAccelerationConfidence().is_bound()) field_lateralAccelerationConfidence = other_value.lateralAccelerationConfidence();
  else field_lateralAccelerationConfidence.clean_up();
}
return *this;
}

boolean LateralAcceleration::operator==(const LateralAcceleration& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lateralAccelerationValue==other_value.field_lateralAccelerationValue
  && field_lateralAccelerationConfidence==other_value.field_lateralAccelerationConfidence;
}

boolean LateralAcceleration::is_bound() const
{
if (bound_flag) return TRUE;
if(field_lateralAccelerationValue.is_bound()) return TRUE;
if(field_lateralAccelerationConfidence.is_bound()) return TRUE;
return FALSE;
}
boolean LateralAcceleration::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_lateralAccelerationValue.is_value()) return FALSE;
if(!field_lateralAccelerationConfidence.is_value()) return FALSE;
return TRUE;
}
int LateralAcceleration::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.LateralAcceleration");
  return 2;
}

void LateralAcceleration::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lateralAccelerationValue := ");
field_lateralAccelerationValue.log();
TTCN_Logger::log_event_str(", lateralAccelerationConfidence := ");
field_lateralAccelerationConfidence.log();
TTCN_Logger::log_event_str(" }");
}

void LateralAcceleration::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.LateralAcceleration'");
    }
    if (strcmp("lateralAccelerationValue", param_field) == 0) {
      lateralAccelerationValue().set_param(param);
      return;
    } else if (strcmp("lateralAccelerationConfidence", param_field) == 0) {
      lateralAccelerationConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.LateralAcceleration'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.LateralAcceleration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lateralAccelerationValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lateralAccelerationConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lateralAccelerationValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lateralAccelerationValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lateralAccelerationConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lateralAccelerationConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.LateralAcceleration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.LateralAcceleration");
  }
}

Module_Param* LateralAcceleration::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.LateralAcceleration'");
    }
    if (strcmp("lateralAccelerationValue", param_field) == 0) {
      return lateralAccelerationValue().get_param(param_name);
    } else if (strcmp("lateralAccelerationConfidence", param_field) == 0) {
      return lateralAccelerationConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.LateralAcceleration'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_lateralAccelerationValue = field_lateralAccelerationValue.get_param(param_name);
  mp_field_lateralAccelerationValue->set_id(new Module_Param_FieldName(mcopystr("lateralAccelerationValue")));
  mp->add_elem(mp_field_lateralAccelerationValue);
  Module_Param* mp_field_lateralAccelerationConfidence = field_lateralAccelerationConfidence.get_param(param_name);
  mp_field_lateralAccelerationConfidence->set_id(new Module_Param_FieldName(mcopystr("lateralAccelerationConfidence")));
  mp->add_elem(mp_field_lateralAccelerationConfidence);
  return mp;
  }

void LateralAcceleration::set_implicit_omit()
{
if (lateralAccelerationValue().is_bound()) lateralAccelerationValue().set_implicit_omit();
if (lateralAccelerationConfidence().is_bound()) lateralAccelerationConfidence().set_implicit_omit();
}

void LateralAcceleration::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.LateralAcceleration.");
field_lateralAccelerationValue.encode_text(text_buf);
field_lateralAccelerationConfidence.encode_text(text_buf);
}

void LateralAcceleration::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lateralAccelerationValue.decode_text(text_buf);
field_lateralAccelerationConfidence.decode_text(text_buf);
}

void LateralAcceleration::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LateralAcceleration::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* LateralAcceleration::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("lateralAccelerationValue': ");
  new_tlv->add_TLV(field_lateralAccelerationValue.BER_encode_TLV(LateralAcceleration_lateralAccelerationValue_descr_, p_coding));
  ec_1.set_msg("lateralAccelerationConfidence': ");
  new_tlv->add_TLV(field_lateralAccelerationConfidence.BER_encode_TLV(LateralAcceleration_lateralAccelerationConfidence_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean LateralAcceleration::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.LateralAcceleration' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("lateralAccelerationValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_lateralAccelerationValue.BER_decode_TLV(LateralAcceleration_lateralAccelerationValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("lateralAccelerationConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_lateralAccelerationConfidence.BER_decode_TLV(LateralAcceleration_lateralAccelerationConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int LateralAcceleration::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.LateralAcceleration.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lateralAccelerationValue");
    enc_len += field_lateralAccelerationValue.JSON_encode(LateralAcceleration_lateralAccelerationValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lateralAccelerationConfidence");
    enc_len += field_lateralAccelerationConfidence.JSON_encode(LateralAcceleration_lateralAccelerationConfidence_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LateralAcceleration::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (24 == name_len && 0 == strncmp(fld_name, "lateralAccelerationValue", name_len)) {
         int ret_val = field_lateralAccelerationValue.JSON_decode(LateralAcceleration_lateralAccelerationValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lateralAccelerationValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (29 == name_len && 0 == strncmp(fld_name, "lateralAccelerationConfidence", name_len)) {
         int ret_val = field_lateralAccelerationConfidence.JSON_decode(LateralAcceleration_lateralAccelerationConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lateralAccelerationConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lateralAccelerationValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lateralAccelerationValue");
    return JSON_ERROR_FATAL;
  }
if (!field_lateralAccelerationConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lateralAccelerationConfidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct LateralAcceleration_template::single_value_struct {
INTEGER_template field_lateralAccelerationValue;
INTEGER_template field_lateralAccelerationConfidence;
};

void LateralAcceleration_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lateralAccelerationValue = ANY_VALUE;
single_value->field_lateralAccelerationConfidence = ANY_VALUE;
}
}
}

void LateralAcceleration_template::copy_value(const LateralAcceleration& other_value)
{
single_value = new single_value_struct;
if (other_value.lateralAccelerationValue().is_bound()) {
  single_value->field_lateralAccelerationValue = other_value.lateralAccelerationValue();
} else {
  single_value->field_lateralAccelerationValue.clean_up();
}
if (other_value.lateralAccelerationConfidence().is_bound()) {
  single_value->field_lateralAccelerationConfidence = other_value.lateralAccelerationConfidence();
} else {
  single_value->field_lateralAccelerationConfidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void LateralAcceleration_template::copy_template(const LateralAcceleration_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lateralAccelerationValue().get_selection()) {
single_value->field_lateralAccelerationValue = other_value.lateralAccelerationValue();
} else {
single_value->field_lateralAccelerationValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lateralAccelerationConfidence().get_selection()) {
single_value->field_lateralAccelerationConfidence = other_value.lateralAccelerationConfidence();
} else {
single_value->field_lateralAccelerationConfidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LateralAcceleration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.LateralAcceleration.");
break;
}
set_selection(other_value);
}

LateralAcceleration_template::LateralAcceleration_template()
{
}

LateralAcceleration_template::LateralAcceleration_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LateralAcceleration_template::LateralAcceleration_template(const LateralAcceleration& other_value)
{
copy_value(other_value);
}

LateralAcceleration_template::LateralAcceleration_template(const OPTIONAL<LateralAcceleration>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LateralAcceleration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.LateralAcceleration from an unbound optional field.");
}
}

LateralAcceleration_template::LateralAcceleration_template(const LateralAcceleration_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

LateralAcceleration_template::~LateralAcceleration_template()
{
clean_up();
}

LateralAcceleration_template& LateralAcceleration_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LateralAcceleration_template& LateralAcceleration_template::operator=(const LateralAcceleration& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LateralAcceleration_template& LateralAcceleration_template::operator=(const OPTIONAL<LateralAcceleration>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LateralAcceleration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.LateralAcceleration.");
}
return *this;
}

LateralAcceleration_template& LateralAcceleration_template::operator=(const LateralAcceleration_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LateralAcceleration_template::match(const LateralAcceleration& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lateralAccelerationValue().is_bound()) return FALSE;
if(!single_value->field_lateralAccelerationValue.match(other_value.lateralAccelerationValue(), legacy))return FALSE;
if(!other_value.lateralAccelerationConfidence().is_bound()) return FALSE;
if(!single_value->field_lateralAccelerationConfidence.match(other_value.lateralAccelerationConfidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.LateralAcceleration.");
}
return FALSE;
}

boolean LateralAcceleration_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lateralAccelerationValue.is_bound()) return TRUE;
if (single_value->field_lateralAccelerationConfidence.is_bound()) return TRUE;
return FALSE;
}

boolean LateralAcceleration_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lateralAccelerationValue.is_value()) return FALSE;
if (!single_value->field_lateralAccelerationConfidence.is_value()) return FALSE;
return TRUE;
}

void LateralAcceleration_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LateralAcceleration LateralAcceleration_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.LateralAcceleration.");
LateralAcceleration ret_val;
if (single_value->field_lateralAccelerationValue.is_bound()) {
ret_val.lateralAccelerationValue() = single_value->field_lateralAccelerationValue.valueof();
}
if (single_value->field_lateralAccelerationConfidence.is_bound()) {
ret_val.lateralAccelerationConfidence() = single_value->field_lateralAccelerationConfidence.valueof();
}
return ret_val;
}

void LateralAcceleration_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.LateralAcceleration.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LateralAcceleration_template[list_length];
}

LateralAcceleration_template& LateralAcceleration_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.LateralAcceleration.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.LateralAcceleration.");
return value_list.list_value[list_index];
}

INTEGER_template& LateralAcceleration_template::lateralAccelerationValue()
{
set_specific();
return single_value->field_lateralAccelerationValue;
}

const INTEGER_template& LateralAcceleration_template::lateralAccelerationValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lateralAccelerationValue of a non-specific template of type @ITS-Container.LateralAcceleration.");
return single_value->field_lateralAccelerationValue;
}

INTEGER_template& LateralAcceleration_template::lateralAccelerationConfidence()
{
set_specific();
return single_value->field_lateralAccelerationConfidence;
}

const INTEGER_template& LateralAcceleration_template::lateralAccelerationConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lateralAccelerationConfidence of a non-specific template of type @ITS-Container.LateralAcceleration.");
return single_value->field_lateralAccelerationConfidence;
}

int LateralAcceleration_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LateralAcceleration which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.LateralAcceleration containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LateralAcceleration containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LateralAcceleration containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LateralAcceleration containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.LateralAcceleration containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.LateralAcceleration.");
  }
  return 0;
}

void LateralAcceleration_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lateralAccelerationValue := ");
single_value->field_lateralAccelerationValue.log();
TTCN_Logger::log_event_str(", lateralAccelerationConfidence := ");
single_value->field_lateralAccelerationConfidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LateralAcceleration_template::log_match(const LateralAcceleration& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_lateralAccelerationValue.match(match_value.lateralAccelerationValue(), legacy)){
TTCN_Logger::log_logmatch_info(".lateralAccelerationValue");
single_value->field_lateralAccelerationValue.log_match(match_value.lateralAccelerationValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lateralAccelerationConfidence.match(match_value.lateralAccelerationConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".lateralAccelerationConfidence");
single_value->field_lateralAccelerationConfidence.log_match(match_value.lateralAccelerationConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lateralAccelerationValue := ");
single_value->field_lateralAccelerationValue.log_match(match_value.lateralAccelerationValue(), legacy);
TTCN_Logger::log_event_str(", lateralAccelerationConfidence := ");
single_value->field_lateralAccelerationConfidence.log_match(match_value.lateralAccelerationConfidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LateralAcceleration_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lateralAccelerationValue.encode_text(text_buf);
single_value->field_lateralAccelerationConfidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.LateralAcceleration.");
}
}

void LateralAcceleration_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lateralAccelerationValue.decode_text(text_buf);
single_value->field_lateralAccelerationConfidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LateralAcceleration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.LateralAcceleration.");
}
}

void LateralAcceleration_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.LateralAcceleration'");
    }
    if (strcmp("lateralAccelerationValue", param_field) == 0) {
      lateralAccelerationValue().set_param(param);
      return;
    } else if (strcmp("lateralAccelerationConfidence", param_field) == 0) {
      lateralAccelerationConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.LateralAcceleration'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LateralAcceleration_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.LateralAcceleration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lateralAccelerationValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lateralAccelerationConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lateralAccelerationValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lateralAccelerationValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lateralAccelerationConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lateralAccelerationConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.LateralAcceleration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.LateralAcceleration");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LateralAcceleration_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.LateralAcceleration'");
    }
    if (strcmp("lateralAccelerationValue", param_field) == 0) {
      return lateralAccelerationValue().get_param(param_name);
    } else if (strcmp("lateralAccelerationConfidence", param_field) == 0) {
      return lateralAccelerationConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.LateralAcceleration'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_lateralAccelerationValue = single_value->field_lateralAccelerationValue.get_param(param_name);
    mp_field_lateralAccelerationValue->set_id(new Module_Param_FieldName(mcopystr("lateralAccelerationValue")));
    mp->add_elem(mp_field_lateralAccelerationValue);
    Module_Param* mp_field_lateralAccelerationConfidence = single_value->field_lateralAccelerationConfidence.get_param(param_name);
    mp_field_lateralAccelerationConfidence->set_id(new Module_Param_FieldName(mcopystr("lateralAccelerationConfidence")));
    mp->add_elem(mp_field_lateralAccelerationConfidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LateralAcceleration_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lateralAccelerationValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.LateralAcceleration");
single_value->field_lateralAccelerationConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.LateralAcceleration");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.LateralAcceleration");
}

boolean LateralAcceleration_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LateralAcceleration_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

VerticalAcceleration::VerticalAcceleration()
{
  bound_flag = FALSE;
}

VerticalAcceleration::VerticalAcceleration(const INTEGER& par_verticalAccelerationValue,
    const INTEGER& par_verticalAccelerationConfidence)
  :   field_verticalAccelerationValue(par_verticalAccelerationValue),
  field_verticalAccelerationConfidence(par_verticalAccelerationConfidence)
{
  bound_flag = TRUE;
}

VerticalAcceleration::VerticalAcceleration(const VerticalAcceleration& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.VerticalAcceleration.");
bound_flag = TRUE;
if (other_value.verticalAccelerationValue().is_bound()) field_verticalAccelerationValue = other_value.verticalAccelerationValue();
else field_verticalAccelerationValue.clean_up();
if (other_value.verticalAccelerationConfidence().is_bound()) field_verticalAccelerationConfidence = other_value.verticalAccelerationConfidence();
else field_verticalAccelerationConfidence.clean_up();
}

void VerticalAcceleration::clean_up()
{
field_verticalAccelerationValue.clean_up();
field_verticalAccelerationConfidence.clean_up();
bound_flag = FALSE;
}

VerticalAcceleration& VerticalAcceleration::operator=(const VerticalAcceleration& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.VerticalAcceleration.");
  bound_flag = TRUE;
  if (other_value.verticalAccelerationValue().is_bound()) field_verticalAccelerationValue = other_value.verticalAccelerationValue();
  else field_verticalAccelerationValue.clean_up();
  if (other_value.verticalAccelerationConfidence().is_bound()) field_verticalAccelerationConfidence = other_value.verticalAccelerationConfidence();
  else field_verticalAccelerationConfidence.clean_up();
}
return *this;
}

boolean VerticalAcceleration::operator==(const VerticalAcceleration& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_verticalAccelerationValue==other_value.field_verticalAccelerationValue
  && field_verticalAccelerationConfidence==other_value.field_verticalAccelerationConfidence;
}

boolean VerticalAcceleration::is_bound() const
{
if (bound_flag) return TRUE;
if(field_verticalAccelerationValue.is_bound()) return TRUE;
if(field_verticalAccelerationConfidence.is_bound()) return TRUE;
return FALSE;
}
boolean VerticalAcceleration::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_verticalAccelerationValue.is_value()) return FALSE;
if(!field_verticalAccelerationConfidence.is_value()) return FALSE;
return TRUE;
}
int VerticalAcceleration::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.VerticalAcceleration");
  return 2;
}

void VerticalAcceleration::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ verticalAccelerationValue := ");
field_verticalAccelerationValue.log();
TTCN_Logger::log_event_str(", verticalAccelerationConfidence := ");
field_verticalAccelerationConfidence.log();
TTCN_Logger::log_event_str(" }");
}

void VerticalAcceleration::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.VerticalAcceleration'");
    }
    if (strcmp("verticalAccelerationValue", param_field) == 0) {
      verticalAccelerationValue().set_param(param);
      return;
    } else if (strcmp("verticalAccelerationConfidence", param_field) == 0) {
      verticalAccelerationConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.VerticalAcceleration'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.VerticalAcceleration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) verticalAccelerationValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) verticalAccelerationConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "verticalAccelerationValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          verticalAccelerationValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "verticalAccelerationConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          verticalAccelerationConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.VerticalAcceleration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.VerticalAcceleration");
  }
}

Module_Param* VerticalAcceleration::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.VerticalAcceleration'");
    }
    if (strcmp("verticalAccelerationValue", param_field) == 0) {
      return verticalAccelerationValue().get_param(param_name);
    } else if (strcmp("verticalAccelerationConfidence", param_field) == 0) {
      return verticalAccelerationConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.VerticalAcceleration'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_verticalAccelerationValue = field_verticalAccelerationValue.get_param(param_name);
  mp_field_verticalAccelerationValue->set_id(new Module_Param_FieldName(mcopystr("verticalAccelerationValue")));
  mp->add_elem(mp_field_verticalAccelerationValue);
  Module_Param* mp_field_verticalAccelerationConfidence = field_verticalAccelerationConfidence.get_param(param_name);
  mp_field_verticalAccelerationConfidence->set_id(new Module_Param_FieldName(mcopystr("verticalAccelerationConfidence")));
  mp->add_elem(mp_field_verticalAccelerationConfidence);
  return mp;
  }

void VerticalAcceleration::set_implicit_omit()
{
if (verticalAccelerationValue().is_bound()) verticalAccelerationValue().set_implicit_omit();
if (verticalAccelerationConfidence().is_bound()) verticalAccelerationConfidence().set_implicit_omit();
}

void VerticalAcceleration::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.VerticalAcceleration.");
field_verticalAccelerationValue.encode_text(text_buf);
field_verticalAccelerationConfidence.encode_text(text_buf);
}

void VerticalAcceleration::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_verticalAccelerationValue.decode_text(text_buf);
field_verticalAccelerationConfidence.decode_text(text_buf);
}

void VerticalAcceleration::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void VerticalAcceleration::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* VerticalAcceleration::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("verticalAccelerationValue': ");
  new_tlv->add_TLV(field_verticalAccelerationValue.BER_encode_TLV(VerticalAcceleration_verticalAccelerationValue_descr_, p_coding));
  ec_1.set_msg("verticalAccelerationConfidence': ");
  new_tlv->add_TLV(field_verticalAccelerationConfidence.BER_encode_TLV(VerticalAcceleration_verticalAccelerationConfidence_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean VerticalAcceleration::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.VerticalAcceleration' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("verticalAccelerationValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_verticalAccelerationValue.BER_decode_TLV(VerticalAcceleration_verticalAccelerationValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("verticalAccelerationConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_verticalAccelerationConfidence.BER_decode_TLV(VerticalAcceleration_verticalAccelerationConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int VerticalAcceleration::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.VerticalAcceleration.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "verticalAccelerationValue");
    enc_len += field_verticalAccelerationValue.JSON_encode(VerticalAcceleration_verticalAccelerationValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "verticalAccelerationConfidence");
    enc_len += field_verticalAccelerationConfidence.JSON_encode(VerticalAcceleration_verticalAccelerationConfidence_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int VerticalAcceleration::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (25 == name_len && 0 == strncmp(fld_name, "verticalAccelerationValue", name_len)) {
         int ret_val = field_verticalAccelerationValue.JSON_decode(VerticalAcceleration_verticalAccelerationValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "verticalAccelerationValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (30 == name_len && 0 == strncmp(fld_name, "verticalAccelerationConfidence", name_len)) {
         int ret_val = field_verticalAccelerationConfidence.JSON_decode(VerticalAcceleration_verticalAccelerationConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "verticalAccelerationConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_verticalAccelerationValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "verticalAccelerationValue");
    return JSON_ERROR_FATAL;
  }
if (!field_verticalAccelerationConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "verticalAccelerationConfidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct VerticalAcceleration_template::single_value_struct {
INTEGER_template field_verticalAccelerationValue;
INTEGER_template field_verticalAccelerationConfidence;
};

void VerticalAcceleration_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_verticalAccelerationValue = ANY_VALUE;
single_value->field_verticalAccelerationConfidence = ANY_VALUE;
}
}
}

void VerticalAcceleration_template::copy_value(const VerticalAcceleration& other_value)
{
single_value = new single_value_struct;
if (other_value.verticalAccelerationValue().is_bound()) {
  single_value->field_verticalAccelerationValue = other_value.verticalAccelerationValue();
} else {
  single_value->field_verticalAccelerationValue.clean_up();
}
if (other_value.verticalAccelerationConfidence().is_bound()) {
  single_value->field_verticalAccelerationConfidence = other_value.verticalAccelerationConfidence();
} else {
  single_value->field_verticalAccelerationConfidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void VerticalAcceleration_template::copy_template(const VerticalAcceleration_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.verticalAccelerationValue().get_selection()) {
single_value->field_verticalAccelerationValue = other_value.verticalAccelerationValue();
} else {
single_value->field_verticalAccelerationValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.verticalAccelerationConfidence().get_selection()) {
single_value->field_verticalAccelerationConfidence = other_value.verticalAccelerationConfidence();
} else {
single_value->field_verticalAccelerationConfidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new VerticalAcceleration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.VerticalAcceleration.");
break;
}
set_selection(other_value);
}

VerticalAcceleration_template::VerticalAcceleration_template()
{
}

VerticalAcceleration_template::VerticalAcceleration_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

VerticalAcceleration_template::VerticalAcceleration_template(const VerticalAcceleration& other_value)
{
copy_value(other_value);
}

VerticalAcceleration_template::VerticalAcceleration_template(const OPTIONAL<VerticalAcceleration>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const VerticalAcceleration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.VerticalAcceleration from an unbound optional field.");
}
}

VerticalAcceleration_template::VerticalAcceleration_template(const VerticalAcceleration_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

VerticalAcceleration_template::~VerticalAcceleration_template()
{
clean_up();
}

VerticalAcceleration_template& VerticalAcceleration_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

VerticalAcceleration_template& VerticalAcceleration_template::operator=(const VerticalAcceleration& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

VerticalAcceleration_template& VerticalAcceleration_template::operator=(const OPTIONAL<VerticalAcceleration>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const VerticalAcceleration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.VerticalAcceleration.");
}
return *this;
}

VerticalAcceleration_template& VerticalAcceleration_template::operator=(const VerticalAcceleration_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean VerticalAcceleration_template::match(const VerticalAcceleration& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.verticalAccelerationValue().is_bound()) return FALSE;
if(!single_value->field_verticalAccelerationValue.match(other_value.verticalAccelerationValue(), legacy))return FALSE;
if(!other_value.verticalAccelerationConfidence().is_bound()) return FALSE;
if(!single_value->field_verticalAccelerationConfidence.match(other_value.verticalAccelerationConfidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.VerticalAcceleration.");
}
return FALSE;
}

boolean VerticalAcceleration_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_verticalAccelerationValue.is_bound()) return TRUE;
if (single_value->field_verticalAccelerationConfidence.is_bound()) return TRUE;
return FALSE;
}

boolean VerticalAcceleration_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_verticalAccelerationValue.is_value()) return FALSE;
if (!single_value->field_verticalAccelerationConfidence.is_value()) return FALSE;
return TRUE;
}

void VerticalAcceleration_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

VerticalAcceleration VerticalAcceleration_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.VerticalAcceleration.");
VerticalAcceleration ret_val;
if (single_value->field_verticalAccelerationValue.is_bound()) {
ret_val.verticalAccelerationValue() = single_value->field_verticalAccelerationValue.valueof();
}
if (single_value->field_verticalAccelerationConfidence.is_bound()) {
ret_val.verticalAccelerationConfidence() = single_value->field_verticalAccelerationConfidence.valueof();
}
return ret_val;
}

void VerticalAcceleration_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.VerticalAcceleration.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new VerticalAcceleration_template[list_length];
}

VerticalAcceleration_template& VerticalAcceleration_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.VerticalAcceleration.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.VerticalAcceleration.");
return value_list.list_value[list_index];
}

INTEGER_template& VerticalAcceleration_template::verticalAccelerationValue()
{
set_specific();
return single_value->field_verticalAccelerationValue;
}

const INTEGER_template& VerticalAcceleration_template::verticalAccelerationValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field verticalAccelerationValue of a non-specific template of type @ITS-Container.VerticalAcceleration.");
return single_value->field_verticalAccelerationValue;
}

INTEGER_template& VerticalAcceleration_template::verticalAccelerationConfidence()
{
set_specific();
return single_value->field_verticalAccelerationConfidence;
}

const INTEGER_template& VerticalAcceleration_template::verticalAccelerationConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field verticalAccelerationConfidence of a non-specific template of type @ITS-Container.VerticalAcceleration.");
return single_value->field_verticalAccelerationConfidence;
}

int VerticalAcceleration_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VerticalAcceleration which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.VerticalAcceleration containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VerticalAcceleration containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VerticalAcceleration containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VerticalAcceleration containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VerticalAcceleration containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.VerticalAcceleration.");
  }
  return 0;
}

void VerticalAcceleration_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ verticalAccelerationValue := ");
single_value->field_verticalAccelerationValue.log();
TTCN_Logger::log_event_str(", verticalAccelerationConfidence := ");
single_value->field_verticalAccelerationConfidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void VerticalAcceleration_template::log_match(const VerticalAcceleration& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_verticalAccelerationValue.match(match_value.verticalAccelerationValue(), legacy)){
TTCN_Logger::log_logmatch_info(".verticalAccelerationValue");
single_value->field_verticalAccelerationValue.log_match(match_value.verticalAccelerationValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_verticalAccelerationConfidence.match(match_value.verticalAccelerationConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".verticalAccelerationConfidence");
single_value->field_verticalAccelerationConfidence.log_match(match_value.verticalAccelerationConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ verticalAccelerationValue := ");
single_value->field_verticalAccelerationValue.log_match(match_value.verticalAccelerationValue(), legacy);
TTCN_Logger::log_event_str(", verticalAccelerationConfidence := ");
single_value->field_verticalAccelerationConfidence.log_match(match_value.verticalAccelerationConfidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void VerticalAcceleration_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_verticalAccelerationValue.encode_text(text_buf);
single_value->field_verticalAccelerationConfidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.VerticalAcceleration.");
}
}

void VerticalAcceleration_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_verticalAccelerationValue.decode_text(text_buf);
single_value->field_verticalAccelerationConfidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new VerticalAcceleration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.VerticalAcceleration.");
}
}

void VerticalAcceleration_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.VerticalAcceleration'");
    }
    if (strcmp("verticalAccelerationValue", param_field) == 0) {
      verticalAccelerationValue().set_param(param);
      return;
    } else if (strcmp("verticalAccelerationConfidence", param_field) == 0) {
      verticalAccelerationConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.VerticalAcceleration'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    VerticalAcceleration_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.VerticalAcceleration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) verticalAccelerationValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) verticalAccelerationConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "verticalAccelerationValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          verticalAccelerationValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "verticalAccelerationConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          verticalAccelerationConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.VerticalAcceleration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.VerticalAcceleration");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* VerticalAcceleration_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.VerticalAcceleration'");
    }
    if (strcmp("verticalAccelerationValue", param_field) == 0) {
      return verticalAccelerationValue().get_param(param_name);
    } else if (strcmp("verticalAccelerationConfidence", param_field) == 0) {
      return verticalAccelerationConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.VerticalAcceleration'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_verticalAccelerationValue = single_value->field_verticalAccelerationValue.get_param(param_name);
    mp_field_verticalAccelerationValue->set_id(new Module_Param_FieldName(mcopystr("verticalAccelerationValue")));
    mp->add_elem(mp_field_verticalAccelerationValue);
    Module_Param* mp_field_verticalAccelerationConfidence = single_value->field_verticalAccelerationConfidence.get_param(param_name);
    mp_field_verticalAccelerationConfidence->set_id(new Module_Param_FieldName(mcopystr("verticalAccelerationConfidence")));
    mp->add_elem(mp_field_verticalAccelerationConfidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void VerticalAcceleration_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_verticalAccelerationValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.VerticalAcceleration");
single_value->field_verticalAccelerationConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.VerticalAcceleration");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.VerticalAcceleration");
}

boolean VerticalAcceleration_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean VerticalAcceleration_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

DangerousGoodsBasic::DangerousGoodsBasic()
{
enum_value = UNBOUND_VALUE;
}

DangerousGoodsBasic::DangerousGoodsBasic(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.DangerousGoodsBasic with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

DangerousGoodsBasic::DangerousGoodsBasic(enum_type other_value)
{
enum_value = other_value;
}

DangerousGoodsBasic::DangerousGoodsBasic(const DangerousGoodsBasic& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
enum_value = other_value.enum_value;
}

DangerousGoodsBasic& DangerousGoodsBasic::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.DangerousGoodsBasic.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

DangerousGoodsBasic& DangerousGoodsBasic::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

DangerousGoodsBasic& DangerousGoodsBasic::operator=(const DangerousGoodsBasic& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
enum_value = other_value.enum_value;
return *this;
}

boolean DangerousGoodsBasic::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
return enum_value == other_value;
}

boolean DangerousGoodsBasic::operator==(const DangerousGoodsBasic& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
return enum_value == other_value.enum_value;
}

boolean DangerousGoodsBasic::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
return enum_value < other_value;
}

boolean DangerousGoodsBasic::operator<(const DangerousGoodsBasic& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
return enum_value < other_value.enum_value;
}

boolean DangerousGoodsBasic::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
return enum_value > other_value;
}

boolean DangerousGoodsBasic::operator>(const DangerousGoodsBasic& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
return enum_value > other_value.enum_value;
}

const char *DangerousGoodsBasic::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case explosives1: return "explosives1";
case explosives2: return "explosives2";
case explosives3: return "explosives3";
case explosives4: return "explosives4";
case explosives5: return "explosives5";
case explosives6: return "explosives6";
case flammableGases: return "flammableGases";
case nonFlammableGases: return "nonFlammableGases";
case toxicGases: return "toxicGases";
case flammableLiquids: return "flammableLiquids";
case flammableSolids: return "flammableSolids";
case substancesLiableToSpontaneousCombustion: return "substancesLiableToSpontaneousCombustion";
case substancesEmittingFlammableGasesUponContactWithWater: return "substancesEmittingFlammableGasesUponContactWithWater";
case oxidizingSubstances: return "oxidizingSubstances";
case organicPeroxides: return "organicPeroxides";
case toxicSubstances: return "toxicSubstances";
case infectiousSubstances: return "infectiousSubstances";
case radioactiveMaterial: return "radioactiveMaterial";
case corrosiveSubstances: return "corrosiveSubstances";
case miscellaneousDangerousSubstances: return "miscellaneousDangerousSubstances";
default: return "<unknown>";
}
}

DangerousGoodsBasic::enum_type DangerousGoodsBasic::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "explosives1")) return explosives1;
else if (!strcmp(str_par, "explosives2")) return explosives2;
else if (!strcmp(str_par, "explosives3")) return explosives3;
else if (!strcmp(str_par, "explosives4")) return explosives4;
else if (!strcmp(str_par, "explosives5")) return explosives5;
else if (!strcmp(str_par, "explosives6")) return explosives6;
else if (!strcmp(str_par, "flammableGases")) return flammableGases;
else if (!strcmp(str_par, "nonFlammableGases")) return nonFlammableGases;
else if (!strcmp(str_par, "toxicGases")) return toxicGases;
else if (!strcmp(str_par, "flammableLiquids")) return flammableLiquids;
else if (!strcmp(str_par, "flammableSolids")) return flammableSolids;
else if (!strcmp(str_par, "substancesLiableToSpontaneousCombustion")) return substancesLiableToSpontaneousCombustion;
else if (!strcmp(str_par, "substancesEmittingFlammableGasesUponContactWithWater")) return substancesEmittingFlammableGasesUponContactWithWater;
else if (!strcmp(str_par, "oxidizingSubstances")) return oxidizingSubstances;
else if (!strcmp(str_par, "organicPeroxides")) return organicPeroxides;
else if (!strcmp(str_par, "toxicSubstances")) return toxicSubstances;
else if (!strcmp(str_par, "infectiousSubstances")) return infectiousSubstances;
else if (!strcmp(str_par, "radioactiveMaterial")) return radioactiveMaterial;
else if (!strcmp(str_par, "corrosiveSubstances")) return corrosiveSubstances;
else if (!strcmp(str_par, "miscellaneousDangerousSubstances")) return miscellaneousDangerousSubstances;
else return UNKNOWN_VALUE;
}

boolean DangerousGoodsBasic::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
case 19:
return TRUE;
default:
return FALSE;
}
}

int DangerousGoodsBasic::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.DangerousGoodsBasic.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int DangerousGoodsBasic::enum2int(const DangerousGoodsBasic& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.DangerousGoodsBasic.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void DangerousGoodsBasic::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.DangerousGoodsBasic.", int_val);
enum_value = (enum_type)int_val;
}

DangerousGoodsBasic::operator DangerousGoodsBasic::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.DangerousGoodsBasic.");
return enum_value;
}

void DangerousGoodsBasic::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void DangerousGoodsBasic::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.DangerousGoodsBasic");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.DangerousGoodsBasic.");
  }
}

Module_Param* DangerousGoodsBasic::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void DangerousGoodsBasic::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
text_buf.push_int(enum_value);
}

void DangerousGoodsBasic::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.DangerousGoodsBasic.", enum_value);
}

void DangerousGoodsBasic::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DangerousGoodsBasic::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* DangerousGoodsBasic::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean DangerousGoodsBasic::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.DangerousGoodsBasic: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int DangerousGoodsBasic::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int DangerousGoodsBasic::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void DangerousGoodsBasic_template::copy_template(const DangerousGoodsBasic_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DangerousGoodsBasic_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.DangerousGoodsBasic.");
}
}

DangerousGoodsBasic_template::DangerousGoodsBasic_template()
{
}

DangerousGoodsBasic_template::DangerousGoodsBasic_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DangerousGoodsBasic_template::DangerousGoodsBasic_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!DangerousGoodsBasic::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.DangerousGoodsBasic with unknown numeric value %d.", other_value);
single_value = (DangerousGoodsBasic::enum_type)other_value;
}

DangerousGoodsBasic_template::DangerousGoodsBasic_template(DangerousGoodsBasic::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

DangerousGoodsBasic_template::DangerousGoodsBasic_template(const DangerousGoodsBasic& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == DangerousGoodsBasic::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic.");
single_value = other_value.enum_value;
}

DangerousGoodsBasic_template::DangerousGoodsBasic_template(const OPTIONAL<DangerousGoodsBasic>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (DangerousGoodsBasic::enum_type)(const DangerousGoodsBasic&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.DangerousGoodsBasic from an unbound optional field.");
}
}

DangerousGoodsBasic_template::DangerousGoodsBasic_template(const DangerousGoodsBasic_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

DangerousGoodsBasic_template::~DangerousGoodsBasic_template()
{
clean_up();
}

boolean DangerousGoodsBasic_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean DangerousGoodsBasic_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != DangerousGoodsBasic::UNBOUND_VALUE;
}

void DangerousGoodsBasic_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

DangerousGoodsBasic_template& DangerousGoodsBasic_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DangerousGoodsBasic_template& DangerousGoodsBasic_template::operator=(int other_value)
{
if (!DangerousGoodsBasic::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.DangerousGoodsBasic.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (DangerousGoodsBasic::enum_type)other_value;
return *this;
}

DangerousGoodsBasic_template& DangerousGoodsBasic_template::operator=(DangerousGoodsBasic::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

DangerousGoodsBasic_template& DangerousGoodsBasic_template::operator=(const DangerousGoodsBasic& other_value)
{
if (other_value.enum_value == DangerousGoodsBasic::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.DangerousGoodsBasic to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

DangerousGoodsBasic_template& DangerousGoodsBasic_template::operator=(const OPTIONAL<DangerousGoodsBasic>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (DangerousGoodsBasic::enum_type)(const DangerousGoodsBasic&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.DangerousGoodsBasic.");
}
return *this;
}

DangerousGoodsBasic_template& DangerousGoodsBasic_template::operator=(const DangerousGoodsBasic_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DangerousGoodsBasic_template::match(DangerousGoodsBasic::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.DangerousGoodsBasic.");
}
return FALSE;
}

boolean DangerousGoodsBasic_template::match(const DangerousGoodsBasic& other_value, boolean) const
{
if (other_value.enum_value == DangerousGoodsBasic::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.DangerousGoodsBasic with an unbound value.");
return match(other_value.enum_value);
}

DangerousGoodsBasic::enum_type DangerousGoodsBasic_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.DangerousGoodsBasic.");
return single_value;
}

void DangerousGoodsBasic_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.DangerousGoodsBasic.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DangerousGoodsBasic_template[list_length];
}

DangerousGoodsBasic_template& DangerousGoodsBasic_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.DangerousGoodsBasic.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.DangerousGoodsBasic.");
return value_list.list_value[list_index];
}

void DangerousGoodsBasic_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(DangerousGoodsBasic::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DangerousGoodsBasic_template::log_match(const DangerousGoodsBasic& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void DangerousGoodsBasic_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.DangerousGoodsBasic.");
}
}

void DangerousGoodsBasic_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (DangerousGoodsBasic::enum_type)text_buf.pull_int().get_val();
if (!DangerousGoodsBasic::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.DangerousGoodsBasic.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DangerousGoodsBasic_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.DangerousGoodsBasic.");
}
}

boolean DangerousGoodsBasic_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DangerousGoodsBasic_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DangerousGoodsBasic_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    DangerousGoodsBasic::enum_type enum_val = (enum_name != NULL) ? DangerousGoodsBasic::str_to_enum(enum_name) : DangerousGoodsBasic::UNKNOWN_VALUE;
    if (DangerousGoodsBasic::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DangerousGoodsBasic_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    DangerousGoodsBasic::enum_type enum_val = DangerousGoodsBasic::str_to_enum(mp->get_enumerated());
    if (!DangerousGoodsBasic::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.DangerousGoodsBasic.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.DangerousGoodsBasic");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DangerousGoodsBasic_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(DangerousGoodsBasic::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DangerousGoodsBasic_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.DangerousGoodsBasic");
}

DangerousGoodsExtended::DangerousGoodsExtended()
{
  bound_flag = FALSE;
}

DangerousGoodsExtended::DangerousGoodsExtended(const DangerousGoodsBasic& par_dangerousGoodsType,
    const INTEGER& par_unNumber,
    const BOOLEAN& par_elevatedTemperature,
    const BOOLEAN& par_tunnelsRestricted,
    const BOOLEAN& par_limitedQuantity,
    const OPTIONAL<CHARSTRING>& par_emergencyActionCode,
    const OPTIONAL<CHARSTRING>& par_phoneNumber,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_companyName)
  :   field_dangerousGoodsType(par_dangerousGoodsType),
  field_unNumber(par_unNumber),
  field_elevatedTemperature(par_elevatedTemperature),
  field_tunnelsRestricted(par_tunnelsRestricted),
  field_limitedQuantity(par_limitedQuantity),
  field_emergencyActionCode(par_emergencyActionCode),
  field_phoneNumber(par_phoneNumber),
  field_companyName(par_companyName)
{
  bound_flag = TRUE;
}

DangerousGoodsExtended::DangerousGoodsExtended(const DangerousGoodsExtended& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.DangerousGoodsExtended.");
bound_flag = TRUE;
if (other_value.dangerousGoodsType().is_bound()) field_dangerousGoodsType = other_value.dangerousGoodsType();
else field_dangerousGoodsType.clean_up();
if (other_value.unNumber().is_bound()) field_unNumber = other_value.unNumber();
else field_unNumber.clean_up();
if (other_value.elevatedTemperature().is_bound()) field_elevatedTemperature = other_value.elevatedTemperature();
else field_elevatedTemperature.clean_up();
if (other_value.tunnelsRestricted().is_bound()) field_tunnelsRestricted = other_value.tunnelsRestricted();
else field_tunnelsRestricted.clean_up();
if (other_value.limitedQuantity().is_bound()) field_limitedQuantity = other_value.limitedQuantity();
else field_limitedQuantity.clean_up();
if (other_value.emergencyActionCode().is_bound()) field_emergencyActionCode = other_value.emergencyActionCode();
else field_emergencyActionCode.clean_up();
if (other_value.phoneNumber().is_bound()) field_phoneNumber = other_value.phoneNumber();
else field_phoneNumber.clean_up();
if (other_value.companyName().is_bound()) field_companyName = other_value.companyName();
else field_companyName.clean_up();
}

void DangerousGoodsExtended::clean_up()
{
field_dangerousGoodsType.clean_up();
field_unNumber.clean_up();
field_elevatedTemperature.clean_up();
field_tunnelsRestricted.clean_up();
field_limitedQuantity.clean_up();
field_emergencyActionCode.clean_up();
field_phoneNumber.clean_up();
field_companyName.clean_up();
bound_flag = FALSE;
}

DangerousGoodsExtended& DangerousGoodsExtended::operator=(const DangerousGoodsExtended& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.DangerousGoodsExtended.");
  bound_flag = TRUE;
  if (other_value.dangerousGoodsType().is_bound()) field_dangerousGoodsType = other_value.dangerousGoodsType();
  else field_dangerousGoodsType.clean_up();
  if (other_value.unNumber().is_bound()) field_unNumber = other_value.unNumber();
  else field_unNumber.clean_up();
  if (other_value.elevatedTemperature().is_bound()) field_elevatedTemperature = other_value.elevatedTemperature();
  else field_elevatedTemperature.clean_up();
  if (other_value.tunnelsRestricted().is_bound()) field_tunnelsRestricted = other_value.tunnelsRestricted();
  else field_tunnelsRestricted.clean_up();
  if (other_value.limitedQuantity().is_bound()) field_limitedQuantity = other_value.limitedQuantity();
  else field_limitedQuantity.clean_up();
  if (other_value.emergencyActionCode().is_bound()) field_emergencyActionCode = other_value.emergencyActionCode();
  else field_emergencyActionCode.clean_up();
  if (other_value.phoneNumber().is_bound()) field_phoneNumber = other_value.phoneNumber();
  else field_phoneNumber.clean_up();
  if (other_value.companyName().is_bound()) field_companyName = other_value.companyName();
  else field_companyName.clean_up();
}
return *this;
}

boolean DangerousGoodsExtended::operator==(const DangerousGoodsExtended& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_dangerousGoodsType==other_value.field_dangerousGoodsType
  && field_unNumber==other_value.field_unNumber
  && field_elevatedTemperature==other_value.field_elevatedTemperature
  && field_tunnelsRestricted==other_value.field_tunnelsRestricted
  && field_limitedQuantity==other_value.field_limitedQuantity
  && field_emergencyActionCode==other_value.field_emergencyActionCode
  && field_phoneNumber==other_value.field_phoneNumber
  && field_companyName==other_value.field_companyName;
}

boolean DangerousGoodsExtended::is_bound() const
{
if (bound_flag) return TRUE;
if(field_dangerousGoodsType.is_bound()) return TRUE;
if(field_unNumber.is_bound()) return TRUE;
if(field_elevatedTemperature.is_bound()) return TRUE;
if(field_tunnelsRestricted.is_bound()) return TRUE;
if(field_limitedQuantity.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_emergencyActionCode.get_selection() || field_emergencyActionCode.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_phoneNumber.get_selection() || field_phoneNumber.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_companyName.get_selection() || field_companyName.is_bound()) return TRUE;
return FALSE;
}
boolean DangerousGoodsExtended::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_dangerousGoodsType.is_value()) return FALSE;
if(!field_unNumber.is_value()) return FALSE;
if(!field_elevatedTemperature.is_value()) return FALSE;
if(!field_tunnelsRestricted.is_value()) return FALSE;
if(!field_limitedQuantity.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_emergencyActionCode.get_selection() && !field_emergencyActionCode.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_phoneNumber.get_selection() && !field_phoneNumber.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_companyName.get_selection() && !field_companyName.is_value()) return FALSE;
return TRUE;
}
int DangerousGoodsExtended::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.DangerousGoodsExtended");
  int ret_val = 5;
  if (field_emergencyActionCode.ispresent()) ret_val++;
  if (field_phoneNumber.ispresent()) ret_val++;
  if (field_companyName.ispresent()) ret_val++;
  return ret_val;
}

void DangerousGoodsExtended::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ dangerousGoodsType := ");
field_dangerousGoodsType.log();
TTCN_Logger::log_event_str(", unNumber := ");
field_unNumber.log();
TTCN_Logger::log_event_str(", elevatedTemperature := ");
field_elevatedTemperature.log();
TTCN_Logger::log_event_str(", tunnelsRestricted := ");
field_tunnelsRestricted.log();
TTCN_Logger::log_event_str(", limitedQuantity := ");
field_limitedQuantity.log();
TTCN_Logger::log_event_str(", emergencyActionCode := ");
field_emergencyActionCode.log();
TTCN_Logger::log_event_str(", phoneNumber := ");
field_phoneNumber.log();
TTCN_Logger::log_event_str(", companyName := ");
field_companyName.log();
TTCN_Logger::log_event_str(" }");
}

void DangerousGoodsExtended::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.DangerousGoodsExtended'");
    }
    if (strcmp("dangerousGoodsType", param_field) == 0) {
      dangerousGoodsType().set_param(param);
      return;
    } else if (strcmp("unNumber", param_field) == 0) {
      unNumber().set_param(param);
      return;
    } else if (strcmp("elevatedTemperature", param_field) == 0) {
      elevatedTemperature().set_param(param);
      return;
    } else if (strcmp("tunnelsRestricted", param_field) == 0) {
      tunnelsRestricted().set_param(param);
      return;
    } else if (strcmp("limitedQuantity", param_field) == 0) {
      limitedQuantity().set_param(param);
      return;
    } else if (strcmp("emergencyActionCode", param_field) == 0) {
      emergencyActionCode().set_param(param);
      return;
    } else if (strcmp("phoneNumber", param_field) == 0) {
      phoneNumber().set_param(param);
      return;
    } else if (strcmp("companyName", param_field) == 0) {
      companyName().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.DangerousGoodsExtended'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record value of type @ITS-Container.DangerousGoodsExtended has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) dangerousGoodsType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) unNumber().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) elevatedTemperature().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) tunnelsRestricted().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) limitedQuantity().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) emergencyActionCode().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) phoneNumber().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) companyName().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousGoodsType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousGoodsType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "unNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          unNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "elevatedTemperature")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          elevatedTemperature().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tunnelsRestricted")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tunnelsRestricted().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "limitedQuantity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          limitedQuantity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergencyActionCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergencyActionCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "phoneNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          phoneNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "companyName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          companyName().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.DangerousGoodsExtended: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.DangerousGoodsExtended");
  }
}

Module_Param* DangerousGoodsExtended::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.DangerousGoodsExtended'");
    }
    if (strcmp("dangerousGoodsType", param_field) == 0) {
      return dangerousGoodsType().get_param(param_name);
    } else if (strcmp("unNumber", param_field) == 0) {
      return unNumber().get_param(param_name);
    } else if (strcmp("elevatedTemperature", param_field) == 0) {
      return elevatedTemperature().get_param(param_name);
    } else if (strcmp("tunnelsRestricted", param_field) == 0) {
      return tunnelsRestricted().get_param(param_name);
    } else if (strcmp("limitedQuantity", param_field) == 0) {
      return limitedQuantity().get_param(param_name);
    } else if (strcmp("emergencyActionCode", param_field) == 0) {
      return emergencyActionCode().get_param(param_name);
    } else if (strcmp("phoneNumber", param_field) == 0) {
      return phoneNumber().get_param(param_name);
    } else if (strcmp("companyName", param_field) == 0) {
      return companyName().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.DangerousGoodsExtended'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_dangerousGoodsType = field_dangerousGoodsType.get_param(param_name);
  mp_field_dangerousGoodsType->set_id(new Module_Param_FieldName(mcopystr("dangerousGoodsType")));
  mp->add_elem(mp_field_dangerousGoodsType);
  Module_Param* mp_field_unNumber = field_unNumber.get_param(param_name);
  mp_field_unNumber->set_id(new Module_Param_FieldName(mcopystr("unNumber")));
  mp->add_elem(mp_field_unNumber);
  Module_Param* mp_field_elevatedTemperature = field_elevatedTemperature.get_param(param_name);
  mp_field_elevatedTemperature->set_id(new Module_Param_FieldName(mcopystr("elevatedTemperature")));
  mp->add_elem(mp_field_elevatedTemperature);
  Module_Param* mp_field_tunnelsRestricted = field_tunnelsRestricted.get_param(param_name);
  mp_field_tunnelsRestricted->set_id(new Module_Param_FieldName(mcopystr("tunnelsRestricted")));
  mp->add_elem(mp_field_tunnelsRestricted);
  Module_Param* mp_field_limitedQuantity = field_limitedQuantity.get_param(param_name);
  mp_field_limitedQuantity->set_id(new Module_Param_FieldName(mcopystr("limitedQuantity")));
  mp->add_elem(mp_field_limitedQuantity);
  Module_Param* mp_field_emergencyActionCode = field_emergencyActionCode.get_param(param_name);
  mp_field_emergencyActionCode->set_id(new Module_Param_FieldName(mcopystr("emergencyActionCode")));
  mp->add_elem(mp_field_emergencyActionCode);
  Module_Param* mp_field_phoneNumber = field_phoneNumber.get_param(param_name);
  mp_field_phoneNumber->set_id(new Module_Param_FieldName(mcopystr("phoneNumber")));
  mp->add_elem(mp_field_phoneNumber);
  Module_Param* mp_field_companyName = field_companyName.get_param(param_name);
  mp_field_companyName->set_id(new Module_Param_FieldName(mcopystr("companyName")));
  mp->add_elem(mp_field_companyName);
  return mp;
  }

void DangerousGoodsExtended::set_implicit_omit()
{
if (dangerousGoodsType().is_bound()) dangerousGoodsType().set_implicit_omit();
if (unNumber().is_bound()) unNumber().set_implicit_omit();
if (elevatedTemperature().is_bound()) elevatedTemperature().set_implicit_omit();
if (tunnelsRestricted().is_bound()) tunnelsRestricted().set_implicit_omit();
if (limitedQuantity().is_bound()) limitedQuantity().set_implicit_omit();
if (!emergencyActionCode().is_bound()) emergencyActionCode() = OMIT_VALUE;
else emergencyActionCode().set_implicit_omit();
if (!phoneNumber().is_bound()) phoneNumber() = OMIT_VALUE;
else phoneNumber().set_implicit_omit();
if (!companyName().is_bound()) companyName() = OMIT_VALUE;
else companyName().set_implicit_omit();
}

void DangerousGoodsExtended::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.DangerousGoodsExtended.");
field_dangerousGoodsType.encode_text(text_buf);
field_unNumber.encode_text(text_buf);
field_elevatedTemperature.encode_text(text_buf);
field_tunnelsRestricted.encode_text(text_buf);
field_limitedQuantity.encode_text(text_buf);
field_emergencyActionCode.encode_text(text_buf);
field_phoneNumber.encode_text(text_buf);
field_companyName.encode_text(text_buf);
}

void DangerousGoodsExtended::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_dangerousGoodsType.decode_text(text_buf);
field_unNumber.decode_text(text_buf);
field_elevatedTemperature.decode_text(text_buf);
field_tunnelsRestricted.decode_text(text_buf);
field_limitedQuantity.decode_text(text_buf);
field_emergencyActionCode.decode_text(text_buf);
field_phoneNumber.decode_text(text_buf);
field_companyName.decode_text(text_buf);
}

void DangerousGoodsExtended::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DangerousGoodsExtended::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* DangerousGoodsExtended::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("dangerousGoodsType': ");
  new_tlv->add_TLV(field_dangerousGoodsType.BER_encode_TLV(DangerousGoodsExtended_dangerousGoodsType_descr_, p_coding));
  ec_1.set_msg("unNumber': ");
  new_tlv->add_TLV(field_unNumber.BER_encode_TLV(DangerousGoodsExtended_unNumber_descr_, p_coding));
  ec_1.set_msg("elevatedTemperature': ");
  new_tlv->add_TLV(field_elevatedTemperature.BER_encode_TLV(DangerousGoodsExtended_elevatedTemperature_descr_, p_coding));
  ec_1.set_msg("tunnelsRestricted': ");
  new_tlv->add_TLV(field_tunnelsRestricted.BER_encode_TLV(DangerousGoodsExtended_tunnelsRestricted_descr_, p_coding));
  ec_1.set_msg("limitedQuantity': ");
  new_tlv->add_TLV(field_limitedQuantity.BER_encode_TLV(DangerousGoodsExtended_limitedQuantity_descr_, p_coding));
  ec_1.set_msg("emergencyActionCode': ");
  new_tlv->add_TLV(field_emergencyActionCode.BER_encode_TLV(DangerousGoodsExtended_emergencyActionCode_descr_, p_coding));
  ec_1.set_msg("phoneNumber': ");
  new_tlv->add_TLV(field_phoneNumber.BER_encode_TLV(DangerousGoodsExtended_phoneNumber_descr_, p_coding));
  ec_1.set_msg("companyName': ");
  new_tlv->add_TLV(field_companyName.BER_encode_TLV(DangerousGoodsExtended_companyName_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean DangerousGoodsExtended::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.DangerousGoodsExtended' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("dangerousGoodsType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_dangerousGoodsType.BER_decode_TLV(DangerousGoodsExtended_dangerousGoodsType_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("unNumber': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_unNumber.BER_decode_TLV(DangerousGoodsExtended_unNumber_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("elevatedTemperature': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_elevatedTemperature.BER_decode_TLV(DangerousGoodsExtended_elevatedTemperature_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("tunnelsRestricted': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_tunnelsRestricted.BER_decode_TLV(DangerousGoodsExtended_tunnelsRestricted_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("limitedQuantity': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_limitedQuantity.BER_decode_TLV(DangerousGoodsExtended_limitedQuantity_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("emergencyActionCode': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_emergencyActionCode=OMIT_VALUE;
    else {
      field_emergencyActionCode.BER_decode_TLV(DangerousGoodsExtended_emergencyActionCode_descr_, tmp_tlv, L_form);
      if(field_emergencyActionCode.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("phoneNumber': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_phoneNumber=OMIT_VALUE;
    else {
      field_phoneNumber.BER_decode_TLV(DangerousGoodsExtended_phoneNumber_descr_, tmp_tlv, L_form);
      if(field_phoneNumber.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("companyName': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_companyName=OMIT_VALUE;
    else {
      field_companyName.BER_decode_TLV(DangerousGoodsExtended_companyName_descr_, tmp_tlv, L_form);
      if(field_companyName.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int DangerousGoodsExtended::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.DangerousGoodsExtended.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dangerousGoodsType");
    enc_len += field_dangerousGoodsType.JSON_encode(DangerousGoodsExtended_dangerousGoodsType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "unNumber");
    enc_len += field_unNumber.JSON_encode(DangerousGoodsExtended_unNumber_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "elevatedTemperature");
    enc_len += field_elevatedTemperature.JSON_encode(DangerousGoodsExtended_elevatedTemperature_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "tunnelsRestricted");
    enc_len += field_tunnelsRestricted.JSON_encode(DangerousGoodsExtended_tunnelsRestricted_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "limitedQuantity");
    enc_len += field_limitedQuantity.JSON_encode(DangerousGoodsExtended_limitedQuantity_descr_, p_tok);
  }

  if (field_emergencyActionCode.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "emergencyActionCode");
    enc_len += field_emergencyActionCode.JSON_encode(DangerousGoodsExtended_emergencyActionCode_descr_, p_tok);
  }

  if (field_phoneNumber.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "phoneNumber");
    enc_len += field_phoneNumber.JSON_encode(DangerousGoodsExtended_phoneNumber_descr_, p_tok);
  }

  if (field_companyName.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "companyName");
    enc_len += field_companyName.JSON_encode(DangerousGoodsExtended_companyName_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DangerousGoodsExtended::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "dangerousGoodsType", name_len)) {
         int ret_val = field_dangerousGoodsType.JSON_decode(DangerousGoodsExtended_dangerousGoodsType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dangerousGoodsType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "unNumber", name_len)) {
         int ret_val = field_unNumber.JSON_decode(DangerousGoodsExtended_unNumber_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "unNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "elevatedTemperature", name_len)) {
         int ret_val = field_elevatedTemperature.JSON_decode(DangerousGoodsExtended_elevatedTemperature_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "elevatedTemperature");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "tunnelsRestricted", name_len)) {
         int ret_val = field_tunnelsRestricted.JSON_decode(DangerousGoodsExtended_tunnelsRestricted_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "tunnelsRestricted");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "limitedQuantity", name_len)) {
         int ret_val = field_limitedQuantity.JSON_decode(DangerousGoodsExtended_limitedQuantity_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "limitedQuantity");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "emergencyActionCode", name_len)) {
         int ret_val = field_emergencyActionCode.JSON_decode(DangerousGoodsExtended_emergencyActionCode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "emergencyActionCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "phoneNumber", name_len)) {
         int ret_val = field_phoneNumber.JSON_decode(DangerousGoodsExtended_phoneNumber_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "phoneNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "companyName", name_len)) {
         int ret_val = field_companyName.JSON_decode(DangerousGoodsExtended_companyName_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "companyName");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_dangerousGoodsType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dangerousGoodsType");
    return JSON_ERROR_FATAL;
  }
if (!field_unNumber.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "unNumber");
    return JSON_ERROR_FATAL;
  }
if (!field_elevatedTemperature.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "elevatedTemperature");
    return JSON_ERROR_FATAL;
  }
if (!field_tunnelsRestricted.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "tunnelsRestricted");
    return JSON_ERROR_FATAL;
  }
if (!field_limitedQuantity.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "limitedQuantity");
    return JSON_ERROR_FATAL;
  }
if (!field_emergencyActionCode.is_bound()) {
    field_emergencyActionCode = OMIT_VALUE;
  }
if (!field_phoneNumber.is_bound()) {
    field_phoneNumber = OMIT_VALUE;
  }
if (!field_companyName.is_bound()) {
    field_companyName = OMIT_VALUE;
  }

  return dec_len;
}

struct DangerousGoodsExtended_template::single_value_struct {
DangerousGoodsBasic_template field_dangerousGoodsType;
INTEGER_template field_unNumber;
BOOLEAN_template field_elevatedTemperature;
BOOLEAN_template field_tunnelsRestricted;
BOOLEAN_template field_limitedQuantity;
CHARSTRING_template field_emergencyActionCode;
CHARSTRING_template field_phoneNumber;
UNIVERSAL_CHARSTRING_template field_companyName;
};

void DangerousGoodsExtended_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_dangerousGoodsType = ANY_VALUE;
single_value->field_unNumber = ANY_VALUE;
single_value->field_elevatedTemperature = ANY_VALUE;
single_value->field_tunnelsRestricted = ANY_VALUE;
single_value->field_limitedQuantity = ANY_VALUE;
single_value->field_emergencyActionCode = ANY_OR_OMIT;
single_value->field_phoneNumber = ANY_OR_OMIT;
single_value->field_companyName = ANY_OR_OMIT;
}
}
}

void DangerousGoodsExtended_template::copy_value(const DangerousGoodsExtended& other_value)
{
single_value = new single_value_struct;
if (other_value.dangerousGoodsType().is_bound()) {
  single_value->field_dangerousGoodsType = other_value.dangerousGoodsType();
} else {
  single_value->field_dangerousGoodsType.clean_up();
}
if (other_value.unNumber().is_bound()) {
  single_value->field_unNumber = other_value.unNumber();
} else {
  single_value->field_unNumber.clean_up();
}
if (other_value.elevatedTemperature().is_bound()) {
  single_value->field_elevatedTemperature = other_value.elevatedTemperature();
} else {
  single_value->field_elevatedTemperature.clean_up();
}
if (other_value.tunnelsRestricted().is_bound()) {
  single_value->field_tunnelsRestricted = other_value.tunnelsRestricted();
} else {
  single_value->field_tunnelsRestricted.clean_up();
}
if (other_value.limitedQuantity().is_bound()) {
  single_value->field_limitedQuantity = other_value.limitedQuantity();
} else {
  single_value->field_limitedQuantity.clean_up();
}
if (other_value.emergencyActionCode().is_bound()) {
  if (other_value.emergencyActionCode().ispresent()) single_value->field_emergencyActionCode = other_value.emergencyActionCode()();
  else single_value->field_emergencyActionCode = OMIT_VALUE;
} else {
  single_value->field_emergencyActionCode.clean_up();
}
if (other_value.phoneNumber().is_bound()) {
  if (other_value.phoneNumber().ispresent()) single_value->field_phoneNumber = other_value.phoneNumber()();
  else single_value->field_phoneNumber = OMIT_VALUE;
} else {
  single_value->field_phoneNumber.clean_up();
}
if (other_value.companyName().is_bound()) {
  if (other_value.companyName().ispresent()) single_value->field_companyName = other_value.companyName()();
  else single_value->field_companyName = OMIT_VALUE;
} else {
  single_value->field_companyName.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void DangerousGoodsExtended_template::copy_template(const DangerousGoodsExtended_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.dangerousGoodsType().get_selection()) {
single_value->field_dangerousGoodsType = other_value.dangerousGoodsType();
} else {
single_value->field_dangerousGoodsType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.unNumber().get_selection()) {
single_value->field_unNumber = other_value.unNumber();
} else {
single_value->field_unNumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.elevatedTemperature().get_selection()) {
single_value->field_elevatedTemperature = other_value.elevatedTemperature();
} else {
single_value->field_elevatedTemperature.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.tunnelsRestricted().get_selection()) {
single_value->field_tunnelsRestricted = other_value.tunnelsRestricted();
} else {
single_value->field_tunnelsRestricted.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.limitedQuantity().get_selection()) {
single_value->field_limitedQuantity = other_value.limitedQuantity();
} else {
single_value->field_limitedQuantity.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.emergencyActionCode().get_selection()) {
single_value->field_emergencyActionCode = other_value.emergencyActionCode();
} else {
single_value->field_emergencyActionCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.phoneNumber().get_selection()) {
single_value->field_phoneNumber = other_value.phoneNumber();
} else {
single_value->field_phoneNumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.companyName().get_selection()) {
single_value->field_companyName = other_value.companyName();
} else {
single_value->field_companyName.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DangerousGoodsExtended_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.DangerousGoodsExtended.");
break;
}
set_selection(other_value);
}

DangerousGoodsExtended_template::DangerousGoodsExtended_template()
{
}

DangerousGoodsExtended_template::DangerousGoodsExtended_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DangerousGoodsExtended_template::DangerousGoodsExtended_template(const DangerousGoodsExtended& other_value)
{
copy_value(other_value);
}

DangerousGoodsExtended_template::DangerousGoodsExtended_template(const OPTIONAL<DangerousGoodsExtended>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DangerousGoodsExtended&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.DangerousGoodsExtended from an unbound optional field.");
}
}

DangerousGoodsExtended_template::DangerousGoodsExtended_template(const DangerousGoodsExtended_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

DangerousGoodsExtended_template::~DangerousGoodsExtended_template()
{
clean_up();
}

DangerousGoodsExtended_template& DangerousGoodsExtended_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DangerousGoodsExtended_template& DangerousGoodsExtended_template::operator=(const DangerousGoodsExtended& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DangerousGoodsExtended_template& DangerousGoodsExtended_template::operator=(const OPTIONAL<DangerousGoodsExtended>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DangerousGoodsExtended&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.DangerousGoodsExtended.");
}
return *this;
}

DangerousGoodsExtended_template& DangerousGoodsExtended_template::operator=(const DangerousGoodsExtended_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DangerousGoodsExtended_template::match(const DangerousGoodsExtended& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.dangerousGoodsType().is_bound()) return FALSE;
if(!single_value->field_dangerousGoodsType.match(other_value.dangerousGoodsType(), legacy))return FALSE;
if(!other_value.unNumber().is_bound()) return FALSE;
if(!single_value->field_unNumber.match(other_value.unNumber(), legacy))return FALSE;
if(!other_value.elevatedTemperature().is_bound()) return FALSE;
if(!single_value->field_elevatedTemperature.match(other_value.elevatedTemperature(), legacy))return FALSE;
if(!other_value.tunnelsRestricted().is_bound()) return FALSE;
if(!single_value->field_tunnelsRestricted.match(other_value.tunnelsRestricted(), legacy))return FALSE;
if(!other_value.limitedQuantity().is_bound()) return FALSE;
if(!single_value->field_limitedQuantity.match(other_value.limitedQuantity(), legacy))return FALSE;
if(!other_value.emergencyActionCode().is_bound()) return FALSE;
if((other_value.emergencyActionCode().ispresent() ? !single_value->field_emergencyActionCode.match((const CHARSTRING&)other_value.emergencyActionCode(), legacy) : !single_value->field_emergencyActionCode.match_omit(legacy)))return FALSE;
if(!other_value.phoneNumber().is_bound()) return FALSE;
if((other_value.phoneNumber().ispresent() ? !single_value->field_phoneNumber.match((const CHARSTRING&)other_value.phoneNumber(), legacy) : !single_value->field_phoneNumber.match_omit(legacy)))return FALSE;
if(!other_value.companyName().is_bound()) return FALSE;
if((other_value.companyName().ispresent() ? !single_value->field_companyName.match((const UNIVERSAL_CHARSTRING&)other_value.companyName(), legacy) : !single_value->field_companyName.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.DangerousGoodsExtended.");
}
return FALSE;
}

boolean DangerousGoodsExtended_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_dangerousGoodsType.is_bound()) return TRUE;
if (single_value->field_unNumber.is_bound()) return TRUE;
if (single_value->field_elevatedTemperature.is_bound()) return TRUE;
if (single_value->field_tunnelsRestricted.is_bound()) return TRUE;
if (single_value->field_limitedQuantity.is_bound()) return TRUE;
if (single_value->field_emergencyActionCode.is_omit() || single_value->field_emergencyActionCode.is_bound()) return TRUE;
if (single_value->field_phoneNumber.is_omit() || single_value->field_phoneNumber.is_bound()) return TRUE;
if (single_value->field_companyName.is_omit() || single_value->field_companyName.is_bound()) return TRUE;
return FALSE;
}

boolean DangerousGoodsExtended_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_dangerousGoodsType.is_value()) return FALSE;
if (!single_value->field_unNumber.is_value()) return FALSE;
if (!single_value->field_elevatedTemperature.is_value()) return FALSE;
if (!single_value->field_tunnelsRestricted.is_value()) return FALSE;
if (!single_value->field_limitedQuantity.is_value()) return FALSE;
if (!single_value->field_emergencyActionCode.is_omit() && !single_value->field_emergencyActionCode.is_value()) return FALSE;
if (!single_value->field_phoneNumber.is_omit() && !single_value->field_phoneNumber.is_value()) return FALSE;
if (!single_value->field_companyName.is_omit() && !single_value->field_companyName.is_value()) return FALSE;
return TRUE;
}

void DangerousGoodsExtended_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DangerousGoodsExtended DangerousGoodsExtended_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.DangerousGoodsExtended.");
DangerousGoodsExtended ret_val;
if (single_value->field_dangerousGoodsType.is_bound()) {
ret_val.dangerousGoodsType() = single_value->field_dangerousGoodsType.valueof();
}
if (single_value->field_unNumber.is_bound()) {
ret_val.unNumber() = single_value->field_unNumber.valueof();
}
if (single_value->field_elevatedTemperature.is_bound()) {
ret_val.elevatedTemperature() = single_value->field_elevatedTemperature.valueof();
}
if (single_value->field_tunnelsRestricted.is_bound()) {
ret_val.tunnelsRestricted() = single_value->field_tunnelsRestricted.valueof();
}
if (single_value->field_limitedQuantity.is_bound()) {
ret_val.limitedQuantity() = single_value->field_limitedQuantity.valueof();
}
if (single_value->field_emergencyActionCode.is_omit()) ret_val.emergencyActionCode() = OMIT_VALUE;
else if (single_value->field_emergencyActionCode.is_bound()) {
ret_val.emergencyActionCode() = single_value->field_emergencyActionCode.valueof();
}
if (single_value->field_phoneNumber.is_omit()) ret_val.phoneNumber() = OMIT_VALUE;
else if (single_value->field_phoneNumber.is_bound()) {
ret_val.phoneNumber() = single_value->field_phoneNumber.valueof();
}
if (single_value->field_companyName.is_omit()) ret_val.companyName() = OMIT_VALUE;
else if (single_value->field_companyName.is_bound()) {
ret_val.companyName() = single_value->field_companyName.valueof();
}
return ret_val;
}

void DangerousGoodsExtended_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.DangerousGoodsExtended.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DangerousGoodsExtended_template[list_length];
}

DangerousGoodsExtended_template& DangerousGoodsExtended_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.DangerousGoodsExtended.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.DangerousGoodsExtended.");
return value_list.list_value[list_index];
}

DangerousGoodsBasic_template& DangerousGoodsExtended_template::dangerousGoodsType()
{
set_specific();
return single_value->field_dangerousGoodsType;
}

const DangerousGoodsBasic_template& DangerousGoodsExtended_template::dangerousGoodsType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dangerousGoodsType of a non-specific template of type @ITS-Container.DangerousGoodsExtended.");
return single_value->field_dangerousGoodsType;
}

INTEGER_template& DangerousGoodsExtended_template::unNumber()
{
set_specific();
return single_value->field_unNumber;
}

const INTEGER_template& DangerousGoodsExtended_template::unNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field unNumber of a non-specific template of type @ITS-Container.DangerousGoodsExtended.");
return single_value->field_unNumber;
}

BOOLEAN_template& DangerousGoodsExtended_template::elevatedTemperature()
{
set_specific();
return single_value->field_elevatedTemperature;
}

const BOOLEAN_template& DangerousGoodsExtended_template::elevatedTemperature() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field elevatedTemperature of a non-specific template of type @ITS-Container.DangerousGoodsExtended.");
return single_value->field_elevatedTemperature;
}

BOOLEAN_template& DangerousGoodsExtended_template::tunnelsRestricted()
{
set_specific();
return single_value->field_tunnelsRestricted;
}

const BOOLEAN_template& DangerousGoodsExtended_template::tunnelsRestricted() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field tunnelsRestricted of a non-specific template of type @ITS-Container.DangerousGoodsExtended.");
return single_value->field_tunnelsRestricted;
}

BOOLEAN_template& DangerousGoodsExtended_template::limitedQuantity()
{
set_specific();
return single_value->field_limitedQuantity;
}

const BOOLEAN_template& DangerousGoodsExtended_template::limitedQuantity() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field limitedQuantity of a non-specific template of type @ITS-Container.DangerousGoodsExtended.");
return single_value->field_limitedQuantity;
}

CHARSTRING_template& DangerousGoodsExtended_template::emergencyActionCode()
{
set_specific();
return single_value->field_emergencyActionCode;
}

const CHARSTRING_template& DangerousGoodsExtended_template::emergencyActionCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field emergencyActionCode of a non-specific template of type @ITS-Container.DangerousGoodsExtended.");
return single_value->field_emergencyActionCode;
}

CHARSTRING_template& DangerousGoodsExtended_template::phoneNumber()
{
set_specific();
return single_value->field_phoneNumber;
}

const CHARSTRING_template& DangerousGoodsExtended_template::phoneNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field phoneNumber of a non-specific template of type @ITS-Container.DangerousGoodsExtended.");
return single_value->field_phoneNumber;
}

UNIVERSAL_CHARSTRING_template& DangerousGoodsExtended_template::companyName()
{
set_specific();
return single_value->field_companyName;
}

const UNIVERSAL_CHARSTRING_template& DangerousGoodsExtended_template::companyName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field companyName of a non-specific template of type @ITS-Container.DangerousGoodsExtended.");
return single_value->field_companyName;
}

int DangerousGoodsExtended_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DangerousGoodsExtended which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 5;
      if (single_value->field_emergencyActionCode.is_present()) ret_val++;
      if (single_value->field_phoneNumber.is_present()) ret_val++;
      if (single_value->field_companyName.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.DangerousGoodsExtended containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DangerousGoodsExtended containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DangerousGoodsExtended containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DangerousGoodsExtended containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.DangerousGoodsExtended containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.DangerousGoodsExtended.");
  }
  return 0;
}

void DangerousGoodsExtended_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ dangerousGoodsType := ");
single_value->field_dangerousGoodsType.log();
TTCN_Logger::log_event_str(", unNumber := ");
single_value->field_unNumber.log();
TTCN_Logger::log_event_str(", elevatedTemperature := ");
single_value->field_elevatedTemperature.log();
TTCN_Logger::log_event_str(", tunnelsRestricted := ");
single_value->field_tunnelsRestricted.log();
TTCN_Logger::log_event_str(", limitedQuantity := ");
single_value->field_limitedQuantity.log();
TTCN_Logger::log_event_str(", emergencyActionCode := ");
single_value->field_emergencyActionCode.log();
TTCN_Logger::log_event_str(", phoneNumber := ");
single_value->field_phoneNumber.log();
TTCN_Logger::log_event_str(", companyName := ");
single_value->field_companyName.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DangerousGoodsExtended_template::log_match(const DangerousGoodsExtended& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_dangerousGoodsType.match(match_value.dangerousGoodsType(), legacy)){
TTCN_Logger::log_logmatch_info(".dangerousGoodsType");
single_value->field_dangerousGoodsType.log_match(match_value.dangerousGoodsType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_unNumber.match(match_value.unNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".unNumber");
single_value->field_unNumber.log_match(match_value.unNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_elevatedTemperature.match(match_value.elevatedTemperature(), legacy)){
TTCN_Logger::log_logmatch_info(".elevatedTemperature");
single_value->field_elevatedTemperature.log_match(match_value.elevatedTemperature(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_tunnelsRestricted.match(match_value.tunnelsRestricted(), legacy)){
TTCN_Logger::log_logmatch_info(".tunnelsRestricted");
single_value->field_tunnelsRestricted.log_match(match_value.tunnelsRestricted(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_limitedQuantity.match(match_value.limitedQuantity(), legacy)){
TTCN_Logger::log_logmatch_info(".limitedQuantity");
single_value->field_limitedQuantity.log_match(match_value.limitedQuantity(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.emergencyActionCode().ispresent()){
if(!single_value->field_emergencyActionCode.match(match_value.emergencyActionCode(), legacy)){
TTCN_Logger::log_logmatch_info(".emergencyActionCode");
single_value->field_emergencyActionCode.log_match(match_value.emergencyActionCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_emergencyActionCode.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".emergencyActionCode := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_emergencyActionCode.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.phoneNumber().ispresent()){
if(!single_value->field_phoneNumber.match(match_value.phoneNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".phoneNumber");
single_value->field_phoneNumber.log_match(match_value.phoneNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_phoneNumber.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".phoneNumber := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_phoneNumber.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.companyName().ispresent()){
if(!single_value->field_companyName.match(match_value.companyName(), legacy)){
TTCN_Logger::log_logmatch_info(".companyName");
single_value->field_companyName.log_match(match_value.companyName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_companyName.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".companyName := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_companyName.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ dangerousGoodsType := ");
single_value->field_dangerousGoodsType.log_match(match_value.dangerousGoodsType(), legacy);
TTCN_Logger::log_event_str(", unNumber := ");
single_value->field_unNumber.log_match(match_value.unNumber(), legacy);
TTCN_Logger::log_event_str(", elevatedTemperature := ");
single_value->field_elevatedTemperature.log_match(match_value.elevatedTemperature(), legacy);
TTCN_Logger::log_event_str(", tunnelsRestricted := ");
single_value->field_tunnelsRestricted.log_match(match_value.tunnelsRestricted(), legacy);
TTCN_Logger::log_event_str(", limitedQuantity := ");
single_value->field_limitedQuantity.log_match(match_value.limitedQuantity(), legacy);
TTCN_Logger::log_event_str(", emergencyActionCode := ");
if (match_value.emergencyActionCode().ispresent()) single_value->field_emergencyActionCode.log_match(match_value.emergencyActionCode(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_emergencyActionCode.log();
if (single_value->field_emergencyActionCode.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", phoneNumber := ");
if (match_value.phoneNumber().ispresent()) single_value->field_phoneNumber.log_match(match_value.phoneNumber(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_phoneNumber.log();
if (single_value->field_phoneNumber.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", companyName := ");
if (match_value.companyName().ispresent()) single_value->field_companyName.log_match(match_value.companyName(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_companyName.log();
if (single_value->field_companyName.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DangerousGoodsExtended_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_dangerousGoodsType.encode_text(text_buf);
single_value->field_unNumber.encode_text(text_buf);
single_value->field_elevatedTemperature.encode_text(text_buf);
single_value->field_tunnelsRestricted.encode_text(text_buf);
single_value->field_limitedQuantity.encode_text(text_buf);
single_value->field_emergencyActionCode.encode_text(text_buf);
single_value->field_phoneNumber.encode_text(text_buf);
single_value->field_companyName.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.DangerousGoodsExtended.");
}
}

void DangerousGoodsExtended_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_dangerousGoodsType.decode_text(text_buf);
single_value->field_unNumber.decode_text(text_buf);
single_value->field_elevatedTemperature.decode_text(text_buf);
single_value->field_tunnelsRestricted.decode_text(text_buf);
single_value->field_limitedQuantity.decode_text(text_buf);
single_value->field_emergencyActionCode.decode_text(text_buf);
single_value->field_phoneNumber.decode_text(text_buf);
single_value->field_companyName.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DangerousGoodsExtended_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.DangerousGoodsExtended.");
}
}

void DangerousGoodsExtended_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.DangerousGoodsExtended'");
    }
    if (strcmp("dangerousGoodsType", param_field) == 0) {
      dangerousGoodsType().set_param(param);
      return;
    } else if (strcmp("unNumber", param_field) == 0) {
      unNumber().set_param(param);
      return;
    } else if (strcmp("elevatedTemperature", param_field) == 0) {
      elevatedTemperature().set_param(param);
      return;
    } else if (strcmp("tunnelsRestricted", param_field) == 0) {
      tunnelsRestricted().set_param(param);
      return;
    } else if (strcmp("limitedQuantity", param_field) == 0) {
      limitedQuantity().set_param(param);
      return;
    } else if (strcmp("emergencyActionCode", param_field) == 0) {
      emergencyActionCode().set_param(param);
      return;
    } else if (strcmp("phoneNumber", param_field) == 0) {
      phoneNumber().set_param(param);
      return;
    } else if (strcmp("companyName", param_field) == 0) {
      companyName().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.DangerousGoodsExtended'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DangerousGoodsExtended_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record template of type @ITS-Container.DangerousGoodsExtended has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) dangerousGoodsType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) unNumber().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) elevatedTemperature().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) tunnelsRestricted().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) limitedQuantity().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) emergencyActionCode().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) phoneNumber().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) companyName().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousGoodsType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousGoodsType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "unNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          unNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "elevatedTemperature")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          elevatedTemperature().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tunnelsRestricted")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tunnelsRestricted().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "limitedQuantity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          limitedQuantity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergencyActionCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergencyActionCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "phoneNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          phoneNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "companyName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          companyName().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.DangerousGoodsExtended: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.DangerousGoodsExtended");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DangerousGoodsExtended_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.DangerousGoodsExtended'");
    }
    if (strcmp("dangerousGoodsType", param_field) == 0) {
      return dangerousGoodsType().get_param(param_name);
    } else if (strcmp("unNumber", param_field) == 0) {
      return unNumber().get_param(param_name);
    } else if (strcmp("elevatedTemperature", param_field) == 0) {
      return elevatedTemperature().get_param(param_name);
    } else if (strcmp("tunnelsRestricted", param_field) == 0) {
      return tunnelsRestricted().get_param(param_name);
    } else if (strcmp("limitedQuantity", param_field) == 0) {
      return limitedQuantity().get_param(param_name);
    } else if (strcmp("emergencyActionCode", param_field) == 0) {
      return emergencyActionCode().get_param(param_name);
    } else if (strcmp("phoneNumber", param_field) == 0) {
      return phoneNumber().get_param(param_name);
    } else if (strcmp("companyName", param_field) == 0) {
      return companyName().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.DangerousGoodsExtended'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_dangerousGoodsType = single_value->field_dangerousGoodsType.get_param(param_name);
    mp_field_dangerousGoodsType->set_id(new Module_Param_FieldName(mcopystr("dangerousGoodsType")));
    mp->add_elem(mp_field_dangerousGoodsType);
    Module_Param* mp_field_unNumber = single_value->field_unNumber.get_param(param_name);
    mp_field_unNumber->set_id(new Module_Param_FieldName(mcopystr("unNumber")));
    mp->add_elem(mp_field_unNumber);
    Module_Param* mp_field_elevatedTemperature = single_value->field_elevatedTemperature.get_param(param_name);
    mp_field_elevatedTemperature->set_id(new Module_Param_FieldName(mcopystr("elevatedTemperature")));
    mp->add_elem(mp_field_elevatedTemperature);
    Module_Param* mp_field_tunnelsRestricted = single_value->field_tunnelsRestricted.get_param(param_name);
    mp_field_tunnelsRestricted->set_id(new Module_Param_FieldName(mcopystr("tunnelsRestricted")));
    mp->add_elem(mp_field_tunnelsRestricted);
    Module_Param* mp_field_limitedQuantity = single_value->field_limitedQuantity.get_param(param_name);
    mp_field_limitedQuantity->set_id(new Module_Param_FieldName(mcopystr("limitedQuantity")));
    mp->add_elem(mp_field_limitedQuantity);
    Module_Param* mp_field_emergencyActionCode = single_value->field_emergencyActionCode.get_param(param_name);
    mp_field_emergencyActionCode->set_id(new Module_Param_FieldName(mcopystr("emergencyActionCode")));
    mp->add_elem(mp_field_emergencyActionCode);
    Module_Param* mp_field_phoneNumber = single_value->field_phoneNumber.get_param(param_name);
    mp_field_phoneNumber->set_id(new Module_Param_FieldName(mcopystr("phoneNumber")));
    mp->add_elem(mp_field_phoneNumber);
    Module_Param* mp_field_companyName = single_value->field_companyName.get_param(param_name);
    mp_field_companyName->set_id(new Module_Param_FieldName(mcopystr("companyName")));
    mp->add_elem(mp_field_companyName);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DangerousGoodsExtended_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_dangerousGoodsType.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DangerousGoodsExtended");
single_value->field_unNumber.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DangerousGoodsExtended");
single_value->field_elevatedTemperature.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DangerousGoodsExtended");
single_value->field_tunnelsRestricted.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DangerousGoodsExtended");
single_value->field_limitedQuantity.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DangerousGoodsExtended");
single_value->field_emergencyActionCode.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DangerousGoodsExtended");
single_value->field_phoneNumber.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DangerousGoodsExtended");
single_value->field_companyName.check_restriction(t_res, t_name ? t_name : "@ITS-Container.DangerousGoodsExtended");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.DangerousGoodsExtended");
}

boolean DangerousGoodsExtended_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DangerousGoodsExtended_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

RequestResponseIndication::RequestResponseIndication()
{
enum_value = UNBOUND_VALUE;
}

RequestResponseIndication::RequestResponseIndication(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.RequestResponseIndication with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

RequestResponseIndication::RequestResponseIndication(enum_type other_value)
{
enum_value = other_value;
}

RequestResponseIndication::RequestResponseIndication(const RequestResponseIndication& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
enum_value = other_value.enum_value;
}

RequestResponseIndication& RequestResponseIndication::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.RequestResponseIndication.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

RequestResponseIndication& RequestResponseIndication::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

RequestResponseIndication& RequestResponseIndication::operator=(const RequestResponseIndication& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
enum_value = other_value.enum_value;
return *this;
}

boolean RequestResponseIndication::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
return enum_value == other_value;
}

boolean RequestResponseIndication::operator==(const RequestResponseIndication& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
return enum_value == other_value.enum_value;
}

boolean RequestResponseIndication::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
return enum_value < other_value;
}

boolean RequestResponseIndication::operator<(const RequestResponseIndication& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
return enum_value < other_value.enum_value;
}

boolean RequestResponseIndication::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
return enum_value > other_value;
}

boolean RequestResponseIndication::operator>(const RequestResponseIndication& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
return enum_value > other_value.enum_value;
}

const char *RequestResponseIndication::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case request: return "request";
case response: return "response";
default: return "<unknown>";
}
}

RequestResponseIndication::enum_type RequestResponseIndication::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "request")) return request;
else if (!strcmp(str_par, "response")) return response;
else return UNKNOWN_VALUE;
}

boolean RequestResponseIndication::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
return TRUE;
default:
return FALSE;
}
}

int RequestResponseIndication::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.RequestResponseIndication.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int RequestResponseIndication::enum2int(const RequestResponseIndication& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.RequestResponseIndication.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void RequestResponseIndication::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.RequestResponseIndication.", int_val);
enum_value = (enum_type)int_val;
}

RequestResponseIndication::operator RequestResponseIndication::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.RequestResponseIndication.");
return enum_value;
}

void RequestResponseIndication::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void RequestResponseIndication::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.RequestResponseIndication");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.RequestResponseIndication.");
  }
}

Module_Param* RequestResponseIndication::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void RequestResponseIndication::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
text_buf.push_int(enum_value);
}

void RequestResponseIndication::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.RequestResponseIndication.", enum_value);
}

void RequestResponseIndication::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RequestResponseIndication::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RequestResponseIndication::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RequestResponseIndication::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.RequestResponseIndication: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int RequestResponseIndication::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int RequestResponseIndication::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void RequestResponseIndication_template::copy_template(const RequestResponseIndication_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RequestResponseIndication_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.RequestResponseIndication.");
}
}

RequestResponseIndication_template::RequestResponseIndication_template()
{
}

RequestResponseIndication_template::RequestResponseIndication_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RequestResponseIndication_template::RequestResponseIndication_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!RequestResponseIndication::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.RequestResponseIndication with unknown numeric value %d.", other_value);
single_value = (RequestResponseIndication::enum_type)other_value;
}

RequestResponseIndication_template::RequestResponseIndication_template(RequestResponseIndication::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

RequestResponseIndication_template::RequestResponseIndication_template(const RequestResponseIndication& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == RequestResponseIndication::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.RequestResponseIndication.");
single_value = other_value.enum_value;
}

RequestResponseIndication_template::RequestResponseIndication_template(const OPTIONAL<RequestResponseIndication>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RequestResponseIndication::enum_type)(const RequestResponseIndication&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.RequestResponseIndication from an unbound optional field.");
}
}

RequestResponseIndication_template::RequestResponseIndication_template(const RequestResponseIndication_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

RequestResponseIndication_template::~RequestResponseIndication_template()
{
clean_up();
}

boolean RequestResponseIndication_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean RequestResponseIndication_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != RequestResponseIndication::UNBOUND_VALUE;
}

void RequestResponseIndication_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

RequestResponseIndication_template& RequestResponseIndication_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RequestResponseIndication_template& RequestResponseIndication_template::operator=(int other_value)
{
if (!RequestResponseIndication::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.RequestResponseIndication.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (RequestResponseIndication::enum_type)other_value;
return *this;
}

RequestResponseIndication_template& RequestResponseIndication_template::operator=(RequestResponseIndication::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

RequestResponseIndication_template& RequestResponseIndication_template::operator=(const RequestResponseIndication& other_value)
{
if (other_value.enum_value == RequestResponseIndication::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.RequestResponseIndication to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

RequestResponseIndication_template& RequestResponseIndication_template::operator=(const OPTIONAL<RequestResponseIndication>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RequestResponseIndication::enum_type)(const RequestResponseIndication&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.RequestResponseIndication.");
}
return *this;
}

RequestResponseIndication_template& RequestResponseIndication_template::operator=(const RequestResponseIndication_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RequestResponseIndication_template::match(RequestResponseIndication::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.RequestResponseIndication.");
}
return FALSE;
}

boolean RequestResponseIndication_template::match(const RequestResponseIndication& other_value, boolean) const
{
if (other_value.enum_value == RequestResponseIndication::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.RequestResponseIndication with an unbound value.");
return match(other_value.enum_value);
}

RequestResponseIndication::enum_type RequestResponseIndication_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.RequestResponseIndication.");
return single_value;
}

void RequestResponseIndication_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.RequestResponseIndication.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RequestResponseIndication_template[list_length];
}

RequestResponseIndication_template& RequestResponseIndication_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.RequestResponseIndication.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.RequestResponseIndication.");
return value_list.list_value[list_index];
}

void RequestResponseIndication_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(RequestResponseIndication::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RequestResponseIndication_template::log_match(const RequestResponseIndication& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void RequestResponseIndication_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.RequestResponseIndication.");
}
}

void RequestResponseIndication_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (RequestResponseIndication::enum_type)text_buf.pull_int().get_val();
if (!RequestResponseIndication::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.RequestResponseIndication.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RequestResponseIndication_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.RequestResponseIndication.");
}
}

boolean RequestResponseIndication_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RequestResponseIndication_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RequestResponseIndication_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    RequestResponseIndication::enum_type enum_val = (enum_name != NULL) ? RequestResponseIndication::str_to_enum(enum_name) : RequestResponseIndication::UNKNOWN_VALUE;
    if (RequestResponseIndication::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RequestResponseIndication_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    RequestResponseIndication::enum_type enum_val = RequestResponseIndication::str_to_enum(mp->get_enumerated());
    if (!RequestResponseIndication::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.RequestResponseIndication.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.RequestResponseIndication");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RequestResponseIndication_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(RequestResponseIndication::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RequestResponseIndication_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.RequestResponseIndication");
}

StationarySince::StationarySince()
{
enum_value = UNBOUND_VALUE;
}

StationarySince::StationarySince(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.StationarySince with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

StationarySince::StationarySince(enum_type other_value)
{
enum_value = other_value;
}

StationarySince::StationarySince(const StationarySince& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.StationarySince.");
enum_value = other_value.enum_value;
}

StationarySince& StationarySince::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.StationarySince.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

StationarySince& StationarySince::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

StationarySince& StationarySince::operator=(const StationarySince& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.StationarySince.");
enum_value = other_value.enum_value;
return *this;
}

boolean StationarySince::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.StationarySince.");
return enum_value == other_value;
}

boolean StationarySince::operator==(const StationarySince& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.StationarySince.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.StationarySince.");
return enum_value == other_value.enum_value;
}

boolean StationarySince::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.StationarySince.");
return enum_value < other_value;
}

boolean StationarySince::operator<(const StationarySince& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.StationarySince.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.StationarySince.");
return enum_value < other_value.enum_value;
}

boolean StationarySince::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.StationarySince.");
return enum_value > other_value;
}

boolean StationarySince::operator>(const StationarySince& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.StationarySince.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.StationarySince.");
return enum_value > other_value.enum_value;
}

const char *StationarySince::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case lessThan1Minute: return "lessThan1Minute";
case lessThan2Minutes: return "lessThan2Minutes";
case lessThan15Minutes: return "lessThan15Minutes";
case equalOrGreater15Minutes: return "equalOrGreater15Minutes";
default: return "<unknown>";
}
}

StationarySince::enum_type StationarySince::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "lessThan1Minute")) return lessThan1Minute;
else if (!strcmp(str_par, "lessThan2Minutes")) return lessThan2Minutes;
else if (!strcmp(str_par, "lessThan15Minutes")) return lessThan15Minutes;
else if (!strcmp(str_par, "equalOrGreater15Minutes")) return equalOrGreater15Minutes;
else return UNKNOWN_VALUE;
}

boolean StationarySince::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int StationarySince::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.StationarySince.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int StationarySince::enum2int(const StationarySince& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.StationarySince.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void StationarySince::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.StationarySince.", int_val);
enum_value = (enum_type)int_val;
}

StationarySince::operator StationarySince::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.StationarySince.");
return enum_value;
}

void StationarySince::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void StationarySince::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.StationarySince");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.StationarySince.");
  }
}

Module_Param* StationarySince::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void StationarySince::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.StationarySince.");
text_buf.push_int(enum_value);
}

void StationarySince::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.StationarySince.", enum_value);
}

void StationarySince::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void StationarySince::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* StationarySince::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean StationarySince::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.StationarySince: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int StationarySince::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.StationarySince.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int StationarySince::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void StationarySince_template::copy_template(const StationarySince_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new StationarySince_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.StationarySince.");
}
}

StationarySince_template::StationarySince_template()
{
}

StationarySince_template::StationarySince_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

StationarySince_template::StationarySince_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!StationarySince::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.StationarySince with unknown numeric value %d.", other_value);
single_value = (StationarySince::enum_type)other_value;
}

StationarySince_template::StationarySince_template(StationarySince::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

StationarySince_template::StationarySince_template(const StationarySince& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == StationarySince::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.StationarySince.");
single_value = other_value.enum_value;
}

StationarySince_template::StationarySince_template(const OPTIONAL<StationarySince>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (StationarySince::enum_type)(const StationarySince&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.StationarySince from an unbound optional field.");
}
}

StationarySince_template::StationarySince_template(const StationarySince_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

StationarySince_template::~StationarySince_template()
{
clean_up();
}

boolean StationarySince_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean StationarySince_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != StationarySince::UNBOUND_VALUE;
}

void StationarySince_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

StationarySince_template& StationarySince_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

StationarySince_template& StationarySince_template::operator=(int other_value)
{
if (!StationarySince::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.StationarySince.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (StationarySince::enum_type)other_value;
return *this;
}

StationarySince_template& StationarySince_template::operator=(StationarySince::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

StationarySince_template& StationarySince_template::operator=(const StationarySince& other_value)
{
if (other_value.enum_value == StationarySince::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.StationarySince to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

StationarySince_template& StationarySince_template::operator=(const OPTIONAL<StationarySince>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (StationarySince::enum_type)(const StationarySince&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.StationarySince.");
}
return *this;
}

StationarySince_template& StationarySince_template::operator=(const StationarySince_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean StationarySince_template::match(StationarySince::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.StationarySince.");
}
return FALSE;
}

boolean StationarySince_template::match(const StationarySince& other_value, boolean) const
{
if (other_value.enum_value == StationarySince::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.StationarySince with an unbound value.");
return match(other_value.enum_value);
}

StationarySince::enum_type StationarySince_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.StationarySince.");
return single_value;
}

void StationarySince_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.StationarySince.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new StationarySince_template[list_length];
}

StationarySince_template& StationarySince_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.StationarySince.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.StationarySince.");
return value_list.list_value[list_index];
}

void StationarySince_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(StationarySince::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void StationarySince_template::log_match(const StationarySince& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void StationarySince_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.StationarySince.");
}
}

void StationarySince_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (StationarySince::enum_type)text_buf.pull_int().get_val();
if (!StationarySince::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.StationarySince.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new StationarySince_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.StationarySince.");
}
}

boolean StationarySince_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean StationarySince_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void StationarySince_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    StationarySince::enum_type enum_val = (enum_name != NULL) ? StationarySince::str_to_enum(enum_name) : StationarySince::UNKNOWN_VALUE;
    if (StationarySince::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    StationarySince_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    StationarySince::enum_type enum_val = StationarySince::str_to_enum(mp->get_enumerated());
    if (!StationarySince::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.StationarySince.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.StationarySince");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* StationarySince_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(StationarySince::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void StationarySince_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.StationarySince");
}

TrafficRule::TrafficRule()
{
enum_value = UNBOUND_VALUE;
}

TrafficRule::TrafficRule(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.TrafficRule with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

TrafficRule::TrafficRule(enum_type other_value)
{
enum_value = other_value;
}

TrafficRule::TrafficRule(const TrafficRule& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.TrafficRule.");
enum_value = other_value.enum_value;
}

TrafficRule& TrafficRule::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.TrafficRule.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

TrafficRule& TrafficRule::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

TrafficRule& TrafficRule::operator=(const TrafficRule& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.TrafficRule.");
enum_value = other_value.enum_value;
return *this;
}

boolean TrafficRule::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.TrafficRule.");
return enum_value == other_value;
}

boolean TrafficRule::operator==(const TrafficRule& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.TrafficRule.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.TrafficRule.");
return enum_value == other_value.enum_value;
}

boolean TrafficRule::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.TrafficRule.");
return enum_value < other_value;
}

boolean TrafficRule::operator<(const TrafficRule& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.TrafficRule.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.TrafficRule.");
return enum_value < other_value.enum_value;
}

boolean TrafficRule::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.TrafficRule.");
return enum_value > other_value;
}

boolean TrafficRule::operator>(const TrafficRule& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.TrafficRule.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.TrafficRule.");
return enum_value > other_value.enum_value;
}

const char *TrafficRule::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case noPassing: return "noPassing";
case noPassingForTrucks: return "noPassingForTrucks";
case passToRight: return "passToRight";
case passToLeft: return "passToLeft";
default: return "<unknown>";
}
}

TrafficRule::enum_type TrafficRule::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "noPassing")) return noPassing;
else if (!strcmp(str_par, "noPassingForTrucks")) return noPassingForTrucks;
else if (!strcmp(str_par, "passToRight")) return passToRight;
else if (!strcmp(str_par, "passToLeft")) return passToLeft;
else return UNKNOWN_VALUE;
}

boolean TrafficRule::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int TrafficRule::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.TrafficRule.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int TrafficRule::enum2int(const TrafficRule& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.TrafficRule.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void TrafficRule::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.TrafficRule.", int_val);
enum_value = (enum_type)int_val;
}

TrafficRule::operator TrafficRule::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.TrafficRule.");
return enum_value;
}

void TrafficRule::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void TrafficRule::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.TrafficRule");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.TrafficRule.");
  }
}

Module_Param* TrafficRule::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void TrafficRule::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.TrafficRule.");
text_buf.push_int(enum_value);
}

void TrafficRule::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.TrafficRule.", enum_value);
}

void TrafficRule::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TrafficRule::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* TrafficRule::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean TrafficRule::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.TrafficRule: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int TrafficRule::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.TrafficRule.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int TrafficRule::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void TrafficRule_template::copy_template(const TrafficRule_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TrafficRule_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.TrafficRule.");
}
}

TrafficRule_template::TrafficRule_template()
{
}

TrafficRule_template::TrafficRule_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TrafficRule_template::TrafficRule_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!TrafficRule::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.TrafficRule with unknown numeric value %d.", other_value);
single_value = (TrafficRule::enum_type)other_value;
}

TrafficRule_template::TrafficRule_template(TrafficRule::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

TrafficRule_template::TrafficRule_template(const TrafficRule& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == TrafficRule::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.TrafficRule.");
single_value = other_value.enum_value;
}

TrafficRule_template::TrafficRule_template(const OPTIONAL<TrafficRule>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TrafficRule::enum_type)(const TrafficRule&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.TrafficRule from an unbound optional field.");
}
}

TrafficRule_template::TrafficRule_template(const TrafficRule_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

TrafficRule_template::~TrafficRule_template()
{
clean_up();
}

boolean TrafficRule_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean TrafficRule_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != TrafficRule::UNBOUND_VALUE;
}

void TrafficRule_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

TrafficRule_template& TrafficRule_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TrafficRule_template& TrafficRule_template::operator=(int other_value)
{
if (!TrafficRule::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.TrafficRule.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (TrafficRule::enum_type)other_value;
return *this;
}

TrafficRule_template& TrafficRule_template::operator=(TrafficRule::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

TrafficRule_template& TrafficRule_template::operator=(const TrafficRule& other_value)
{
if (other_value.enum_value == TrafficRule::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.TrafficRule to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

TrafficRule_template& TrafficRule_template::operator=(const OPTIONAL<TrafficRule>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TrafficRule::enum_type)(const TrafficRule&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.TrafficRule.");
}
return *this;
}

TrafficRule_template& TrafficRule_template::operator=(const TrafficRule_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TrafficRule_template::match(TrafficRule::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.TrafficRule.");
}
return FALSE;
}

boolean TrafficRule_template::match(const TrafficRule& other_value, boolean) const
{
if (other_value.enum_value == TrafficRule::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.TrafficRule with an unbound value.");
return match(other_value.enum_value);
}

TrafficRule::enum_type TrafficRule_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.TrafficRule.");
return single_value;
}

void TrafficRule_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.TrafficRule.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TrafficRule_template[list_length];
}

TrafficRule_template& TrafficRule_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.TrafficRule.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.TrafficRule.");
return value_list.list_value[list_index];
}

void TrafficRule_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(TrafficRule::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TrafficRule_template::log_match(const TrafficRule& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void TrafficRule_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.TrafficRule.");
}
}

void TrafficRule_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (TrafficRule::enum_type)text_buf.pull_int().get_val();
if (!TrafficRule::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.TrafficRule.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TrafficRule_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.TrafficRule.");
}
}

boolean TrafficRule_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TrafficRule_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void TrafficRule_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    TrafficRule::enum_type enum_val = (enum_name != NULL) ? TrafficRule::str_to_enum(enum_name) : TrafficRule::UNKNOWN_VALUE;
    if (TrafficRule::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TrafficRule_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    TrafficRule::enum_type enum_val = TrafficRule::str_to_enum(mp->get_enumerated());
    if (!TrafficRule::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.TrafficRule.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.TrafficRule");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TrafficRule_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(TrafficRule::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TrafficRule_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.TrafficRule");
}

PositioningSolutionType::PositioningSolutionType()
{
enum_value = UNBOUND_VALUE;
}

PositioningSolutionType::PositioningSolutionType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.PositioningSolutionType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

PositioningSolutionType::PositioningSolutionType(enum_type other_value)
{
enum_value = other_value;
}

PositioningSolutionType::PositioningSolutionType(const PositioningSolutionType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
enum_value = other_value.enum_value;
}

PositioningSolutionType& PositioningSolutionType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.PositioningSolutionType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

PositioningSolutionType& PositioningSolutionType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

PositioningSolutionType& PositioningSolutionType::operator=(const PositioningSolutionType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
enum_value = other_value.enum_value;
return *this;
}

boolean PositioningSolutionType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
return enum_value == other_value;
}

boolean PositioningSolutionType::operator==(const PositioningSolutionType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
return enum_value == other_value.enum_value;
}

boolean PositioningSolutionType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
return enum_value < other_value;
}

boolean PositioningSolutionType::operator<(const PositioningSolutionType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
return enum_value < other_value.enum_value;
}

boolean PositioningSolutionType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
return enum_value > other_value;
}

boolean PositioningSolutionType::operator>(const PositioningSolutionType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
return enum_value > other_value.enum_value;
}

const char *PositioningSolutionType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case noPositioningSolution: return "noPositioningSolution";
case sGNSS: return "sGNSS";
case dGNSS: return "dGNSS";
case sGNSSplusDR: return "sGNSSplusDR";
case dGNSSplusDR: return "dGNSSplusDR";
case dR: return "dR";
default: return "<unknown>";
}
}

PositioningSolutionType::enum_type PositioningSolutionType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "noPositioningSolution")) return noPositioningSolution;
else if (!strcmp(str_par, "sGNSS")) return sGNSS;
else if (!strcmp(str_par, "dGNSS")) return dGNSS;
else if (!strcmp(str_par, "sGNSSplusDR")) return sGNSSplusDR;
else if (!strcmp(str_par, "dGNSSplusDR")) return dGNSSplusDR;
else if (!strcmp(str_par, "dR")) return dR;
else return UNKNOWN_VALUE;
}

boolean PositioningSolutionType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
return TRUE;
default:
return FALSE;
}
}

int PositioningSolutionType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.PositioningSolutionType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int PositioningSolutionType::enum2int(const PositioningSolutionType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.PositioningSolutionType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void PositioningSolutionType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.PositioningSolutionType.", int_val);
enum_value = (enum_type)int_val;
}

PositioningSolutionType::operator PositioningSolutionType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.PositioningSolutionType.");
return enum_value;
}

void PositioningSolutionType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void PositioningSolutionType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.PositioningSolutionType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.PositioningSolutionType.");
  }
}

Module_Param* PositioningSolutionType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void PositioningSolutionType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
text_buf.push_int(enum_value);
}

void PositioningSolutionType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.PositioningSolutionType.", enum_value);
}

void PositioningSolutionType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PositioningSolutionType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* PositioningSolutionType::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean PositioningSolutionType::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.PositioningSolutionType: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int PositioningSolutionType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int PositioningSolutionType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void PositioningSolutionType_template::copy_template(const PositioningSolutionType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PositioningSolutionType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.PositioningSolutionType.");
}
}

PositioningSolutionType_template::PositioningSolutionType_template()
{
}

PositioningSolutionType_template::PositioningSolutionType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PositioningSolutionType_template::PositioningSolutionType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!PositioningSolutionType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.PositioningSolutionType with unknown numeric value %d.", other_value);
single_value = (PositioningSolutionType::enum_type)other_value;
}

PositioningSolutionType_template::PositioningSolutionType_template(PositioningSolutionType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

PositioningSolutionType_template::PositioningSolutionType_template(const PositioningSolutionType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == PositioningSolutionType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.PositioningSolutionType.");
single_value = other_value.enum_value;
}

PositioningSolutionType_template::PositioningSolutionType_template(const OPTIONAL<PositioningSolutionType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PositioningSolutionType::enum_type)(const PositioningSolutionType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.PositioningSolutionType from an unbound optional field.");
}
}

PositioningSolutionType_template::PositioningSolutionType_template(const PositioningSolutionType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

PositioningSolutionType_template::~PositioningSolutionType_template()
{
clean_up();
}

boolean PositioningSolutionType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean PositioningSolutionType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != PositioningSolutionType::UNBOUND_VALUE;
}

void PositioningSolutionType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

PositioningSolutionType_template& PositioningSolutionType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PositioningSolutionType_template& PositioningSolutionType_template::operator=(int other_value)
{
if (!PositioningSolutionType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.PositioningSolutionType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (PositioningSolutionType::enum_type)other_value;
return *this;
}

PositioningSolutionType_template& PositioningSolutionType_template::operator=(PositioningSolutionType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

PositioningSolutionType_template& PositioningSolutionType_template::operator=(const PositioningSolutionType& other_value)
{
if (other_value.enum_value == PositioningSolutionType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.PositioningSolutionType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

PositioningSolutionType_template& PositioningSolutionType_template::operator=(const OPTIONAL<PositioningSolutionType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PositioningSolutionType::enum_type)(const PositioningSolutionType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.PositioningSolutionType.");
}
return *this;
}

PositioningSolutionType_template& PositioningSolutionType_template::operator=(const PositioningSolutionType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PositioningSolutionType_template::match(PositioningSolutionType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.PositioningSolutionType.");
}
return FALSE;
}

boolean PositioningSolutionType_template::match(const PositioningSolutionType& other_value, boolean) const
{
if (other_value.enum_value == PositioningSolutionType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.PositioningSolutionType with an unbound value.");
return match(other_value.enum_value);
}

PositioningSolutionType::enum_type PositioningSolutionType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.PositioningSolutionType.");
return single_value;
}

void PositioningSolutionType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.PositioningSolutionType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PositioningSolutionType_template[list_length];
}

PositioningSolutionType_template& PositioningSolutionType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.PositioningSolutionType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.PositioningSolutionType.");
return value_list.list_value[list_index];
}

void PositioningSolutionType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(PositioningSolutionType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PositioningSolutionType_template::log_match(const PositioningSolutionType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void PositioningSolutionType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.PositioningSolutionType.");
}
}

void PositioningSolutionType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (PositioningSolutionType::enum_type)text_buf.pull_int().get_val();
if (!PositioningSolutionType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.PositioningSolutionType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PositioningSolutionType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.PositioningSolutionType.");
}
}

boolean PositioningSolutionType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PositioningSolutionType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PositioningSolutionType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    PositioningSolutionType::enum_type enum_val = (enum_name != NULL) ? PositioningSolutionType::str_to_enum(enum_name) : PositioningSolutionType::UNKNOWN_VALUE;
    if (PositioningSolutionType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PositioningSolutionType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    PositioningSolutionType::enum_type enum_val = PositioningSolutionType::str_to_enum(mp->get_enumerated());
    if (!PositioningSolutionType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.PositioningSolutionType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.PositioningSolutionType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PositioningSolutionType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(PositioningSolutionType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PositioningSolutionType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.PositioningSolutionType");
}

VehicleIdentification::VehicleIdentification()
{
  bound_flag = FALSE;
}

VehicleIdentification::VehicleIdentification(const OPTIONAL<CHARSTRING>& par_wMInumber,
    const OPTIONAL<CHARSTRING>& par_vDS)
  :   field_wMInumber(par_wMInumber),
  field_vDS(par_vDS)
{
  bound_flag = TRUE;
}

VehicleIdentification::VehicleIdentification(const VehicleIdentification& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.VehicleIdentification.");
bound_flag = TRUE;
if (other_value.wMInumber().is_bound()) field_wMInumber = other_value.wMInumber();
else field_wMInumber.clean_up();
if (other_value.vDS().is_bound()) field_vDS = other_value.vDS();
else field_vDS.clean_up();
}

void VehicleIdentification::clean_up()
{
field_wMInumber.clean_up();
field_vDS.clean_up();
bound_flag = FALSE;
}

VehicleIdentification& VehicleIdentification::operator=(const VehicleIdentification& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.VehicleIdentification.");
  bound_flag = TRUE;
  if (other_value.wMInumber().is_bound()) field_wMInumber = other_value.wMInumber();
  else field_wMInumber.clean_up();
  if (other_value.vDS().is_bound()) field_vDS = other_value.vDS();
  else field_vDS.clean_up();
}
return *this;
}

boolean VehicleIdentification::operator==(const VehicleIdentification& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_wMInumber==other_value.field_wMInumber
  && field_vDS==other_value.field_vDS;
}

boolean VehicleIdentification::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_wMInumber.get_selection() || field_wMInumber.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_vDS.get_selection() || field_vDS.is_bound()) return TRUE;
return FALSE;
}
boolean VehicleIdentification::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_wMInumber.get_selection() && !field_wMInumber.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_vDS.get_selection() && !field_vDS.is_value()) return FALSE;
return TRUE;
}
int VehicleIdentification::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.VehicleIdentification");
  int ret_val = 0;
  if (field_wMInumber.ispresent()) ret_val++;
  if (field_vDS.ispresent()) ret_val++;
  return ret_val;
}

void VehicleIdentification::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ wMInumber := ");
field_wMInumber.log();
TTCN_Logger::log_event_str(", vDS := ");
field_vDS.log();
TTCN_Logger::log_event_str(" }");
}

void VehicleIdentification::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.VehicleIdentification'");
    }
    if (strcmp("wMInumber", param_field) == 0) {
      wMInumber().set_param(param);
      return;
    } else if (strcmp("vDS", param_field) == 0) {
      vDS().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.VehicleIdentification'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.VehicleIdentification has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) wMInumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) vDS().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "wMInumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          wMInumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vDS")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vDS().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.VehicleIdentification: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.VehicleIdentification");
  }
}

Module_Param* VehicleIdentification::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.VehicleIdentification'");
    }
    if (strcmp("wMInumber", param_field) == 0) {
      return wMInumber().get_param(param_name);
    } else if (strcmp("vDS", param_field) == 0) {
      return vDS().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.VehicleIdentification'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_wMInumber = field_wMInumber.get_param(param_name);
  mp_field_wMInumber->set_id(new Module_Param_FieldName(mcopystr("wMInumber")));
  mp->add_elem(mp_field_wMInumber);
  Module_Param* mp_field_vDS = field_vDS.get_param(param_name);
  mp_field_vDS->set_id(new Module_Param_FieldName(mcopystr("vDS")));
  mp->add_elem(mp_field_vDS);
  return mp;
  }

void VehicleIdentification::set_implicit_omit()
{
if (!wMInumber().is_bound()) wMInumber() = OMIT_VALUE;
else wMInumber().set_implicit_omit();
if (!vDS().is_bound()) vDS() = OMIT_VALUE;
else vDS().set_implicit_omit();
}

void VehicleIdentification::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.VehicleIdentification.");
field_wMInumber.encode_text(text_buf);
field_vDS.encode_text(text_buf);
}

void VehicleIdentification::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_wMInumber.decode_text(text_buf);
field_vDS.decode_text(text_buf);
}

void VehicleIdentification::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void VehicleIdentification::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* VehicleIdentification::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("wMInumber': ");
  new_tlv->add_TLV(field_wMInumber.BER_encode_TLV(VehicleIdentification_wMInumber_descr_, p_coding));
  ec_1.set_msg("vDS': ");
  new_tlv->add_TLV(field_vDS.BER_encode_TLV(VehicleIdentification_vDS_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean VehicleIdentification::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.VehicleIdentification' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("wMInumber': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_wMInumber=OMIT_VALUE;
    else {
      field_wMInumber.BER_decode_TLV(VehicleIdentification_wMInumber_descr_, tmp_tlv, L_form);
      if(field_wMInumber.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("vDS': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_vDS=OMIT_VALUE;
    else {
      field_vDS.BER_decode_TLV(VehicleIdentification_vDS_descr_, tmp_tlv, L_form);
      if(field_vDS.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int VehicleIdentification::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.VehicleIdentification.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_wMInumber.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "wMInumber");
    enc_len += field_wMInumber.JSON_encode(VehicleIdentification_wMInumber_descr_, p_tok);
  }

  if (field_vDS.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vDS");
    enc_len += field_vDS.JSON_encode(VehicleIdentification_vDS_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int VehicleIdentification::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "wMInumber", name_len)) {
         int ret_val = field_wMInumber.JSON_decode(VehicleIdentification_wMInumber_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "wMInumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (3 == name_len && 0 == strncmp(fld_name, "vDS", name_len)) {
         int ret_val = field_vDS.JSON_decode(VehicleIdentification_vDS_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vDS");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_wMInumber.is_bound()) {
    field_wMInumber = OMIT_VALUE;
  }
if (!field_vDS.is_bound()) {
    field_vDS = OMIT_VALUE;
  }

  return dec_len;
}

struct VehicleIdentification_template::single_value_struct {
CHARSTRING_template field_wMInumber;
CHARSTRING_template field_vDS;
};

void VehicleIdentification_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_wMInumber = ANY_OR_OMIT;
single_value->field_vDS = ANY_OR_OMIT;
}
}
}

void VehicleIdentification_template::copy_value(const VehicleIdentification& other_value)
{
single_value = new single_value_struct;
if (other_value.wMInumber().is_bound()) {
  if (other_value.wMInumber().ispresent()) single_value->field_wMInumber = other_value.wMInumber()();
  else single_value->field_wMInumber = OMIT_VALUE;
} else {
  single_value->field_wMInumber.clean_up();
}
if (other_value.vDS().is_bound()) {
  if (other_value.vDS().ispresent()) single_value->field_vDS = other_value.vDS()();
  else single_value->field_vDS = OMIT_VALUE;
} else {
  single_value->field_vDS.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void VehicleIdentification_template::copy_template(const VehicleIdentification_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.wMInumber().get_selection()) {
single_value->field_wMInumber = other_value.wMInumber();
} else {
single_value->field_wMInumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.vDS().get_selection()) {
single_value->field_vDS = other_value.vDS();
} else {
single_value->field_vDS.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new VehicleIdentification_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.VehicleIdentification.");
break;
}
set_selection(other_value);
}

VehicleIdentification_template::VehicleIdentification_template()
{
}

VehicleIdentification_template::VehicleIdentification_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

VehicleIdentification_template::VehicleIdentification_template(const VehicleIdentification& other_value)
{
copy_value(other_value);
}

VehicleIdentification_template::VehicleIdentification_template(const OPTIONAL<VehicleIdentification>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const VehicleIdentification&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.VehicleIdentification from an unbound optional field.");
}
}

VehicleIdentification_template::VehicleIdentification_template(const VehicleIdentification_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

VehicleIdentification_template::~VehicleIdentification_template()
{
clean_up();
}

VehicleIdentification_template& VehicleIdentification_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

VehicleIdentification_template& VehicleIdentification_template::operator=(const VehicleIdentification& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

VehicleIdentification_template& VehicleIdentification_template::operator=(const OPTIONAL<VehicleIdentification>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const VehicleIdentification&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.VehicleIdentification.");
}
return *this;
}

VehicleIdentification_template& VehicleIdentification_template::operator=(const VehicleIdentification_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean VehicleIdentification_template::match(const VehicleIdentification& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.wMInumber().is_bound()) return FALSE;
if((other_value.wMInumber().ispresent() ? !single_value->field_wMInumber.match((const CHARSTRING&)other_value.wMInumber(), legacy) : !single_value->field_wMInumber.match_omit(legacy)))return FALSE;
if(!other_value.vDS().is_bound()) return FALSE;
if((other_value.vDS().ispresent() ? !single_value->field_vDS.match((const CHARSTRING&)other_value.vDS(), legacy) : !single_value->field_vDS.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.VehicleIdentification.");
}
return FALSE;
}

boolean VehicleIdentification_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_wMInumber.is_omit() || single_value->field_wMInumber.is_bound()) return TRUE;
if (single_value->field_vDS.is_omit() || single_value->field_vDS.is_bound()) return TRUE;
return FALSE;
}

boolean VehicleIdentification_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_wMInumber.is_omit() && !single_value->field_wMInumber.is_value()) return FALSE;
if (!single_value->field_vDS.is_omit() && !single_value->field_vDS.is_value()) return FALSE;
return TRUE;
}

void VehicleIdentification_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

VehicleIdentification VehicleIdentification_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.VehicleIdentification.");
VehicleIdentification ret_val;
if (single_value->field_wMInumber.is_omit()) ret_val.wMInumber() = OMIT_VALUE;
else if (single_value->field_wMInumber.is_bound()) {
ret_val.wMInumber() = single_value->field_wMInumber.valueof();
}
if (single_value->field_vDS.is_omit()) ret_val.vDS() = OMIT_VALUE;
else if (single_value->field_vDS.is_bound()) {
ret_val.vDS() = single_value->field_vDS.valueof();
}
return ret_val;
}

void VehicleIdentification_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.VehicleIdentification.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new VehicleIdentification_template[list_length];
}

VehicleIdentification_template& VehicleIdentification_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.VehicleIdentification.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.VehicleIdentification.");
return value_list.list_value[list_index];
}

CHARSTRING_template& VehicleIdentification_template::wMInumber()
{
set_specific();
return single_value->field_wMInumber;
}

const CHARSTRING_template& VehicleIdentification_template::wMInumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field wMInumber of a non-specific template of type @ITS-Container.VehicleIdentification.");
return single_value->field_wMInumber;
}

CHARSTRING_template& VehicleIdentification_template::vDS()
{
set_specific();
return single_value->field_vDS;
}

const CHARSTRING_template& VehicleIdentification_template::vDS() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field vDS of a non-specific template of type @ITS-Container.VehicleIdentification.");
return single_value->field_vDS;
}

int VehicleIdentification_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleIdentification which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_wMInumber.is_present()) ret_val++;
      if (single_value->field_vDS.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.VehicleIdentification containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleIdentification containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleIdentification containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleIdentification containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleIdentification containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.VehicleIdentification.");
  }
  return 0;
}

void VehicleIdentification_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ wMInumber := ");
single_value->field_wMInumber.log();
TTCN_Logger::log_event_str(", vDS := ");
single_value->field_vDS.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void VehicleIdentification_template::log_match(const VehicleIdentification& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.wMInumber().ispresent()){
if(!single_value->field_wMInumber.match(match_value.wMInumber(), legacy)){
TTCN_Logger::log_logmatch_info(".wMInumber");
single_value->field_wMInumber.log_match(match_value.wMInumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_wMInumber.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".wMInumber := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_wMInumber.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.vDS().ispresent()){
if(!single_value->field_vDS.match(match_value.vDS(), legacy)){
TTCN_Logger::log_logmatch_info(".vDS");
single_value->field_vDS.log_match(match_value.vDS(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_vDS.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".vDS := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_vDS.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ wMInumber := ");
if (match_value.wMInumber().ispresent()) single_value->field_wMInumber.log_match(match_value.wMInumber(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_wMInumber.log();
if (single_value->field_wMInumber.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", vDS := ");
if (match_value.vDS().ispresent()) single_value->field_vDS.log_match(match_value.vDS(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_vDS.log();
if (single_value->field_vDS.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void VehicleIdentification_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_wMInumber.encode_text(text_buf);
single_value->field_vDS.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.VehicleIdentification.");
}
}

void VehicleIdentification_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_wMInumber.decode_text(text_buf);
single_value->field_vDS.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new VehicleIdentification_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.VehicleIdentification.");
}
}

void VehicleIdentification_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.VehicleIdentification'");
    }
    if (strcmp("wMInumber", param_field) == 0) {
      wMInumber().set_param(param);
      return;
    } else if (strcmp("vDS", param_field) == 0) {
      vDS().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.VehicleIdentification'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    VehicleIdentification_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.VehicleIdentification has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) wMInumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) vDS().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "wMInumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          wMInumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vDS")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vDS().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.VehicleIdentification: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.VehicleIdentification");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* VehicleIdentification_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.VehicleIdentification'");
    }
    if (strcmp("wMInumber", param_field) == 0) {
      return wMInumber().get_param(param_name);
    } else if (strcmp("vDS", param_field) == 0) {
      return vDS().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.VehicleIdentification'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_wMInumber = single_value->field_wMInumber.get_param(param_name);
    mp_field_wMInumber->set_id(new Module_Param_FieldName(mcopystr("wMInumber")));
    mp->add_elem(mp_field_wMInumber);
    Module_Param* mp_field_vDS = single_value->field_vDS.get_param(param_name);
    mp_field_vDS->set_id(new Module_Param_FieldName(mcopystr("vDS")));
    mp->add_elem(mp_field_vDS);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void VehicleIdentification_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_wMInumber.check_restriction(t_res, t_name ? t_name : "@ITS-Container.VehicleIdentification");
single_value->field_vDS.check_restriction(t_res, t_name ? t_name : "@ITS-Container.VehicleIdentification");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.VehicleIdentification");
}

boolean VehicleIdentification_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean VehicleIdentification_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

VehicleLengthConfidenceIndication::VehicleLengthConfidenceIndication()
{
enum_value = UNBOUND_VALUE;
}

VehicleLengthConfidenceIndication::VehicleLengthConfidenceIndication(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.VehicleLengthConfidenceIndication with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

VehicleLengthConfidenceIndication::VehicleLengthConfidenceIndication(enum_type other_value)
{
enum_value = other_value;
}

VehicleLengthConfidenceIndication::VehicleLengthConfidenceIndication(const VehicleLengthConfidenceIndication& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
enum_value = other_value.enum_value;
}

VehicleLengthConfidenceIndication& VehicleLengthConfidenceIndication::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

VehicleLengthConfidenceIndication& VehicleLengthConfidenceIndication::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

VehicleLengthConfidenceIndication& VehicleLengthConfidenceIndication::operator=(const VehicleLengthConfidenceIndication& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
enum_value = other_value.enum_value;
return *this;
}

boolean VehicleLengthConfidenceIndication::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
return enum_value == other_value;
}

boolean VehicleLengthConfidenceIndication::operator==(const VehicleLengthConfidenceIndication& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
return enum_value == other_value.enum_value;
}

boolean VehicleLengthConfidenceIndication::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
return enum_value < other_value;
}

boolean VehicleLengthConfidenceIndication::operator<(const VehicleLengthConfidenceIndication& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
return enum_value < other_value.enum_value;
}

boolean VehicleLengthConfidenceIndication::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
return enum_value > other_value;
}

boolean VehicleLengthConfidenceIndication::operator>(const VehicleLengthConfidenceIndication& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
return enum_value > other_value.enum_value;
}

const char *VehicleLengthConfidenceIndication::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case noTrailerPresent: return "noTrailerPresent";
case trailerPresentWithKnownLength: return "trailerPresentWithKnownLength";
case trailerPresentWithUnknownLength: return "trailerPresentWithUnknownLength";
case trailerPresenceIsUnknown: return "trailerPresenceIsUnknown";
case unavailable: return "unavailable";
default: return "<unknown>";
}
}

VehicleLengthConfidenceIndication::enum_type VehicleLengthConfidenceIndication::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "noTrailerPresent")) return noTrailerPresent;
else if (!strcmp(str_par, "trailerPresentWithKnownLength")) return trailerPresentWithKnownLength;
else if (!strcmp(str_par, "trailerPresentWithUnknownLength")) return trailerPresentWithUnknownLength;
else if (!strcmp(str_par, "trailerPresenceIsUnknown")) return trailerPresenceIsUnknown;
else if (!strcmp(str_par, "unavailable")) return unavailable;
else return UNKNOWN_VALUE;
}

boolean VehicleLengthConfidenceIndication::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int VehicleLengthConfidenceIndication::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int VehicleLengthConfidenceIndication::enum2int(const VehicleLengthConfidenceIndication& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void VehicleLengthConfidenceIndication::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.", int_val);
enum_value = (enum_type)int_val;
}

VehicleLengthConfidenceIndication::operator VehicleLengthConfidenceIndication::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
return enum_value;
}

void VehicleLengthConfidenceIndication::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void VehicleLengthConfidenceIndication::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.VehicleLengthConfidenceIndication");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.VehicleLengthConfidenceIndication.");
  }
}

Module_Param* VehicleLengthConfidenceIndication::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void VehicleLengthConfidenceIndication::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
text_buf.push_int(enum_value);
}

void VehicleLengthConfidenceIndication::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.VehicleLengthConfidenceIndication.", enum_value);
}

void VehicleLengthConfidenceIndication::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void VehicleLengthConfidenceIndication::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* VehicleLengthConfidenceIndication::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean VehicleLengthConfidenceIndication::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.VehicleLengthConfidenceIndication: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int VehicleLengthConfidenceIndication::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int VehicleLengthConfidenceIndication::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void VehicleLengthConfidenceIndication_template::copy_template(const VehicleLengthConfidenceIndication_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new VehicleLengthConfidenceIndication_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
}
}

VehicleLengthConfidenceIndication_template::VehicleLengthConfidenceIndication_template()
{
}

VehicleLengthConfidenceIndication_template::VehicleLengthConfidenceIndication_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

VehicleLengthConfidenceIndication_template::VehicleLengthConfidenceIndication_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!VehicleLengthConfidenceIndication::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication with unknown numeric value %d.", other_value);
single_value = (VehicleLengthConfidenceIndication::enum_type)other_value;
}

VehicleLengthConfidenceIndication_template::VehicleLengthConfidenceIndication_template(VehicleLengthConfidenceIndication::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

VehicleLengthConfidenceIndication_template::VehicleLengthConfidenceIndication_template(const VehicleLengthConfidenceIndication& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == VehicleLengthConfidenceIndication::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
single_value = other_value.enum_value;
}

VehicleLengthConfidenceIndication_template::VehicleLengthConfidenceIndication_template(const OPTIONAL<VehicleLengthConfidenceIndication>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (VehicleLengthConfidenceIndication::enum_type)(const VehicleLengthConfidenceIndication&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication from an unbound optional field.");
}
}

VehicleLengthConfidenceIndication_template::VehicleLengthConfidenceIndication_template(const VehicleLengthConfidenceIndication_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

VehicleLengthConfidenceIndication_template::~VehicleLengthConfidenceIndication_template()
{
clean_up();
}

boolean VehicleLengthConfidenceIndication_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean VehicleLengthConfidenceIndication_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != VehicleLengthConfidenceIndication::UNBOUND_VALUE;
}

void VehicleLengthConfidenceIndication_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

VehicleLengthConfidenceIndication_template& VehicleLengthConfidenceIndication_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

VehicleLengthConfidenceIndication_template& VehicleLengthConfidenceIndication_template::operator=(int other_value)
{
if (!VehicleLengthConfidenceIndication::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (VehicleLengthConfidenceIndication::enum_type)other_value;
return *this;
}

VehicleLengthConfidenceIndication_template& VehicleLengthConfidenceIndication_template::operator=(VehicleLengthConfidenceIndication::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

VehicleLengthConfidenceIndication_template& VehicleLengthConfidenceIndication_template::operator=(const VehicleLengthConfidenceIndication& other_value)
{
if (other_value.enum_value == VehicleLengthConfidenceIndication::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.VehicleLengthConfidenceIndication to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

VehicleLengthConfidenceIndication_template& VehicleLengthConfidenceIndication_template::operator=(const OPTIONAL<VehicleLengthConfidenceIndication>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (VehicleLengthConfidenceIndication::enum_type)(const VehicleLengthConfidenceIndication&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
}
return *this;
}

VehicleLengthConfidenceIndication_template& VehicleLengthConfidenceIndication_template::operator=(const VehicleLengthConfidenceIndication_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean VehicleLengthConfidenceIndication_template::match(VehicleLengthConfidenceIndication::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
}
return FALSE;
}

boolean VehicleLengthConfidenceIndication_template::match(const VehicleLengthConfidenceIndication& other_value, boolean) const
{
if (other_value.enum_value == VehicleLengthConfidenceIndication::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication with an unbound value.");
return match(other_value.enum_value);
}

VehicleLengthConfidenceIndication::enum_type VehicleLengthConfidenceIndication_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
return single_value;
}

void VehicleLengthConfidenceIndication_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new VehicleLengthConfidenceIndication_template[list_length];
}

VehicleLengthConfidenceIndication_template& VehicleLengthConfidenceIndication_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
return value_list.list_value[list_index];
}

void VehicleLengthConfidenceIndication_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(VehicleLengthConfidenceIndication::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void VehicleLengthConfidenceIndication_template::log_match(const VehicleLengthConfidenceIndication& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void VehicleLengthConfidenceIndication_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
}
}

void VehicleLengthConfidenceIndication_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (VehicleLengthConfidenceIndication::enum_type)text_buf.pull_int().get_val();
if (!VehicleLengthConfidenceIndication::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new VehicleLengthConfidenceIndication_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.VehicleLengthConfidenceIndication.");
}
}

boolean VehicleLengthConfidenceIndication_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean VehicleLengthConfidenceIndication_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void VehicleLengthConfidenceIndication_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    VehicleLengthConfidenceIndication::enum_type enum_val = (enum_name != NULL) ? VehicleLengthConfidenceIndication::str_to_enum(enum_name) : VehicleLengthConfidenceIndication::UNKNOWN_VALUE;
    if (VehicleLengthConfidenceIndication::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    VehicleLengthConfidenceIndication_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    VehicleLengthConfidenceIndication::enum_type enum_val = VehicleLengthConfidenceIndication::str_to_enum(mp->get_enumerated());
    if (!VehicleLengthConfidenceIndication::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.VehicleLengthConfidenceIndication.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.VehicleLengthConfidenceIndication");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* VehicleLengthConfidenceIndication_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(VehicleLengthConfidenceIndication::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void VehicleLengthConfidenceIndication_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.VehicleLengthConfidenceIndication");
}

VehicleLength::VehicleLength()
{
  bound_flag = FALSE;
}

VehicleLength::VehicleLength(const INTEGER& par_vehicleLengthValue,
    const VehicleLengthConfidenceIndication& par_vehicleLengthConfidenceIndication)
  :   field_vehicleLengthValue(par_vehicleLengthValue),
  field_vehicleLengthConfidenceIndication(par_vehicleLengthConfidenceIndication)
{
  bound_flag = TRUE;
}

VehicleLength::VehicleLength(const VehicleLength& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.VehicleLength.");
bound_flag = TRUE;
if (other_value.vehicleLengthValue().is_bound()) field_vehicleLengthValue = other_value.vehicleLengthValue();
else field_vehicleLengthValue.clean_up();
if (other_value.vehicleLengthConfidenceIndication().is_bound()) field_vehicleLengthConfidenceIndication = other_value.vehicleLengthConfidenceIndication();
else field_vehicleLengthConfidenceIndication.clean_up();
}

void VehicleLength::clean_up()
{
field_vehicleLengthValue.clean_up();
field_vehicleLengthConfidenceIndication.clean_up();
bound_flag = FALSE;
}

VehicleLength& VehicleLength::operator=(const VehicleLength& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.VehicleLength.");
  bound_flag = TRUE;
  if (other_value.vehicleLengthValue().is_bound()) field_vehicleLengthValue = other_value.vehicleLengthValue();
  else field_vehicleLengthValue.clean_up();
  if (other_value.vehicleLengthConfidenceIndication().is_bound()) field_vehicleLengthConfidenceIndication = other_value.vehicleLengthConfidenceIndication();
  else field_vehicleLengthConfidenceIndication.clean_up();
}
return *this;
}

boolean VehicleLength::operator==(const VehicleLength& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_vehicleLengthValue==other_value.field_vehicleLengthValue
  && field_vehicleLengthConfidenceIndication==other_value.field_vehicleLengthConfidenceIndication;
}

boolean VehicleLength::is_bound() const
{
if (bound_flag) return TRUE;
if(field_vehicleLengthValue.is_bound()) return TRUE;
if(field_vehicleLengthConfidenceIndication.is_bound()) return TRUE;
return FALSE;
}
boolean VehicleLength::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_vehicleLengthValue.is_value()) return FALSE;
if(!field_vehicleLengthConfidenceIndication.is_value()) return FALSE;
return TRUE;
}
int VehicleLength::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.VehicleLength");
  return 2;
}

void VehicleLength::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ vehicleLengthValue := ");
field_vehicleLengthValue.log();
TTCN_Logger::log_event_str(", vehicleLengthConfidenceIndication := ");
field_vehicleLengthConfidenceIndication.log();
TTCN_Logger::log_event_str(" }");
}

void VehicleLength::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.VehicleLength'");
    }
    if (strcmp("vehicleLengthValue", param_field) == 0) {
      vehicleLengthValue().set_param(param);
      return;
    } else if (strcmp("vehicleLengthConfidenceIndication", param_field) == 0) {
      vehicleLengthConfidenceIndication().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.VehicleLength'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.VehicleLength has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) vehicleLengthValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) vehicleLengthConfidenceIndication().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleLengthValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleLengthValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleLengthConfidenceIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleLengthConfidenceIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.VehicleLength: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.VehicleLength");
  }
}

Module_Param* VehicleLength::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.VehicleLength'");
    }
    if (strcmp("vehicleLengthValue", param_field) == 0) {
      return vehicleLengthValue().get_param(param_name);
    } else if (strcmp("vehicleLengthConfidenceIndication", param_field) == 0) {
      return vehicleLengthConfidenceIndication().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.VehicleLength'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_vehicleLengthValue = field_vehicleLengthValue.get_param(param_name);
  mp_field_vehicleLengthValue->set_id(new Module_Param_FieldName(mcopystr("vehicleLengthValue")));
  mp->add_elem(mp_field_vehicleLengthValue);
  Module_Param* mp_field_vehicleLengthConfidenceIndication = field_vehicleLengthConfidenceIndication.get_param(param_name);
  mp_field_vehicleLengthConfidenceIndication->set_id(new Module_Param_FieldName(mcopystr("vehicleLengthConfidenceIndication")));
  mp->add_elem(mp_field_vehicleLengthConfidenceIndication);
  return mp;
  }

void VehicleLength::set_implicit_omit()
{
if (vehicleLengthValue().is_bound()) vehicleLengthValue().set_implicit_omit();
if (vehicleLengthConfidenceIndication().is_bound()) vehicleLengthConfidenceIndication().set_implicit_omit();
}

void VehicleLength::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.VehicleLength.");
field_vehicleLengthValue.encode_text(text_buf);
field_vehicleLengthConfidenceIndication.encode_text(text_buf);
}

void VehicleLength::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_vehicleLengthValue.decode_text(text_buf);
field_vehicleLengthConfidenceIndication.decode_text(text_buf);
}

void VehicleLength::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void VehicleLength::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* VehicleLength::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("vehicleLengthValue': ");
  new_tlv->add_TLV(field_vehicleLengthValue.BER_encode_TLV(VehicleLength_vehicleLengthValue_descr_, p_coding));
  ec_1.set_msg("vehicleLengthConfidenceIndication': ");
  new_tlv->add_TLV(field_vehicleLengthConfidenceIndication.BER_encode_TLV(VehicleLength_vehicleLengthConfidenceIndication_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean VehicleLength::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.VehicleLength' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("vehicleLengthValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_vehicleLengthValue.BER_decode_TLV(VehicleLength_vehicleLengthValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("vehicleLengthConfidenceIndication': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_vehicleLengthConfidenceIndication.BER_decode_TLV(VehicleLength_vehicleLengthConfidenceIndication_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int VehicleLength::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.VehicleLength.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vehicleLengthValue");
    enc_len += field_vehicleLengthValue.JSON_encode(VehicleLength_vehicleLengthValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vehicleLengthConfidenceIndication");
    enc_len += field_vehicleLengthConfidenceIndication.JSON_encode(VehicleLength_vehicleLengthConfidenceIndication_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int VehicleLength::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "vehicleLengthValue", name_len)) {
         int ret_val = field_vehicleLengthValue.JSON_decode(VehicleLength_vehicleLengthValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vehicleLengthValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (33 == name_len && 0 == strncmp(fld_name, "vehicleLengthConfidenceIndication", name_len)) {
         int ret_val = field_vehicleLengthConfidenceIndication.JSON_decode(VehicleLength_vehicleLengthConfidenceIndication_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vehicleLengthConfidenceIndication");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_vehicleLengthValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "vehicleLengthValue");
    return JSON_ERROR_FATAL;
  }
if (!field_vehicleLengthConfidenceIndication.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "vehicleLengthConfidenceIndication");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct VehicleLength_template::single_value_struct {
INTEGER_template field_vehicleLengthValue;
VehicleLengthConfidenceIndication_template field_vehicleLengthConfidenceIndication;
};

void VehicleLength_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_vehicleLengthValue = ANY_VALUE;
single_value->field_vehicleLengthConfidenceIndication = ANY_VALUE;
}
}
}

void VehicleLength_template::copy_value(const VehicleLength& other_value)
{
single_value = new single_value_struct;
if (other_value.vehicleLengthValue().is_bound()) {
  single_value->field_vehicleLengthValue = other_value.vehicleLengthValue();
} else {
  single_value->field_vehicleLengthValue.clean_up();
}
if (other_value.vehicleLengthConfidenceIndication().is_bound()) {
  single_value->field_vehicleLengthConfidenceIndication = other_value.vehicleLengthConfidenceIndication();
} else {
  single_value->field_vehicleLengthConfidenceIndication.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void VehicleLength_template::copy_template(const VehicleLength_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.vehicleLengthValue().get_selection()) {
single_value->field_vehicleLengthValue = other_value.vehicleLengthValue();
} else {
single_value->field_vehicleLengthValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.vehicleLengthConfidenceIndication().get_selection()) {
single_value->field_vehicleLengthConfidenceIndication = other_value.vehicleLengthConfidenceIndication();
} else {
single_value->field_vehicleLengthConfidenceIndication.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new VehicleLength_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.VehicleLength.");
break;
}
set_selection(other_value);
}

VehicleLength_template::VehicleLength_template()
{
}

VehicleLength_template::VehicleLength_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

VehicleLength_template::VehicleLength_template(const VehicleLength& other_value)
{
copy_value(other_value);
}

VehicleLength_template::VehicleLength_template(const OPTIONAL<VehicleLength>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const VehicleLength&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.VehicleLength from an unbound optional field.");
}
}

VehicleLength_template::VehicleLength_template(const VehicleLength_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

VehicleLength_template::~VehicleLength_template()
{
clean_up();
}

VehicleLength_template& VehicleLength_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

VehicleLength_template& VehicleLength_template::operator=(const VehicleLength& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

VehicleLength_template& VehicleLength_template::operator=(const OPTIONAL<VehicleLength>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const VehicleLength&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.VehicleLength.");
}
return *this;
}

VehicleLength_template& VehicleLength_template::operator=(const VehicleLength_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean VehicleLength_template::match(const VehicleLength& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.vehicleLengthValue().is_bound()) return FALSE;
if(!single_value->field_vehicleLengthValue.match(other_value.vehicleLengthValue(), legacy))return FALSE;
if(!other_value.vehicleLengthConfidenceIndication().is_bound()) return FALSE;
if(!single_value->field_vehicleLengthConfidenceIndication.match(other_value.vehicleLengthConfidenceIndication(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.VehicleLength.");
}
return FALSE;
}

boolean VehicleLength_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_vehicleLengthValue.is_bound()) return TRUE;
if (single_value->field_vehicleLengthConfidenceIndication.is_bound()) return TRUE;
return FALSE;
}

boolean VehicleLength_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_vehicleLengthValue.is_value()) return FALSE;
if (!single_value->field_vehicleLengthConfidenceIndication.is_value()) return FALSE;
return TRUE;
}

void VehicleLength_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

VehicleLength VehicleLength_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.VehicleLength.");
VehicleLength ret_val;
if (single_value->field_vehicleLengthValue.is_bound()) {
ret_val.vehicleLengthValue() = single_value->field_vehicleLengthValue.valueof();
}
if (single_value->field_vehicleLengthConfidenceIndication.is_bound()) {
ret_val.vehicleLengthConfidenceIndication() = single_value->field_vehicleLengthConfidenceIndication.valueof();
}
return ret_val;
}

void VehicleLength_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.VehicleLength.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new VehicleLength_template[list_length];
}

VehicleLength_template& VehicleLength_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.VehicleLength.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.VehicleLength.");
return value_list.list_value[list_index];
}

INTEGER_template& VehicleLength_template::vehicleLengthValue()
{
set_specific();
return single_value->field_vehicleLengthValue;
}

const INTEGER_template& VehicleLength_template::vehicleLengthValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field vehicleLengthValue of a non-specific template of type @ITS-Container.VehicleLength.");
return single_value->field_vehicleLengthValue;
}

VehicleLengthConfidenceIndication_template& VehicleLength_template::vehicleLengthConfidenceIndication()
{
set_specific();
return single_value->field_vehicleLengthConfidenceIndication;
}

const VehicleLengthConfidenceIndication_template& VehicleLength_template::vehicleLengthConfidenceIndication() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field vehicleLengthConfidenceIndication of a non-specific template of type @ITS-Container.VehicleLength.");
return single_value->field_vehicleLengthConfidenceIndication;
}

int VehicleLength_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleLength which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.VehicleLength containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleLength containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleLength containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleLength containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.VehicleLength containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.VehicleLength.");
  }
  return 0;
}

void VehicleLength_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ vehicleLengthValue := ");
single_value->field_vehicleLengthValue.log();
TTCN_Logger::log_event_str(", vehicleLengthConfidenceIndication := ");
single_value->field_vehicleLengthConfidenceIndication.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void VehicleLength_template::log_match(const VehicleLength& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_vehicleLengthValue.match(match_value.vehicleLengthValue(), legacy)){
TTCN_Logger::log_logmatch_info(".vehicleLengthValue");
single_value->field_vehicleLengthValue.log_match(match_value.vehicleLengthValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_vehicleLengthConfidenceIndication.match(match_value.vehicleLengthConfidenceIndication(), legacy)){
TTCN_Logger::log_logmatch_info(".vehicleLengthConfidenceIndication");
single_value->field_vehicleLengthConfidenceIndication.log_match(match_value.vehicleLengthConfidenceIndication(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ vehicleLengthValue := ");
single_value->field_vehicleLengthValue.log_match(match_value.vehicleLengthValue(), legacy);
TTCN_Logger::log_event_str(", vehicleLengthConfidenceIndication := ");
single_value->field_vehicleLengthConfidenceIndication.log_match(match_value.vehicleLengthConfidenceIndication(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void VehicleLength_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_vehicleLengthValue.encode_text(text_buf);
single_value->field_vehicleLengthConfidenceIndication.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.VehicleLength.");
}
}

void VehicleLength_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_vehicleLengthValue.decode_text(text_buf);
single_value->field_vehicleLengthConfidenceIndication.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new VehicleLength_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.VehicleLength.");
}
}

void VehicleLength_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.VehicleLength'");
    }
    if (strcmp("vehicleLengthValue", param_field) == 0) {
      vehicleLengthValue().set_param(param);
      return;
    } else if (strcmp("vehicleLengthConfidenceIndication", param_field) == 0) {
      vehicleLengthConfidenceIndication().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.VehicleLength'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    VehicleLength_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.VehicleLength has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) vehicleLengthValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) vehicleLengthConfidenceIndication().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleLengthValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleLengthValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleLengthConfidenceIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleLengthConfidenceIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.VehicleLength: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.VehicleLength");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* VehicleLength_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.VehicleLength'");
    }
    if (strcmp("vehicleLengthValue", param_field) == 0) {
      return vehicleLengthValue().get_param(param_name);
    } else if (strcmp("vehicleLengthConfidenceIndication", param_field) == 0) {
      return vehicleLengthConfidenceIndication().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.VehicleLength'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_vehicleLengthValue = single_value->field_vehicleLengthValue.get_param(param_name);
    mp_field_vehicleLengthValue->set_id(new Module_Param_FieldName(mcopystr("vehicleLengthValue")));
    mp->add_elem(mp_field_vehicleLengthValue);
    Module_Param* mp_field_vehicleLengthConfidenceIndication = single_value->field_vehicleLengthConfidenceIndication.get_param(param_name);
    mp_field_vehicleLengthConfidenceIndication->set_id(new Module_Param_FieldName(mcopystr("vehicleLengthConfidenceIndication")));
    mp->add_elem(mp_field_vehicleLengthConfidenceIndication);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void VehicleLength_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_vehicleLengthValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.VehicleLength");
single_value->field_vehicleLengthConfidenceIndication.check_restriction(t_res, t_name ? t_name : "@ITS-Container.VehicleLength");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.VehicleLength");
}

boolean VehicleLength_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean VehicleLength_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const PathPoint PathHistory::UNBOUND_ELEM;
PathHistory::PathHistory()
{
val_ptr = NULL;
}

PathHistory::PathHistory(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

PathHistory::PathHistory(const PathHistory& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.PathHistory.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

PathHistory::~PathHistory()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void PathHistory::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

PathHistory& PathHistory::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

PathHistory& PathHistory::operator=(const PathHistory& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @ITS-Container.PathHistory.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean PathHistory::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.PathHistory.");
return val_ptr->n_elements == 0 ;
}

boolean PathHistory::operator==(const PathHistory& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.PathHistory.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.PathHistory.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

PathPoint& PathHistory::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.PathHistory using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (PathPoint**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PathPoint(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new PathPoint;
}
return *val_ptr->value_elements[index_value];
}

PathPoint& PathHistory::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.PathHistory.");
return (*this)[(int)index_value];
}

const PathPoint& PathHistory::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @ITS-Container.PathHistory.");
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.PathHistory using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @ITS-Container.PathHistory: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const PathPoint& PathHistory::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.PathHistory.");
return (*this)[(int)index_value];
}

PathHistory PathHistory::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

PathHistory PathHistory::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

PathHistory PathHistory::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

PathHistory PathHistory::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @ITS-Container.PathHistory.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
PathHistory ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new PathPoint(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

PathHistory PathHistory::operator+(const PathHistory& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @ITS-Container.PathHistory concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
PathHistory ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PathPoint(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new PathPoint(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

PathHistory PathHistory::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @ITS-Container.PathHistory.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@ITS-Container.PathHistory","element");
PathHistory ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new PathPoint(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

PathHistory PathHistory::replace(int index, int len, const PathHistory& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @ITS-Container.PathHistory.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @ITS-Container.PathHistory.");
check_replace_arguments(val_ptr->n_elements, index, len, "@ITS-Container.PathHistory","element");
PathHistory ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PathPoint(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new PathPoint(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new PathPoint(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

PathHistory PathHistory::replace(int index, int len, const PathHistory_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void PathHistory::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @ITS-Container.PathHistory.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (PathPoint**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PathPoint(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (PathPoint**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @ITS-Container.PathHistory: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (PathPoint**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean PathHistory::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int PathHistory::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @ITS-Container.PathHistory.");
return val_ptr->n_elements;
}

int PathHistory::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @ITS-Container.PathHistory.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void PathHistory::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void PathHistory::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@ITS-Container.PathHistory'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@ITS-Container.PathHistory");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@ITS-Container.PathHistory");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* PathHistory::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@ITS-Container.PathHistory'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void PathHistory::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void PathHistory::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @ITS-Container.PathHistory.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void PathHistory::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @ITS-Container.PathHistory.");
val_ptr->value_elements = (PathPoint**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new PathPoint;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void PathHistory::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PathHistory::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* PathHistory::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean PathHistory::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (PathPoint**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new PathPoint;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int PathHistory::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.PathHistory.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int PathHistory::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    PathPoint* val = new PathPoint;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (PathPoint**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void PathHistory_template::copy_value(const PathHistory& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @ITS-Container.PathHistory with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (PathPoint_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new PathPoint_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new PathPoint_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void PathHistory_template::copy_template(const PathHistory_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (PathPoint_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new PathPoint_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new PathPoint_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PathHistory_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.PathHistory.");
break;
}
set_selection(other_value);
}

boolean PathHistory_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const PathHistory_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const PathHistory*)value_ptr)[value_index], legacy);
else return ((const PathHistory_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

PathHistory_template::PathHistory_template()
{
}

PathHistory_template::PathHistory_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

PathHistory_template::PathHistory_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

PathHistory_template::PathHistory_template(const PathHistory& other_value)
{
copy_value(other_value);
}

PathHistory_template::PathHistory_template(const OPTIONAL<PathHistory>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PathHistory&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.PathHistory from an unbound optional field.");
}
}

PathHistory_template::PathHistory_template(const PathHistory_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

PathHistory_template::~PathHistory_template()
{
clean_up();
}

void PathHistory_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PathHistory_template& PathHistory_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PathHistory_template& PathHistory_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

PathHistory_template& PathHistory_template::operator=(const PathHistory& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PathHistory_template& PathHistory_template::operator=(const OPTIONAL<PathHistory>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PathHistory&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.PathHistory.");
}
return *this;
}

PathHistory_template& PathHistory_template::operator=(const PathHistory_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

PathPoint_template& PathHistory_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.PathHistory using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.PathHistory.");
    break;
}
return *single_value.value_elements[index_value];
}

PathPoint_template& PathHistory_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.PathHistory.");
return (*this)[(int)index_value];
}

const PathPoint_template& PathHistory_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.PathHistory using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.PathHistory.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @ITS-Container.PathHistory: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const PathPoint_template& PathHistory_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.PathHistory.");
return (*this)[(int)index_value];
}

void PathHistory_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @ITS-Container.PathHistory.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (PathPoint_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PathPoint_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PathPoint_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (PathPoint_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int PathHistory_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int PathHistory_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @ITS-Container.PathHistory which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.PathHistory containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.PathHistory containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @ITS-Container.PathHistory containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.PathHistory containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.PathHistory containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @ITS-Container.PathHistory.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @ITS-Container.PathHistory");
}

boolean PathHistory_template::match(const PathHistory& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @ITS-Container.PathHistory.");
}
return FALSE;
}

boolean PathHistory_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

PathHistory PathHistory_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @ITS-Container.PathHistory.");
PathHistory ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

PathHistory PathHistory_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

PathHistory PathHistory_template::replace(int index, int len, const PathHistory_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

PathHistory PathHistory_template::replace(int index, int len, const PathHistory& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void PathHistory_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new PathHistory_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @ITS-Container.PathHistory.");
}
set_selection(template_type);
}

PathHistory_template& PathHistory_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @ITS-Container.PathHistory.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @ITS-Container.PathHistory.");
return value_list.list_value[list_index];
}

void PathHistory_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void PathHistory_template::log_match(const PathHistory& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PathHistory_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.PathHistory.");
}
}

void PathHistory_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @ITS-Container.PathHistory.");
single_value.value_elements = (PathPoint_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new PathPoint_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PathHistory_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @ITS-Container.PathHistory.");
}
}

boolean PathHistory_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PathHistory_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PathHistory_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@ITS-Container.PathHistory'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PathHistory_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@ITS-Container.PathHistory");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* PathHistory_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@ITS-Container.PathHistory'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void PathHistory_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@ITS-Container.PathHistory");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.PathHistory");
}

RoadType::RoadType()
{
enum_value = UNBOUND_VALUE;
}

RoadType::RoadType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.RoadType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

RoadType::RoadType(enum_type other_value)
{
enum_value = other_value;
}

RoadType::RoadType(const RoadType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.RoadType.");
enum_value = other_value.enum_value;
}

RoadType& RoadType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.RoadType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

RoadType& RoadType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

RoadType& RoadType::operator=(const RoadType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.RoadType.");
enum_value = other_value.enum_value;
return *this;
}

boolean RoadType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RoadType.");
return enum_value == other_value;
}

boolean RoadType::operator==(const RoadType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RoadType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RoadType.");
return enum_value == other_value.enum_value;
}

boolean RoadType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RoadType.");
return enum_value < other_value;
}

boolean RoadType::operator<(const RoadType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RoadType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RoadType.");
return enum_value < other_value.enum_value;
}

boolean RoadType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RoadType.");
return enum_value > other_value;
}

boolean RoadType::operator>(const RoadType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RoadType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RoadType.");
return enum_value > other_value.enum_value;
}

const char *RoadType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case urban__NoStructuralSeparationToOppositeLanes: return "urban_NoStructuralSeparationToOppositeLanes";
case urban__WithStructuralSeparationToOppositeLanes: return "urban_WithStructuralSeparationToOppositeLanes";
case nonUrban__NoStructuralSeparationToOppositeLanes: return "nonUrban_NoStructuralSeparationToOppositeLanes";
case nonUrban__WithStructuralSeparationToOppositeLanes: return "nonUrban_WithStructuralSeparationToOppositeLanes";
default: return "<unknown>";
}
}

RoadType::enum_type RoadType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "urban_NoStructuralSeparationToOppositeLanes")) return urban__NoStructuralSeparationToOppositeLanes;
else if (!strcmp(str_par, "urban_WithStructuralSeparationToOppositeLanes")) return urban__WithStructuralSeparationToOppositeLanes;
else if (!strcmp(str_par, "nonUrban_NoStructuralSeparationToOppositeLanes")) return nonUrban__NoStructuralSeparationToOppositeLanes;
else if (!strcmp(str_par, "nonUrban_WithStructuralSeparationToOppositeLanes")) return nonUrban__WithStructuralSeparationToOppositeLanes;
else return UNKNOWN_VALUE;
}

boolean RoadType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int RoadType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.RoadType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int RoadType::enum2int(const RoadType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.RoadType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void RoadType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.RoadType.", int_val);
enum_value = (enum_type)int_val;
}

RoadType::operator RoadType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.RoadType.");
return enum_value;
}

void RoadType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void RoadType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.RoadType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.RoadType.");
  }
}

Module_Param* RoadType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void RoadType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.RoadType.");
text_buf.push_int(enum_value);
}

void RoadType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.RoadType.", enum_value);
}

void RoadType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RoadType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RoadType::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RoadType::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.RoadType: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int RoadType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.RoadType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int RoadType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void RoadType_template::copy_template(const RoadType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RoadType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.RoadType.");
}
}

RoadType_template::RoadType_template()
{
}

RoadType_template::RoadType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RoadType_template::RoadType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!RoadType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.RoadType with unknown numeric value %d.", other_value);
single_value = (RoadType::enum_type)other_value;
}

RoadType_template::RoadType_template(RoadType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

RoadType_template::RoadType_template(const RoadType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == RoadType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.RoadType.");
single_value = other_value.enum_value;
}

RoadType_template::RoadType_template(const OPTIONAL<RoadType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RoadType::enum_type)(const RoadType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.RoadType from an unbound optional field.");
}
}

RoadType_template::RoadType_template(const RoadType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

RoadType_template::~RoadType_template()
{
clean_up();
}

boolean RoadType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean RoadType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != RoadType::UNBOUND_VALUE;
}

void RoadType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

RoadType_template& RoadType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RoadType_template& RoadType_template::operator=(int other_value)
{
if (!RoadType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.RoadType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (RoadType::enum_type)other_value;
return *this;
}

RoadType_template& RoadType_template::operator=(RoadType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

RoadType_template& RoadType_template::operator=(const RoadType& other_value)
{
if (other_value.enum_value == RoadType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.RoadType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

RoadType_template& RoadType_template::operator=(const OPTIONAL<RoadType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RoadType::enum_type)(const RoadType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.RoadType.");
}
return *this;
}

RoadType_template& RoadType_template::operator=(const RoadType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RoadType_template::match(RoadType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.RoadType.");
}
return FALSE;
}

boolean RoadType_template::match(const RoadType& other_value, boolean) const
{
if (other_value.enum_value == RoadType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.RoadType with an unbound value.");
return match(other_value.enum_value);
}

RoadType::enum_type RoadType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.RoadType.");
return single_value;
}

void RoadType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.RoadType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RoadType_template[list_length];
}

RoadType_template& RoadType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.RoadType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.RoadType.");
return value_list.list_value[list_index];
}

void RoadType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(RoadType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RoadType_template::log_match(const RoadType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void RoadType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.RoadType.");
}
}

void RoadType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (RoadType::enum_type)text_buf.pull_int().get_val();
if (!RoadType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.RoadType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RoadType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.RoadType.");
}
}

boolean RoadType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RoadType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RoadType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    RoadType::enum_type enum_val = (enum_name != NULL) ? RoadType::str_to_enum(enum_name) : RoadType::UNKNOWN_VALUE;
    if (RoadType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RoadType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    RoadType::enum_type enum_val = RoadType::str_to_enum(mp->get_enumerated());
    if (!RoadType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.RoadType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.RoadType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RoadType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(RoadType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RoadType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.RoadType");
}

SteeringWheelAngle::SteeringWheelAngle()
{
  bound_flag = FALSE;
}

SteeringWheelAngle::SteeringWheelAngle(const INTEGER& par_steeringWheelAngleValue,
    const INTEGER& par_steeringWheelAngleConfidence)
  :   field_steeringWheelAngleValue(par_steeringWheelAngleValue),
  field_steeringWheelAngleConfidence(par_steeringWheelAngleConfidence)
{
  bound_flag = TRUE;
}

SteeringWheelAngle::SteeringWheelAngle(const SteeringWheelAngle& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.SteeringWheelAngle.");
bound_flag = TRUE;
if (other_value.steeringWheelAngleValue().is_bound()) field_steeringWheelAngleValue = other_value.steeringWheelAngleValue();
else field_steeringWheelAngleValue.clean_up();
if (other_value.steeringWheelAngleConfidence().is_bound()) field_steeringWheelAngleConfidence = other_value.steeringWheelAngleConfidence();
else field_steeringWheelAngleConfidence.clean_up();
}

void SteeringWheelAngle::clean_up()
{
field_steeringWheelAngleValue.clean_up();
field_steeringWheelAngleConfidence.clean_up();
bound_flag = FALSE;
}

SteeringWheelAngle& SteeringWheelAngle::operator=(const SteeringWheelAngle& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.SteeringWheelAngle.");
  bound_flag = TRUE;
  if (other_value.steeringWheelAngleValue().is_bound()) field_steeringWheelAngleValue = other_value.steeringWheelAngleValue();
  else field_steeringWheelAngleValue.clean_up();
  if (other_value.steeringWheelAngleConfidence().is_bound()) field_steeringWheelAngleConfidence = other_value.steeringWheelAngleConfidence();
  else field_steeringWheelAngleConfidence.clean_up();
}
return *this;
}

boolean SteeringWheelAngle::operator==(const SteeringWheelAngle& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_steeringWheelAngleValue==other_value.field_steeringWheelAngleValue
  && field_steeringWheelAngleConfidence==other_value.field_steeringWheelAngleConfidence;
}

boolean SteeringWheelAngle::is_bound() const
{
if (bound_flag) return TRUE;
if(field_steeringWheelAngleValue.is_bound()) return TRUE;
if(field_steeringWheelAngleConfidence.is_bound()) return TRUE;
return FALSE;
}
boolean SteeringWheelAngle::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_steeringWheelAngleValue.is_value()) return FALSE;
if(!field_steeringWheelAngleConfidence.is_value()) return FALSE;
return TRUE;
}
int SteeringWheelAngle::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.SteeringWheelAngle");
  return 2;
}

void SteeringWheelAngle::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ steeringWheelAngleValue := ");
field_steeringWheelAngleValue.log();
TTCN_Logger::log_event_str(", steeringWheelAngleConfidence := ");
field_steeringWheelAngleConfidence.log();
TTCN_Logger::log_event_str(" }");
}

void SteeringWheelAngle::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.SteeringWheelAngle'");
    }
    if (strcmp("steeringWheelAngleValue", param_field) == 0) {
      steeringWheelAngleValue().set_param(param);
      return;
    } else if (strcmp("steeringWheelAngleConfidence", param_field) == 0) {
      steeringWheelAngleConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.SteeringWheelAngle'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.SteeringWheelAngle has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) steeringWheelAngleValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) steeringWheelAngleConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "steeringWheelAngleValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          steeringWheelAngleValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "steeringWheelAngleConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          steeringWheelAngleConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.SteeringWheelAngle: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.SteeringWheelAngle");
  }
}

Module_Param* SteeringWheelAngle::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.SteeringWheelAngle'");
    }
    if (strcmp("steeringWheelAngleValue", param_field) == 0) {
      return steeringWheelAngleValue().get_param(param_name);
    } else if (strcmp("steeringWheelAngleConfidence", param_field) == 0) {
      return steeringWheelAngleConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.SteeringWheelAngle'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_steeringWheelAngleValue = field_steeringWheelAngleValue.get_param(param_name);
  mp_field_steeringWheelAngleValue->set_id(new Module_Param_FieldName(mcopystr("steeringWheelAngleValue")));
  mp->add_elem(mp_field_steeringWheelAngleValue);
  Module_Param* mp_field_steeringWheelAngleConfidence = field_steeringWheelAngleConfidence.get_param(param_name);
  mp_field_steeringWheelAngleConfidence->set_id(new Module_Param_FieldName(mcopystr("steeringWheelAngleConfidence")));
  mp->add_elem(mp_field_steeringWheelAngleConfidence);
  return mp;
  }

void SteeringWheelAngle::set_implicit_omit()
{
if (steeringWheelAngleValue().is_bound()) steeringWheelAngleValue().set_implicit_omit();
if (steeringWheelAngleConfidence().is_bound()) steeringWheelAngleConfidence().set_implicit_omit();
}

void SteeringWheelAngle::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.SteeringWheelAngle.");
field_steeringWheelAngleValue.encode_text(text_buf);
field_steeringWheelAngleConfidence.encode_text(text_buf);
}

void SteeringWheelAngle::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_steeringWheelAngleValue.decode_text(text_buf);
field_steeringWheelAngleConfidence.decode_text(text_buf);
}

void SteeringWheelAngle::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SteeringWheelAngle::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* SteeringWheelAngle::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("steeringWheelAngleValue': ");
  new_tlv->add_TLV(field_steeringWheelAngleValue.BER_encode_TLV(SteeringWheelAngle_steeringWheelAngleValue_descr_, p_coding));
  ec_1.set_msg("steeringWheelAngleConfidence': ");
  new_tlv->add_TLV(field_steeringWheelAngleConfidence.BER_encode_TLV(SteeringWheelAngle_steeringWheelAngleConfidence_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean SteeringWheelAngle::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.SteeringWheelAngle' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("steeringWheelAngleValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_steeringWheelAngleValue.BER_decode_TLV(SteeringWheelAngle_steeringWheelAngleValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("steeringWheelAngleConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_steeringWheelAngleConfidence.BER_decode_TLV(SteeringWheelAngle_steeringWheelAngleConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int SteeringWheelAngle::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.SteeringWheelAngle.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "steeringWheelAngleValue");
    enc_len += field_steeringWheelAngleValue.JSON_encode(SteeringWheelAngle_steeringWheelAngleValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "steeringWheelAngleConfidence");
    enc_len += field_steeringWheelAngleConfidence.JSON_encode(SteeringWheelAngle_steeringWheelAngleConfidence_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SteeringWheelAngle::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (23 == name_len && 0 == strncmp(fld_name, "steeringWheelAngleValue", name_len)) {
         int ret_val = field_steeringWheelAngleValue.JSON_decode(SteeringWheelAngle_steeringWheelAngleValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "steeringWheelAngleValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (28 == name_len && 0 == strncmp(fld_name, "steeringWheelAngleConfidence", name_len)) {
         int ret_val = field_steeringWheelAngleConfidence.JSON_decode(SteeringWheelAngle_steeringWheelAngleConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "steeringWheelAngleConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_steeringWheelAngleValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "steeringWheelAngleValue");
    return JSON_ERROR_FATAL;
  }
if (!field_steeringWheelAngleConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "steeringWheelAngleConfidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SteeringWheelAngle_template::single_value_struct {
INTEGER_template field_steeringWheelAngleValue;
INTEGER_template field_steeringWheelAngleConfidence;
};

void SteeringWheelAngle_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_steeringWheelAngleValue = ANY_VALUE;
single_value->field_steeringWheelAngleConfidence = ANY_VALUE;
}
}
}

void SteeringWheelAngle_template::copy_value(const SteeringWheelAngle& other_value)
{
single_value = new single_value_struct;
if (other_value.steeringWheelAngleValue().is_bound()) {
  single_value->field_steeringWheelAngleValue = other_value.steeringWheelAngleValue();
} else {
  single_value->field_steeringWheelAngleValue.clean_up();
}
if (other_value.steeringWheelAngleConfidence().is_bound()) {
  single_value->field_steeringWheelAngleConfidence = other_value.steeringWheelAngleConfidence();
} else {
  single_value->field_steeringWheelAngleConfidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SteeringWheelAngle_template::copy_template(const SteeringWheelAngle_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.steeringWheelAngleValue().get_selection()) {
single_value->field_steeringWheelAngleValue = other_value.steeringWheelAngleValue();
} else {
single_value->field_steeringWheelAngleValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.steeringWheelAngleConfidence().get_selection()) {
single_value->field_steeringWheelAngleConfidence = other_value.steeringWheelAngleConfidence();
} else {
single_value->field_steeringWheelAngleConfidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SteeringWheelAngle_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.SteeringWheelAngle.");
break;
}
set_selection(other_value);
}

SteeringWheelAngle_template::SteeringWheelAngle_template()
{
}

SteeringWheelAngle_template::SteeringWheelAngle_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SteeringWheelAngle_template::SteeringWheelAngle_template(const SteeringWheelAngle& other_value)
{
copy_value(other_value);
}

SteeringWheelAngle_template::SteeringWheelAngle_template(const OPTIONAL<SteeringWheelAngle>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SteeringWheelAngle&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.SteeringWheelAngle from an unbound optional field.");
}
}

SteeringWheelAngle_template::SteeringWheelAngle_template(const SteeringWheelAngle_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SteeringWheelAngle_template::~SteeringWheelAngle_template()
{
clean_up();
}

SteeringWheelAngle_template& SteeringWheelAngle_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SteeringWheelAngle_template& SteeringWheelAngle_template::operator=(const SteeringWheelAngle& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SteeringWheelAngle_template& SteeringWheelAngle_template::operator=(const OPTIONAL<SteeringWheelAngle>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SteeringWheelAngle&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.SteeringWheelAngle.");
}
return *this;
}

SteeringWheelAngle_template& SteeringWheelAngle_template::operator=(const SteeringWheelAngle_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SteeringWheelAngle_template::match(const SteeringWheelAngle& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.steeringWheelAngleValue().is_bound()) return FALSE;
if(!single_value->field_steeringWheelAngleValue.match(other_value.steeringWheelAngleValue(), legacy))return FALSE;
if(!other_value.steeringWheelAngleConfidence().is_bound()) return FALSE;
if(!single_value->field_steeringWheelAngleConfidence.match(other_value.steeringWheelAngleConfidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.SteeringWheelAngle.");
}
return FALSE;
}

boolean SteeringWheelAngle_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_steeringWheelAngleValue.is_bound()) return TRUE;
if (single_value->field_steeringWheelAngleConfidence.is_bound()) return TRUE;
return FALSE;
}

boolean SteeringWheelAngle_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_steeringWheelAngleValue.is_value()) return FALSE;
if (!single_value->field_steeringWheelAngleConfidence.is_value()) return FALSE;
return TRUE;
}

void SteeringWheelAngle_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SteeringWheelAngle SteeringWheelAngle_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.SteeringWheelAngle.");
SteeringWheelAngle ret_val;
if (single_value->field_steeringWheelAngleValue.is_bound()) {
ret_val.steeringWheelAngleValue() = single_value->field_steeringWheelAngleValue.valueof();
}
if (single_value->field_steeringWheelAngleConfidence.is_bound()) {
ret_val.steeringWheelAngleConfidence() = single_value->field_steeringWheelAngleConfidence.valueof();
}
return ret_val;
}

void SteeringWheelAngle_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.SteeringWheelAngle.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SteeringWheelAngle_template[list_length];
}

SteeringWheelAngle_template& SteeringWheelAngle_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.SteeringWheelAngle.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.SteeringWheelAngle.");
return value_list.list_value[list_index];
}

INTEGER_template& SteeringWheelAngle_template::steeringWheelAngleValue()
{
set_specific();
return single_value->field_steeringWheelAngleValue;
}

const INTEGER_template& SteeringWheelAngle_template::steeringWheelAngleValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field steeringWheelAngleValue of a non-specific template of type @ITS-Container.SteeringWheelAngle.");
return single_value->field_steeringWheelAngleValue;
}

INTEGER_template& SteeringWheelAngle_template::steeringWheelAngleConfidence()
{
set_specific();
return single_value->field_steeringWheelAngleConfidence;
}

const INTEGER_template& SteeringWheelAngle_template::steeringWheelAngleConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field steeringWheelAngleConfidence of a non-specific template of type @ITS-Container.SteeringWheelAngle.");
return single_value->field_steeringWheelAngleConfidence;
}

int SteeringWheelAngle_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.SteeringWheelAngle which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.SteeringWheelAngle containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.SteeringWheelAngle containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.SteeringWheelAngle containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.SteeringWheelAngle containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.SteeringWheelAngle containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.SteeringWheelAngle.");
  }
  return 0;
}

void SteeringWheelAngle_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ steeringWheelAngleValue := ");
single_value->field_steeringWheelAngleValue.log();
TTCN_Logger::log_event_str(", steeringWheelAngleConfidence := ");
single_value->field_steeringWheelAngleConfidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SteeringWheelAngle_template::log_match(const SteeringWheelAngle& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_steeringWheelAngleValue.match(match_value.steeringWheelAngleValue(), legacy)){
TTCN_Logger::log_logmatch_info(".steeringWheelAngleValue");
single_value->field_steeringWheelAngleValue.log_match(match_value.steeringWheelAngleValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_steeringWheelAngleConfidence.match(match_value.steeringWheelAngleConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".steeringWheelAngleConfidence");
single_value->field_steeringWheelAngleConfidence.log_match(match_value.steeringWheelAngleConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ steeringWheelAngleValue := ");
single_value->field_steeringWheelAngleValue.log_match(match_value.steeringWheelAngleValue(), legacy);
TTCN_Logger::log_event_str(", steeringWheelAngleConfidence := ");
single_value->field_steeringWheelAngleConfidence.log_match(match_value.steeringWheelAngleConfidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SteeringWheelAngle_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_steeringWheelAngleValue.encode_text(text_buf);
single_value->field_steeringWheelAngleConfidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.SteeringWheelAngle.");
}
}

void SteeringWheelAngle_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_steeringWheelAngleValue.decode_text(text_buf);
single_value->field_steeringWheelAngleConfidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SteeringWheelAngle_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.SteeringWheelAngle.");
}
}

void SteeringWheelAngle_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.SteeringWheelAngle'");
    }
    if (strcmp("steeringWheelAngleValue", param_field) == 0) {
      steeringWheelAngleValue().set_param(param);
      return;
    } else if (strcmp("steeringWheelAngleConfidence", param_field) == 0) {
      steeringWheelAngleConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.SteeringWheelAngle'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SteeringWheelAngle_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.SteeringWheelAngle has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) steeringWheelAngleValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) steeringWheelAngleConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "steeringWheelAngleValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          steeringWheelAngleValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "steeringWheelAngleConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          steeringWheelAngleConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.SteeringWheelAngle: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.SteeringWheelAngle");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SteeringWheelAngle_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.SteeringWheelAngle'");
    }
    if (strcmp("steeringWheelAngleValue", param_field) == 0) {
      return steeringWheelAngleValue().get_param(param_name);
    } else if (strcmp("steeringWheelAngleConfidence", param_field) == 0) {
      return steeringWheelAngleConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.SteeringWheelAngle'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_steeringWheelAngleValue = single_value->field_steeringWheelAngleValue.get_param(param_name);
    mp_field_steeringWheelAngleValue->set_id(new Module_Param_FieldName(mcopystr("steeringWheelAngleValue")));
    mp->add_elem(mp_field_steeringWheelAngleValue);
    Module_Param* mp_field_steeringWheelAngleConfidence = single_value->field_steeringWheelAngleConfidence.get_param(param_name);
    mp_field_steeringWheelAngleConfidence->set_id(new Module_Param_FieldName(mcopystr("steeringWheelAngleConfidence")));
    mp->add_elem(mp_field_steeringWheelAngleConfidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SteeringWheelAngle_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_steeringWheelAngleValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.SteeringWheelAngle");
single_value->field_steeringWheelAngleConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.SteeringWheelAngle");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.SteeringWheelAngle");
}

boolean SteeringWheelAngle_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SteeringWheelAngle_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

VehicleRole::VehicleRole()
{
enum_value = UNBOUND_VALUE;
}

VehicleRole::VehicleRole(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.VehicleRole with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

VehicleRole::VehicleRole(enum_type other_value)
{
enum_value = other_value;
}

VehicleRole::VehicleRole(const VehicleRole& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.VehicleRole.");
enum_value = other_value.enum_value;
}

VehicleRole& VehicleRole::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.VehicleRole.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

VehicleRole& VehicleRole::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

VehicleRole& VehicleRole::operator=(const VehicleRole& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.VehicleRole.");
enum_value = other_value.enum_value;
return *this;
}

boolean VehicleRole::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleRole.");
return enum_value == other_value;
}

boolean VehicleRole::operator==(const VehicleRole& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleRole.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleRole.");
return enum_value == other_value.enum_value;
}

boolean VehicleRole::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleRole.");
return enum_value < other_value;
}

boolean VehicleRole::operator<(const VehicleRole& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleRole.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleRole.");
return enum_value < other_value.enum_value;
}

boolean VehicleRole::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleRole.");
return enum_value > other_value;
}

boolean VehicleRole::operator>(const VehicleRole& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleRole.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.VehicleRole.");
return enum_value > other_value.enum_value;
}

const char *VehicleRole::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case default__: return "default_";
case publicTransport: return "publicTransport";
case specialTransport: return "specialTransport";
case dangerousGoods: return "dangerousGoods";
case roadWork: return "roadWork";
case rescue: return "rescue";
case emergency: return "emergency";
case safetyCar: return "safetyCar";
case agriculture: return "agriculture";
case commercial: return "commercial";
case military: return "military";
case roadOperator: return "roadOperator";
case taxi: return "taxi";
case reserved1: return "reserved1";
case reserved2: return "reserved2";
case reserved3: return "reserved3";
default: return "<unknown>";
}
}

VehicleRole::enum_type VehicleRole::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "default_")) return default__;
else if (!strcmp(str_par, "publicTransport")) return publicTransport;
else if (!strcmp(str_par, "specialTransport")) return specialTransport;
else if (!strcmp(str_par, "dangerousGoods")) return dangerousGoods;
else if (!strcmp(str_par, "roadWork")) return roadWork;
else if (!strcmp(str_par, "rescue")) return rescue;
else if (!strcmp(str_par, "emergency")) return emergency;
else if (!strcmp(str_par, "safetyCar")) return safetyCar;
else if (!strcmp(str_par, "agriculture")) return agriculture;
else if (!strcmp(str_par, "commercial")) return commercial;
else if (!strcmp(str_par, "military")) return military;
else if (!strcmp(str_par, "roadOperator")) return roadOperator;
else if (!strcmp(str_par, "taxi")) return taxi;
else if (!strcmp(str_par, "reserved1")) return reserved1;
else if (!strcmp(str_par, "reserved2")) return reserved2;
else if (!strcmp(str_par, "reserved3")) return reserved3;
else return UNKNOWN_VALUE;
}

boolean VehicleRole::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
return TRUE;
default:
return FALSE;
}
}

int VehicleRole::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.VehicleRole.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int VehicleRole::enum2int(const VehicleRole& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.VehicleRole.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void VehicleRole::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.VehicleRole.", int_val);
enum_value = (enum_type)int_val;
}

VehicleRole::operator VehicleRole::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.VehicleRole.");
return enum_value;
}

void VehicleRole::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void VehicleRole::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.VehicleRole");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.VehicleRole.");
  }
}

Module_Param* VehicleRole::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void VehicleRole::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.VehicleRole.");
text_buf.push_int(enum_value);
}

void VehicleRole::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.VehicleRole.", enum_value);
}

void VehicleRole::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void VehicleRole::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* VehicleRole::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean VehicleRole::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.VehicleRole: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int VehicleRole::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.VehicleRole.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int VehicleRole::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void VehicleRole_template::copy_template(const VehicleRole_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new VehicleRole_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.VehicleRole.");
}
}

VehicleRole_template::VehicleRole_template()
{
}

VehicleRole_template::VehicleRole_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

VehicleRole_template::VehicleRole_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!VehicleRole::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.VehicleRole with unknown numeric value %d.", other_value);
single_value = (VehicleRole::enum_type)other_value;
}

VehicleRole_template::VehicleRole_template(VehicleRole::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

VehicleRole_template::VehicleRole_template(const VehicleRole& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == VehicleRole::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.VehicleRole.");
single_value = other_value.enum_value;
}

VehicleRole_template::VehicleRole_template(const OPTIONAL<VehicleRole>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (VehicleRole::enum_type)(const VehicleRole&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.VehicleRole from an unbound optional field.");
}
}

VehicleRole_template::VehicleRole_template(const VehicleRole_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

VehicleRole_template::~VehicleRole_template()
{
clean_up();
}

boolean VehicleRole_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean VehicleRole_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != VehicleRole::UNBOUND_VALUE;
}

void VehicleRole_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

VehicleRole_template& VehicleRole_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

VehicleRole_template& VehicleRole_template::operator=(int other_value)
{
if (!VehicleRole::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.VehicleRole.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (VehicleRole::enum_type)other_value;
return *this;
}

VehicleRole_template& VehicleRole_template::operator=(VehicleRole::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

VehicleRole_template& VehicleRole_template::operator=(const VehicleRole& other_value)
{
if (other_value.enum_value == VehicleRole::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.VehicleRole to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

VehicleRole_template& VehicleRole_template::operator=(const OPTIONAL<VehicleRole>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (VehicleRole::enum_type)(const VehicleRole&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.VehicleRole.");
}
return *this;
}

VehicleRole_template& VehicleRole_template::operator=(const VehicleRole_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean VehicleRole_template::match(VehicleRole::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.VehicleRole.");
}
return FALSE;
}

boolean VehicleRole_template::match(const VehicleRole& other_value, boolean) const
{
if (other_value.enum_value == VehicleRole::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.VehicleRole with an unbound value.");
return match(other_value.enum_value);
}

VehicleRole::enum_type VehicleRole_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.VehicleRole.");
return single_value;
}

void VehicleRole_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.VehicleRole.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new VehicleRole_template[list_length];
}

VehicleRole_template& VehicleRole_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.VehicleRole.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.VehicleRole.");
return value_list.list_value[list_index];
}

void VehicleRole_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(VehicleRole::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void VehicleRole_template::log_match(const VehicleRole& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void VehicleRole_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.VehicleRole.");
}
}

void VehicleRole_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (VehicleRole::enum_type)text_buf.pull_int().get_val();
if (!VehicleRole::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.VehicleRole.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new VehicleRole_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.VehicleRole.");
}
}

boolean VehicleRole_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean VehicleRole_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void VehicleRole_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    VehicleRole::enum_type enum_val = (enum_name != NULL) ? VehicleRole::str_to_enum(enum_name) : VehicleRole::UNKNOWN_VALUE;
    if (VehicleRole::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    VehicleRole_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    VehicleRole::enum_type enum_val = VehicleRole::str_to_enum(mp->get_enumerated());
    if (!VehicleRole::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.VehicleRole.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.VehicleRole");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* VehicleRole_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(VehicleRole::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void VehicleRole_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.VehicleRole");
}

YawRateConfidence::YawRateConfidence()
{
enum_value = UNBOUND_VALUE;
}

YawRateConfidence::YawRateConfidence(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.YawRateConfidence with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

YawRateConfidence::YawRateConfidence(enum_type other_value)
{
enum_value = other_value;
}

YawRateConfidence::YawRateConfidence(const YawRateConfidence& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
enum_value = other_value.enum_value;
}

YawRateConfidence& YawRateConfidence::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.YawRateConfidence.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

YawRateConfidence& YawRateConfidence::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

YawRateConfidence& YawRateConfidence::operator=(const YawRateConfidence& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
enum_value = other_value.enum_value;
return *this;
}

boolean YawRateConfidence::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
return enum_value == other_value;
}

boolean YawRateConfidence::operator==(const YawRateConfidence& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
return enum_value == other_value.enum_value;
}

boolean YawRateConfidence::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
return enum_value < other_value;
}

boolean YawRateConfidence::operator<(const YawRateConfidence& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
return enum_value < other_value.enum_value;
}

boolean YawRateConfidence::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
return enum_value > other_value;
}

boolean YawRateConfidence::operator>(const YawRateConfidence& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
return enum_value > other_value.enum_value;
}

const char *YawRateConfidence::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case degSec__000__01: return "degSec_000_01";
case degSec__000__05: return "degSec_000_05";
case degSec__000__10: return "degSec_000_10";
case degSec__001__00: return "degSec_001_00";
case degSec__005__00: return "degSec_005_00";
case degSec__010__00: return "degSec_010_00";
case degSec__100__00: return "degSec_100_00";
case outOfRange: return "outOfRange";
case unavailable: return "unavailable";
default: return "<unknown>";
}
}

YawRateConfidence::enum_type YawRateConfidence::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "degSec_000_01")) return degSec__000__01;
else if (!strcmp(str_par, "degSec_000_05")) return degSec__000__05;
else if (!strcmp(str_par, "degSec_000_10")) return degSec__000__10;
else if (!strcmp(str_par, "degSec_001_00")) return degSec__001__00;
else if (!strcmp(str_par, "degSec_005_00")) return degSec__005__00;
else if (!strcmp(str_par, "degSec_010_00")) return degSec__010__00;
else if (!strcmp(str_par, "degSec_100_00")) return degSec__100__00;
else if (!strcmp(str_par, "outOfRange")) return outOfRange;
else if (!strcmp(str_par, "unavailable")) return unavailable;
else return UNKNOWN_VALUE;
}

boolean YawRateConfidence::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
return TRUE;
default:
return FALSE;
}
}

int YawRateConfidence::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.YawRateConfidence.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int YawRateConfidence::enum2int(const YawRateConfidence& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.YawRateConfidence.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void YawRateConfidence::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.YawRateConfidence.", int_val);
enum_value = (enum_type)int_val;
}

YawRateConfidence::operator YawRateConfidence::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.YawRateConfidence.");
return enum_value;
}

void YawRateConfidence::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void YawRateConfidence::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.YawRateConfidence");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.YawRateConfidence.");
  }
}

Module_Param* YawRateConfidence::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void YawRateConfidence::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
text_buf.push_int(enum_value);
}

void YawRateConfidence::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.YawRateConfidence.", enum_value);
}

void YawRateConfidence::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void YawRateConfidence::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* YawRateConfidence::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean YawRateConfidence::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.YawRateConfidence: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int YawRateConfidence::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int YawRateConfidence::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void YawRateConfidence_template::copy_template(const YawRateConfidence_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new YawRateConfidence_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.YawRateConfidence.");
}
}

YawRateConfidence_template::YawRateConfidence_template()
{
}

YawRateConfidence_template::YawRateConfidence_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

YawRateConfidence_template::YawRateConfidence_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!YawRateConfidence::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.YawRateConfidence with unknown numeric value %d.", other_value);
single_value = (YawRateConfidence::enum_type)other_value;
}

YawRateConfidence_template::YawRateConfidence_template(YawRateConfidence::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

YawRateConfidence_template::YawRateConfidence_template(const YawRateConfidence& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == YawRateConfidence::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.YawRateConfidence.");
single_value = other_value.enum_value;
}

YawRateConfidence_template::YawRateConfidence_template(const OPTIONAL<YawRateConfidence>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (YawRateConfidence::enum_type)(const YawRateConfidence&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.YawRateConfidence from an unbound optional field.");
}
}

YawRateConfidence_template::YawRateConfidence_template(const YawRateConfidence_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

YawRateConfidence_template::~YawRateConfidence_template()
{
clean_up();
}

boolean YawRateConfidence_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean YawRateConfidence_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != YawRateConfidence::UNBOUND_VALUE;
}

void YawRateConfidence_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

YawRateConfidence_template& YawRateConfidence_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

YawRateConfidence_template& YawRateConfidence_template::operator=(int other_value)
{
if (!YawRateConfidence::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.YawRateConfidence.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (YawRateConfidence::enum_type)other_value;
return *this;
}

YawRateConfidence_template& YawRateConfidence_template::operator=(YawRateConfidence::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

YawRateConfidence_template& YawRateConfidence_template::operator=(const YawRateConfidence& other_value)
{
if (other_value.enum_value == YawRateConfidence::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.YawRateConfidence to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

YawRateConfidence_template& YawRateConfidence_template::operator=(const OPTIONAL<YawRateConfidence>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (YawRateConfidence::enum_type)(const YawRateConfidence&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.YawRateConfidence.");
}
return *this;
}

YawRateConfidence_template& YawRateConfidence_template::operator=(const YawRateConfidence_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean YawRateConfidence_template::match(YawRateConfidence::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.YawRateConfidence.");
}
return FALSE;
}

boolean YawRateConfidence_template::match(const YawRateConfidence& other_value, boolean) const
{
if (other_value.enum_value == YawRateConfidence::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.YawRateConfidence with an unbound value.");
return match(other_value.enum_value);
}

YawRateConfidence::enum_type YawRateConfidence_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.YawRateConfidence.");
return single_value;
}

void YawRateConfidence_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.YawRateConfidence.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new YawRateConfidence_template[list_length];
}

YawRateConfidence_template& YawRateConfidence_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.YawRateConfidence.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.YawRateConfidence.");
return value_list.list_value[list_index];
}

void YawRateConfidence_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(YawRateConfidence::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void YawRateConfidence_template::log_match(const YawRateConfidence& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void YawRateConfidence_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.YawRateConfidence.");
}
}

void YawRateConfidence_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (YawRateConfidence::enum_type)text_buf.pull_int().get_val();
if (!YawRateConfidence::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.YawRateConfidence.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new YawRateConfidence_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.YawRateConfidence.");
}
}

boolean YawRateConfidence_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean YawRateConfidence_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void YawRateConfidence_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    YawRateConfidence::enum_type enum_val = (enum_name != NULL) ? YawRateConfidence::str_to_enum(enum_name) : YawRateConfidence::UNKNOWN_VALUE;
    if (YawRateConfidence::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    YawRateConfidence_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    YawRateConfidence::enum_type enum_val = YawRateConfidence::str_to_enum(mp->get_enumerated());
    if (!YawRateConfidence::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.YawRateConfidence.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.YawRateConfidence");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* YawRateConfidence_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(YawRateConfidence::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void YawRateConfidence_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.YawRateConfidence");
}

YawRate::YawRate()
{
  bound_flag = FALSE;
}

YawRate::YawRate(const INTEGER& par_yawRateValue,
    const YawRateConfidence& par_yawRateConfidence)
  :   field_yawRateValue(par_yawRateValue),
  field_yawRateConfidence(par_yawRateConfidence)
{
  bound_flag = TRUE;
}

YawRate::YawRate(const YawRate& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.YawRate.");
bound_flag = TRUE;
if (other_value.yawRateValue().is_bound()) field_yawRateValue = other_value.yawRateValue();
else field_yawRateValue.clean_up();
if (other_value.yawRateConfidence().is_bound()) field_yawRateConfidence = other_value.yawRateConfidence();
else field_yawRateConfidence.clean_up();
}

void YawRate::clean_up()
{
field_yawRateValue.clean_up();
field_yawRateConfidence.clean_up();
bound_flag = FALSE;
}

YawRate& YawRate::operator=(const YawRate& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.YawRate.");
  bound_flag = TRUE;
  if (other_value.yawRateValue().is_bound()) field_yawRateValue = other_value.yawRateValue();
  else field_yawRateValue.clean_up();
  if (other_value.yawRateConfidence().is_bound()) field_yawRateConfidence = other_value.yawRateConfidence();
  else field_yawRateConfidence.clean_up();
}
return *this;
}

boolean YawRate::operator==(const YawRate& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_yawRateValue==other_value.field_yawRateValue
  && field_yawRateConfidence==other_value.field_yawRateConfidence;
}

boolean YawRate::is_bound() const
{
if (bound_flag) return TRUE;
if(field_yawRateValue.is_bound()) return TRUE;
if(field_yawRateConfidence.is_bound()) return TRUE;
return FALSE;
}
boolean YawRate::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_yawRateValue.is_value()) return FALSE;
if(!field_yawRateConfidence.is_value()) return FALSE;
return TRUE;
}
int YawRate::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.YawRate");
  return 2;
}

void YawRate::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ yawRateValue := ");
field_yawRateValue.log();
TTCN_Logger::log_event_str(", yawRateConfidence := ");
field_yawRateConfidence.log();
TTCN_Logger::log_event_str(" }");
}

void YawRate::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.YawRate'");
    }
    if (strcmp("yawRateValue", param_field) == 0) {
      yawRateValue().set_param(param);
      return;
    } else if (strcmp("yawRateConfidence", param_field) == 0) {
      yawRateConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.YawRate'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.YawRate has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) yawRateValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) yawRateConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "yawRateValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          yawRateValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "yawRateConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          yawRateConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.YawRate: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.YawRate");
  }
}

Module_Param* YawRate::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.YawRate'");
    }
    if (strcmp("yawRateValue", param_field) == 0) {
      return yawRateValue().get_param(param_name);
    } else if (strcmp("yawRateConfidence", param_field) == 0) {
      return yawRateConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.YawRate'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_yawRateValue = field_yawRateValue.get_param(param_name);
  mp_field_yawRateValue->set_id(new Module_Param_FieldName(mcopystr("yawRateValue")));
  mp->add_elem(mp_field_yawRateValue);
  Module_Param* mp_field_yawRateConfidence = field_yawRateConfidence.get_param(param_name);
  mp_field_yawRateConfidence->set_id(new Module_Param_FieldName(mcopystr("yawRateConfidence")));
  mp->add_elem(mp_field_yawRateConfidence);
  return mp;
  }

void YawRate::set_implicit_omit()
{
if (yawRateValue().is_bound()) yawRateValue().set_implicit_omit();
if (yawRateConfidence().is_bound()) yawRateConfidence().set_implicit_omit();
}

void YawRate::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.YawRate.");
field_yawRateValue.encode_text(text_buf);
field_yawRateConfidence.encode_text(text_buf);
}

void YawRate::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_yawRateValue.decode_text(text_buf);
field_yawRateConfidence.decode_text(text_buf);
}

void YawRate::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void YawRate::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* YawRate::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("yawRateValue': ");
  new_tlv->add_TLV(field_yawRateValue.BER_encode_TLV(YawRate_yawRateValue_descr_, p_coding));
  ec_1.set_msg("yawRateConfidence': ");
  new_tlv->add_TLV(field_yawRateConfidence.BER_encode_TLV(YawRate_yawRateConfidence_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean YawRate::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.YawRate' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("yawRateValue': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_yawRateValue.BER_decode_TLV(YawRate_yawRateValue_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("yawRateConfidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_yawRateConfidence.BER_decode_TLV(YawRate_yawRateConfidence_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int YawRate::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.YawRate.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "yawRateValue");
    enc_len += field_yawRateValue.JSON_encode(YawRate_yawRateValue_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "yawRateConfidence");
    enc_len += field_yawRateConfidence.JSON_encode(YawRate_yawRateConfidence_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int YawRate::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "yawRateValue", name_len)) {
         int ret_val = field_yawRateValue.JSON_decode(YawRate_yawRateValue_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "yawRateValue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "yawRateConfidence", name_len)) {
         int ret_val = field_yawRateConfidence.JSON_decode(YawRate_yawRateConfidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "yawRateConfidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_yawRateValue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "yawRateValue");
    return JSON_ERROR_FATAL;
  }
if (!field_yawRateConfidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "yawRateConfidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct YawRate_template::single_value_struct {
INTEGER_template field_yawRateValue;
YawRateConfidence_template field_yawRateConfidence;
};

void YawRate_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_yawRateValue = ANY_VALUE;
single_value->field_yawRateConfidence = ANY_VALUE;
}
}
}

void YawRate_template::copy_value(const YawRate& other_value)
{
single_value = new single_value_struct;
if (other_value.yawRateValue().is_bound()) {
  single_value->field_yawRateValue = other_value.yawRateValue();
} else {
  single_value->field_yawRateValue.clean_up();
}
if (other_value.yawRateConfidence().is_bound()) {
  single_value->field_yawRateConfidence = other_value.yawRateConfidence();
} else {
  single_value->field_yawRateConfidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void YawRate_template::copy_template(const YawRate_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.yawRateValue().get_selection()) {
single_value->field_yawRateValue = other_value.yawRateValue();
} else {
single_value->field_yawRateValue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.yawRateConfidence().get_selection()) {
single_value->field_yawRateConfidence = other_value.yawRateConfidence();
} else {
single_value->field_yawRateConfidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new YawRate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.YawRate.");
break;
}
set_selection(other_value);
}

YawRate_template::YawRate_template()
{
}

YawRate_template::YawRate_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

YawRate_template::YawRate_template(const YawRate& other_value)
{
copy_value(other_value);
}

YawRate_template::YawRate_template(const OPTIONAL<YawRate>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const YawRate&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.YawRate from an unbound optional field.");
}
}

YawRate_template::YawRate_template(const YawRate_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

YawRate_template::~YawRate_template()
{
clean_up();
}

YawRate_template& YawRate_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

YawRate_template& YawRate_template::operator=(const YawRate& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

YawRate_template& YawRate_template::operator=(const OPTIONAL<YawRate>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const YawRate&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.YawRate.");
}
return *this;
}

YawRate_template& YawRate_template::operator=(const YawRate_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean YawRate_template::match(const YawRate& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.yawRateValue().is_bound()) return FALSE;
if(!single_value->field_yawRateValue.match(other_value.yawRateValue(), legacy))return FALSE;
if(!other_value.yawRateConfidence().is_bound()) return FALSE;
if(!single_value->field_yawRateConfidence.match(other_value.yawRateConfidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.YawRate.");
}
return FALSE;
}

boolean YawRate_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_yawRateValue.is_bound()) return TRUE;
if (single_value->field_yawRateConfidence.is_bound()) return TRUE;
return FALSE;
}

boolean YawRate_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_yawRateValue.is_value()) return FALSE;
if (!single_value->field_yawRateConfidence.is_value()) return FALSE;
return TRUE;
}

void YawRate_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

YawRate YawRate_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.YawRate.");
YawRate ret_val;
if (single_value->field_yawRateValue.is_bound()) {
ret_val.yawRateValue() = single_value->field_yawRateValue.valueof();
}
if (single_value->field_yawRateConfidence.is_bound()) {
ret_val.yawRateConfidence() = single_value->field_yawRateConfidence.valueof();
}
return ret_val;
}

void YawRate_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.YawRate.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new YawRate_template[list_length];
}

YawRate_template& YawRate_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.YawRate.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.YawRate.");
return value_list.list_value[list_index];
}

INTEGER_template& YawRate_template::yawRateValue()
{
set_specific();
return single_value->field_yawRateValue;
}

const INTEGER_template& YawRate_template::yawRateValue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field yawRateValue of a non-specific template of type @ITS-Container.YawRate.");
return single_value->field_yawRateValue;
}

YawRateConfidence_template& YawRate_template::yawRateConfidence()
{
set_specific();
return single_value->field_yawRateConfidence;
}

const YawRateConfidence_template& YawRate_template::yawRateConfidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field yawRateConfidence of a non-specific template of type @ITS-Container.YawRate.");
return single_value->field_yawRateConfidence;
}

int YawRate_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.YawRate which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.YawRate containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.YawRate containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.YawRate containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.YawRate containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.YawRate containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.YawRate.");
  }
  return 0;
}

void YawRate_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ yawRateValue := ");
single_value->field_yawRateValue.log();
TTCN_Logger::log_event_str(", yawRateConfidence := ");
single_value->field_yawRateConfidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void YawRate_template::log_match(const YawRate& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_yawRateValue.match(match_value.yawRateValue(), legacy)){
TTCN_Logger::log_logmatch_info(".yawRateValue");
single_value->field_yawRateValue.log_match(match_value.yawRateValue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_yawRateConfidence.match(match_value.yawRateConfidence(), legacy)){
TTCN_Logger::log_logmatch_info(".yawRateConfidence");
single_value->field_yawRateConfidence.log_match(match_value.yawRateConfidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ yawRateValue := ");
single_value->field_yawRateValue.log_match(match_value.yawRateValue(), legacy);
TTCN_Logger::log_event_str(", yawRateConfidence := ");
single_value->field_yawRateConfidence.log_match(match_value.yawRateConfidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void YawRate_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_yawRateValue.encode_text(text_buf);
single_value->field_yawRateConfidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.YawRate.");
}
}

void YawRate_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_yawRateValue.decode_text(text_buf);
single_value->field_yawRateConfidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new YawRate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.YawRate.");
}
}

void YawRate_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.YawRate'");
    }
    if (strcmp("yawRateValue", param_field) == 0) {
      yawRateValue().set_param(param);
      return;
    } else if (strcmp("yawRateConfidence", param_field) == 0) {
      yawRateConfidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.YawRate'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    YawRate_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.YawRate has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) yawRateValue().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) yawRateConfidence().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "yawRateValue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          yawRateValue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "yawRateConfidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          yawRateConfidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.YawRate: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.YawRate");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* YawRate_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.YawRate'");
    }
    if (strcmp("yawRateValue", param_field) == 0) {
      return yawRateValue().get_param(param_name);
    } else if (strcmp("yawRateConfidence", param_field) == 0) {
      return yawRateConfidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.YawRate'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_yawRateValue = single_value->field_yawRateValue.get_param(param_name);
    mp_field_yawRateValue->set_id(new Module_Param_FieldName(mcopystr("yawRateValue")));
    mp->add_elem(mp_field_yawRateValue);
    Module_Param* mp_field_yawRateConfidence = single_value->field_yawRateConfidence.get_param(param_name);
    mp_field_yawRateConfidence->set_id(new Module_Param_FieldName(mcopystr("yawRateConfidence")));
    mp->add_elem(mp_field_yawRateConfidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void YawRate_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_yawRateValue.check_restriction(t_res, t_name ? t_name : "@ITS-Container.YawRate");
single_value->field_yawRateConfidence.check_restriction(t_res, t_name ? t_name : "@ITS-Container.YawRate");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.YawRate");
}

boolean YawRate_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean YawRate_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ProtectedZoneType::ProtectedZoneType()
{
enum_value = UNBOUND_VALUE;
}

ProtectedZoneType::ProtectedZoneType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.ProtectedZoneType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

ProtectedZoneType::ProtectedZoneType(enum_type other_value)
{
enum_value = other_value;
}

ProtectedZoneType::ProtectedZoneType(const ProtectedZoneType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
enum_value = other_value.enum_value;
}

ProtectedZoneType& ProtectedZoneType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.ProtectedZoneType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

ProtectedZoneType& ProtectedZoneType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

ProtectedZoneType& ProtectedZoneType::operator=(const ProtectedZoneType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
enum_value = other_value.enum_value;
return *this;
}

boolean ProtectedZoneType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
return enum_value == other_value;
}

boolean ProtectedZoneType::operator==(const ProtectedZoneType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
return enum_value == other_value.enum_value;
}

boolean ProtectedZoneType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
return enum_value < other_value;
}

boolean ProtectedZoneType::operator<(const ProtectedZoneType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
return enum_value < other_value.enum_value;
}

boolean ProtectedZoneType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
return enum_value > other_value;
}

boolean ProtectedZoneType::operator>(const ProtectedZoneType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
return enum_value > other_value.enum_value;
}

const char *ProtectedZoneType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case cenDsrcTolling: return "cenDsrcTolling";
default: return "<unknown>";
}
}

ProtectedZoneType::enum_type ProtectedZoneType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "cenDsrcTolling")) return cenDsrcTolling;
else return UNKNOWN_VALUE;
}

boolean ProtectedZoneType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
return TRUE;
default:
return FALSE;
}
}

int ProtectedZoneType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.ProtectedZoneType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int ProtectedZoneType::enum2int(const ProtectedZoneType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.ProtectedZoneType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void ProtectedZoneType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.ProtectedZoneType.", int_val);
enum_value = (enum_type)int_val;
}

ProtectedZoneType::operator ProtectedZoneType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.ProtectedZoneType.");
return enum_value;
}

void ProtectedZoneType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void ProtectedZoneType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.ProtectedZoneType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.ProtectedZoneType.");
  }
}

Module_Param* ProtectedZoneType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void ProtectedZoneType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
text_buf.push_int(enum_value);
}

void ProtectedZoneType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.ProtectedZoneType.", enum_value);
}

void ProtectedZoneType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ProtectedZoneType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ProtectedZoneType::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ProtectedZoneType::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.ProtectedZoneType: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int ProtectedZoneType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int ProtectedZoneType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void ProtectedZoneType_template::copy_template(const ProtectedZoneType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ProtectedZoneType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.ProtectedZoneType.");
}
}

ProtectedZoneType_template::ProtectedZoneType_template()
{
}

ProtectedZoneType_template::ProtectedZoneType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ProtectedZoneType_template::ProtectedZoneType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!ProtectedZoneType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.ProtectedZoneType with unknown numeric value %d.", other_value);
single_value = (ProtectedZoneType::enum_type)other_value;
}

ProtectedZoneType_template::ProtectedZoneType_template(ProtectedZoneType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

ProtectedZoneType_template::ProtectedZoneType_template(const ProtectedZoneType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == ProtectedZoneType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.ProtectedZoneType.");
single_value = other_value.enum_value;
}

ProtectedZoneType_template::ProtectedZoneType_template(const OPTIONAL<ProtectedZoneType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (ProtectedZoneType::enum_type)(const ProtectedZoneType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.ProtectedZoneType from an unbound optional field.");
}
}

ProtectedZoneType_template::ProtectedZoneType_template(const ProtectedZoneType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

ProtectedZoneType_template::~ProtectedZoneType_template()
{
clean_up();
}

boolean ProtectedZoneType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean ProtectedZoneType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != ProtectedZoneType::UNBOUND_VALUE;
}

void ProtectedZoneType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

ProtectedZoneType_template& ProtectedZoneType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ProtectedZoneType_template& ProtectedZoneType_template::operator=(int other_value)
{
if (!ProtectedZoneType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.ProtectedZoneType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (ProtectedZoneType::enum_type)other_value;
return *this;
}

ProtectedZoneType_template& ProtectedZoneType_template::operator=(ProtectedZoneType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

ProtectedZoneType_template& ProtectedZoneType_template::operator=(const ProtectedZoneType& other_value)
{
if (other_value.enum_value == ProtectedZoneType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.ProtectedZoneType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

ProtectedZoneType_template& ProtectedZoneType_template::operator=(const OPTIONAL<ProtectedZoneType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (ProtectedZoneType::enum_type)(const ProtectedZoneType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.ProtectedZoneType.");
}
return *this;
}

ProtectedZoneType_template& ProtectedZoneType_template::operator=(const ProtectedZoneType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ProtectedZoneType_template::match(ProtectedZoneType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.ProtectedZoneType.");
}
return FALSE;
}

boolean ProtectedZoneType_template::match(const ProtectedZoneType& other_value, boolean) const
{
if (other_value.enum_value == ProtectedZoneType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.ProtectedZoneType with an unbound value.");
return match(other_value.enum_value);
}

ProtectedZoneType::enum_type ProtectedZoneType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.ProtectedZoneType.");
return single_value;
}

void ProtectedZoneType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.ProtectedZoneType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ProtectedZoneType_template[list_length];
}

ProtectedZoneType_template& ProtectedZoneType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.ProtectedZoneType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.ProtectedZoneType.");
return value_list.list_value[list_index];
}

void ProtectedZoneType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(ProtectedZoneType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ProtectedZoneType_template::log_match(const ProtectedZoneType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void ProtectedZoneType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.ProtectedZoneType.");
}
}

void ProtectedZoneType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (ProtectedZoneType::enum_type)text_buf.pull_int().get_val();
if (!ProtectedZoneType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.ProtectedZoneType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ProtectedZoneType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.ProtectedZoneType.");
}
}

boolean ProtectedZoneType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ProtectedZoneType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ProtectedZoneType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    ProtectedZoneType::enum_type enum_val = (enum_name != NULL) ? ProtectedZoneType::str_to_enum(enum_name) : ProtectedZoneType::UNKNOWN_VALUE;
    if (ProtectedZoneType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ProtectedZoneType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    ProtectedZoneType::enum_type enum_val = ProtectedZoneType::str_to_enum(mp->get_enumerated());
    if (!ProtectedZoneType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.ProtectedZoneType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.ProtectedZoneType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ProtectedZoneType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(ProtectedZoneType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ProtectedZoneType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.ProtectedZoneType");
}

RelevanceDistance::RelevanceDistance()
{
enum_value = UNBOUND_VALUE;
}

RelevanceDistance::RelevanceDistance(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.RelevanceDistance with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

RelevanceDistance::RelevanceDistance(enum_type other_value)
{
enum_value = other_value;
}

RelevanceDistance::RelevanceDistance(const RelevanceDistance& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
enum_value = other_value.enum_value;
}

RelevanceDistance& RelevanceDistance::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.RelevanceDistance.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

RelevanceDistance& RelevanceDistance::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

RelevanceDistance& RelevanceDistance::operator=(const RelevanceDistance& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
enum_value = other_value.enum_value;
return *this;
}

boolean RelevanceDistance::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
return enum_value == other_value;
}

boolean RelevanceDistance::operator==(const RelevanceDistance& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
return enum_value == other_value.enum_value;
}

boolean RelevanceDistance::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
return enum_value < other_value;
}

boolean RelevanceDistance::operator<(const RelevanceDistance& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
return enum_value < other_value.enum_value;
}

boolean RelevanceDistance::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
return enum_value > other_value;
}

boolean RelevanceDistance::operator>(const RelevanceDistance& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
return enum_value > other_value.enum_value;
}

const char *RelevanceDistance::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case lessThan50m: return "lessThan50m";
case lessThan100m: return "lessThan100m";
case lessThan200m: return "lessThan200m";
case lessThan500m: return "lessThan500m";
case lessThan1000m: return "lessThan1000m";
case lessThan5km: return "lessThan5km";
case lessThan10km: return "lessThan10km";
case over10km: return "over10km";
default: return "<unknown>";
}
}

RelevanceDistance::enum_type RelevanceDistance::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "lessThan50m")) return lessThan50m;
else if (!strcmp(str_par, "lessThan100m")) return lessThan100m;
else if (!strcmp(str_par, "lessThan200m")) return lessThan200m;
else if (!strcmp(str_par, "lessThan500m")) return lessThan500m;
else if (!strcmp(str_par, "lessThan1000m")) return lessThan1000m;
else if (!strcmp(str_par, "lessThan5km")) return lessThan5km;
else if (!strcmp(str_par, "lessThan10km")) return lessThan10km;
else if (!strcmp(str_par, "over10km")) return over10km;
else return UNKNOWN_VALUE;
}

boolean RelevanceDistance::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
return TRUE;
default:
return FALSE;
}
}

int RelevanceDistance::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.RelevanceDistance.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int RelevanceDistance::enum2int(const RelevanceDistance& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.RelevanceDistance.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void RelevanceDistance::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.RelevanceDistance.", int_val);
enum_value = (enum_type)int_val;
}

RelevanceDistance::operator RelevanceDistance::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.RelevanceDistance.");
return enum_value;
}

void RelevanceDistance::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void RelevanceDistance::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.RelevanceDistance");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.RelevanceDistance.");
  }
}

Module_Param* RelevanceDistance::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void RelevanceDistance::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
text_buf.push_int(enum_value);
}

void RelevanceDistance::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.RelevanceDistance.", enum_value);
}

void RelevanceDistance::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RelevanceDistance::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RelevanceDistance::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RelevanceDistance::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.RelevanceDistance: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int RelevanceDistance::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int RelevanceDistance::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void RelevanceDistance_template::copy_template(const RelevanceDistance_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RelevanceDistance_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.RelevanceDistance.");
}
}

RelevanceDistance_template::RelevanceDistance_template()
{
}

RelevanceDistance_template::RelevanceDistance_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RelevanceDistance_template::RelevanceDistance_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!RelevanceDistance::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.RelevanceDistance with unknown numeric value %d.", other_value);
single_value = (RelevanceDistance::enum_type)other_value;
}

RelevanceDistance_template::RelevanceDistance_template(RelevanceDistance::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

RelevanceDistance_template::RelevanceDistance_template(const RelevanceDistance& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == RelevanceDistance::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.RelevanceDistance.");
single_value = other_value.enum_value;
}

RelevanceDistance_template::RelevanceDistance_template(const OPTIONAL<RelevanceDistance>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RelevanceDistance::enum_type)(const RelevanceDistance&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.RelevanceDistance from an unbound optional field.");
}
}

RelevanceDistance_template::RelevanceDistance_template(const RelevanceDistance_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

RelevanceDistance_template::~RelevanceDistance_template()
{
clean_up();
}

boolean RelevanceDistance_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean RelevanceDistance_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != RelevanceDistance::UNBOUND_VALUE;
}

void RelevanceDistance_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

RelevanceDistance_template& RelevanceDistance_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RelevanceDistance_template& RelevanceDistance_template::operator=(int other_value)
{
if (!RelevanceDistance::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.RelevanceDistance.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (RelevanceDistance::enum_type)other_value;
return *this;
}

RelevanceDistance_template& RelevanceDistance_template::operator=(RelevanceDistance::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

RelevanceDistance_template& RelevanceDistance_template::operator=(const RelevanceDistance& other_value)
{
if (other_value.enum_value == RelevanceDistance::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.RelevanceDistance to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

RelevanceDistance_template& RelevanceDistance_template::operator=(const OPTIONAL<RelevanceDistance>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RelevanceDistance::enum_type)(const RelevanceDistance&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.RelevanceDistance.");
}
return *this;
}

RelevanceDistance_template& RelevanceDistance_template::operator=(const RelevanceDistance_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RelevanceDistance_template::match(RelevanceDistance::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.RelevanceDistance.");
}
return FALSE;
}

boolean RelevanceDistance_template::match(const RelevanceDistance& other_value, boolean) const
{
if (other_value.enum_value == RelevanceDistance::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.RelevanceDistance with an unbound value.");
return match(other_value.enum_value);
}

RelevanceDistance::enum_type RelevanceDistance_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.RelevanceDistance.");
return single_value;
}

void RelevanceDistance_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.RelevanceDistance.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RelevanceDistance_template[list_length];
}

RelevanceDistance_template& RelevanceDistance_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.RelevanceDistance.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.RelevanceDistance.");
return value_list.list_value[list_index];
}

void RelevanceDistance_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(RelevanceDistance::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RelevanceDistance_template::log_match(const RelevanceDistance& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void RelevanceDistance_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.RelevanceDistance.");
}
}

void RelevanceDistance_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (RelevanceDistance::enum_type)text_buf.pull_int().get_val();
if (!RelevanceDistance::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.RelevanceDistance.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RelevanceDistance_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.RelevanceDistance.");
}
}

boolean RelevanceDistance_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RelevanceDistance_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RelevanceDistance_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    RelevanceDistance::enum_type enum_val = (enum_name != NULL) ? RelevanceDistance::str_to_enum(enum_name) : RelevanceDistance::UNKNOWN_VALUE;
    if (RelevanceDistance::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RelevanceDistance_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    RelevanceDistance::enum_type enum_val = RelevanceDistance::str_to_enum(mp->get_enumerated());
    if (!RelevanceDistance::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.RelevanceDistance.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.RelevanceDistance");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RelevanceDistance_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(RelevanceDistance::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RelevanceDistance_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.RelevanceDistance");
}

RelevanceTrafficDirection::RelevanceTrafficDirection()
{
enum_value = UNBOUND_VALUE;
}

RelevanceTrafficDirection::RelevanceTrafficDirection(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @ITS-Container.RelevanceTrafficDirection with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

RelevanceTrafficDirection::RelevanceTrafficDirection(enum_type other_value)
{
enum_value = other_value;
}

RelevanceTrafficDirection::RelevanceTrafficDirection(const RelevanceTrafficDirection& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
enum_value = other_value.enum_value;
}

RelevanceTrafficDirection& RelevanceTrafficDirection::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @ITS-Container.RelevanceTrafficDirection.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

RelevanceTrafficDirection& RelevanceTrafficDirection::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

RelevanceTrafficDirection& RelevanceTrafficDirection::operator=(const RelevanceTrafficDirection& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
enum_value = other_value.enum_value;
return *this;
}

boolean RelevanceTrafficDirection::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
return enum_value == other_value;
}

boolean RelevanceTrafficDirection::operator==(const RelevanceTrafficDirection& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
return enum_value == other_value.enum_value;
}

boolean RelevanceTrafficDirection::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
return enum_value < other_value;
}

boolean RelevanceTrafficDirection::operator<(const RelevanceTrafficDirection& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
return enum_value < other_value.enum_value;
}

boolean RelevanceTrafficDirection::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
return enum_value > other_value;
}

boolean RelevanceTrafficDirection::operator>(const RelevanceTrafficDirection& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
return enum_value > other_value.enum_value;
}

const char *RelevanceTrafficDirection::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case allTrafficDirections: return "allTrafficDirections";
case upstreamTraffic: return "upstreamTraffic";
case downstreamTraffic: return "downstreamTraffic";
case oppositeTraffic: return "oppositeTraffic";
default: return "<unknown>";
}
}

RelevanceTrafficDirection::enum_type RelevanceTrafficDirection::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "allTrafficDirections")) return allTrafficDirections;
else if (!strcmp(str_par, "upstreamTraffic")) return upstreamTraffic;
else if (!strcmp(str_par, "downstreamTraffic")) return downstreamTraffic;
else if (!strcmp(str_par, "oppositeTraffic")) return oppositeTraffic;
else return UNKNOWN_VALUE;
}

boolean RelevanceTrafficDirection::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int RelevanceTrafficDirection::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.RelevanceTrafficDirection.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int RelevanceTrafficDirection::enum2int(const RelevanceTrafficDirection& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @ITS-Container.RelevanceTrafficDirection.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void RelevanceTrafficDirection::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @ITS-Container.RelevanceTrafficDirection.", int_val);
enum_value = (enum_type)int_val;
}

RelevanceTrafficDirection::operator RelevanceTrafficDirection::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @ITS-Container.RelevanceTrafficDirection.");
return enum_value;
}

void RelevanceTrafficDirection::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void RelevanceTrafficDirection::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@ITS-Container.RelevanceTrafficDirection");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @ITS-Container.RelevanceTrafficDirection.");
  }
}

Module_Param* RelevanceTrafficDirection::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void RelevanceTrafficDirection::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
text_buf.push_int(enum_value);
}

void RelevanceTrafficDirection::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @ITS-Container.RelevanceTrafficDirection.", enum_value);
}

void RelevanceTrafficDirection::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RelevanceTrafficDirection::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RelevanceTrafficDirection::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RelevanceTrafficDirection::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @ITS-Container.RelevanceTrafficDirection: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int RelevanceTrafficDirection::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int RelevanceTrafficDirection::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void RelevanceTrafficDirection_template::copy_template(const RelevanceTrafficDirection_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RelevanceTrafficDirection_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @ITS-Container.RelevanceTrafficDirection.");
}
}

RelevanceTrafficDirection_template::RelevanceTrafficDirection_template()
{
}

RelevanceTrafficDirection_template::RelevanceTrafficDirection_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RelevanceTrafficDirection_template::RelevanceTrafficDirection_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!RelevanceTrafficDirection::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @ITS-Container.RelevanceTrafficDirection with unknown numeric value %d.", other_value);
single_value = (RelevanceTrafficDirection::enum_type)other_value;
}

RelevanceTrafficDirection_template::RelevanceTrafficDirection_template(RelevanceTrafficDirection::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

RelevanceTrafficDirection_template::RelevanceTrafficDirection_template(const RelevanceTrafficDirection& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == RelevanceTrafficDirection::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection.");
single_value = other_value.enum_value;
}

RelevanceTrafficDirection_template::RelevanceTrafficDirection_template(const OPTIONAL<RelevanceTrafficDirection>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RelevanceTrafficDirection::enum_type)(const RelevanceTrafficDirection&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @ITS-Container.RelevanceTrafficDirection from an unbound optional field.");
}
}

RelevanceTrafficDirection_template::RelevanceTrafficDirection_template(const RelevanceTrafficDirection_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

RelevanceTrafficDirection_template::~RelevanceTrafficDirection_template()
{
clean_up();
}

boolean RelevanceTrafficDirection_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean RelevanceTrafficDirection_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != RelevanceTrafficDirection::UNBOUND_VALUE;
}

void RelevanceTrafficDirection_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

RelevanceTrafficDirection_template& RelevanceTrafficDirection_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RelevanceTrafficDirection_template& RelevanceTrafficDirection_template::operator=(int other_value)
{
if (!RelevanceTrafficDirection::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @ITS-Container.RelevanceTrafficDirection.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (RelevanceTrafficDirection::enum_type)other_value;
return *this;
}

RelevanceTrafficDirection_template& RelevanceTrafficDirection_template::operator=(RelevanceTrafficDirection::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

RelevanceTrafficDirection_template& RelevanceTrafficDirection_template::operator=(const RelevanceTrafficDirection& other_value)
{
if (other_value.enum_value == RelevanceTrafficDirection::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @ITS-Container.RelevanceTrafficDirection to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

RelevanceTrafficDirection_template& RelevanceTrafficDirection_template::operator=(const OPTIONAL<RelevanceTrafficDirection>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RelevanceTrafficDirection::enum_type)(const RelevanceTrafficDirection&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @ITS-Container.RelevanceTrafficDirection.");
}
return *this;
}

RelevanceTrafficDirection_template& RelevanceTrafficDirection_template::operator=(const RelevanceTrafficDirection_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RelevanceTrafficDirection_template::match(RelevanceTrafficDirection::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @ITS-Container.RelevanceTrafficDirection.");
}
return FALSE;
}

boolean RelevanceTrafficDirection_template::match(const RelevanceTrafficDirection& other_value, boolean) const
{
if (other_value.enum_value == RelevanceTrafficDirection::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @ITS-Container.RelevanceTrafficDirection with an unbound value.");
return match(other_value.enum_value);
}

RelevanceTrafficDirection::enum_type RelevanceTrafficDirection_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @ITS-Container.RelevanceTrafficDirection.");
return single_value;
}

void RelevanceTrafficDirection_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @ITS-Container.RelevanceTrafficDirection.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RelevanceTrafficDirection_template[list_length];
}

RelevanceTrafficDirection_template& RelevanceTrafficDirection_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @ITS-Container.RelevanceTrafficDirection.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @ITS-Container.RelevanceTrafficDirection.");
return value_list.list_value[list_index];
}

void RelevanceTrafficDirection_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(RelevanceTrafficDirection::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RelevanceTrafficDirection_template::log_match(const RelevanceTrafficDirection& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void RelevanceTrafficDirection_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @ITS-Container.RelevanceTrafficDirection.");
}
}

void RelevanceTrafficDirection_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (RelevanceTrafficDirection::enum_type)text_buf.pull_int().get_val();
if (!RelevanceTrafficDirection::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @ITS-Container.RelevanceTrafficDirection.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RelevanceTrafficDirection_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @ITS-Container.RelevanceTrafficDirection.");
}
}

boolean RelevanceTrafficDirection_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RelevanceTrafficDirection_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RelevanceTrafficDirection_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    RelevanceTrafficDirection::enum_type enum_val = (enum_name != NULL) ? RelevanceTrafficDirection::str_to_enum(enum_name) : RelevanceTrafficDirection::UNKNOWN_VALUE;
    if (RelevanceTrafficDirection::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RelevanceTrafficDirection_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    RelevanceTrafficDirection::enum_type enum_val = RelevanceTrafficDirection::str_to_enum(mp->get_enumerated());
    if (!RelevanceTrafficDirection::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @ITS-Container.RelevanceTrafficDirection.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@ITS-Container.RelevanceTrafficDirection");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RelevanceTrafficDirection_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(RelevanceTrafficDirection::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RelevanceTrafficDirection_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.RelevanceTrafficDirection");
}

ActionID::ActionID()
{
  bound_flag = FALSE;
}

ActionID::ActionID(const INTEGER& par_originatingStationID,
    const INTEGER& par_sequenceNumber)
  :   field_originatingStationID(par_originatingStationID),
  field_sequenceNumber(par_sequenceNumber)
{
  bound_flag = TRUE;
}

ActionID::ActionID(const ActionID& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.ActionID.");
bound_flag = TRUE;
if (other_value.originatingStationID().is_bound()) field_originatingStationID = other_value.originatingStationID();
else field_originatingStationID.clean_up();
if (other_value.sequenceNumber().is_bound()) field_sequenceNumber = other_value.sequenceNumber();
else field_sequenceNumber.clean_up();
}

void ActionID::clean_up()
{
field_originatingStationID.clean_up();
field_sequenceNumber.clean_up();
bound_flag = FALSE;
}

ActionID& ActionID::operator=(const ActionID& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.ActionID.");
  bound_flag = TRUE;
  if (other_value.originatingStationID().is_bound()) field_originatingStationID = other_value.originatingStationID();
  else field_originatingStationID.clean_up();
  if (other_value.sequenceNumber().is_bound()) field_sequenceNumber = other_value.sequenceNumber();
  else field_sequenceNumber.clean_up();
}
return *this;
}

boolean ActionID::operator==(const ActionID& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_originatingStationID==other_value.field_originatingStationID
  && field_sequenceNumber==other_value.field_sequenceNumber;
}

boolean ActionID::is_bound() const
{
if (bound_flag) return TRUE;
if(field_originatingStationID.is_bound()) return TRUE;
if(field_sequenceNumber.is_bound()) return TRUE;
return FALSE;
}
boolean ActionID::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_originatingStationID.is_value()) return FALSE;
if(!field_sequenceNumber.is_value()) return FALSE;
return TRUE;
}
int ActionID::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.ActionID");
  return 2;
}

void ActionID::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ originatingStationID := ");
field_originatingStationID.log();
TTCN_Logger::log_event_str(", sequenceNumber := ");
field_sequenceNumber.log();
TTCN_Logger::log_event_str(" }");
}

void ActionID::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.ActionID'");
    }
    if (strcmp("originatingStationID", param_field) == 0) {
      originatingStationID().set_param(param);
      return;
    } else if (strcmp("sequenceNumber", param_field) == 0) {
      sequenceNumber().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.ActionID'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @ITS-Container.ActionID has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) originatingStationID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sequenceNumber().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "originatingStationID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          originatingStationID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sequenceNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sequenceNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ActionID: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.ActionID");
  }
}

Module_Param* ActionID::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.ActionID'");
    }
    if (strcmp("originatingStationID", param_field) == 0) {
      return originatingStationID().get_param(param_name);
    } else if (strcmp("sequenceNumber", param_field) == 0) {
      return sequenceNumber().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ActionID'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_originatingStationID = field_originatingStationID.get_param(param_name);
  mp_field_originatingStationID->set_id(new Module_Param_FieldName(mcopystr("originatingStationID")));
  mp->add_elem(mp_field_originatingStationID);
  Module_Param* mp_field_sequenceNumber = field_sequenceNumber.get_param(param_name);
  mp_field_sequenceNumber->set_id(new Module_Param_FieldName(mcopystr("sequenceNumber")));
  mp->add_elem(mp_field_sequenceNumber);
  return mp;
  }

void ActionID::set_implicit_omit()
{
if (originatingStationID().is_bound()) originatingStationID().set_implicit_omit();
if (sequenceNumber().is_bound()) sequenceNumber().set_implicit_omit();
}

void ActionID::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.ActionID.");
field_originatingStationID.encode_text(text_buf);
field_sequenceNumber.encode_text(text_buf);
}

void ActionID::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_originatingStationID.decode_text(text_buf);
field_sequenceNumber.decode_text(text_buf);
}

void ActionID::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ActionID::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ActionID::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("originatingStationID': ");
  new_tlv->add_TLV(field_originatingStationID.BER_encode_TLV(ActionID_originatingStationID_descr_, p_coding));
  ec_1.set_msg("sequenceNumber': ");
  new_tlv->add_TLV(field_sequenceNumber.BER_encode_TLV(ActionID_sequenceNumber_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ActionID::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.ActionID' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("originatingStationID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_originatingStationID.BER_decode_TLV(ActionID_originatingStationID_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("sequenceNumber': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_sequenceNumber.BER_decode_TLV(ActionID_sequenceNumber_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ActionID::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.ActionID.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "originatingStationID");
    enc_len += field_originatingStationID.JSON_encode(ActionID_originatingStationID_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sequenceNumber");
    enc_len += field_sequenceNumber.JSON_encode(ActionID_sequenceNumber_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ActionID::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (20 == name_len && 0 == strncmp(fld_name, "originatingStationID", name_len)) {
         int ret_val = field_originatingStationID.JSON_decode(ActionID_originatingStationID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "originatingStationID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "sequenceNumber", name_len)) {
         int ret_val = field_sequenceNumber.JSON_decode(ActionID_sequenceNumber_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sequenceNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_originatingStationID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "originatingStationID");
    return JSON_ERROR_FATAL;
  }
if (!field_sequenceNumber.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "sequenceNumber");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ActionID_template::single_value_struct {
INTEGER_template field_originatingStationID;
INTEGER_template field_sequenceNumber;
};

void ActionID_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_originatingStationID = ANY_VALUE;
single_value->field_sequenceNumber = ANY_VALUE;
}
}
}

void ActionID_template::copy_value(const ActionID& other_value)
{
single_value = new single_value_struct;
if (other_value.originatingStationID().is_bound()) {
  single_value->field_originatingStationID = other_value.originatingStationID();
} else {
  single_value->field_originatingStationID.clean_up();
}
if (other_value.sequenceNumber().is_bound()) {
  single_value->field_sequenceNumber = other_value.sequenceNumber();
} else {
  single_value->field_sequenceNumber.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ActionID_template::copy_template(const ActionID_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.originatingStationID().get_selection()) {
single_value->field_originatingStationID = other_value.originatingStationID();
} else {
single_value->field_originatingStationID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sequenceNumber().get_selection()) {
single_value->field_sequenceNumber = other_value.sequenceNumber();
} else {
single_value->field_sequenceNumber.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ActionID_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.ActionID.");
break;
}
set_selection(other_value);
}

ActionID_template::ActionID_template()
{
}

ActionID_template::ActionID_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ActionID_template::ActionID_template(const ActionID& other_value)
{
copy_value(other_value);
}

ActionID_template::ActionID_template(const OPTIONAL<ActionID>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ActionID&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.ActionID from an unbound optional field.");
}
}

ActionID_template::ActionID_template(const ActionID_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ActionID_template::~ActionID_template()
{
clean_up();
}

ActionID_template& ActionID_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ActionID_template& ActionID_template::operator=(const ActionID& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ActionID_template& ActionID_template::operator=(const OPTIONAL<ActionID>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ActionID&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.ActionID.");
}
return *this;
}

ActionID_template& ActionID_template::operator=(const ActionID_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ActionID_template::match(const ActionID& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.originatingStationID().is_bound()) return FALSE;
if(!single_value->field_originatingStationID.match(other_value.originatingStationID(), legacy))return FALSE;
if(!other_value.sequenceNumber().is_bound()) return FALSE;
if(!single_value->field_sequenceNumber.match(other_value.sequenceNumber(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.ActionID.");
}
return FALSE;
}

boolean ActionID_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_originatingStationID.is_bound()) return TRUE;
if (single_value->field_sequenceNumber.is_bound()) return TRUE;
return FALSE;
}

boolean ActionID_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_originatingStationID.is_value()) return FALSE;
if (!single_value->field_sequenceNumber.is_value()) return FALSE;
return TRUE;
}

void ActionID_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ActionID ActionID_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.ActionID.");
ActionID ret_val;
if (single_value->field_originatingStationID.is_bound()) {
ret_val.originatingStationID() = single_value->field_originatingStationID.valueof();
}
if (single_value->field_sequenceNumber.is_bound()) {
ret_val.sequenceNumber() = single_value->field_sequenceNumber.valueof();
}
return ret_val;
}

void ActionID_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.ActionID.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ActionID_template[list_length];
}

ActionID_template& ActionID_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.ActionID.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.ActionID.");
return value_list.list_value[list_index];
}

INTEGER_template& ActionID_template::originatingStationID()
{
set_specific();
return single_value->field_originatingStationID;
}

const INTEGER_template& ActionID_template::originatingStationID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field originatingStationID of a non-specific template of type @ITS-Container.ActionID.");
return single_value->field_originatingStationID;
}

INTEGER_template& ActionID_template::sequenceNumber()
{
set_specific();
return single_value->field_sequenceNumber;
}

const INTEGER_template& ActionID_template::sequenceNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sequenceNumber of a non-specific template of type @ITS-Container.ActionID.");
return single_value->field_sequenceNumber;
}

int ActionID_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ActionID which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.ActionID containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ActionID containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ActionID containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ActionID containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ActionID containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.ActionID.");
  }
  return 0;
}

void ActionID_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ originatingStationID := ");
single_value->field_originatingStationID.log();
TTCN_Logger::log_event_str(", sequenceNumber := ");
single_value->field_sequenceNumber.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ActionID_template::log_match(const ActionID& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_originatingStationID.match(match_value.originatingStationID(), legacy)){
TTCN_Logger::log_logmatch_info(".originatingStationID");
single_value->field_originatingStationID.log_match(match_value.originatingStationID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sequenceNumber.match(match_value.sequenceNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".sequenceNumber");
single_value->field_sequenceNumber.log_match(match_value.sequenceNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ originatingStationID := ");
single_value->field_originatingStationID.log_match(match_value.originatingStationID(), legacy);
TTCN_Logger::log_event_str(", sequenceNumber := ");
single_value->field_sequenceNumber.log_match(match_value.sequenceNumber(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ActionID_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_originatingStationID.encode_text(text_buf);
single_value->field_sequenceNumber.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.ActionID.");
}
}

void ActionID_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_originatingStationID.decode_text(text_buf);
single_value->field_sequenceNumber.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ActionID_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.ActionID.");
}
}

void ActionID_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.ActionID'");
    }
    if (strcmp("originatingStationID", param_field) == 0) {
      originatingStationID().set_param(param);
      return;
    } else if (strcmp("sequenceNumber", param_field) == 0) {
      sequenceNumber().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.ActionID'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ActionID_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @ITS-Container.ActionID has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) originatingStationID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sequenceNumber().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "originatingStationID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          originatingStationID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sequenceNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sequenceNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ActionID: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.ActionID");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ActionID_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.ActionID'");
    }
    if (strcmp("originatingStationID", param_field) == 0) {
      return originatingStationID().get_param(param_name);
    } else if (strcmp("sequenceNumber", param_field) == 0) {
      return sequenceNumber().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ActionID'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_originatingStationID = single_value->field_originatingStationID.get_param(param_name);
    mp_field_originatingStationID->set_id(new Module_Param_FieldName(mcopystr("originatingStationID")));
    mp->add_elem(mp_field_originatingStationID);
    Module_Param* mp_field_sequenceNumber = single_value->field_sequenceNumber.get_param(param_name);
    mp_field_sequenceNumber->set_id(new Module_Param_FieldName(mcopystr("sequenceNumber")));
    mp->add_elem(mp_field_sequenceNumber);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ActionID_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_originatingStationID.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ActionID");
single_value->field_sequenceNumber.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ActionID");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.ActionID");
}

boolean ActionID_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ActionID_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const ReferencePosition ItineraryPath::UNBOUND_ELEM;
ItineraryPath::ItineraryPath()
{
val_ptr = NULL;
}

ItineraryPath::ItineraryPath(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

ItineraryPath::ItineraryPath(const ItineraryPath& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.ItineraryPath.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

ItineraryPath::~ItineraryPath()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void ItineraryPath::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

ItineraryPath& ItineraryPath::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

ItineraryPath& ItineraryPath::operator=(const ItineraryPath& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @ITS-Container.ItineraryPath.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean ItineraryPath::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.ItineraryPath.");
return val_ptr->n_elements == 0 ;
}

boolean ItineraryPath::operator==(const ItineraryPath& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.ItineraryPath.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.ItineraryPath.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

ReferencePosition& ItineraryPath::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.ItineraryPath using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (ReferencePosition**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ReferencePosition(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new ReferencePosition;
}
return *val_ptr->value_elements[index_value];
}

ReferencePosition& ItineraryPath::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.ItineraryPath.");
return (*this)[(int)index_value];
}

const ReferencePosition& ItineraryPath::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @ITS-Container.ItineraryPath.");
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.ItineraryPath using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @ITS-Container.ItineraryPath: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const ReferencePosition& ItineraryPath::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.ItineraryPath.");
return (*this)[(int)index_value];
}

ItineraryPath ItineraryPath::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

ItineraryPath ItineraryPath::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

ItineraryPath ItineraryPath::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

ItineraryPath ItineraryPath::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @ITS-Container.ItineraryPath.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
ItineraryPath ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new ReferencePosition(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

ItineraryPath ItineraryPath::operator+(const ItineraryPath& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @ITS-Container.ItineraryPath concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
ItineraryPath ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ReferencePosition(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new ReferencePosition(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

ItineraryPath ItineraryPath::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @ITS-Container.ItineraryPath.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@ITS-Container.ItineraryPath","element");
ItineraryPath ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new ReferencePosition(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

ItineraryPath ItineraryPath::replace(int index, int len, const ItineraryPath& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @ITS-Container.ItineraryPath.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @ITS-Container.ItineraryPath.");
check_replace_arguments(val_ptr->n_elements, index, len, "@ITS-Container.ItineraryPath","element");
ItineraryPath ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ReferencePosition(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new ReferencePosition(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new ReferencePosition(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

ItineraryPath ItineraryPath::replace(int index, int len, const ItineraryPath_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void ItineraryPath::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @ITS-Container.ItineraryPath.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (ReferencePosition**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ReferencePosition(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (ReferencePosition**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @ITS-Container.ItineraryPath: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (ReferencePosition**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean ItineraryPath::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int ItineraryPath::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @ITS-Container.ItineraryPath.");
return val_ptr->n_elements;
}

int ItineraryPath::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @ITS-Container.ItineraryPath.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void ItineraryPath::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void ItineraryPath::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@ITS-Container.ItineraryPath'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@ITS-Container.ItineraryPath");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@ITS-Container.ItineraryPath");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* ItineraryPath::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@ITS-Container.ItineraryPath'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void ItineraryPath::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void ItineraryPath::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @ITS-Container.ItineraryPath.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void ItineraryPath::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @ITS-Container.ItineraryPath.");
val_ptr->value_elements = (ReferencePosition**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new ReferencePosition;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void ItineraryPath::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ItineraryPath::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ItineraryPath::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ItineraryPath::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (ReferencePosition**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new ReferencePosition;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int ItineraryPath::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.ItineraryPath.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int ItineraryPath::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    ReferencePosition* val = new ReferencePosition;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (ReferencePosition**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ItineraryPath_template::copy_value(const ItineraryPath& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @ITS-Container.ItineraryPath with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (ReferencePosition_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new ReferencePosition_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new ReferencePosition_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void ItineraryPath_template::copy_template(const ItineraryPath_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (ReferencePosition_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new ReferencePosition_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new ReferencePosition_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ItineraryPath_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.ItineraryPath.");
break;
}
set_selection(other_value);
}

boolean ItineraryPath_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ItineraryPath_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const ItineraryPath*)value_ptr)[value_index], legacy);
else return ((const ItineraryPath_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

ItineraryPath_template::ItineraryPath_template()
{
}

ItineraryPath_template::ItineraryPath_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

ItineraryPath_template::ItineraryPath_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

ItineraryPath_template::ItineraryPath_template(const ItineraryPath& other_value)
{
copy_value(other_value);
}

ItineraryPath_template::ItineraryPath_template(const OPTIONAL<ItineraryPath>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ItineraryPath&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.ItineraryPath from an unbound optional field.");
}
}

ItineraryPath_template::ItineraryPath_template(const ItineraryPath_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

ItineraryPath_template::~ItineraryPath_template()
{
clean_up();
}

void ItineraryPath_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ItineraryPath_template& ItineraryPath_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ItineraryPath_template& ItineraryPath_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

ItineraryPath_template& ItineraryPath_template::operator=(const ItineraryPath& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ItineraryPath_template& ItineraryPath_template::operator=(const OPTIONAL<ItineraryPath>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ItineraryPath&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.ItineraryPath.");
}
return *this;
}

ItineraryPath_template& ItineraryPath_template::operator=(const ItineraryPath_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

ReferencePosition_template& ItineraryPath_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.ItineraryPath using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.ItineraryPath.");
    break;
}
return *single_value.value_elements[index_value];
}

ReferencePosition_template& ItineraryPath_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.ItineraryPath.");
return (*this)[(int)index_value];
}

const ReferencePosition_template& ItineraryPath_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.ItineraryPath using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.ItineraryPath.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @ITS-Container.ItineraryPath: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const ReferencePosition_template& ItineraryPath_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.ItineraryPath.");
return (*this)[(int)index_value];
}

void ItineraryPath_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @ITS-Container.ItineraryPath.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (ReferencePosition_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ReferencePosition_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ReferencePosition_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (ReferencePosition_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int ItineraryPath_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int ItineraryPath_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ItineraryPath which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ItineraryPath containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ItineraryPath containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ItineraryPath containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ItineraryPath containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ItineraryPath containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @ITS-Container.ItineraryPath.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @ITS-Container.ItineraryPath");
}

boolean ItineraryPath_template::match(const ItineraryPath& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @ITS-Container.ItineraryPath.");
}
return FALSE;
}

boolean ItineraryPath_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

ItineraryPath ItineraryPath_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @ITS-Container.ItineraryPath.");
ItineraryPath ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

ItineraryPath ItineraryPath_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

ItineraryPath ItineraryPath_template::replace(int index, int len, const ItineraryPath_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

ItineraryPath ItineraryPath_template::replace(int index, int len, const ItineraryPath& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void ItineraryPath_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new ItineraryPath_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @ITS-Container.ItineraryPath.");
}
set_selection(template_type);
}

ItineraryPath_template& ItineraryPath_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @ITS-Container.ItineraryPath.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @ITS-Container.ItineraryPath.");
return value_list.list_value[list_index];
}

void ItineraryPath_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void ItineraryPath_template::log_match(const ItineraryPath& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ItineraryPath_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.ItineraryPath.");
}
}

void ItineraryPath_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @ITS-Container.ItineraryPath.");
single_value.value_elements = (ReferencePosition_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new ReferencePosition_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ItineraryPath_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @ITS-Container.ItineraryPath.");
}
}

boolean ItineraryPath_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ItineraryPath_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ItineraryPath_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@ITS-Container.ItineraryPath'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ItineraryPath_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@ITS-Container.ItineraryPath");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* ItineraryPath_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@ITS-Container.ItineraryPath'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void ItineraryPath_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@ITS-Container.ItineraryPath");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.ItineraryPath");
}

ProtectedCommunicationZone::ProtectedCommunicationZone()
{
  bound_flag = FALSE;
}

ProtectedCommunicationZone::ProtectedCommunicationZone(const ProtectedZoneType& par_protectedZoneType,
    const OPTIONAL<INTEGER>& par_expiryTime,
    const INTEGER& par_protectedZoneLatitude,
    const INTEGER& par_protectedZoneLongitude,
    const OPTIONAL<INTEGER>& par_protectedZoneRadius,
    const OPTIONAL<INTEGER>& par_protectedZoneID)
  :   field_protectedZoneType(par_protectedZoneType),
  field_expiryTime(par_expiryTime),
  field_protectedZoneLatitude(par_protectedZoneLatitude),
  field_protectedZoneLongitude(par_protectedZoneLongitude),
  field_protectedZoneRadius(par_protectedZoneRadius),
  field_protectedZoneID(par_protectedZoneID)
{
  bound_flag = TRUE;
}

ProtectedCommunicationZone::ProtectedCommunicationZone(const ProtectedCommunicationZone& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.ProtectedCommunicationZone.");
bound_flag = TRUE;
if (other_value.protectedZoneType().is_bound()) field_protectedZoneType = other_value.protectedZoneType();
else field_protectedZoneType.clean_up();
if (other_value.expiryTime().is_bound()) field_expiryTime = other_value.expiryTime();
else field_expiryTime.clean_up();
if (other_value.protectedZoneLatitude().is_bound()) field_protectedZoneLatitude = other_value.protectedZoneLatitude();
else field_protectedZoneLatitude.clean_up();
if (other_value.protectedZoneLongitude().is_bound()) field_protectedZoneLongitude = other_value.protectedZoneLongitude();
else field_protectedZoneLongitude.clean_up();
if (other_value.protectedZoneRadius().is_bound()) field_protectedZoneRadius = other_value.protectedZoneRadius();
else field_protectedZoneRadius.clean_up();
if (other_value.protectedZoneID().is_bound()) field_protectedZoneID = other_value.protectedZoneID();
else field_protectedZoneID.clean_up();
}

void ProtectedCommunicationZone::clean_up()
{
field_protectedZoneType.clean_up();
field_expiryTime.clean_up();
field_protectedZoneLatitude.clean_up();
field_protectedZoneLongitude.clean_up();
field_protectedZoneRadius.clean_up();
field_protectedZoneID.clean_up();
bound_flag = FALSE;
}

ProtectedCommunicationZone& ProtectedCommunicationZone::operator=(const ProtectedCommunicationZone& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.ProtectedCommunicationZone.");
  bound_flag = TRUE;
  if (other_value.protectedZoneType().is_bound()) field_protectedZoneType = other_value.protectedZoneType();
  else field_protectedZoneType.clean_up();
  if (other_value.expiryTime().is_bound()) field_expiryTime = other_value.expiryTime();
  else field_expiryTime.clean_up();
  if (other_value.protectedZoneLatitude().is_bound()) field_protectedZoneLatitude = other_value.protectedZoneLatitude();
  else field_protectedZoneLatitude.clean_up();
  if (other_value.protectedZoneLongitude().is_bound()) field_protectedZoneLongitude = other_value.protectedZoneLongitude();
  else field_protectedZoneLongitude.clean_up();
  if (other_value.protectedZoneRadius().is_bound()) field_protectedZoneRadius = other_value.protectedZoneRadius();
  else field_protectedZoneRadius.clean_up();
  if (other_value.protectedZoneID().is_bound()) field_protectedZoneID = other_value.protectedZoneID();
  else field_protectedZoneID.clean_up();
}
return *this;
}

boolean ProtectedCommunicationZone::operator==(const ProtectedCommunicationZone& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_protectedZoneType==other_value.field_protectedZoneType
  && field_expiryTime==other_value.field_expiryTime
  && field_protectedZoneLatitude==other_value.field_protectedZoneLatitude
  && field_protectedZoneLongitude==other_value.field_protectedZoneLongitude
  && field_protectedZoneRadius==other_value.field_protectedZoneRadius
  && field_protectedZoneID==other_value.field_protectedZoneID;
}

boolean ProtectedCommunicationZone::is_bound() const
{
if (bound_flag) return TRUE;
if(field_protectedZoneType.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_expiryTime.get_selection() || field_expiryTime.is_bound()) return TRUE;
if(field_protectedZoneLatitude.is_bound()) return TRUE;
if(field_protectedZoneLongitude.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_protectedZoneRadius.get_selection() || field_protectedZoneRadius.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_protectedZoneID.get_selection() || field_protectedZoneID.is_bound()) return TRUE;
return FALSE;
}
boolean ProtectedCommunicationZone::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_protectedZoneType.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_expiryTime.get_selection() && !field_expiryTime.is_value()) return FALSE;
if(!field_protectedZoneLatitude.is_value()) return FALSE;
if(!field_protectedZoneLongitude.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_protectedZoneRadius.get_selection() && !field_protectedZoneRadius.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_protectedZoneID.get_selection() && !field_protectedZoneID.is_value()) return FALSE;
return TRUE;
}
int ProtectedCommunicationZone::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.ProtectedCommunicationZone");
  int ret_val = 3;
  if (field_expiryTime.ispresent()) ret_val++;
  if (field_protectedZoneRadius.ispresent()) ret_val++;
  if (field_protectedZoneID.ispresent()) ret_val++;
  return ret_val;
}

void ProtectedCommunicationZone::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ protectedZoneType := ");
field_protectedZoneType.log();
TTCN_Logger::log_event_str(", expiryTime := ");
field_expiryTime.log();
TTCN_Logger::log_event_str(", protectedZoneLatitude := ");
field_protectedZoneLatitude.log();
TTCN_Logger::log_event_str(", protectedZoneLongitude := ");
field_protectedZoneLongitude.log();
TTCN_Logger::log_event_str(", protectedZoneRadius := ");
field_protectedZoneRadius.log();
TTCN_Logger::log_event_str(", protectedZoneID := ");
field_protectedZoneID.log();
TTCN_Logger::log_event_str(" }");
}

void ProtectedCommunicationZone::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.ProtectedCommunicationZone'");
    }
    if (strcmp("protectedZoneType", param_field) == 0) {
      protectedZoneType().set_param(param);
      return;
    } else if (strcmp("expiryTime", param_field) == 0) {
      expiryTime().set_param(param);
      return;
    } else if (strcmp("protectedZoneLatitude", param_field) == 0) {
      protectedZoneLatitude().set_param(param);
      return;
    } else if (strcmp("protectedZoneLongitude", param_field) == 0) {
      protectedZoneLongitude().set_param(param);
      return;
    } else if (strcmp("protectedZoneRadius", param_field) == 0) {
      protectedZoneRadius().set_param(param);
      return;
    } else if (strcmp("protectedZoneID", param_field) == 0) {
      protectedZoneID().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.ProtectedCommunicationZone'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record value of type @ITS-Container.ProtectedCommunicationZone has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protectedZoneType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) expiryTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) protectedZoneLatitude().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) protectedZoneLongitude().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) protectedZoneRadius().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) protectedZoneID().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "expiryTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          expiryTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneRadius")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneRadius().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ProtectedCommunicationZone: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.ProtectedCommunicationZone");
  }
}

Module_Param* ProtectedCommunicationZone::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.ProtectedCommunicationZone'");
    }
    if (strcmp("protectedZoneType", param_field) == 0) {
      return protectedZoneType().get_param(param_name);
    } else if (strcmp("expiryTime", param_field) == 0) {
      return expiryTime().get_param(param_name);
    } else if (strcmp("protectedZoneLatitude", param_field) == 0) {
      return protectedZoneLatitude().get_param(param_name);
    } else if (strcmp("protectedZoneLongitude", param_field) == 0) {
      return protectedZoneLongitude().get_param(param_name);
    } else if (strcmp("protectedZoneRadius", param_field) == 0) {
      return protectedZoneRadius().get_param(param_name);
    } else if (strcmp("protectedZoneID", param_field) == 0) {
      return protectedZoneID().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ProtectedCommunicationZone'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_protectedZoneType = field_protectedZoneType.get_param(param_name);
  mp_field_protectedZoneType->set_id(new Module_Param_FieldName(mcopystr("protectedZoneType")));
  mp->add_elem(mp_field_protectedZoneType);
  Module_Param* mp_field_expiryTime = field_expiryTime.get_param(param_name);
  mp_field_expiryTime->set_id(new Module_Param_FieldName(mcopystr("expiryTime")));
  mp->add_elem(mp_field_expiryTime);
  Module_Param* mp_field_protectedZoneLatitude = field_protectedZoneLatitude.get_param(param_name);
  mp_field_protectedZoneLatitude->set_id(new Module_Param_FieldName(mcopystr("protectedZoneLatitude")));
  mp->add_elem(mp_field_protectedZoneLatitude);
  Module_Param* mp_field_protectedZoneLongitude = field_protectedZoneLongitude.get_param(param_name);
  mp_field_protectedZoneLongitude->set_id(new Module_Param_FieldName(mcopystr("protectedZoneLongitude")));
  mp->add_elem(mp_field_protectedZoneLongitude);
  Module_Param* mp_field_protectedZoneRadius = field_protectedZoneRadius.get_param(param_name);
  mp_field_protectedZoneRadius->set_id(new Module_Param_FieldName(mcopystr("protectedZoneRadius")));
  mp->add_elem(mp_field_protectedZoneRadius);
  Module_Param* mp_field_protectedZoneID = field_protectedZoneID.get_param(param_name);
  mp_field_protectedZoneID->set_id(new Module_Param_FieldName(mcopystr("protectedZoneID")));
  mp->add_elem(mp_field_protectedZoneID);
  return mp;
  }

void ProtectedCommunicationZone::set_implicit_omit()
{
if (protectedZoneType().is_bound()) protectedZoneType().set_implicit_omit();
if (!expiryTime().is_bound()) expiryTime() = OMIT_VALUE;
else expiryTime().set_implicit_omit();
if (protectedZoneLatitude().is_bound()) protectedZoneLatitude().set_implicit_omit();
if (protectedZoneLongitude().is_bound()) protectedZoneLongitude().set_implicit_omit();
if (!protectedZoneRadius().is_bound()) protectedZoneRadius() = OMIT_VALUE;
else protectedZoneRadius().set_implicit_omit();
if (!protectedZoneID().is_bound()) protectedZoneID() = OMIT_VALUE;
else protectedZoneID().set_implicit_omit();
}

void ProtectedCommunicationZone::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.ProtectedCommunicationZone.");
field_protectedZoneType.encode_text(text_buf);
field_expiryTime.encode_text(text_buf);
field_protectedZoneLatitude.encode_text(text_buf);
field_protectedZoneLongitude.encode_text(text_buf);
field_protectedZoneRadius.encode_text(text_buf);
field_protectedZoneID.encode_text(text_buf);
}

void ProtectedCommunicationZone::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_protectedZoneType.decode_text(text_buf);
field_expiryTime.decode_text(text_buf);
field_protectedZoneLatitude.decode_text(text_buf);
field_protectedZoneLongitude.decode_text(text_buf);
field_protectedZoneRadius.decode_text(text_buf);
field_protectedZoneID.decode_text(text_buf);
}

void ProtectedCommunicationZone::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ProtectedCommunicationZone::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ProtectedCommunicationZone::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("protectedZoneType': ");
  new_tlv->add_TLV(field_protectedZoneType.BER_encode_TLV(ProtectedCommunicationZone_protectedZoneType_descr_, p_coding));
  ec_1.set_msg("expiryTime': ");
  new_tlv->add_TLV(field_expiryTime.BER_encode_TLV(ProtectedCommunicationZone_expiryTime_descr_, p_coding));
  ec_1.set_msg("protectedZoneLatitude': ");
  new_tlv->add_TLV(field_protectedZoneLatitude.BER_encode_TLV(ProtectedCommunicationZone_protectedZoneLatitude_descr_, p_coding));
  ec_1.set_msg("protectedZoneLongitude': ");
  new_tlv->add_TLV(field_protectedZoneLongitude.BER_encode_TLV(ProtectedCommunicationZone_protectedZoneLongitude_descr_, p_coding));
  ec_1.set_msg("protectedZoneRadius': ");
  new_tlv->add_TLV(field_protectedZoneRadius.BER_encode_TLV(ProtectedCommunicationZone_protectedZoneRadius_descr_, p_coding));
  ec_1.set_msg("protectedZoneID': ");
  new_tlv->add_TLV(field_protectedZoneID.BER_encode_TLV(ProtectedCommunicationZone_protectedZoneID_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ProtectedCommunicationZone::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.ProtectedCommunicationZone' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("protectedZoneType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_protectedZoneType.BER_decode_TLV(ProtectedCommunicationZone_protectedZoneType_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("expiryTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_expiryTime=OMIT_VALUE;
    else {
      field_expiryTime.BER_decode_TLV(ProtectedCommunicationZone_expiryTime_descr_, tmp_tlv, L_form);
      if(field_expiryTime.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("protectedZoneLatitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_protectedZoneLatitude.BER_decode_TLV(ProtectedCommunicationZone_protectedZoneLatitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("protectedZoneLongitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_protectedZoneLongitude.BER_decode_TLV(ProtectedCommunicationZone_protectedZoneLongitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("protectedZoneRadius': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_protectedZoneRadius=OMIT_VALUE;
    else {
      field_protectedZoneRadius.BER_decode_TLV(ProtectedCommunicationZone_protectedZoneRadius_descr_, tmp_tlv, L_form);
      if(field_protectedZoneRadius.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("protectedZoneID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_protectedZoneID=OMIT_VALUE;
    else {
      field_protectedZoneID.BER_decode_TLV(ProtectedCommunicationZone_protectedZoneID_descr_, tmp_tlv, L_form);
      if(field_protectedZoneID.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ProtectedCommunicationZone::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.ProtectedCommunicationZone.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protectedZoneType");
    enc_len += field_protectedZoneType.JSON_encode(ProtectedCommunicationZone_protectedZoneType_descr_, p_tok);
  }

  if (field_expiryTime.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "expiryTime");
    enc_len += field_expiryTime.JSON_encode(ProtectedCommunicationZone_expiryTime_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protectedZoneLatitude");
    enc_len += field_protectedZoneLatitude.JSON_encode(ProtectedCommunicationZone_protectedZoneLatitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protectedZoneLongitude");
    enc_len += field_protectedZoneLongitude.JSON_encode(ProtectedCommunicationZone_protectedZoneLongitude_descr_, p_tok);
  }

  if (field_protectedZoneRadius.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protectedZoneRadius");
    enc_len += field_protectedZoneRadius.JSON_encode(ProtectedCommunicationZone_protectedZoneRadius_descr_, p_tok);
  }

  if (field_protectedZoneID.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protectedZoneID");
    enc_len += field_protectedZoneID.JSON_encode(ProtectedCommunicationZone_protectedZoneID_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ProtectedCommunicationZone::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (17 == name_len && 0 == strncmp(fld_name, "protectedZoneType", name_len)) {
         int ret_val = field_protectedZoneType.JSON_decode(ProtectedCommunicationZone_protectedZoneType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protectedZoneType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "expiryTime", name_len)) {
         int ret_val = field_expiryTime.JSON_decode(ProtectedCommunicationZone_expiryTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "expiryTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (21 == name_len && 0 == strncmp(fld_name, "protectedZoneLatitude", name_len)) {
         int ret_val = field_protectedZoneLatitude.JSON_decode(ProtectedCommunicationZone_protectedZoneLatitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protectedZoneLatitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (22 == name_len && 0 == strncmp(fld_name, "protectedZoneLongitude", name_len)) {
         int ret_val = field_protectedZoneLongitude.JSON_decode(ProtectedCommunicationZone_protectedZoneLongitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protectedZoneLongitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "protectedZoneRadius", name_len)) {
         int ret_val = field_protectedZoneRadius.JSON_decode(ProtectedCommunicationZone_protectedZoneRadius_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protectedZoneRadius");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "protectedZoneID", name_len)) {
         int ret_val = field_protectedZoneID.JSON_decode(ProtectedCommunicationZone_protectedZoneID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protectedZoneID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_protectedZoneType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protectedZoneType");
    return JSON_ERROR_FATAL;
  }
if (!field_expiryTime.is_bound()) {
    field_expiryTime = OMIT_VALUE;
  }
if (!field_protectedZoneLatitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protectedZoneLatitude");
    return JSON_ERROR_FATAL;
  }
if (!field_protectedZoneLongitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protectedZoneLongitude");
    return JSON_ERROR_FATAL;
  }
if (!field_protectedZoneRadius.is_bound()) {
    field_protectedZoneRadius = OMIT_VALUE;
  }
if (!field_protectedZoneID.is_bound()) {
    field_protectedZoneID = OMIT_VALUE;
  }

  return dec_len;
}

struct ProtectedCommunicationZone_template::single_value_struct {
ProtectedZoneType_template field_protectedZoneType;
INTEGER_template field_expiryTime;
INTEGER_template field_protectedZoneLatitude;
INTEGER_template field_protectedZoneLongitude;
INTEGER_template field_protectedZoneRadius;
INTEGER_template field_protectedZoneID;
};

void ProtectedCommunicationZone_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_protectedZoneType = ANY_VALUE;
single_value->field_expiryTime = ANY_OR_OMIT;
single_value->field_protectedZoneLatitude = ANY_VALUE;
single_value->field_protectedZoneLongitude = ANY_VALUE;
single_value->field_protectedZoneRadius = ANY_OR_OMIT;
single_value->field_protectedZoneID = ANY_OR_OMIT;
}
}
}

void ProtectedCommunicationZone_template::copy_value(const ProtectedCommunicationZone& other_value)
{
single_value = new single_value_struct;
if (other_value.protectedZoneType().is_bound()) {
  single_value->field_protectedZoneType = other_value.protectedZoneType();
} else {
  single_value->field_protectedZoneType.clean_up();
}
if (other_value.expiryTime().is_bound()) {
  if (other_value.expiryTime().ispresent()) single_value->field_expiryTime = other_value.expiryTime()();
  else single_value->field_expiryTime = OMIT_VALUE;
} else {
  single_value->field_expiryTime.clean_up();
}
if (other_value.protectedZoneLatitude().is_bound()) {
  single_value->field_protectedZoneLatitude = other_value.protectedZoneLatitude();
} else {
  single_value->field_protectedZoneLatitude.clean_up();
}
if (other_value.protectedZoneLongitude().is_bound()) {
  single_value->field_protectedZoneLongitude = other_value.protectedZoneLongitude();
} else {
  single_value->field_protectedZoneLongitude.clean_up();
}
if (other_value.protectedZoneRadius().is_bound()) {
  if (other_value.protectedZoneRadius().ispresent()) single_value->field_protectedZoneRadius = other_value.protectedZoneRadius()();
  else single_value->field_protectedZoneRadius = OMIT_VALUE;
} else {
  single_value->field_protectedZoneRadius.clean_up();
}
if (other_value.protectedZoneID().is_bound()) {
  if (other_value.protectedZoneID().ispresent()) single_value->field_protectedZoneID = other_value.protectedZoneID()();
  else single_value->field_protectedZoneID = OMIT_VALUE;
} else {
  single_value->field_protectedZoneID.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ProtectedCommunicationZone_template::copy_template(const ProtectedCommunicationZone_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.protectedZoneType().get_selection()) {
single_value->field_protectedZoneType = other_value.protectedZoneType();
} else {
single_value->field_protectedZoneType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.expiryTime().get_selection()) {
single_value->field_expiryTime = other_value.expiryTime();
} else {
single_value->field_expiryTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.protectedZoneLatitude().get_selection()) {
single_value->field_protectedZoneLatitude = other_value.protectedZoneLatitude();
} else {
single_value->field_protectedZoneLatitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.protectedZoneLongitude().get_selection()) {
single_value->field_protectedZoneLongitude = other_value.protectedZoneLongitude();
} else {
single_value->field_protectedZoneLongitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.protectedZoneRadius().get_selection()) {
single_value->field_protectedZoneRadius = other_value.protectedZoneRadius();
} else {
single_value->field_protectedZoneRadius.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.protectedZoneID().get_selection()) {
single_value->field_protectedZoneID = other_value.protectedZoneID();
} else {
single_value->field_protectedZoneID.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ProtectedCommunicationZone_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.ProtectedCommunicationZone.");
break;
}
set_selection(other_value);
}

ProtectedCommunicationZone_template::ProtectedCommunicationZone_template()
{
}

ProtectedCommunicationZone_template::ProtectedCommunicationZone_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ProtectedCommunicationZone_template::ProtectedCommunicationZone_template(const ProtectedCommunicationZone& other_value)
{
copy_value(other_value);
}

ProtectedCommunicationZone_template::ProtectedCommunicationZone_template(const OPTIONAL<ProtectedCommunicationZone>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ProtectedCommunicationZone&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.ProtectedCommunicationZone from an unbound optional field.");
}
}

ProtectedCommunicationZone_template::ProtectedCommunicationZone_template(const ProtectedCommunicationZone_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ProtectedCommunicationZone_template::~ProtectedCommunicationZone_template()
{
clean_up();
}

ProtectedCommunicationZone_template& ProtectedCommunicationZone_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ProtectedCommunicationZone_template& ProtectedCommunicationZone_template::operator=(const ProtectedCommunicationZone& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ProtectedCommunicationZone_template& ProtectedCommunicationZone_template::operator=(const OPTIONAL<ProtectedCommunicationZone>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ProtectedCommunicationZone&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.ProtectedCommunicationZone.");
}
return *this;
}

ProtectedCommunicationZone_template& ProtectedCommunicationZone_template::operator=(const ProtectedCommunicationZone_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ProtectedCommunicationZone_template::match(const ProtectedCommunicationZone& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.protectedZoneType().is_bound()) return FALSE;
if(!single_value->field_protectedZoneType.match(other_value.protectedZoneType(), legacy))return FALSE;
if(!other_value.expiryTime().is_bound()) return FALSE;
if((other_value.expiryTime().ispresent() ? !single_value->field_expiryTime.match((const INTEGER&)other_value.expiryTime(), legacy) : !single_value->field_expiryTime.match_omit(legacy)))return FALSE;
if(!other_value.protectedZoneLatitude().is_bound()) return FALSE;
if(!single_value->field_protectedZoneLatitude.match(other_value.protectedZoneLatitude(), legacy))return FALSE;
if(!other_value.protectedZoneLongitude().is_bound()) return FALSE;
if(!single_value->field_protectedZoneLongitude.match(other_value.protectedZoneLongitude(), legacy))return FALSE;
if(!other_value.protectedZoneRadius().is_bound()) return FALSE;
if((other_value.protectedZoneRadius().ispresent() ? !single_value->field_protectedZoneRadius.match((const INTEGER&)other_value.protectedZoneRadius(), legacy) : !single_value->field_protectedZoneRadius.match_omit(legacy)))return FALSE;
if(!other_value.protectedZoneID().is_bound()) return FALSE;
if((other_value.protectedZoneID().ispresent() ? !single_value->field_protectedZoneID.match((const INTEGER&)other_value.protectedZoneID(), legacy) : !single_value->field_protectedZoneID.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.ProtectedCommunicationZone.");
}
return FALSE;
}

boolean ProtectedCommunicationZone_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_protectedZoneType.is_bound()) return TRUE;
if (single_value->field_expiryTime.is_omit() || single_value->field_expiryTime.is_bound()) return TRUE;
if (single_value->field_protectedZoneLatitude.is_bound()) return TRUE;
if (single_value->field_protectedZoneLongitude.is_bound()) return TRUE;
if (single_value->field_protectedZoneRadius.is_omit() || single_value->field_protectedZoneRadius.is_bound()) return TRUE;
if (single_value->field_protectedZoneID.is_omit() || single_value->field_protectedZoneID.is_bound()) return TRUE;
return FALSE;
}

boolean ProtectedCommunicationZone_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_protectedZoneType.is_value()) return FALSE;
if (!single_value->field_expiryTime.is_omit() && !single_value->field_expiryTime.is_value()) return FALSE;
if (!single_value->field_protectedZoneLatitude.is_value()) return FALSE;
if (!single_value->field_protectedZoneLongitude.is_value()) return FALSE;
if (!single_value->field_protectedZoneRadius.is_omit() && !single_value->field_protectedZoneRadius.is_value()) return FALSE;
if (!single_value->field_protectedZoneID.is_omit() && !single_value->field_protectedZoneID.is_value()) return FALSE;
return TRUE;
}

void ProtectedCommunicationZone_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ProtectedCommunicationZone ProtectedCommunicationZone_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.ProtectedCommunicationZone.");
ProtectedCommunicationZone ret_val;
if (single_value->field_protectedZoneType.is_bound()) {
ret_val.protectedZoneType() = single_value->field_protectedZoneType.valueof();
}
if (single_value->field_expiryTime.is_omit()) ret_val.expiryTime() = OMIT_VALUE;
else if (single_value->field_expiryTime.is_bound()) {
ret_val.expiryTime() = single_value->field_expiryTime.valueof();
}
if (single_value->field_protectedZoneLatitude.is_bound()) {
ret_val.protectedZoneLatitude() = single_value->field_protectedZoneLatitude.valueof();
}
if (single_value->field_protectedZoneLongitude.is_bound()) {
ret_val.protectedZoneLongitude() = single_value->field_protectedZoneLongitude.valueof();
}
if (single_value->field_protectedZoneRadius.is_omit()) ret_val.protectedZoneRadius() = OMIT_VALUE;
else if (single_value->field_protectedZoneRadius.is_bound()) {
ret_val.protectedZoneRadius() = single_value->field_protectedZoneRadius.valueof();
}
if (single_value->field_protectedZoneID.is_omit()) ret_val.protectedZoneID() = OMIT_VALUE;
else if (single_value->field_protectedZoneID.is_bound()) {
ret_val.protectedZoneID() = single_value->field_protectedZoneID.valueof();
}
return ret_val;
}

void ProtectedCommunicationZone_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.ProtectedCommunicationZone.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ProtectedCommunicationZone_template[list_length];
}

ProtectedCommunicationZone_template& ProtectedCommunicationZone_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.ProtectedCommunicationZone.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.ProtectedCommunicationZone.");
return value_list.list_value[list_index];
}

ProtectedZoneType_template& ProtectedCommunicationZone_template::protectedZoneType()
{
set_specific();
return single_value->field_protectedZoneType;
}

const ProtectedZoneType_template& ProtectedCommunicationZone_template::protectedZoneType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protectedZoneType of a non-specific template of type @ITS-Container.ProtectedCommunicationZone.");
return single_value->field_protectedZoneType;
}

INTEGER_template& ProtectedCommunicationZone_template::expiryTime()
{
set_specific();
return single_value->field_expiryTime;
}

const INTEGER_template& ProtectedCommunicationZone_template::expiryTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field expiryTime of a non-specific template of type @ITS-Container.ProtectedCommunicationZone.");
return single_value->field_expiryTime;
}

INTEGER_template& ProtectedCommunicationZone_template::protectedZoneLatitude()
{
set_specific();
return single_value->field_protectedZoneLatitude;
}

const INTEGER_template& ProtectedCommunicationZone_template::protectedZoneLatitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protectedZoneLatitude of a non-specific template of type @ITS-Container.ProtectedCommunicationZone.");
return single_value->field_protectedZoneLatitude;
}

INTEGER_template& ProtectedCommunicationZone_template::protectedZoneLongitude()
{
set_specific();
return single_value->field_protectedZoneLongitude;
}

const INTEGER_template& ProtectedCommunicationZone_template::protectedZoneLongitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protectedZoneLongitude of a non-specific template of type @ITS-Container.ProtectedCommunicationZone.");
return single_value->field_protectedZoneLongitude;
}

INTEGER_template& ProtectedCommunicationZone_template::protectedZoneRadius()
{
set_specific();
return single_value->field_protectedZoneRadius;
}

const INTEGER_template& ProtectedCommunicationZone_template::protectedZoneRadius() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protectedZoneRadius of a non-specific template of type @ITS-Container.ProtectedCommunicationZone.");
return single_value->field_protectedZoneRadius;
}

INTEGER_template& ProtectedCommunicationZone_template::protectedZoneID()
{
set_specific();
return single_value->field_protectedZoneID;
}

const INTEGER_template& ProtectedCommunicationZone_template::protectedZoneID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protectedZoneID of a non-specific template of type @ITS-Container.ProtectedCommunicationZone.");
return single_value->field_protectedZoneID;
}

int ProtectedCommunicationZone_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ProtectedCommunicationZone which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 3;
      if (single_value->field_expiryTime.is_present()) ret_val++;
      if (single_value->field_protectedZoneRadius.is_present()) ret_val++;
      if (single_value->field_protectedZoneID.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.ProtectedCommunicationZone containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ProtectedCommunicationZone containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ProtectedCommunicationZone containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ProtectedCommunicationZone containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.ProtectedCommunicationZone containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.ProtectedCommunicationZone.");
  }
  return 0;
}

void ProtectedCommunicationZone_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ protectedZoneType := ");
single_value->field_protectedZoneType.log();
TTCN_Logger::log_event_str(", expiryTime := ");
single_value->field_expiryTime.log();
TTCN_Logger::log_event_str(", protectedZoneLatitude := ");
single_value->field_protectedZoneLatitude.log();
TTCN_Logger::log_event_str(", protectedZoneLongitude := ");
single_value->field_protectedZoneLongitude.log();
TTCN_Logger::log_event_str(", protectedZoneRadius := ");
single_value->field_protectedZoneRadius.log();
TTCN_Logger::log_event_str(", protectedZoneID := ");
single_value->field_protectedZoneID.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ProtectedCommunicationZone_template::log_match(const ProtectedCommunicationZone& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_protectedZoneType.match(match_value.protectedZoneType(), legacy)){
TTCN_Logger::log_logmatch_info(".protectedZoneType");
single_value->field_protectedZoneType.log_match(match_value.protectedZoneType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.expiryTime().ispresent()){
if(!single_value->field_expiryTime.match(match_value.expiryTime(), legacy)){
TTCN_Logger::log_logmatch_info(".expiryTime");
single_value->field_expiryTime.log_match(match_value.expiryTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_expiryTime.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".expiryTime := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_expiryTime.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_protectedZoneLatitude.match(match_value.protectedZoneLatitude(), legacy)){
TTCN_Logger::log_logmatch_info(".protectedZoneLatitude");
single_value->field_protectedZoneLatitude.log_match(match_value.protectedZoneLatitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_protectedZoneLongitude.match(match_value.protectedZoneLongitude(), legacy)){
TTCN_Logger::log_logmatch_info(".protectedZoneLongitude");
single_value->field_protectedZoneLongitude.log_match(match_value.protectedZoneLongitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.protectedZoneRadius().ispresent()){
if(!single_value->field_protectedZoneRadius.match(match_value.protectedZoneRadius(), legacy)){
TTCN_Logger::log_logmatch_info(".protectedZoneRadius");
single_value->field_protectedZoneRadius.log_match(match_value.protectedZoneRadius(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_protectedZoneRadius.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".protectedZoneRadius := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_protectedZoneRadius.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.protectedZoneID().ispresent()){
if(!single_value->field_protectedZoneID.match(match_value.protectedZoneID(), legacy)){
TTCN_Logger::log_logmatch_info(".protectedZoneID");
single_value->field_protectedZoneID.log_match(match_value.protectedZoneID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_protectedZoneID.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".protectedZoneID := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_protectedZoneID.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ protectedZoneType := ");
single_value->field_protectedZoneType.log_match(match_value.protectedZoneType(), legacy);
TTCN_Logger::log_event_str(", expiryTime := ");
if (match_value.expiryTime().ispresent()) single_value->field_expiryTime.log_match(match_value.expiryTime(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_expiryTime.log();
if (single_value->field_expiryTime.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", protectedZoneLatitude := ");
single_value->field_protectedZoneLatitude.log_match(match_value.protectedZoneLatitude(), legacy);
TTCN_Logger::log_event_str(", protectedZoneLongitude := ");
single_value->field_protectedZoneLongitude.log_match(match_value.protectedZoneLongitude(), legacy);
TTCN_Logger::log_event_str(", protectedZoneRadius := ");
if (match_value.protectedZoneRadius().ispresent()) single_value->field_protectedZoneRadius.log_match(match_value.protectedZoneRadius(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_protectedZoneRadius.log();
if (single_value->field_protectedZoneRadius.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", protectedZoneID := ");
if (match_value.protectedZoneID().ispresent()) single_value->field_protectedZoneID.log_match(match_value.protectedZoneID(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_protectedZoneID.log();
if (single_value->field_protectedZoneID.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ProtectedCommunicationZone_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_protectedZoneType.encode_text(text_buf);
single_value->field_expiryTime.encode_text(text_buf);
single_value->field_protectedZoneLatitude.encode_text(text_buf);
single_value->field_protectedZoneLongitude.encode_text(text_buf);
single_value->field_protectedZoneRadius.encode_text(text_buf);
single_value->field_protectedZoneID.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.ProtectedCommunicationZone.");
}
}

void ProtectedCommunicationZone_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_protectedZoneType.decode_text(text_buf);
single_value->field_expiryTime.decode_text(text_buf);
single_value->field_protectedZoneLatitude.decode_text(text_buf);
single_value->field_protectedZoneLongitude.decode_text(text_buf);
single_value->field_protectedZoneRadius.decode_text(text_buf);
single_value->field_protectedZoneID.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ProtectedCommunicationZone_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.ProtectedCommunicationZone.");
}
}

void ProtectedCommunicationZone_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.ProtectedCommunicationZone'");
    }
    if (strcmp("protectedZoneType", param_field) == 0) {
      protectedZoneType().set_param(param);
      return;
    } else if (strcmp("expiryTime", param_field) == 0) {
      expiryTime().set_param(param);
      return;
    } else if (strcmp("protectedZoneLatitude", param_field) == 0) {
      protectedZoneLatitude().set_param(param);
      return;
    } else if (strcmp("protectedZoneLongitude", param_field) == 0) {
      protectedZoneLongitude().set_param(param);
      return;
    } else if (strcmp("protectedZoneRadius", param_field) == 0) {
      protectedZoneRadius().set_param(param);
      return;
    } else if (strcmp("protectedZoneID", param_field) == 0) {
      protectedZoneID().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.ProtectedCommunicationZone'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ProtectedCommunicationZone_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record template of type @ITS-Container.ProtectedCommunicationZone has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protectedZoneType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) expiryTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) protectedZoneLatitude().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) protectedZoneLongitude().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) protectedZoneRadius().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) protectedZoneID().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "expiryTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          expiryTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneRadius")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneRadius().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.ProtectedCommunicationZone: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.ProtectedCommunicationZone");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ProtectedCommunicationZone_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.ProtectedCommunicationZone'");
    }
    if (strcmp("protectedZoneType", param_field) == 0) {
      return protectedZoneType().get_param(param_name);
    } else if (strcmp("expiryTime", param_field) == 0) {
      return expiryTime().get_param(param_name);
    } else if (strcmp("protectedZoneLatitude", param_field) == 0) {
      return protectedZoneLatitude().get_param(param_name);
    } else if (strcmp("protectedZoneLongitude", param_field) == 0) {
      return protectedZoneLongitude().get_param(param_name);
    } else if (strcmp("protectedZoneRadius", param_field) == 0) {
      return protectedZoneRadius().get_param(param_name);
    } else if (strcmp("protectedZoneID", param_field) == 0) {
      return protectedZoneID().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.ProtectedCommunicationZone'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_protectedZoneType = single_value->field_protectedZoneType.get_param(param_name);
    mp_field_protectedZoneType->set_id(new Module_Param_FieldName(mcopystr("protectedZoneType")));
    mp->add_elem(mp_field_protectedZoneType);
    Module_Param* mp_field_expiryTime = single_value->field_expiryTime.get_param(param_name);
    mp_field_expiryTime->set_id(new Module_Param_FieldName(mcopystr("expiryTime")));
    mp->add_elem(mp_field_expiryTime);
    Module_Param* mp_field_protectedZoneLatitude = single_value->field_protectedZoneLatitude.get_param(param_name);
    mp_field_protectedZoneLatitude->set_id(new Module_Param_FieldName(mcopystr("protectedZoneLatitude")));
    mp->add_elem(mp_field_protectedZoneLatitude);
    Module_Param* mp_field_protectedZoneLongitude = single_value->field_protectedZoneLongitude.get_param(param_name);
    mp_field_protectedZoneLongitude->set_id(new Module_Param_FieldName(mcopystr("protectedZoneLongitude")));
    mp->add_elem(mp_field_protectedZoneLongitude);
    Module_Param* mp_field_protectedZoneRadius = single_value->field_protectedZoneRadius.get_param(param_name);
    mp_field_protectedZoneRadius->set_id(new Module_Param_FieldName(mcopystr("protectedZoneRadius")));
    mp->add_elem(mp_field_protectedZoneRadius);
    Module_Param* mp_field_protectedZoneID = single_value->field_protectedZoneID.get_param(param_name);
    mp_field_protectedZoneID->set_id(new Module_Param_FieldName(mcopystr("protectedZoneID")));
    mp->add_elem(mp_field_protectedZoneID);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ProtectedCommunicationZone_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_protectedZoneType.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ProtectedCommunicationZone");
single_value->field_expiryTime.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ProtectedCommunicationZone");
single_value->field_protectedZoneLatitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ProtectedCommunicationZone");
single_value->field_protectedZoneLongitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ProtectedCommunicationZone");
single_value->field_protectedZoneRadius.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ProtectedCommunicationZone");
single_value->field_protectedZoneID.check_restriction(t_res, t_name ? t_name : "@ITS-Container.ProtectedCommunicationZone");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.ProtectedCommunicationZone");
}

boolean ProtectedCommunicationZone_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ProtectedCommunicationZone_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const PathHistory Traces::UNBOUND_ELEM;
Traces::Traces()
{
val_ptr = NULL;
}

Traces::Traces(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

Traces::Traces(const Traces& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.Traces.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

Traces::~Traces()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void Traces::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

Traces& Traces::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

Traces& Traces::operator=(const Traces& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @ITS-Container.Traces.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean Traces::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.Traces.");
return val_ptr->n_elements == 0 ;
}

boolean Traces::operator==(const Traces& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.Traces.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.Traces.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

PathHistory& Traces::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.Traces using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (PathHistory**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PathHistory(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new PathHistory;
}
return *val_ptr->value_elements[index_value];
}

PathHistory& Traces::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.Traces.");
return (*this)[(int)index_value];
}

const PathHistory& Traces::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @ITS-Container.Traces.");
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.Traces using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @ITS-Container.Traces: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const PathHistory& Traces::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.Traces.");
return (*this)[(int)index_value];
}

Traces Traces::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

Traces Traces::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

Traces Traces::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

Traces Traces::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @ITS-Container.Traces.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
Traces ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new PathHistory(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

Traces Traces::operator+(const Traces& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @ITS-Container.Traces concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
Traces ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PathHistory(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new PathHistory(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

Traces Traces::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @ITS-Container.Traces.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@ITS-Container.Traces","element");
Traces ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new PathHistory(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

Traces Traces::replace(int index, int len, const Traces& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @ITS-Container.Traces.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @ITS-Container.Traces.");
check_replace_arguments(val_ptr->n_elements, index, len, "@ITS-Container.Traces","element");
Traces ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PathHistory(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new PathHistory(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new PathHistory(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

Traces Traces::replace(int index, int len, const Traces_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void Traces::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @ITS-Container.Traces.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (PathHistory**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PathHistory(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (PathHistory**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @ITS-Container.Traces: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (PathHistory**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean Traces::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int Traces::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @ITS-Container.Traces.");
return val_ptr->n_elements;
}

int Traces::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @ITS-Container.Traces.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void Traces::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void Traces::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@ITS-Container.Traces'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@ITS-Container.Traces");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@ITS-Container.Traces");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* Traces::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@ITS-Container.Traces'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void Traces::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void Traces::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @ITS-Container.Traces.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void Traces::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @ITS-Container.Traces.");
val_ptr->value_elements = (PathHistory**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new PathHistory;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void Traces::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Traces::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* Traces::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean Traces::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (PathHistory**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new PathHistory;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int Traces::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.Traces.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int Traces::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    PathHistory* val = new PathHistory;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (PathHistory**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void Traces_template::copy_value(const Traces& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @ITS-Container.Traces with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (PathHistory_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new PathHistory_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new PathHistory_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void Traces_template::copy_template(const Traces_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (PathHistory_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new PathHistory_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new PathHistory_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Traces_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.Traces.");
break;
}
set_selection(other_value);
}

boolean Traces_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const Traces_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const Traces*)value_ptr)[value_index], legacy);
else return ((const Traces_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

Traces_template::Traces_template()
{
}

Traces_template::Traces_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

Traces_template::Traces_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

Traces_template::Traces_template(const Traces& other_value)
{
copy_value(other_value);
}

Traces_template::Traces_template(const OPTIONAL<Traces>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Traces&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.Traces from an unbound optional field.");
}
}

Traces_template::Traces_template(const Traces_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

Traces_template::~Traces_template()
{
clean_up();
}

void Traces_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Traces_template& Traces_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Traces_template& Traces_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

Traces_template& Traces_template::operator=(const Traces& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Traces_template& Traces_template::operator=(const OPTIONAL<Traces>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Traces&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.Traces.");
}
return *this;
}

Traces_template& Traces_template::operator=(const Traces_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

PathHistory_template& Traces_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.Traces using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.Traces.");
    break;
}
return *single_value.value_elements[index_value];
}

PathHistory_template& Traces_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.Traces.");
return (*this)[(int)index_value];
}

const PathHistory_template& Traces_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.Traces using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.Traces.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @ITS-Container.Traces: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const PathHistory_template& Traces_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.Traces.");
return (*this)[(int)index_value];
}

void Traces_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @ITS-Container.Traces.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (PathHistory_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PathHistory_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PathHistory_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (PathHistory_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int Traces_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int Traces_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @ITS-Container.Traces which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.Traces containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.Traces containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @ITS-Container.Traces containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.Traces containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.Traces containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @ITS-Container.Traces.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @ITS-Container.Traces");
}

boolean Traces_template::match(const Traces& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @ITS-Container.Traces.");
}
return FALSE;
}

boolean Traces_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

Traces Traces_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @ITS-Container.Traces.");
Traces ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

Traces Traces_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

Traces Traces_template::replace(int index, int len, const Traces_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

Traces Traces_template::replace(int index, int len, const Traces& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void Traces_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new Traces_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @ITS-Container.Traces.");
}
set_selection(template_type);
}

Traces_template& Traces_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @ITS-Container.Traces.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @ITS-Container.Traces.");
return value_list.list_value[list_index];
}

void Traces_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void Traces_template::log_match(const Traces& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Traces_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.Traces.");
}
}

void Traces_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @ITS-Container.Traces.");
single_value.value_elements = (PathHistory_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new PathHistory_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Traces_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @ITS-Container.Traces.");
}
}

boolean Traces_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Traces_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void Traces_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@ITS-Container.Traces'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Traces_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@ITS-Container.Traces");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* Traces_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@ITS-Container.Traces'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void Traces_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@ITS-Container.Traces");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.Traces");
}


const EventPoint EventHistory::UNBOUND_ELEM;
EventHistory::EventHistory()
{
val_ptr = NULL;
}

EventHistory::EventHistory(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

EventHistory::EventHistory(const EventHistory& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.EventHistory.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

EventHistory::~EventHistory()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void EventHistory::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

EventHistory& EventHistory::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

EventHistory& EventHistory::operator=(const EventHistory& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @ITS-Container.EventHistory.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean EventHistory::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.EventHistory.");
return val_ptr->n_elements == 0 ;
}

boolean EventHistory::operator==(const EventHistory& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.EventHistory.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.EventHistory.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

EventPoint& EventHistory::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.EventHistory using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (EventPoint**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new EventPoint(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new EventPoint;
}
return *val_ptr->value_elements[index_value];
}

EventPoint& EventHistory::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.EventHistory.");
return (*this)[(int)index_value];
}

const EventPoint& EventHistory::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @ITS-Container.EventHistory.");
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.EventHistory using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @ITS-Container.EventHistory: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const EventPoint& EventHistory::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.EventHistory.");
return (*this)[(int)index_value];
}

EventHistory EventHistory::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

EventHistory EventHistory::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

EventHistory EventHistory::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

EventHistory EventHistory::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @ITS-Container.EventHistory.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
EventHistory ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new EventPoint(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

EventHistory EventHistory::operator+(const EventHistory& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @ITS-Container.EventHistory concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
EventHistory ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new EventPoint(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new EventPoint(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

EventHistory EventHistory::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @ITS-Container.EventHistory.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@ITS-Container.EventHistory","element");
EventHistory ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new EventPoint(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

EventHistory EventHistory::replace(int index, int len, const EventHistory& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @ITS-Container.EventHistory.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @ITS-Container.EventHistory.");
check_replace_arguments(val_ptr->n_elements, index, len, "@ITS-Container.EventHistory","element");
EventHistory ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new EventPoint(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new EventPoint(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new EventPoint(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

EventHistory EventHistory::replace(int index, int len, const EventHistory_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void EventHistory::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @ITS-Container.EventHistory.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (EventPoint**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new EventPoint(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (EventPoint**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @ITS-Container.EventHistory: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (EventPoint**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean EventHistory::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int EventHistory::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @ITS-Container.EventHistory.");
return val_ptr->n_elements;
}

int EventHistory::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @ITS-Container.EventHistory.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void EventHistory::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void EventHistory::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@ITS-Container.EventHistory'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@ITS-Container.EventHistory");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@ITS-Container.EventHistory");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* EventHistory::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@ITS-Container.EventHistory'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void EventHistory::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void EventHistory::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @ITS-Container.EventHistory.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void EventHistory::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @ITS-Container.EventHistory.");
val_ptr->value_elements = (EventPoint**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new EventPoint;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void EventHistory::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EventHistory::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* EventHistory::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean EventHistory::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (EventPoint**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new EventPoint;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int EventHistory::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.EventHistory.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int EventHistory::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    EventPoint* val = new EventPoint;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (EventPoint**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void EventHistory_template::copy_value(const EventHistory& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @ITS-Container.EventHistory with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (EventPoint_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new EventPoint_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new EventPoint_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void EventHistory_template::copy_template(const EventHistory_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (EventPoint_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new EventPoint_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new EventPoint_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EventHistory_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.EventHistory.");
break;
}
set_selection(other_value);
}

boolean EventHistory_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const EventHistory_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const EventHistory*)value_ptr)[value_index], legacy);
else return ((const EventHistory_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

EventHistory_template::EventHistory_template()
{
}

EventHistory_template::EventHistory_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

EventHistory_template::EventHistory_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

EventHistory_template::EventHistory_template(const EventHistory& other_value)
{
copy_value(other_value);
}

EventHistory_template::EventHistory_template(const OPTIONAL<EventHistory>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EventHistory&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.EventHistory from an unbound optional field.");
}
}

EventHistory_template::EventHistory_template(const EventHistory_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

EventHistory_template::~EventHistory_template()
{
clean_up();
}

void EventHistory_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

EventHistory_template& EventHistory_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EventHistory_template& EventHistory_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

EventHistory_template& EventHistory_template::operator=(const EventHistory& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

EventHistory_template& EventHistory_template::operator=(const OPTIONAL<EventHistory>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EventHistory&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.EventHistory.");
}
return *this;
}

EventHistory_template& EventHistory_template::operator=(const EventHistory_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

EventPoint_template& EventHistory_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.EventHistory using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.EventHistory.");
    break;
}
return *single_value.value_elements[index_value];
}

EventPoint_template& EventHistory_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.EventHistory.");
return (*this)[(int)index_value];
}

const EventPoint_template& EventHistory_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.EventHistory using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.EventHistory.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @ITS-Container.EventHistory: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const EventPoint_template& EventHistory_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.EventHistory.");
return (*this)[(int)index_value];
}

void EventHistory_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @ITS-Container.EventHistory.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (EventPoint_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new EventPoint_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new EventPoint_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (EventPoint_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int EventHistory_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int EventHistory_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @ITS-Container.EventHistory which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.EventHistory containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.EventHistory containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @ITS-Container.EventHistory containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.EventHistory containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.EventHistory containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @ITS-Container.EventHistory.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @ITS-Container.EventHistory");
}

boolean EventHistory_template::match(const EventHistory& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @ITS-Container.EventHistory.");
}
return FALSE;
}

boolean EventHistory_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

EventHistory EventHistory_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @ITS-Container.EventHistory.");
EventHistory ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

EventHistory EventHistory_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

EventHistory EventHistory_template::replace(int index, int len, const EventHistory_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

EventHistory EventHistory_template::replace(int index, int len, const EventHistory& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void EventHistory_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new EventHistory_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @ITS-Container.EventHistory.");
}
set_selection(template_type);
}

EventHistory_template& EventHistory_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @ITS-Container.EventHistory.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @ITS-Container.EventHistory.");
return value_list.list_value[list_index];
}

void EventHistory_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void EventHistory_template::log_match(const EventHistory& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void EventHistory_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.EventHistory.");
}
}

void EventHistory_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @ITS-Container.EventHistory.");
single_value.value_elements = (EventPoint_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new EventPoint_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EventHistory_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @ITS-Container.EventHistory.");
}
}

boolean EventHistory_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EventHistory_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void EventHistory_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@ITS-Container.EventHistory'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EventHistory_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@ITS-Container.EventHistory");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* EventHistory_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@ITS-Container.EventHistory'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void EventHistory_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@ITS-Container.EventHistory");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.EventHistory");
}

EventPoint::EventPoint()
{
  bound_flag = FALSE;
}

EventPoint::EventPoint(const DeltaReferencePosition& par_eventPosition,
    const OPTIONAL<INTEGER>& par_eventDeltaTime,
    const INTEGER& par_informationQuality)
  :   field_eventPosition(par_eventPosition),
  field_eventDeltaTime(par_eventDeltaTime),
  field_informationQuality(par_informationQuality)
{
  bound_flag = TRUE;
}

EventPoint::EventPoint(const EventPoint& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.EventPoint.");
bound_flag = TRUE;
if (other_value.eventPosition().is_bound()) field_eventPosition = other_value.eventPosition();
else field_eventPosition.clean_up();
if (other_value.eventDeltaTime().is_bound()) field_eventDeltaTime = other_value.eventDeltaTime();
else field_eventDeltaTime.clean_up();
if (other_value.informationQuality().is_bound()) field_informationQuality = other_value.informationQuality();
else field_informationQuality.clean_up();
}

void EventPoint::clean_up()
{
field_eventPosition.clean_up();
field_eventDeltaTime.clean_up();
field_informationQuality.clean_up();
bound_flag = FALSE;
}

EventPoint& EventPoint::operator=(const EventPoint& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.EventPoint.");
  bound_flag = TRUE;
  if (other_value.eventPosition().is_bound()) field_eventPosition = other_value.eventPosition();
  else field_eventPosition.clean_up();
  if (other_value.eventDeltaTime().is_bound()) field_eventDeltaTime = other_value.eventDeltaTime();
  else field_eventDeltaTime.clean_up();
  if (other_value.informationQuality().is_bound()) field_informationQuality = other_value.informationQuality();
  else field_informationQuality.clean_up();
}
return *this;
}

boolean EventPoint::operator==(const EventPoint& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_eventPosition==other_value.field_eventPosition
  && field_eventDeltaTime==other_value.field_eventDeltaTime
  && field_informationQuality==other_value.field_informationQuality;
}

boolean EventPoint::is_bound() const
{
if (bound_flag) return TRUE;
if(field_eventPosition.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_eventDeltaTime.get_selection() || field_eventDeltaTime.is_bound()) return TRUE;
if(field_informationQuality.is_bound()) return TRUE;
return FALSE;
}
boolean EventPoint::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_eventPosition.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_eventDeltaTime.get_selection() && !field_eventDeltaTime.is_value()) return FALSE;
if(!field_informationQuality.is_value()) return FALSE;
return TRUE;
}
int EventPoint::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.EventPoint");
  int ret_val = 2;
  if (field_eventDeltaTime.ispresent()) ret_val++;
  return ret_val;
}

void EventPoint::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ eventPosition := ");
field_eventPosition.log();
TTCN_Logger::log_event_str(", eventDeltaTime := ");
field_eventDeltaTime.log();
TTCN_Logger::log_event_str(", informationQuality := ");
field_informationQuality.log();
TTCN_Logger::log_event_str(" }");
}

void EventPoint::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.EventPoint'");
    }
    if (strcmp("eventPosition", param_field) == 0) {
      eventPosition().set_param(param);
      return;
    } else if (strcmp("eventDeltaTime", param_field) == 0) {
      eventDeltaTime().set_param(param);
      return;
    } else if (strcmp("informationQuality", param_field) == 0) {
      informationQuality().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.EventPoint'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @ITS-Container.EventPoint has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) eventPosition().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) eventDeltaTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) informationQuality().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventPosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventPosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventDeltaTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventDeltaTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "informationQuality")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          informationQuality().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.EventPoint: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.EventPoint");
  }
}

Module_Param* EventPoint::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.EventPoint'");
    }
    if (strcmp("eventPosition", param_field) == 0) {
      return eventPosition().get_param(param_name);
    } else if (strcmp("eventDeltaTime", param_field) == 0) {
      return eventDeltaTime().get_param(param_name);
    } else if (strcmp("informationQuality", param_field) == 0) {
      return informationQuality().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.EventPoint'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_eventPosition = field_eventPosition.get_param(param_name);
  mp_field_eventPosition->set_id(new Module_Param_FieldName(mcopystr("eventPosition")));
  mp->add_elem(mp_field_eventPosition);
  Module_Param* mp_field_eventDeltaTime = field_eventDeltaTime.get_param(param_name);
  mp_field_eventDeltaTime->set_id(new Module_Param_FieldName(mcopystr("eventDeltaTime")));
  mp->add_elem(mp_field_eventDeltaTime);
  Module_Param* mp_field_informationQuality = field_informationQuality.get_param(param_name);
  mp_field_informationQuality->set_id(new Module_Param_FieldName(mcopystr("informationQuality")));
  mp->add_elem(mp_field_informationQuality);
  return mp;
  }

void EventPoint::set_implicit_omit()
{
if (eventPosition().is_bound()) eventPosition().set_implicit_omit();
if (!eventDeltaTime().is_bound()) eventDeltaTime() = OMIT_VALUE;
else eventDeltaTime().set_implicit_omit();
if (informationQuality().is_bound()) informationQuality().set_implicit_omit();
}

void EventPoint::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.EventPoint.");
field_eventPosition.encode_text(text_buf);
field_eventDeltaTime.encode_text(text_buf);
field_informationQuality.encode_text(text_buf);
}

void EventPoint::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_eventPosition.decode_text(text_buf);
field_eventDeltaTime.decode_text(text_buf);
field_informationQuality.decode_text(text_buf);
}

void EventPoint::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EventPoint::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* EventPoint::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("eventPosition': ");
  new_tlv->add_TLV(field_eventPosition.BER_encode_TLV(EventPoint_eventPosition_descr_, p_coding));
  ec_1.set_msg("eventDeltaTime': ");
  new_tlv->add_TLV(field_eventDeltaTime.BER_encode_TLV(EventPoint_eventDeltaTime_descr_, p_coding));
  ec_1.set_msg("informationQuality': ");
  new_tlv->add_TLV(field_informationQuality.BER_encode_TLV(EventPoint_informationQuality_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean EventPoint::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.EventPoint' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("eventPosition': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_eventPosition.BER_decode_TLV(EventPoint_eventPosition_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("eventDeltaTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_eventDeltaTime=OMIT_VALUE;
    else {
      field_eventDeltaTime.BER_decode_TLV(EventPoint_eventDeltaTime_descr_, tmp_tlv, L_form);
      if(field_eventDeltaTime.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("informationQuality': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_informationQuality.BER_decode_TLV(EventPoint_informationQuality_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int EventPoint::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.EventPoint.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eventPosition");
    enc_len += field_eventPosition.JSON_encode(EventPoint_eventPosition_descr_, p_tok);
  }

  if (field_eventDeltaTime.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eventDeltaTime");
    enc_len += field_eventDeltaTime.JSON_encode(EventPoint_eventDeltaTime_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "informationQuality");
    enc_len += field_informationQuality.JSON_encode(EventPoint_informationQuality_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int EventPoint::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (13 == name_len && 0 == strncmp(fld_name, "eventPosition", name_len)) {
         int ret_val = field_eventPosition.JSON_decode(EventPoint_eventPosition_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eventPosition");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "eventDeltaTime", name_len)) {
         int ret_val = field_eventDeltaTime.JSON_decode(EventPoint_eventDeltaTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eventDeltaTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "informationQuality", name_len)) {
         int ret_val = field_informationQuality.JSON_decode(EventPoint_informationQuality_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "informationQuality");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_eventPosition.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "eventPosition");
    return JSON_ERROR_FATAL;
  }
if (!field_eventDeltaTime.is_bound()) {
    field_eventDeltaTime = OMIT_VALUE;
  }
if (!field_informationQuality.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "informationQuality");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct EventPoint_template::single_value_struct {
DeltaReferencePosition_template field_eventPosition;
INTEGER_template field_eventDeltaTime;
INTEGER_template field_informationQuality;
};

void EventPoint_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_eventPosition = ANY_VALUE;
single_value->field_eventDeltaTime = ANY_OR_OMIT;
single_value->field_informationQuality = ANY_VALUE;
}
}
}

void EventPoint_template::copy_value(const EventPoint& other_value)
{
single_value = new single_value_struct;
if (other_value.eventPosition().is_bound()) {
  single_value->field_eventPosition = other_value.eventPosition();
} else {
  single_value->field_eventPosition.clean_up();
}
if (other_value.eventDeltaTime().is_bound()) {
  if (other_value.eventDeltaTime().ispresent()) single_value->field_eventDeltaTime = other_value.eventDeltaTime()();
  else single_value->field_eventDeltaTime = OMIT_VALUE;
} else {
  single_value->field_eventDeltaTime.clean_up();
}
if (other_value.informationQuality().is_bound()) {
  single_value->field_informationQuality = other_value.informationQuality();
} else {
  single_value->field_informationQuality.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void EventPoint_template::copy_template(const EventPoint_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.eventPosition().get_selection()) {
single_value->field_eventPosition = other_value.eventPosition();
} else {
single_value->field_eventPosition.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.eventDeltaTime().get_selection()) {
single_value->field_eventDeltaTime = other_value.eventDeltaTime();
} else {
single_value->field_eventDeltaTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.informationQuality().get_selection()) {
single_value->field_informationQuality = other_value.informationQuality();
} else {
single_value->field_informationQuality.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EventPoint_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.EventPoint.");
break;
}
set_selection(other_value);
}

EventPoint_template::EventPoint_template()
{
}

EventPoint_template::EventPoint_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

EventPoint_template::EventPoint_template(const EventPoint& other_value)
{
copy_value(other_value);
}

EventPoint_template::EventPoint_template(const OPTIONAL<EventPoint>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EventPoint&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.EventPoint from an unbound optional field.");
}
}

EventPoint_template::EventPoint_template(const EventPoint_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

EventPoint_template::~EventPoint_template()
{
clean_up();
}

EventPoint_template& EventPoint_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EventPoint_template& EventPoint_template::operator=(const EventPoint& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

EventPoint_template& EventPoint_template::operator=(const OPTIONAL<EventPoint>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EventPoint&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.EventPoint.");
}
return *this;
}

EventPoint_template& EventPoint_template::operator=(const EventPoint_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean EventPoint_template::match(const EventPoint& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.eventPosition().is_bound()) return FALSE;
if(!single_value->field_eventPosition.match(other_value.eventPosition(), legacy))return FALSE;
if(!other_value.eventDeltaTime().is_bound()) return FALSE;
if((other_value.eventDeltaTime().ispresent() ? !single_value->field_eventDeltaTime.match((const INTEGER&)other_value.eventDeltaTime(), legacy) : !single_value->field_eventDeltaTime.match_omit(legacy)))return FALSE;
if(!other_value.informationQuality().is_bound()) return FALSE;
if(!single_value->field_informationQuality.match(other_value.informationQuality(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.EventPoint.");
}
return FALSE;
}

boolean EventPoint_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_eventPosition.is_bound()) return TRUE;
if (single_value->field_eventDeltaTime.is_omit() || single_value->field_eventDeltaTime.is_bound()) return TRUE;
if (single_value->field_informationQuality.is_bound()) return TRUE;
return FALSE;
}

boolean EventPoint_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_eventPosition.is_value()) return FALSE;
if (!single_value->field_eventDeltaTime.is_omit() && !single_value->field_eventDeltaTime.is_value()) return FALSE;
if (!single_value->field_informationQuality.is_value()) return FALSE;
return TRUE;
}

void EventPoint_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

EventPoint EventPoint_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.EventPoint.");
EventPoint ret_val;
if (single_value->field_eventPosition.is_bound()) {
ret_val.eventPosition() = single_value->field_eventPosition.valueof();
}
if (single_value->field_eventDeltaTime.is_omit()) ret_val.eventDeltaTime() = OMIT_VALUE;
else if (single_value->field_eventDeltaTime.is_bound()) {
ret_val.eventDeltaTime() = single_value->field_eventDeltaTime.valueof();
}
if (single_value->field_informationQuality.is_bound()) {
ret_val.informationQuality() = single_value->field_informationQuality.valueof();
}
return ret_val;
}

void EventPoint_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.EventPoint.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new EventPoint_template[list_length];
}

EventPoint_template& EventPoint_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.EventPoint.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.EventPoint.");
return value_list.list_value[list_index];
}

DeltaReferencePosition_template& EventPoint_template::eventPosition()
{
set_specific();
return single_value->field_eventPosition;
}

const DeltaReferencePosition_template& EventPoint_template::eventPosition() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field eventPosition of a non-specific template of type @ITS-Container.EventPoint.");
return single_value->field_eventPosition;
}

INTEGER_template& EventPoint_template::eventDeltaTime()
{
set_specific();
return single_value->field_eventDeltaTime;
}

const INTEGER_template& EventPoint_template::eventDeltaTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field eventDeltaTime of a non-specific template of type @ITS-Container.EventPoint.");
return single_value->field_eventDeltaTime;
}

INTEGER_template& EventPoint_template::informationQuality()
{
set_specific();
return single_value->field_informationQuality;
}

const INTEGER_template& EventPoint_template::informationQuality() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field informationQuality of a non-specific template of type @ITS-Container.EventPoint.");
return single_value->field_informationQuality;
}

int EventPoint_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.EventPoint which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_eventDeltaTime.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.EventPoint containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.EventPoint containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.EventPoint containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.EventPoint containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.EventPoint containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.EventPoint.");
  }
  return 0;
}

void EventPoint_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ eventPosition := ");
single_value->field_eventPosition.log();
TTCN_Logger::log_event_str(", eventDeltaTime := ");
single_value->field_eventDeltaTime.log();
TTCN_Logger::log_event_str(", informationQuality := ");
single_value->field_informationQuality.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void EventPoint_template::log_match(const EventPoint& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_eventPosition.match(match_value.eventPosition(), legacy)){
TTCN_Logger::log_logmatch_info(".eventPosition");
single_value->field_eventPosition.log_match(match_value.eventPosition(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.eventDeltaTime().ispresent()){
if(!single_value->field_eventDeltaTime.match(match_value.eventDeltaTime(), legacy)){
TTCN_Logger::log_logmatch_info(".eventDeltaTime");
single_value->field_eventDeltaTime.log_match(match_value.eventDeltaTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_eventDeltaTime.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".eventDeltaTime := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_eventDeltaTime.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_informationQuality.match(match_value.informationQuality(), legacy)){
TTCN_Logger::log_logmatch_info(".informationQuality");
single_value->field_informationQuality.log_match(match_value.informationQuality(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ eventPosition := ");
single_value->field_eventPosition.log_match(match_value.eventPosition(), legacy);
TTCN_Logger::log_event_str(", eventDeltaTime := ");
if (match_value.eventDeltaTime().ispresent()) single_value->field_eventDeltaTime.log_match(match_value.eventDeltaTime(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_eventDeltaTime.log();
if (single_value->field_eventDeltaTime.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", informationQuality := ");
single_value->field_informationQuality.log_match(match_value.informationQuality(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void EventPoint_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_eventPosition.encode_text(text_buf);
single_value->field_eventDeltaTime.encode_text(text_buf);
single_value->field_informationQuality.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.EventPoint.");
}
}

void EventPoint_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_eventPosition.decode_text(text_buf);
single_value->field_eventDeltaTime.decode_text(text_buf);
single_value->field_informationQuality.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EventPoint_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.EventPoint.");
}
}

void EventPoint_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.EventPoint'");
    }
    if (strcmp("eventPosition", param_field) == 0) {
      eventPosition().set_param(param);
      return;
    } else if (strcmp("eventDeltaTime", param_field) == 0) {
      eventDeltaTime().set_param(param);
      return;
    } else if (strcmp("informationQuality", param_field) == 0) {
      informationQuality().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.EventPoint'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EventPoint_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @ITS-Container.EventPoint has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) eventPosition().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) eventDeltaTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) informationQuality().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventPosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventPosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventDeltaTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventDeltaTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "informationQuality")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          informationQuality().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.EventPoint: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.EventPoint");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* EventPoint_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.EventPoint'");
    }
    if (strcmp("eventPosition", param_field) == 0) {
      return eventPosition().get_param(param_name);
    } else if (strcmp("eventDeltaTime", param_field) == 0) {
      return eventDeltaTime().get_param(param_name);
    } else if (strcmp("informationQuality", param_field) == 0) {
      return informationQuality().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.EventPoint'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_eventPosition = single_value->field_eventPosition.get_param(param_name);
    mp_field_eventPosition->set_id(new Module_Param_FieldName(mcopystr("eventPosition")));
    mp->add_elem(mp_field_eventPosition);
    Module_Param* mp_field_eventDeltaTime = single_value->field_eventDeltaTime.get_param(param_name);
    mp_field_eventDeltaTime->set_id(new Module_Param_FieldName(mcopystr("eventDeltaTime")));
    mp->add_elem(mp_field_eventDeltaTime);
    Module_Param* mp_field_informationQuality = single_value->field_informationQuality.get_param(param_name);
    mp_field_informationQuality->set_id(new Module_Param_FieldName(mcopystr("informationQuality")));
    mp->add_elem(mp_field_informationQuality);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void EventPoint_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_eventPosition.check_restriction(t_res, t_name ? t_name : "@ITS-Container.EventPoint");
single_value->field_eventDeltaTime.check_restriction(t_res, t_name ? t_name : "@ITS-Container.EventPoint");
single_value->field_informationQuality.check_restriction(t_res, t_name ? t_name : "@ITS-Container.EventPoint");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.EventPoint");
}

boolean EventPoint_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EventPoint_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const ProtectedCommunicationZone ProtectedCommunicationZonesRSU::UNBOUND_ELEM;
ProtectedCommunicationZonesRSU::ProtectedCommunicationZonesRSU()
{
val_ptr = NULL;
}

ProtectedCommunicationZonesRSU::ProtectedCommunicationZonesRSU(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

ProtectedCommunicationZonesRSU::ProtectedCommunicationZonesRSU(const ProtectedCommunicationZonesRSU& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

ProtectedCommunicationZonesRSU::~ProtectedCommunicationZonesRSU()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void ProtectedCommunicationZonesRSU::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

ProtectedCommunicationZonesRSU& ProtectedCommunicationZonesRSU::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

ProtectedCommunicationZonesRSU& ProtectedCommunicationZonesRSU::operator=(const ProtectedCommunicationZonesRSU& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean ProtectedCommunicationZonesRSU::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
return val_ptr->n_elements == 0 ;
}

boolean ProtectedCommunicationZonesRSU::operator==(const ProtectedCommunicationZonesRSU& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

ProtectedCommunicationZone& ProtectedCommunicationZonesRSU::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.ProtectedCommunicationZonesRSU using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (ProtectedCommunicationZone**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ProtectedCommunicationZone(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new ProtectedCommunicationZone;
}
return *val_ptr->value_elements[index_value];
}

ProtectedCommunicationZone& ProtectedCommunicationZonesRSU::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
return (*this)[(int)index_value];
}

const ProtectedCommunicationZone& ProtectedCommunicationZonesRSU::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
if (index_value < 0) TTCN_error("Accessing an element of type @ITS-Container.ProtectedCommunicationZonesRSU using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @ITS-Container.ProtectedCommunicationZonesRSU: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const ProtectedCommunicationZone& ProtectedCommunicationZonesRSU::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
return (*this)[(int)index_value];
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
ProtectedCommunicationZonesRSU ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new ProtectedCommunicationZone(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU::operator+(const ProtectedCommunicationZonesRSU& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @ITS-Container.ProtectedCommunicationZonesRSU concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
ProtectedCommunicationZonesRSU ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ProtectedCommunicationZone(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new ProtectedCommunicationZone(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@ITS-Container.ProtectedCommunicationZonesRSU","element");
ProtectedCommunicationZonesRSU ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new ProtectedCommunicationZone(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU::replace(int index, int len, const ProtectedCommunicationZonesRSU& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
check_replace_arguments(val_ptr->n_elements, index, len, "@ITS-Container.ProtectedCommunicationZonesRSU","element");
ProtectedCommunicationZonesRSU ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ProtectedCommunicationZone(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new ProtectedCommunicationZone(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new ProtectedCommunicationZone(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU::replace(int index, int len, const ProtectedCommunicationZonesRSU_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void ProtectedCommunicationZonesRSU::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (ProtectedCommunicationZone**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ProtectedCommunicationZone(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (ProtectedCommunicationZone**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @ITS-Container.ProtectedCommunicationZonesRSU: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (ProtectedCommunicationZone**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean ProtectedCommunicationZonesRSU::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int ProtectedCommunicationZonesRSU::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
return val_ptr->n_elements;
}

int ProtectedCommunicationZonesRSU::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void ProtectedCommunicationZonesRSU::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void ProtectedCommunicationZonesRSU::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@ITS-Container.ProtectedCommunicationZonesRSU'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@ITS-Container.ProtectedCommunicationZonesRSU");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@ITS-Container.ProtectedCommunicationZonesRSU");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* ProtectedCommunicationZonesRSU::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@ITS-Container.ProtectedCommunicationZonesRSU'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void ProtectedCommunicationZonesRSU::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void ProtectedCommunicationZonesRSU::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void ProtectedCommunicationZonesRSU::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
val_ptr->value_elements = (ProtectedCommunicationZone**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new ProtectedCommunicationZone;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void ProtectedCommunicationZonesRSU::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ProtectedCommunicationZonesRSU::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ProtectedCommunicationZonesRSU::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ProtectedCommunicationZonesRSU::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (ProtectedCommunicationZone**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new ProtectedCommunicationZone;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int ProtectedCommunicationZonesRSU::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int ProtectedCommunicationZonesRSU::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    ProtectedCommunicationZone* val = new ProtectedCommunicationZone;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (ProtectedCommunicationZone**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ProtectedCommunicationZonesRSU_template::copy_value(const ProtectedCommunicationZonesRSU& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @ITS-Container.ProtectedCommunicationZonesRSU with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (ProtectedCommunicationZone_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new ProtectedCommunicationZone_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new ProtectedCommunicationZone_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void ProtectedCommunicationZonesRSU_template::copy_template(const ProtectedCommunicationZonesRSU_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (ProtectedCommunicationZone_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new ProtectedCommunicationZone_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new ProtectedCommunicationZone_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ProtectedCommunicationZonesRSU_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
break;
}
set_selection(other_value);
}

boolean ProtectedCommunicationZonesRSU_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ProtectedCommunicationZonesRSU_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const ProtectedCommunicationZonesRSU*)value_ptr)[value_index], legacy);
else return ((const ProtectedCommunicationZonesRSU_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

ProtectedCommunicationZonesRSU_template::ProtectedCommunicationZonesRSU_template()
{
}

ProtectedCommunicationZonesRSU_template::ProtectedCommunicationZonesRSU_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

ProtectedCommunicationZonesRSU_template::ProtectedCommunicationZonesRSU_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

ProtectedCommunicationZonesRSU_template::ProtectedCommunicationZonesRSU_template(const ProtectedCommunicationZonesRSU& other_value)
{
copy_value(other_value);
}

ProtectedCommunicationZonesRSU_template::ProtectedCommunicationZonesRSU_template(const OPTIONAL<ProtectedCommunicationZonesRSU>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ProtectedCommunicationZonesRSU&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.ProtectedCommunicationZonesRSU from an unbound optional field.");
}
}

ProtectedCommunicationZonesRSU_template::ProtectedCommunicationZonesRSU_template(const ProtectedCommunicationZonesRSU_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

ProtectedCommunicationZonesRSU_template::~ProtectedCommunicationZonesRSU_template()
{
clean_up();
}

void ProtectedCommunicationZonesRSU_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ProtectedCommunicationZonesRSU_template& ProtectedCommunicationZonesRSU_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ProtectedCommunicationZonesRSU_template& ProtectedCommunicationZonesRSU_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

ProtectedCommunicationZonesRSU_template& ProtectedCommunicationZonesRSU_template::operator=(const ProtectedCommunicationZonesRSU& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ProtectedCommunicationZonesRSU_template& ProtectedCommunicationZonesRSU_template::operator=(const OPTIONAL<ProtectedCommunicationZonesRSU>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ProtectedCommunicationZonesRSU&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
}
return *this;
}

ProtectedCommunicationZonesRSU_template& ProtectedCommunicationZonesRSU_template::operator=(const ProtectedCommunicationZonesRSU_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

ProtectedCommunicationZone_template& ProtectedCommunicationZonesRSU_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.ProtectedCommunicationZonesRSU using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.ProtectedCommunicationZonesRSU.");
    break;
}
return *single_value.value_elements[index_value];
}

ProtectedCommunicationZone_template& ProtectedCommunicationZonesRSU_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
return (*this)[(int)index_value];
}

const ProtectedCommunicationZone_template& ProtectedCommunicationZonesRSU_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @ITS-Container.ProtectedCommunicationZonesRSU using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @ITS-Container.ProtectedCommunicationZonesRSU.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @ITS-Container.ProtectedCommunicationZonesRSU: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const ProtectedCommunicationZone_template& ProtectedCommunicationZonesRSU_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
return (*this)[(int)index_value];
}

void ProtectedCommunicationZonesRSU_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (ProtectedCommunicationZone_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ProtectedCommunicationZone_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ProtectedCommunicationZone_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (ProtectedCommunicationZone_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int ProtectedCommunicationZonesRSU_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int ProtectedCommunicationZonesRSU_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ProtectedCommunicationZonesRSU which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ProtectedCommunicationZonesRSU containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ProtectedCommunicationZonesRSU containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ProtectedCommunicationZonesRSU containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ProtectedCommunicationZonesRSU containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @ITS-Container.ProtectedCommunicationZonesRSU containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @ITS-Container.ProtectedCommunicationZonesRSU.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @ITS-Container.ProtectedCommunicationZonesRSU");
}

boolean ProtectedCommunicationZonesRSU_template::match(const ProtectedCommunicationZonesRSU& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
}
return FALSE;
}

boolean ProtectedCommunicationZonesRSU_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
ProtectedCommunicationZonesRSU ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU_template::replace(int index, int len, const ProtectedCommunicationZonesRSU_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

ProtectedCommunicationZonesRSU ProtectedCommunicationZonesRSU_template::replace(int index, int len, const ProtectedCommunicationZonesRSU& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void ProtectedCommunicationZonesRSU_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new ProtectedCommunicationZonesRSU_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
}
set_selection(template_type);
}

ProtectedCommunicationZonesRSU_template& ProtectedCommunicationZonesRSU_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
return value_list.list_value[list_index];
}

void ProtectedCommunicationZonesRSU_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void ProtectedCommunicationZonesRSU_template::log_match(const ProtectedCommunicationZonesRSU& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ProtectedCommunicationZonesRSU_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
}
}

void ProtectedCommunicationZonesRSU_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
single_value.value_elements = (ProtectedCommunicationZone_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new ProtectedCommunicationZone_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ProtectedCommunicationZonesRSU_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @ITS-Container.ProtectedCommunicationZonesRSU.");
}
}

boolean ProtectedCommunicationZonesRSU_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ProtectedCommunicationZonesRSU_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ProtectedCommunicationZonesRSU_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@ITS-Container.ProtectedCommunicationZonesRSU'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ProtectedCommunicationZonesRSU_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@ITS-Container.ProtectedCommunicationZonesRSU");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* ProtectedCommunicationZonesRSU_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@ITS-Container.ProtectedCommunicationZonesRSU'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void ProtectedCommunicationZonesRSU_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@ITS-Container.ProtectedCommunicationZonesRSU");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.ProtectedCommunicationZonesRSU");
}

CenDsrcTollingZone::CenDsrcTollingZone()
{
  bound_flag = FALSE;
}

CenDsrcTollingZone::CenDsrcTollingZone(const INTEGER& par_protectedZoneLatitude,
    const INTEGER& par_protectedZoneLongitude,
    const OPTIONAL<INTEGER>& par_cenDsrcTollingZoneID)
  :   field_protectedZoneLatitude(par_protectedZoneLatitude),
  field_protectedZoneLongitude(par_protectedZoneLongitude),
  field_cenDsrcTollingZoneID(par_cenDsrcTollingZoneID)
{
  bound_flag = TRUE;
}

CenDsrcTollingZone::CenDsrcTollingZone(const CenDsrcTollingZone& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @ITS-Container.CenDsrcTollingZone.");
bound_flag = TRUE;
if (other_value.protectedZoneLatitude().is_bound()) field_protectedZoneLatitude = other_value.protectedZoneLatitude();
else field_protectedZoneLatitude.clean_up();
if (other_value.protectedZoneLongitude().is_bound()) field_protectedZoneLongitude = other_value.protectedZoneLongitude();
else field_protectedZoneLongitude.clean_up();
if (other_value.cenDsrcTollingZoneID().is_bound()) field_cenDsrcTollingZoneID = other_value.cenDsrcTollingZoneID();
else field_cenDsrcTollingZoneID.clean_up();
}

void CenDsrcTollingZone::clean_up()
{
field_protectedZoneLatitude.clean_up();
field_protectedZoneLongitude.clean_up();
field_cenDsrcTollingZoneID.clean_up();
bound_flag = FALSE;
}

CenDsrcTollingZone& CenDsrcTollingZone::operator=(const CenDsrcTollingZone& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @ITS-Container.CenDsrcTollingZone.");
  bound_flag = TRUE;
  if (other_value.protectedZoneLatitude().is_bound()) field_protectedZoneLatitude = other_value.protectedZoneLatitude();
  else field_protectedZoneLatitude.clean_up();
  if (other_value.protectedZoneLongitude().is_bound()) field_protectedZoneLongitude = other_value.protectedZoneLongitude();
  else field_protectedZoneLongitude.clean_up();
  if (other_value.cenDsrcTollingZoneID().is_bound()) field_cenDsrcTollingZoneID = other_value.cenDsrcTollingZoneID();
  else field_cenDsrcTollingZoneID.clean_up();
}
return *this;
}

boolean CenDsrcTollingZone::operator==(const CenDsrcTollingZone& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_protectedZoneLatitude==other_value.field_protectedZoneLatitude
  && field_protectedZoneLongitude==other_value.field_protectedZoneLongitude
  && field_cenDsrcTollingZoneID==other_value.field_cenDsrcTollingZoneID;
}

boolean CenDsrcTollingZone::is_bound() const
{
if (bound_flag) return TRUE;
if(field_protectedZoneLatitude.is_bound()) return TRUE;
if(field_protectedZoneLongitude.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_cenDsrcTollingZoneID.get_selection() || field_cenDsrcTollingZoneID.is_bound()) return TRUE;
return FALSE;
}
boolean CenDsrcTollingZone::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_protectedZoneLatitude.is_value()) return FALSE;
if(!field_protectedZoneLongitude.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_cenDsrcTollingZoneID.get_selection() && !field_cenDsrcTollingZoneID.is_value()) return FALSE;
return TRUE;
}
int CenDsrcTollingZone::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @ITS-Container.CenDsrcTollingZone");
  int ret_val = 2;
  if (field_cenDsrcTollingZoneID.ispresent()) ret_val++;
  return ret_val;
}

void CenDsrcTollingZone::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ protectedZoneLatitude := ");
field_protectedZoneLatitude.log();
TTCN_Logger::log_event_str(", protectedZoneLongitude := ");
field_protectedZoneLongitude.log();
TTCN_Logger::log_event_str(", cenDsrcTollingZoneID := ");
field_cenDsrcTollingZoneID.log();
TTCN_Logger::log_event_str(" }");
}

void CenDsrcTollingZone::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@ITS-Container.CenDsrcTollingZone'");
    }
    if (strcmp("protectedZoneLatitude", param_field) == 0) {
      protectedZoneLatitude().set_param(param);
      return;
    } else if (strcmp("protectedZoneLongitude", param_field) == 0) {
      protectedZoneLongitude().set_param(param);
      return;
    } else if (strcmp("cenDsrcTollingZoneID", param_field) == 0) {
      cenDsrcTollingZoneID().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@ITS-Container.CenDsrcTollingZone'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @ITS-Container.CenDsrcTollingZone has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protectedZoneLatitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) protectedZoneLongitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) cenDsrcTollingZoneID().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cenDsrcTollingZoneID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cenDsrcTollingZoneID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.CenDsrcTollingZone: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@ITS-Container.CenDsrcTollingZone");
  }
}

Module_Param* CenDsrcTollingZone::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@ITS-Container.CenDsrcTollingZone'");
    }
    if (strcmp("protectedZoneLatitude", param_field) == 0) {
      return protectedZoneLatitude().get_param(param_name);
    } else if (strcmp("protectedZoneLongitude", param_field) == 0) {
      return protectedZoneLongitude().get_param(param_name);
    } else if (strcmp("cenDsrcTollingZoneID", param_field) == 0) {
      return cenDsrcTollingZoneID().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.CenDsrcTollingZone'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_protectedZoneLatitude = field_protectedZoneLatitude.get_param(param_name);
  mp_field_protectedZoneLatitude->set_id(new Module_Param_FieldName(mcopystr("protectedZoneLatitude")));
  mp->add_elem(mp_field_protectedZoneLatitude);
  Module_Param* mp_field_protectedZoneLongitude = field_protectedZoneLongitude.get_param(param_name);
  mp_field_protectedZoneLongitude->set_id(new Module_Param_FieldName(mcopystr("protectedZoneLongitude")));
  mp->add_elem(mp_field_protectedZoneLongitude);
  Module_Param* mp_field_cenDsrcTollingZoneID = field_cenDsrcTollingZoneID.get_param(param_name);
  mp_field_cenDsrcTollingZoneID->set_id(new Module_Param_FieldName(mcopystr("cenDsrcTollingZoneID")));
  mp->add_elem(mp_field_cenDsrcTollingZoneID);
  return mp;
  }

void CenDsrcTollingZone::set_implicit_omit()
{
if (protectedZoneLatitude().is_bound()) protectedZoneLatitude().set_implicit_omit();
if (protectedZoneLongitude().is_bound()) protectedZoneLongitude().set_implicit_omit();
if (!cenDsrcTollingZoneID().is_bound()) cenDsrcTollingZoneID() = OMIT_VALUE;
else cenDsrcTollingZoneID().set_implicit_omit();
}

void CenDsrcTollingZone::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @ITS-Container.CenDsrcTollingZone.");
field_protectedZoneLatitude.encode_text(text_buf);
field_protectedZoneLongitude.encode_text(text_buf);
field_cenDsrcTollingZoneID.encode_text(text_buf);
}

void CenDsrcTollingZone::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_protectedZoneLatitude.decode_text(text_buf);
field_protectedZoneLongitude.decode_text(text_buf);
field_cenDsrcTollingZoneID.decode_text(text_buf);
}

void CenDsrcTollingZone::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CenDsrcTollingZone::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* CenDsrcTollingZone::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("protectedZoneLatitude': ");
  new_tlv->add_TLV(field_protectedZoneLatitude.BER_encode_TLV(CenDsrcTollingZone_protectedZoneLatitude_descr_, p_coding));
  ec_1.set_msg("protectedZoneLongitude': ");
  new_tlv->add_TLV(field_protectedZoneLongitude.BER_encode_TLV(CenDsrcTollingZone_protectedZoneLongitude_descr_, p_coding));
  ec_1.set_msg("cenDsrcTollingZoneID': ");
  new_tlv->add_TLV(field_cenDsrcTollingZoneID.BER_encode_TLV(CenDsrcTollingZone_cenDsrcTollingZoneID_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean CenDsrcTollingZone::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@ITS-Container.CenDsrcTollingZone' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("protectedZoneLatitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_protectedZoneLatitude.BER_decode_TLV(CenDsrcTollingZone_protectedZoneLatitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("protectedZoneLongitude': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_protectedZoneLongitude.BER_decode_TLV(CenDsrcTollingZone_protectedZoneLongitude_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("cenDsrcTollingZoneID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_cenDsrcTollingZoneID=OMIT_VALUE;
    else {
      field_cenDsrcTollingZoneID.BER_decode_TLV(CenDsrcTollingZone_cenDsrcTollingZoneID_descr_, tmp_tlv, L_form);
      if(field_cenDsrcTollingZoneID.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int CenDsrcTollingZone::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @ITS-Container.CenDsrcTollingZone.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protectedZoneLatitude");
    enc_len += field_protectedZoneLatitude.JSON_encode(CenDsrcTollingZone_protectedZoneLatitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protectedZoneLongitude");
    enc_len += field_protectedZoneLongitude.JSON_encode(CenDsrcTollingZone_protectedZoneLongitude_descr_, p_tok);
  }

  if (field_cenDsrcTollingZoneID.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "cenDsrcTollingZoneID");
    enc_len += field_cenDsrcTollingZoneID.JSON_encode(CenDsrcTollingZone_cenDsrcTollingZoneID_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CenDsrcTollingZone::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (21 == name_len && 0 == strncmp(fld_name, "protectedZoneLatitude", name_len)) {
         int ret_val = field_protectedZoneLatitude.JSON_decode(CenDsrcTollingZone_protectedZoneLatitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protectedZoneLatitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (22 == name_len && 0 == strncmp(fld_name, "protectedZoneLongitude", name_len)) {
         int ret_val = field_protectedZoneLongitude.JSON_decode(CenDsrcTollingZone_protectedZoneLongitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protectedZoneLongitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "cenDsrcTollingZoneID", name_len)) {
         int ret_val = field_cenDsrcTollingZoneID.JSON_decode(CenDsrcTollingZone_cenDsrcTollingZoneID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "cenDsrcTollingZoneID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_protectedZoneLatitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protectedZoneLatitude");
    return JSON_ERROR_FATAL;
  }
if (!field_protectedZoneLongitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protectedZoneLongitude");
    return JSON_ERROR_FATAL;
  }
if (!field_cenDsrcTollingZoneID.is_bound()) {
    field_cenDsrcTollingZoneID = OMIT_VALUE;
  }

  return dec_len;
}

struct CenDsrcTollingZone_template::single_value_struct {
INTEGER_template field_protectedZoneLatitude;
INTEGER_template field_protectedZoneLongitude;
INTEGER_template field_cenDsrcTollingZoneID;
};

void CenDsrcTollingZone_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_protectedZoneLatitude = ANY_VALUE;
single_value->field_protectedZoneLongitude = ANY_VALUE;
single_value->field_cenDsrcTollingZoneID = ANY_OR_OMIT;
}
}
}

void CenDsrcTollingZone_template::copy_value(const CenDsrcTollingZone& other_value)
{
single_value = new single_value_struct;
if (other_value.protectedZoneLatitude().is_bound()) {
  single_value->field_protectedZoneLatitude = other_value.protectedZoneLatitude();
} else {
  single_value->field_protectedZoneLatitude.clean_up();
}
if (other_value.protectedZoneLongitude().is_bound()) {
  single_value->field_protectedZoneLongitude = other_value.protectedZoneLongitude();
} else {
  single_value->field_protectedZoneLongitude.clean_up();
}
if (other_value.cenDsrcTollingZoneID().is_bound()) {
  if (other_value.cenDsrcTollingZoneID().ispresent()) single_value->field_cenDsrcTollingZoneID = other_value.cenDsrcTollingZoneID()();
  else single_value->field_cenDsrcTollingZoneID = OMIT_VALUE;
} else {
  single_value->field_cenDsrcTollingZoneID.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CenDsrcTollingZone_template::copy_template(const CenDsrcTollingZone_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.protectedZoneLatitude().get_selection()) {
single_value->field_protectedZoneLatitude = other_value.protectedZoneLatitude();
} else {
single_value->field_protectedZoneLatitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.protectedZoneLongitude().get_selection()) {
single_value->field_protectedZoneLongitude = other_value.protectedZoneLongitude();
} else {
single_value->field_protectedZoneLongitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.cenDsrcTollingZoneID().get_selection()) {
single_value->field_cenDsrcTollingZoneID = other_value.cenDsrcTollingZoneID();
} else {
single_value->field_cenDsrcTollingZoneID.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CenDsrcTollingZone_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @ITS-Container.CenDsrcTollingZone.");
break;
}
set_selection(other_value);
}

CenDsrcTollingZone_template::CenDsrcTollingZone_template()
{
}

CenDsrcTollingZone_template::CenDsrcTollingZone_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CenDsrcTollingZone_template::CenDsrcTollingZone_template(const CenDsrcTollingZone& other_value)
{
copy_value(other_value);
}

CenDsrcTollingZone_template::CenDsrcTollingZone_template(const OPTIONAL<CenDsrcTollingZone>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CenDsrcTollingZone&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @ITS-Container.CenDsrcTollingZone from an unbound optional field.");
}
}

CenDsrcTollingZone_template::CenDsrcTollingZone_template(const CenDsrcTollingZone_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CenDsrcTollingZone_template::~CenDsrcTollingZone_template()
{
clean_up();
}

CenDsrcTollingZone_template& CenDsrcTollingZone_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CenDsrcTollingZone_template& CenDsrcTollingZone_template::operator=(const CenDsrcTollingZone& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CenDsrcTollingZone_template& CenDsrcTollingZone_template::operator=(const OPTIONAL<CenDsrcTollingZone>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CenDsrcTollingZone&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @ITS-Container.CenDsrcTollingZone.");
}
return *this;
}

CenDsrcTollingZone_template& CenDsrcTollingZone_template::operator=(const CenDsrcTollingZone_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CenDsrcTollingZone_template::match(const CenDsrcTollingZone& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.protectedZoneLatitude().is_bound()) return FALSE;
if(!single_value->field_protectedZoneLatitude.match(other_value.protectedZoneLatitude(), legacy))return FALSE;
if(!other_value.protectedZoneLongitude().is_bound()) return FALSE;
if(!single_value->field_protectedZoneLongitude.match(other_value.protectedZoneLongitude(), legacy))return FALSE;
if(!other_value.cenDsrcTollingZoneID().is_bound()) return FALSE;
if((other_value.cenDsrcTollingZoneID().ispresent() ? !single_value->field_cenDsrcTollingZoneID.match((const INTEGER&)other_value.cenDsrcTollingZoneID(), legacy) : !single_value->field_cenDsrcTollingZoneID.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @ITS-Container.CenDsrcTollingZone.");
}
return FALSE;
}

boolean CenDsrcTollingZone_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_protectedZoneLatitude.is_bound()) return TRUE;
if (single_value->field_protectedZoneLongitude.is_bound()) return TRUE;
if (single_value->field_cenDsrcTollingZoneID.is_omit() || single_value->field_cenDsrcTollingZoneID.is_bound()) return TRUE;
return FALSE;
}

boolean CenDsrcTollingZone_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_protectedZoneLatitude.is_value()) return FALSE;
if (!single_value->field_protectedZoneLongitude.is_value()) return FALSE;
if (!single_value->field_cenDsrcTollingZoneID.is_omit() && !single_value->field_cenDsrcTollingZoneID.is_value()) return FALSE;
return TRUE;
}

void CenDsrcTollingZone_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CenDsrcTollingZone CenDsrcTollingZone_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @ITS-Container.CenDsrcTollingZone.");
CenDsrcTollingZone ret_val;
if (single_value->field_protectedZoneLatitude.is_bound()) {
ret_val.protectedZoneLatitude() = single_value->field_protectedZoneLatitude.valueof();
}
if (single_value->field_protectedZoneLongitude.is_bound()) {
ret_val.protectedZoneLongitude() = single_value->field_protectedZoneLongitude.valueof();
}
if (single_value->field_cenDsrcTollingZoneID.is_omit()) ret_val.cenDsrcTollingZoneID() = OMIT_VALUE;
else if (single_value->field_cenDsrcTollingZoneID.is_bound()) {
ret_val.cenDsrcTollingZoneID() = single_value->field_cenDsrcTollingZoneID.valueof();
}
return ret_val;
}

void CenDsrcTollingZone_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @ITS-Container.CenDsrcTollingZone.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CenDsrcTollingZone_template[list_length];
}

CenDsrcTollingZone_template& CenDsrcTollingZone_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @ITS-Container.CenDsrcTollingZone.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @ITS-Container.CenDsrcTollingZone.");
return value_list.list_value[list_index];
}

INTEGER_template& CenDsrcTollingZone_template::protectedZoneLatitude()
{
set_specific();
return single_value->field_protectedZoneLatitude;
}

const INTEGER_template& CenDsrcTollingZone_template::protectedZoneLatitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protectedZoneLatitude of a non-specific template of type @ITS-Container.CenDsrcTollingZone.");
return single_value->field_protectedZoneLatitude;
}

INTEGER_template& CenDsrcTollingZone_template::protectedZoneLongitude()
{
set_specific();
return single_value->field_protectedZoneLongitude;
}

const INTEGER_template& CenDsrcTollingZone_template::protectedZoneLongitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protectedZoneLongitude of a non-specific template of type @ITS-Container.CenDsrcTollingZone.");
return single_value->field_protectedZoneLongitude;
}

INTEGER_template& CenDsrcTollingZone_template::cenDsrcTollingZoneID()
{
set_specific();
return single_value->field_cenDsrcTollingZoneID;
}

const INTEGER_template& CenDsrcTollingZone_template::cenDsrcTollingZoneID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cenDsrcTollingZoneID of a non-specific template of type @ITS-Container.CenDsrcTollingZone.");
return single_value->field_cenDsrcTollingZoneID;
}

int CenDsrcTollingZone_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CenDsrcTollingZone which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_cenDsrcTollingZoneID.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @ITS-Container.CenDsrcTollingZone containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CenDsrcTollingZone containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CenDsrcTollingZone containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CenDsrcTollingZone containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @ITS-Container.CenDsrcTollingZone containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @ITS-Container.CenDsrcTollingZone.");
  }
  return 0;
}

void CenDsrcTollingZone_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ protectedZoneLatitude := ");
single_value->field_protectedZoneLatitude.log();
TTCN_Logger::log_event_str(", protectedZoneLongitude := ");
single_value->field_protectedZoneLongitude.log();
TTCN_Logger::log_event_str(", cenDsrcTollingZoneID := ");
single_value->field_cenDsrcTollingZoneID.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CenDsrcTollingZone_template::log_match(const CenDsrcTollingZone& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_protectedZoneLatitude.match(match_value.protectedZoneLatitude(), legacy)){
TTCN_Logger::log_logmatch_info(".protectedZoneLatitude");
single_value->field_protectedZoneLatitude.log_match(match_value.protectedZoneLatitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_protectedZoneLongitude.match(match_value.protectedZoneLongitude(), legacy)){
TTCN_Logger::log_logmatch_info(".protectedZoneLongitude");
single_value->field_protectedZoneLongitude.log_match(match_value.protectedZoneLongitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.cenDsrcTollingZoneID().ispresent()){
if(!single_value->field_cenDsrcTollingZoneID.match(match_value.cenDsrcTollingZoneID(), legacy)){
TTCN_Logger::log_logmatch_info(".cenDsrcTollingZoneID");
single_value->field_cenDsrcTollingZoneID.log_match(match_value.cenDsrcTollingZoneID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_cenDsrcTollingZoneID.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".cenDsrcTollingZoneID := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_cenDsrcTollingZoneID.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ protectedZoneLatitude := ");
single_value->field_protectedZoneLatitude.log_match(match_value.protectedZoneLatitude(), legacy);
TTCN_Logger::log_event_str(", protectedZoneLongitude := ");
single_value->field_protectedZoneLongitude.log_match(match_value.protectedZoneLongitude(), legacy);
TTCN_Logger::log_event_str(", cenDsrcTollingZoneID := ");
if (match_value.cenDsrcTollingZoneID().ispresent()) single_value->field_cenDsrcTollingZoneID.log_match(match_value.cenDsrcTollingZoneID(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_cenDsrcTollingZoneID.log();
if (single_value->field_cenDsrcTollingZoneID.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CenDsrcTollingZone_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_protectedZoneLatitude.encode_text(text_buf);
single_value->field_protectedZoneLongitude.encode_text(text_buf);
single_value->field_cenDsrcTollingZoneID.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @ITS-Container.CenDsrcTollingZone.");
}
}

void CenDsrcTollingZone_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_protectedZoneLatitude.decode_text(text_buf);
single_value->field_protectedZoneLongitude.decode_text(text_buf);
single_value->field_cenDsrcTollingZoneID.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CenDsrcTollingZone_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @ITS-Container.CenDsrcTollingZone.");
}
}

void CenDsrcTollingZone_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@ITS-Container.CenDsrcTollingZone'");
    }
    if (strcmp("protectedZoneLatitude", param_field) == 0) {
      protectedZoneLatitude().set_param(param);
      return;
    } else if (strcmp("protectedZoneLongitude", param_field) == 0) {
      protectedZoneLongitude().set_param(param);
      return;
    } else if (strcmp("cenDsrcTollingZoneID", param_field) == 0) {
      cenDsrcTollingZoneID().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@ITS-Container.CenDsrcTollingZone'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CenDsrcTollingZone_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @ITS-Container.CenDsrcTollingZone has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protectedZoneLatitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) protectedZoneLongitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) cenDsrcTollingZoneID().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protectedZoneLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protectedZoneLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cenDsrcTollingZoneID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cenDsrcTollingZoneID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @ITS-Container.CenDsrcTollingZone: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@ITS-Container.CenDsrcTollingZone");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CenDsrcTollingZone_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@ITS-Container.CenDsrcTollingZone'");
    }
    if (strcmp("protectedZoneLatitude", param_field) == 0) {
      return protectedZoneLatitude().get_param(param_name);
    } else if (strcmp("protectedZoneLongitude", param_field) == 0) {
      return protectedZoneLongitude().get_param(param_name);
    } else if (strcmp("cenDsrcTollingZoneID", param_field) == 0) {
      return cenDsrcTollingZoneID().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@ITS-Container.CenDsrcTollingZone'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_protectedZoneLatitude = single_value->field_protectedZoneLatitude.get_param(param_name);
    mp_field_protectedZoneLatitude->set_id(new Module_Param_FieldName(mcopystr("protectedZoneLatitude")));
    mp->add_elem(mp_field_protectedZoneLatitude);
    Module_Param* mp_field_protectedZoneLongitude = single_value->field_protectedZoneLongitude.get_param(param_name);
    mp_field_protectedZoneLongitude->set_id(new Module_Param_FieldName(mcopystr("protectedZoneLongitude")));
    mp->add_elem(mp_field_protectedZoneLongitude);
    Module_Param* mp_field_cenDsrcTollingZoneID = single_value->field_cenDsrcTollingZoneID.get_param(param_name);
    mp_field_cenDsrcTollingZoneID->set_id(new Module_Param_FieldName(mcopystr("cenDsrcTollingZoneID")));
    mp->add_elem(mp_field_cenDsrcTollingZoneID);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CenDsrcTollingZone_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_protectedZoneLatitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.CenDsrcTollingZone");
single_value->field_protectedZoneLongitude.check_restriction(t_res, t_name ? t_name : "@ITS-Container.CenDsrcTollingZone");
single_value->field_cenDsrcTollingZoneID.check_restriction(t_res, t_name ? t_name : "@ITS-Container.CenDsrcTollingZone");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@ITS-Container.CenDsrcTollingZone");
}

boolean CenDsrcTollingZone_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CenDsrcTollingZone_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const PathHistory& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.PathHistory.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const ItineraryPath& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.ItineraryPath.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const Traces& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.Traces.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const EventHistory& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.EventHistory.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const ProtectedCommunicationZonesRSU& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @ITS-Container.ProtectedCommunicationZonesRSU.");
return other_value.val_ptr->n_elements == 0;
}


} /* end of namespace */
