// This C++ header file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef ITS__Container_HH
#define ITS__Container_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the ASN.1 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef ITS__Container_HH
#endif

namespace ITS__Container {

/* Forward declarations of classes */

class ItsPduHeader;
class ItsPduHeader_template;
class PosConfidenceEllipse;
class PosConfidenceEllipse_template;
class AltitudeConfidence;
class AltitudeConfidence_template;
class Altitude;
class Altitude_template;
class ReferencePosition;
class ReferencePosition_template;
class DeltaReferencePosition;
class DeltaReferencePosition_template;
class PathPoint;
class PathPoint_template;
class PtActivation;
class PtActivation_template;
class CauseCode;
class CauseCode_template;
class CurvatureConfidence;
class CurvatureConfidence_template;
class Curvature;
class Curvature_template;
class CurvatureCalculationMode;
class CurvatureCalculationMode_template;
class Heading;
class Heading_template;
class ClosedLanes;
class ClosedLanes_template;
class HardShoulderStatus;
class HardShoulderStatus_template;
class Speed;
class Speed_template;
class DriveDirection;
class DriveDirection_template;
class LongitudinalAcceleration;
class LongitudinalAcceleration_template;
class LateralAcceleration;
class LateralAcceleration_template;
class VerticalAcceleration;
class VerticalAcceleration_template;
class DangerousGoodsBasic;
class DangerousGoodsBasic_template;
class DangerousGoodsExtended;
class DangerousGoodsExtended_template;
class RequestResponseIndication;
class RequestResponseIndication_template;
class StationarySince;
class StationarySince_template;
class TrafficRule;
class TrafficRule_template;
class PositioningSolutionType;
class PositioningSolutionType_template;
class VehicleIdentification;
class VehicleIdentification_template;
class VehicleLengthConfidenceIndication;
class VehicleLengthConfidenceIndication_template;
class VehicleLength;
class VehicleLength_template;
class PathHistory;
class PathHistory_template;
class RoadType;
class RoadType_template;
class SteeringWheelAngle;
class SteeringWheelAngle_template;
class VehicleRole;
class VehicleRole_template;
class YawRateConfidence;
class YawRateConfidence_template;
class YawRate;
class YawRate_template;
class ProtectedZoneType;
class ProtectedZoneType_template;
class RelevanceDistance;
class RelevanceDistance_template;
class RelevanceTrafficDirection;
class RelevanceTrafficDirection_template;
class ActionID;
class ActionID_template;
class ItineraryPath;
class ItineraryPath_template;
class ProtectedCommunicationZone;
class ProtectedCommunicationZone_template;
class Traces;
class Traces_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER PositionOfPillars;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template PositionOfPillars_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER RestrictedTypes;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template RestrictedTypes_template;
class EventHistory;
class EventHistory_template;
class EventPoint;
class EventPoint_template;
class ProtectedCommunicationZonesRSU;
class ProtectedCommunicationZonesRSU_template;
class CenDsrcTollingZone;
class CenDsrcTollingZone_template;

} /* end of namespace */

#ifndef ITS__Container_HH
#define ITS__Container_HH

namespace ITS__Container {

/* Type definitions */

typedef INTEGER StationID;
typedef INTEGER_template StationID_template;
typedef INTEGER Latitude;
typedef INTEGER_template Latitude_template;
typedef INTEGER Longitude;
typedef INTEGER_template Longitude_template;
typedef INTEGER SemiAxisLength;
typedef INTEGER_template SemiAxisLength_template;
typedef INTEGER HeadingValue;
typedef INTEGER_template HeadingValue_template;
typedef INTEGER AltitudeValue;
typedef INTEGER_template AltitudeValue_template;
typedef INTEGER DeltaLatitude;
typedef INTEGER_template DeltaLatitude_template;
typedef INTEGER DeltaLongitude;
typedef INTEGER_template DeltaLongitude_template;
typedef INTEGER DeltaAltitude;
typedef INTEGER_template DeltaAltitude_template;
typedef INTEGER PathDeltaTime;
typedef INTEGER_template PathDeltaTime_template;
typedef INTEGER PtActivationType;
typedef INTEGER_template PtActivationType_template;
typedef OCTETSTRING PtActivationData;
typedef OCTETSTRING_template PtActivationData_template;
typedef BITSTRING AccelerationControl;
typedef BITSTRING_template AccelerationControl_template;
typedef INTEGER CauseCodeType;
typedef INTEGER_template CauseCodeType_template;
typedef INTEGER SubCauseCodeType;
typedef INTEGER_template SubCauseCodeType_template;
typedef INTEGER TrafficConditionSubCauseCode;
typedef INTEGER_template TrafficConditionSubCauseCode_template;
typedef INTEGER AccidentSubCauseCode;
typedef INTEGER_template AccidentSubCauseCode_template;
typedef INTEGER RoadworksSubCauseCode;
typedef INTEGER_template RoadworksSubCauseCode_template;
typedef INTEGER HumanPresenceOnTheRoadSubCauseCode;
typedef INTEGER_template HumanPresenceOnTheRoadSubCauseCode_template;
typedef INTEGER WrongWayDrivingSubCauseCode;
typedef INTEGER_template WrongWayDrivingSubCauseCode_template;
typedef INTEGER AdverseWeatherCondition__ExtremeWeatherConditionSubCauseCode;
typedef INTEGER_template AdverseWeatherCondition__ExtremeWeatherConditionSubCauseCode_template;
typedef INTEGER AdverseWeatherCondition__AdhesionSubCauseCode;
typedef INTEGER_template AdverseWeatherCondition__AdhesionSubCauseCode_template;
typedef INTEGER AdverseWeatherCondition__VisibilitySubCauseCode;
typedef INTEGER_template AdverseWeatherCondition__VisibilitySubCauseCode_template;
typedef INTEGER AdverseWeatherCondition__PrecipitationSubCauseCode;
typedef INTEGER_template AdverseWeatherCondition__PrecipitationSubCauseCode_template;
typedef INTEGER SlowVehicleSubCauseCode;
typedef INTEGER_template SlowVehicleSubCauseCode_template;
typedef INTEGER StationaryVehicleSubCauseCode;
typedef INTEGER_template StationaryVehicleSubCauseCode_template;
typedef INTEGER HumanProblemSubCauseCode;
typedef INTEGER_template HumanProblemSubCauseCode_template;
typedef INTEGER EmergencyVehicleApproachingSubCauseCode;
typedef INTEGER_template EmergencyVehicleApproachingSubCauseCode_template;
typedef INTEGER HazardousLocation__DangerousCurveSubCauseCode;
typedef INTEGER_template HazardousLocation__DangerousCurveSubCauseCode_template;
typedef INTEGER HazardousLocation__SurfaceConditionSubCauseCode;
typedef INTEGER_template HazardousLocation__SurfaceConditionSubCauseCode_template;
typedef INTEGER HazardousLocation__ObstacleOnTheRoadSubCauseCode;
typedef INTEGER_template HazardousLocation__ObstacleOnTheRoadSubCauseCode_template;
typedef INTEGER HazardousLocation__AnimalOnTheRoadSubCauseCode;
typedef INTEGER_template HazardousLocation__AnimalOnTheRoadSubCauseCode_template;
typedef INTEGER CollisionRiskSubCauseCode;
typedef INTEGER_template CollisionRiskSubCauseCode_template;
typedef INTEGER SignalViolationSubCauseCode;
typedef INTEGER_template SignalViolationSubCauseCode_template;
typedef INTEGER RescueAndRecoveryWorkInProgressSubCauseCode;
typedef INTEGER_template RescueAndRecoveryWorkInProgressSubCauseCode_template;
typedef INTEGER DangerousEndOfQueueSubCauseCode;
typedef INTEGER_template DangerousEndOfQueueSubCauseCode_template;
typedef INTEGER DangerousSituationSubCauseCode;
typedef INTEGER_template DangerousSituationSubCauseCode_template;
typedef INTEGER VehicleBreakdownSubCauseCode;
typedef INTEGER_template VehicleBreakdownSubCauseCode_template;
typedef INTEGER PostCrashSubCauseCode;
typedef INTEGER_template PostCrashSubCauseCode_template;
typedef INTEGER CurvatureValue;
typedef INTEGER_template CurvatureValue_template;
typedef INTEGER HeadingConfidence;
typedef INTEGER_template HeadingConfidence_template;
typedef INTEGER LanePosition;
typedef INTEGER_template LanePosition_template;
typedef BITSTRING DrivingLaneStatus;
typedef BITSTRING_template DrivingLaneStatus_template;
typedef INTEGER PerformanceClass;
typedef INTEGER_template PerformanceClass_template;
typedef INTEGER SpeedValue;
typedef INTEGER_template SpeedValue_template;
typedef INTEGER SpeedConfidence;
typedef INTEGER_template SpeedConfidence_template;
typedef INTEGER VehicleMass;
typedef INTEGER_template VehicleMass_template;
typedef BOOLEAN EmbarkationStatus;
typedef BOOLEAN_template EmbarkationStatus_template;
typedef INTEGER LongitudinalAccelerationValue;
typedef INTEGER_template LongitudinalAccelerationValue_template;
typedef INTEGER AccelerationConfidence;
typedef INTEGER_template AccelerationConfidence_template;
typedef INTEGER LateralAccelerationValue;
typedef INTEGER_template LateralAccelerationValue_template;
typedef INTEGER VerticalAccelerationValue;
typedef INTEGER_template VerticalAccelerationValue_template;
typedef INTEGER StationType;
typedef INTEGER_template StationType_template;
typedef BITSTRING ExteriorLights;
typedef BITSTRING_template ExteriorLights_template;
typedef BITSTRING SpecialTransportType;
typedef BITSTRING_template SpecialTransportType_template;
typedef BITSTRING LightBarSirenInUse;
typedef BITSTRING_template LightBarSirenInUse_template;
typedef INTEGER HeightLonCarr;
typedef INTEGER_template HeightLonCarr_template;
typedef INTEGER PosLonCarr;
typedef INTEGER_template PosLonCarr_template;
typedef INTEGER PosPillar;
typedef INTEGER_template PosPillar_template;
typedef INTEGER PosCentMass;
typedef INTEGER_template PosCentMass_template;
typedef INTEGER SpeedLimit;
typedef INTEGER_template SpeedLimit_template;
typedef INTEGER Temperature;
typedef INTEGER_template Temperature_template;
typedef INTEGER WheelBaseVehicle;
typedef INTEGER_template WheelBaseVehicle_template;
typedef INTEGER TurningRadius;
typedef INTEGER_template TurningRadius_template;
typedef INTEGER PosFrontAx;
typedef INTEGER_template PosFrontAx_template;
typedef BITSTRING PositionOfOccupants;
typedef BITSTRING_template PositionOfOccupants_template;
typedef CHARSTRING WMInumber;
typedef CHARSTRING_template WMInumber_template;
typedef CHARSTRING VDS;
typedef CHARSTRING_template VDS_template;
typedef BITSTRING EnergyStorageType;
typedef BITSTRING_template EnergyStorageType_template;
typedef INTEGER VehicleLengthValue;
typedef INTEGER_template VehicleLengthValue_template;
typedef INTEGER VehicleWidth;
typedef INTEGER_template VehicleWidth_template;
typedef BITSTRING EmergencyPriority;
typedef BITSTRING_template EmergencyPriority_template;
typedef INTEGER InformationQuality;
typedef INTEGER_template InformationQuality_template;
typedef INTEGER SteeringWheelAngleValue;
typedef INTEGER_template SteeringWheelAngleValue_template;
typedef INTEGER SteeringWheelAngleConfidence;
typedef INTEGER_template SteeringWheelAngleConfidence_template;
typedef INTEGER TimestampIts;
typedef INTEGER_template TimestampIts_template;
typedef INTEGER YawRateValue;
typedef INTEGER_template YawRateValue_template;
typedef INTEGER TransmissionInterval;
typedef INTEGER_template TransmissionInterval_template;
typedef INTEGER ValidityDuration;
typedef INTEGER_template ValidityDuration_template;
typedef INTEGER SequenceNumber;
typedef INTEGER_template SequenceNumber_template;
typedef INTEGER ProtectedZoneRadius;
typedef INTEGER_template ProtectedZoneRadius_template;
typedef INTEGER ProtectedZoneID;
typedef INTEGER_template ProtectedZoneID_template;
typedef INTEGER NumberOfOccupants;
typedef INTEGER_template NumberOfOccupants_template;
typedef INTEGER CenDsrcTollingZoneID;
typedef INTEGER_template CenDsrcTollingZoneID_template;

/* Class definitions */

class ItsPduHeader : public Base_Type {
  INTEGER field_protocolVersion;
  INTEGER field_messageID;
  INTEGER field_stationID;
  boolean bound_flag;
public:
  ItsPduHeader();
  ItsPduHeader(const INTEGER& par_protocolVersion,
    const INTEGER& par_messageID,
    const INTEGER& par_stationID);
  ItsPduHeader(const ItsPduHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ItsPduHeader& operator=(const ItsPduHeader& other_value);
  boolean operator==(const ItsPduHeader& other_value) const;
  inline boolean operator!=(const ItsPduHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& protocolVersion()
    {return field_protocolVersion;}
  inline const INTEGER& protocolVersion() const
    {return field_protocolVersion;}
  inline INTEGER& messageID()
    {return field_messageID;}
  inline const INTEGER& messageID() const
    {return field_messageID;}
  inline INTEGER& stationID()
    {return field_stationID;}
  inline const INTEGER& stationID() const
    {return field_stationID;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ItsPduHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ItsPduHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ItsPduHeader& other_value);
void copy_template(const ItsPduHeader_template& other_value);

public:
ItsPduHeader_template();
ItsPduHeader_template(template_sel other_value);
ItsPduHeader_template(const ItsPduHeader& other_value);
ItsPduHeader_template(const OPTIONAL<ItsPduHeader>& other_value);
ItsPduHeader_template(const ItsPduHeader_template& other_value);
~ItsPduHeader_template();
ItsPduHeader_template& operator=(template_sel other_value);
ItsPduHeader_template& operator=(const ItsPduHeader& other_value);
ItsPduHeader_template& operator=(const OPTIONAL<ItsPduHeader>& other_value);
ItsPduHeader_template& operator=(const ItsPduHeader_template& other_value);
boolean match(const ItsPduHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ItsPduHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ItsPduHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& protocolVersion();
const INTEGER_template& protocolVersion() const;
INTEGER_template& messageID();
const INTEGER_template& messageID() const;
INTEGER_template& stationID();
const INTEGER_template& stationID() const;
int size_of() const;
void log() const;
void log_match(const ItsPduHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PosConfidenceEllipse : public Base_Type {
  INTEGER field_semiMajorConfidence;
  INTEGER field_semiMinorConfidence;
  INTEGER field_semiMajorOrientation;
  boolean bound_flag;
public:
  PosConfidenceEllipse();
  PosConfidenceEllipse(const INTEGER& par_semiMajorConfidence,
    const INTEGER& par_semiMinorConfidence,
    const INTEGER& par_semiMajorOrientation);
  PosConfidenceEllipse(const PosConfidenceEllipse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PosConfidenceEllipse& operator=(const PosConfidenceEllipse& other_value);
  boolean operator==(const PosConfidenceEllipse& other_value) const;
  inline boolean operator!=(const PosConfidenceEllipse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& semiMajorConfidence()
    {return field_semiMajorConfidence;}
  inline const INTEGER& semiMajorConfidence() const
    {return field_semiMajorConfidence;}
  inline INTEGER& semiMinorConfidence()
    {return field_semiMinorConfidence;}
  inline const INTEGER& semiMinorConfidence() const
    {return field_semiMinorConfidence;}
  inline INTEGER& semiMajorOrientation()
    {return field_semiMajorOrientation;}
  inline const INTEGER& semiMajorOrientation() const
    {return field_semiMajorOrientation;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PosConfidenceEllipse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PosConfidenceEllipse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PosConfidenceEllipse& other_value);
void copy_template(const PosConfidenceEllipse_template& other_value);

public:
PosConfidenceEllipse_template();
PosConfidenceEllipse_template(template_sel other_value);
PosConfidenceEllipse_template(const PosConfidenceEllipse& other_value);
PosConfidenceEllipse_template(const OPTIONAL<PosConfidenceEllipse>& other_value);
PosConfidenceEllipse_template(const PosConfidenceEllipse_template& other_value);
~PosConfidenceEllipse_template();
PosConfidenceEllipse_template& operator=(template_sel other_value);
PosConfidenceEllipse_template& operator=(const PosConfidenceEllipse& other_value);
PosConfidenceEllipse_template& operator=(const OPTIONAL<PosConfidenceEllipse>& other_value);
PosConfidenceEllipse_template& operator=(const PosConfidenceEllipse_template& other_value);
boolean match(const PosConfidenceEllipse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PosConfidenceEllipse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PosConfidenceEllipse_template& list_item(unsigned int list_index) const;
INTEGER_template& semiMajorConfidence();
const INTEGER_template& semiMajorConfidence() const;
INTEGER_template& semiMinorConfidence();
const INTEGER_template& semiMinorConfidence() const;
INTEGER_template& semiMajorOrientation();
const INTEGER_template& semiMajorOrientation() const;
int size_of() const;
void log() const;
void log_match(const PosConfidenceEllipse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AltitudeConfidence : public Base_Type { // enum
friend class AltitudeConfidence_template;
public:
enum enum_type { alt__000__01 = 0, alt__000__02 = 1, alt__000__05 = 2, alt__000__10 = 3, alt__000__20 = 4, alt__000__50 = 5, alt__001__00 = 6, alt__002__00 = 7, alt__005__00 = 8, alt__010__00 = 9, alt__020__00 = 10, alt__050__00 = 11, alt__100__00 = 12, alt__200__00 = 13, outOfRange = 14, unavailable = 15, UNKNOWN_VALUE = 16, UNBOUND_VALUE = 17 };
private:
enum_type enum_value;

public:
AltitudeConfidence();
AltitudeConfidence(int other_value);
AltitudeConfidence(enum_type other_value);
AltitudeConfidence(const AltitudeConfidence& other_value);

AltitudeConfidence& operator=(int other_value);
AltitudeConfidence& operator=(enum_type other_value);
AltitudeConfidence& operator=(const AltitudeConfidence& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const AltitudeConfidence& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AltitudeConfidence& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const AltitudeConfidence& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const AltitudeConfidence& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const AltitudeConfidence& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const AltitudeConfidence& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const AltitudeConfidence& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AltitudeConfidence_template : public Base_Template {
union {
AltitudeConfidence::enum_type single_value;
struct {
unsigned int n_values;
AltitudeConfidence_template *list_value;
} value_list;
};

void copy_template(const AltitudeConfidence_template& other_value);

public:
AltitudeConfidence_template();
AltitudeConfidence_template(template_sel other_value);
AltitudeConfidence_template(int other_value);
AltitudeConfidence_template(AltitudeConfidence::enum_type other_value);
AltitudeConfidence_template(const AltitudeConfidence& other_value);
AltitudeConfidence_template(const OPTIONAL<AltitudeConfidence>& other_value);
AltitudeConfidence_template(const AltitudeConfidence_template& other_value);
~AltitudeConfidence_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
AltitudeConfidence_template& operator=(template_sel other_value);
AltitudeConfidence_template& operator=(int other_value);
AltitudeConfidence_template& operator=(AltitudeConfidence::enum_type other_value);
AltitudeConfidence_template& operator=(const AltitudeConfidence& other_value);
AltitudeConfidence_template& operator=(const OPTIONAL<AltitudeConfidence>& other_value);
AltitudeConfidence_template& operator=(const AltitudeConfidence_template& other_value);

boolean match(AltitudeConfidence::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const AltitudeConfidence& other_value, boolean legacy = FALSE) const;
AltitudeConfidence::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AltitudeConfidence_template& list_item(unsigned int list_index);
void log() const;
void log_match(const AltitudeConfidence& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Altitude : public Base_Type {
  INTEGER field_altitudeValue;
  AltitudeConfidence field_altitudeConfidence;
  boolean bound_flag;
public:
  Altitude();
  Altitude(const INTEGER& par_altitudeValue,
    const AltitudeConfidence& par_altitudeConfidence);
  Altitude(const Altitude& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Altitude& operator=(const Altitude& other_value);
  boolean operator==(const Altitude& other_value) const;
  inline boolean operator!=(const Altitude& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& altitudeValue()
    {return field_altitudeValue;}
  inline const INTEGER& altitudeValue() const
    {return field_altitudeValue;}
  inline AltitudeConfidence& altitudeConfidence()
    {return field_altitudeConfidence;}
  inline const AltitudeConfidence& altitudeConfidence() const
    {return field_altitudeConfidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Altitude_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Altitude_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Altitude& other_value);
void copy_template(const Altitude_template& other_value);

public:
Altitude_template();
Altitude_template(template_sel other_value);
Altitude_template(const Altitude& other_value);
Altitude_template(const OPTIONAL<Altitude>& other_value);
Altitude_template(const Altitude_template& other_value);
~Altitude_template();
Altitude_template& operator=(template_sel other_value);
Altitude_template& operator=(const Altitude& other_value);
Altitude_template& operator=(const OPTIONAL<Altitude>& other_value);
Altitude_template& operator=(const Altitude_template& other_value);
boolean match(const Altitude& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Altitude valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Altitude_template& list_item(unsigned int list_index) const;
INTEGER_template& altitudeValue();
const INTEGER_template& altitudeValue() const;
AltitudeConfidence_template& altitudeConfidence();
const AltitudeConfidence_template& altitudeConfidence() const;
int size_of() const;
void log() const;
void log_match(const Altitude& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReferencePosition : public Base_Type {
  INTEGER field_latitude;
  INTEGER field_longitude;
  PosConfidenceEllipse field_positionConfidenceEllipse;
  Altitude field_altitude;
  boolean bound_flag;
public:
  ReferencePosition();
  ReferencePosition(const INTEGER& par_latitude,
    const INTEGER& par_longitude,
    const PosConfidenceEllipse& par_positionConfidenceEllipse,
    const Altitude& par_altitude);
  ReferencePosition(const ReferencePosition& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReferencePosition& operator=(const ReferencePosition& other_value);
  boolean operator==(const ReferencePosition& other_value) const;
  inline boolean operator!=(const ReferencePosition& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& latitude()
    {return field_latitude;}
  inline const INTEGER& latitude() const
    {return field_latitude;}
  inline INTEGER& longitude()
    {return field_longitude;}
  inline const INTEGER& longitude() const
    {return field_longitude;}
  inline PosConfidenceEllipse& positionConfidenceEllipse()
    {return field_positionConfidenceEllipse;}
  inline const PosConfidenceEllipse& positionConfidenceEllipse() const
    {return field_positionConfidenceEllipse;}
  inline Altitude& altitude()
    {return field_altitude;}
  inline const Altitude& altitude() const
    {return field_altitude;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ReferencePosition_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReferencePosition_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReferencePosition& other_value);
void copy_template(const ReferencePosition_template& other_value);

public:
ReferencePosition_template();
ReferencePosition_template(template_sel other_value);
ReferencePosition_template(const ReferencePosition& other_value);
ReferencePosition_template(const OPTIONAL<ReferencePosition>& other_value);
ReferencePosition_template(const ReferencePosition_template& other_value);
~ReferencePosition_template();
ReferencePosition_template& operator=(template_sel other_value);
ReferencePosition_template& operator=(const ReferencePosition& other_value);
ReferencePosition_template& operator=(const OPTIONAL<ReferencePosition>& other_value);
ReferencePosition_template& operator=(const ReferencePosition_template& other_value);
boolean match(const ReferencePosition& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReferencePosition valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReferencePosition_template& list_item(unsigned int list_index) const;
INTEGER_template& latitude();
const INTEGER_template& latitude() const;
INTEGER_template& longitude();
const INTEGER_template& longitude() const;
PosConfidenceEllipse_template& positionConfidenceEllipse();
const PosConfidenceEllipse_template& positionConfidenceEllipse() const;
Altitude_template& altitude();
const Altitude_template& altitude() const;
int size_of() const;
void log() const;
void log_match(const ReferencePosition& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeltaReferencePosition : public Base_Type {
  INTEGER field_deltaLatitude;
  INTEGER field_deltaLongitude;
  INTEGER field_deltaAltitude;
  boolean bound_flag;
public:
  DeltaReferencePosition();
  DeltaReferencePosition(const INTEGER& par_deltaLatitude,
    const INTEGER& par_deltaLongitude,
    const INTEGER& par_deltaAltitude);
  DeltaReferencePosition(const DeltaReferencePosition& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeltaReferencePosition& operator=(const DeltaReferencePosition& other_value);
  boolean operator==(const DeltaReferencePosition& other_value) const;
  inline boolean operator!=(const DeltaReferencePosition& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& deltaLatitude()
    {return field_deltaLatitude;}
  inline const INTEGER& deltaLatitude() const
    {return field_deltaLatitude;}
  inline INTEGER& deltaLongitude()
    {return field_deltaLongitude;}
  inline const INTEGER& deltaLongitude() const
    {return field_deltaLongitude;}
  inline INTEGER& deltaAltitude()
    {return field_deltaAltitude;}
  inline const INTEGER& deltaAltitude() const
    {return field_deltaAltitude;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DeltaReferencePosition_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeltaReferencePosition_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeltaReferencePosition& other_value);
void copy_template(const DeltaReferencePosition_template& other_value);

public:
DeltaReferencePosition_template();
DeltaReferencePosition_template(template_sel other_value);
DeltaReferencePosition_template(const DeltaReferencePosition& other_value);
DeltaReferencePosition_template(const OPTIONAL<DeltaReferencePosition>& other_value);
DeltaReferencePosition_template(const DeltaReferencePosition_template& other_value);
~DeltaReferencePosition_template();
DeltaReferencePosition_template& operator=(template_sel other_value);
DeltaReferencePosition_template& operator=(const DeltaReferencePosition& other_value);
DeltaReferencePosition_template& operator=(const OPTIONAL<DeltaReferencePosition>& other_value);
DeltaReferencePosition_template& operator=(const DeltaReferencePosition_template& other_value);
boolean match(const DeltaReferencePosition& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeltaReferencePosition valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeltaReferencePosition_template& list_item(unsigned int list_index) const;
INTEGER_template& deltaLatitude();
const INTEGER_template& deltaLatitude() const;
INTEGER_template& deltaLongitude();
const INTEGER_template& deltaLongitude() const;
INTEGER_template& deltaAltitude();
const INTEGER_template& deltaAltitude() const;
int size_of() const;
void log() const;
void log_match(const DeltaReferencePosition& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PathPoint : public Base_Type {
  DeltaReferencePosition field_pathPosition;
  OPTIONAL<INTEGER> field_pathDeltaTime;
  boolean bound_flag;
public:
  PathPoint();
  PathPoint(const DeltaReferencePosition& par_pathPosition,
    const OPTIONAL<INTEGER>& par_pathDeltaTime);
  PathPoint(const PathPoint& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PathPoint& operator=(const PathPoint& other_value);
  boolean operator==(const PathPoint& other_value) const;
  inline boolean operator!=(const PathPoint& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline DeltaReferencePosition& pathPosition()
    {return field_pathPosition;}
  inline const DeltaReferencePosition& pathPosition() const
    {return field_pathPosition;}
  inline OPTIONAL<INTEGER>& pathDeltaTime()
    {return field_pathDeltaTime;}
  inline const OPTIONAL<INTEGER>& pathDeltaTime() const
    {return field_pathDeltaTime;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PathPoint_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PathPoint_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PathPoint& other_value);
void copy_template(const PathPoint_template& other_value);

public:
PathPoint_template();
PathPoint_template(template_sel other_value);
PathPoint_template(const PathPoint& other_value);
PathPoint_template(const OPTIONAL<PathPoint>& other_value);
PathPoint_template(const PathPoint_template& other_value);
~PathPoint_template();
PathPoint_template& operator=(template_sel other_value);
PathPoint_template& operator=(const PathPoint& other_value);
PathPoint_template& operator=(const OPTIONAL<PathPoint>& other_value);
PathPoint_template& operator=(const PathPoint_template& other_value);
boolean match(const PathPoint& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PathPoint valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PathPoint_template& list_item(unsigned int list_index) const;
DeltaReferencePosition_template& pathPosition();
const DeltaReferencePosition_template& pathPosition() const;
INTEGER_template& pathDeltaTime();
const INTEGER_template& pathDeltaTime() const;
int size_of() const;
void log() const;
void log_match(const PathPoint& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PtActivation : public Base_Type {
  INTEGER field_ptActivationType;
  OCTETSTRING field_ptActivationData;
  boolean bound_flag;
public:
  PtActivation();
  PtActivation(const INTEGER& par_ptActivationType,
    const OCTETSTRING& par_ptActivationData);
  PtActivation(const PtActivation& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PtActivation& operator=(const PtActivation& other_value);
  boolean operator==(const PtActivation& other_value) const;
  inline boolean operator!=(const PtActivation& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& ptActivationType()
    {return field_ptActivationType;}
  inline const INTEGER& ptActivationType() const
    {return field_ptActivationType;}
  inline OCTETSTRING& ptActivationData()
    {return field_ptActivationData;}
  inline const OCTETSTRING& ptActivationData() const
    {return field_ptActivationData;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PtActivation_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PtActivation_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PtActivation& other_value);
void copy_template(const PtActivation_template& other_value);

public:
PtActivation_template();
PtActivation_template(template_sel other_value);
PtActivation_template(const PtActivation& other_value);
PtActivation_template(const OPTIONAL<PtActivation>& other_value);
PtActivation_template(const PtActivation_template& other_value);
~PtActivation_template();
PtActivation_template& operator=(template_sel other_value);
PtActivation_template& operator=(const PtActivation& other_value);
PtActivation_template& operator=(const OPTIONAL<PtActivation>& other_value);
PtActivation_template& operator=(const PtActivation_template& other_value);
boolean match(const PtActivation& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PtActivation valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PtActivation_template& list_item(unsigned int list_index) const;
INTEGER_template& ptActivationType();
const INTEGER_template& ptActivationType() const;
OCTETSTRING_template& ptActivationData();
const OCTETSTRING_template& ptActivationData() const;
int size_of() const;
void log() const;
void log_match(const PtActivation& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CauseCode : public Base_Type {
  INTEGER field_causeCode;
  INTEGER field_subCauseCode;
  boolean bound_flag;
public:
  CauseCode();
  CauseCode(const INTEGER& par_causeCode,
    const INTEGER& par_subCauseCode);
  CauseCode(const CauseCode& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CauseCode& operator=(const CauseCode& other_value);
  boolean operator==(const CauseCode& other_value) const;
  inline boolean operator!=(const CauseCode& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& causeCode()
    {return field_causeCode;}
  inline const INTEGER& causeCode() const
    {return field_causeCode;}
  inline INTEGER& subCauseCode()
    {return field_subCauseCode;}
  inline const INTEGER& subCauseCode() const
    {return field_subCauseCode;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CauseCode_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CauseCode_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CauseCode& other_value);
void copy_template(const CauseCode_template& other_value);

public:
CauseCode_template();
CauseCode_template(template_sel other_value);
CauseCode_template(const CauseCode& other_value);
CauseCode_template(const OPTIONAL<CauseCode>& other_value);
CauseCode_template(const CauseCode_template& other_value);
~CauseCode_template();
CauseCode_template& operator=(template_sel other_value);
CauseCode_template& operator=(const CauseCode& other_value);
CauseCode_template& operator=(const OPTIONAL<CauseCode>& other_value);
CauseCode_template& operator=(const CauseCode_template& other_value);
boolean match(const CauseCode& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CauseCode valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CauseCode_template& list_item(unsigned int list_index) const;
INTEGER_template& causeCode();
const INTEGER_template& causeCode() const;
INTEGER_template& subCauseCode();
const INTEGER_template& subCauseCode() const;
int size_of() const;
void log() const;
void log_match(const CauseCode& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CurvatureConfidence : public Base_Type { // enum
friend class CurvatureConfidence_template;
public:
enum enum_type { onePerMeter__0__00002 = 0, onePerMeter__0__0001 = 1, onePerMeter__0__0005 = 2, onePerMeter__0__002 = 3, onePerMeter__0__01 = 4, onePerMeter__0__1 = 5, outOfRange = 6, unavailable = 7, UNKNOWN_VALUE = 8, UNBOUND_VALUE = 9 };
private:
enum_type enum_value;

public:
CurvatureConfidence();
CurvatureConfidence(int other_value);
CurvatureConfidence(enum_type other_value);
CurvatureConfidence(const CurvatureConfidence& other_value);

CurvatureConfidence& operator=(int other_value);
CurvatureConfidence& operator=(enum_type other_value);
CurvatureConfidence& operator=(const CurvatureConfidence& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const CurvatureConfidence& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const CurvatureConfidence& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const CurvatureConfidence& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const CurvatureConfidence& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const CurvatureConfidence& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const CurvatureConfidence& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const CurvatureConfidence& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CurvatureConfidence_template : public Base_Template {
union {
CurvatureConfidence::enum_type single_value;
struct {
unsigned int n_values;
CurvatureConfidence_template *list_value;
} value_list;
};

void copy_template(const CurvatureConfidence_template& other_value);

public:
CurvatureConfidence_template();
CurvatureConfidence_template(template_sel other_value);
CurvatureConfidence_template(int other_value);
CurvatureConfidence_template(CurvatureConfidence::enum_type other_value);
CurvatureConfidence_template(const CurvatureConfidence& other_value);
CurvatureConfidence_template(const OPTIONAL<CurvatureConfidence>& other_value);
CurvatureConfidence_template(const CurvatureConfidence_template& other_value);
~CurvatureConfidence_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
CurvatureConfidence_template& operator=(template_sel other_value);
CurvatureConfidence_template& operator=(int other_value);
CurvatureConfidence_template& operator=(CurvatureConfidence::enum_type other_value);
CurvatureConfidence_template& operator=(const CurvatureConfidence& other_value);
CurvatureConfidence_template& operator=(const OPTIONAL<CurvatureConfidence>& other_value);
CurvatureConfidence_template& operator=(const CurvatureConfidence_template& other_value);

boolean match(CurvatureConfidence::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const CurvatureConfidence& other_value, boolean legacy = FALSE) const;
CurvatureConfidence::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CurvatureConfidence_template& list_item(unsigned int list_index);
void log() const;
void log_match(const CurvatureConfidence& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Curvature : public Base_Type {
  INTEGER field_curvatureValue;
  CurvatureConfidence field_curvatureConfidence;
  boolean bound_flag;
public:
  Curvature();
  Curvature(const INTEGER& par_curvatureValue,
    const CurvatureConfidence& par_curvatureConfidence);
  Curvature(const Curvature& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Curvature& operator=(const Curvature& other_value);
  boolean operator==(const Curvature& other_value) const;
  inline boolean operator!=(const Curvature& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& curvatureValue()
    {return field_curvatureValue;}
  inline const INTEGER& curvatureValue() const
    {return field_curvatureValue;}
  inline CurvatureConfidence& curvatureConfidence()
    {return field_curvatureConfidence;}
  inline const CurvatureConfidence& curvatureConfidence() const
    {return field_curvatureConfidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Curvature_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Curvature_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Curvature& other_value);
void copy_template(const Curvature_template& other_value);

public:
Curvature_template();
Curvature_template(template_sel other_value);
Curvature_template(const Curvature& other_value);
Curvature_template(const OPTIONAL<Curvature>& other_value);
Curvature_template(const Curvature_template& other_value);
~Curvature_template();
Curvature_template& operator=(template_sel other_value);
Curvature_template& operator=(const Curvature& other_value);
Curvature_template& operator=(const OPTIONAL<Curvature>& other_value);
Curvature_template& operator=(const Curvature_template& other_value);
boolean match(const Curvature& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Curvature valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Curvature_template& list_item(unsigned int list_index) const;
INTEGER_template& curvatureValue();
const INTEGER_template& curvatureValue() const;
CurvatureConfidence_template& curvatureConfidence();
const CurvatureConfidence_template& curvatureConfidence() const;
int size_of() const;
void log() const;
void log_match(const Curvature& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CurvatureCalculationMode : public Base_Type { // enum
friend class CurvatureCalculationMode_template;
public:
enum enum_type { yawRateUsed = 0, yawRateNotUsed = 1, unavailable = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
CurvatureCalculationMode();
CurvatureCalculationMode(int other_value);
CurvatureCalculationMode(enum_type other_value);
CurvatureCalculationMode(const CurvatureCalculationMode& other_value);

CurvatureCalculationMode& operator=(int other_value);
CurvatureCalculationMode& operator=(enum_type other_value);
CurvatureCalculationMode& operator=(const CurvatureCalculationMode& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const CurvatureCalculationMode& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const CurvatureCalculationMode& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const CurvatureCalculationMode& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const CurvatureCalculationMode& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const CurvatureCalculationMode& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const CurvatureCalculationMode& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const CurvatureCalculationMode& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CurvatureCalculationMode_template : public Base_Template {
union {
CurvatureCalculationMode::enum_type single_value;
struct {
unsigned int n_values;
CurvatureCalculationMode_template *list_value;
} value_list;
};

void copy_template(const CurvatureCalculationMode_template& other_value);

public:
CurvatureCalculationMode_template();
CurvatureCalculationMode_template(template_sel other_value);
CurvatureCalculationMode_template(int other_value);
CurvatureCalculationMode_template(CurvatureCalculationMode::enum_type other_value);
CurvatureCalculationMode_template(const CurvatureCalculationMode& other_value);
CurvatureCalculationMode_template(const OPTIONAL<CurvatureCalculationMode>& other_value);
CurvatureCalculationMode_template(const CurvatureCalculationMode_template& other_value);
~CurvatureCalculationMode_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
CurvatureCalculationMode_template& operator=(template_sel other_value);
CurvatureCalculationMode_template& operator=(int other_value);
CurvatureCalculationMode_template& operator=(CurvatureCalculationMode::enum_type other_value);
CurvatureCalculationMode_template& operator=(const CurvatureCalculationMode& other_value);
CurvatureCalculationMode_template& operator=(const OPTIONAL<CurvatureCalculationMode>& other_value);
CurvatureCalculationMode_template& operator=(const CurvatureCalculationMode_template& other_value);

boolean match(CurvatureCalculationMode::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const CurvatureCalculationMode& other_value, boolean legacy = FALSE) const;
CurvatureCalculationMode::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CurvatureCalculationMode_template& list_item(unsigned int list_index);
void log() const;
void log_match(const CurvatureCalculationMode& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Heading : public Base_Type {
  INTEGER field_headingValue;
  INTEGER field_headingConfidence;
  boolean bound_flag;
public:
  Heading();
  Heading(const INTEGER& par_headingValue,
    const INTEGER& par_headingConfidence);
  Heading(const Heading& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Heading& operator=(const Heading& other_value);
  boolean operator==(const Heading& other_value) const;
  inline boolean operator!=(const Heading& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& headingValue()
    {return field_headingValue;}
  inline const INTEGER& headingValue() const
    {return field_headingValue;}
  inline INTEGER& headingConfidence()
    {return field_headingConfidence;}
  inline const INTEGER& headingConfidence() const
    {return field_headingConfidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Heading_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Heading_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Heading& other_value);
void copy_template(const Heading_template& other_value);

public:
Heading_template();
Heading_template(template_sel other_value);
Heading_template(const Heading& other_value);
Heading_template(const OPTIONAL<Heading>& other_value);
Heading_template(const Heading_template& other_value);
~Heading_template();
Heading_template& operator=(template_sel other_value);
Heading_template& operator=(const Heading& other_value);
Heading_template& operator=(const OPTIONAL<Heading>& other_value);
Heading_template& operator=(const Heading_template& other_value);
boolean match(const Heading& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Heading valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Heading_template& list_item(unsigned int list_index) const;
INTEGER_template& headingValue();
const INTEGER_template& headingValue() const;
INTEGER_template& headingConfidence();
const INTEGER_template& headingConfidence() const;
int size_of() const;
void log() const;
void log_match(const Heading& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ClosedLanes : public Base_Type {
  OPTIONAL<HardShoulderStatus> field_hardShoulderStatus;
  BITSTRING field_drivingLaneStatus;
  boolean bound_flag;
public:
  ClosedLanes();
  ClosedLanes(const OPTIONAL<HardShoulderStatus>& par_hardShoulderStatus,
    const BITSTRING& par_drivingLaneStatus);
  ClosedLanes(const ClosedLanes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ClosedLanes& operator=(const ClosedLanes& other_value);
  boolean operator==(const ClosedLanes& other_value) const;
  inline boolean operator!=(const ClosedLanes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<HardShoulderStatus>& hardShoulderStatus()
    {return field_hardShoulderStatus;}
  inline const OPTIONAL<HardShoulderStatus>& hardShoulderStatus() const
    {return field_hardShoulderStatus;}
  inline BITSTRING& drivingLaneStatus()
    {return field_drivingLaneStatus;}
  inline const BITSTRING& drivingLaneStatus() const
    {return field_drivingLaneStatus;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ClosedLanes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ClosedLanes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ClosedLanes& other_value);
void copy_template(const ClosedLanes_template& other_value);

public:
ClosedLanes_template();
ClosedLanes_template(template_sel other_value);
ClosedLanes_template(const ClosedLanes& other_value);
ClosedLanes_template(const OPTIONAL<ClosedLanes>& other_value);
ClosedLanes_template(const ClosedLanes_template& other_value);
~ClosedLanes_template();
ClosedLanes_template& operator=(template_sel other_value);
ClosedLanes_template& operator=(const ClosedLanes& other_value);
ClosedLanes_template& operator=(const OPTIONAL<ClosedLanes>& other_value);
ClosedLanes_template& operator=(const ClosedLanes_template& other_value);
boolean match(const ClosedLanes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ClosedLanes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ClosedLanes_template& list_item(unsigned int list_index) const;
HardShoulderStatus_template& hardShoulderStatus();
const HardShoulderStatus_template& hardShoulderStatus() const;
BITSTRING_template& drivingLaneStatus();
const BITSTRING_template& drivingLaneStatus() const;
int size_of() const;
void log() const;
void log_match(const ClosedLanes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HardShoulderStatus : public Base_Type { // enum
friend class HardShoulderStatus_template;
public:
enum enum_type { availableForStopping = 0, closed = 1, availableForDriving = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
HardShoulderStatus();
HardShoulderStatus(int other_value);
HardShoulderStatus(enum_type other_value);
HardShoulderStatus(const HardShoulderStatus& other_value);

HardShoulderStatus& operator=(int other_value);
HardShoulderStatus& operator=(enum_type other_value);
HardShoulderStatus& operator=(const HardShoulderStatus& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const HardShoulderStatus& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HardShoulderStatus& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const HardShoulderStatus& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const HardShoulderStatus& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const HardShoulderStatus& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const HardShoulderStatus& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const HardShoulderStatus& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HardShoulderStatus_template : public Base_Template {
union {
HardShoulderStatus::enum_type single_value;
struct {
unsigned int n_values;
HardShoulderStatus_template *list_value;
} value_list;
};

void copy_template(const HardShoulderStatus_template& other_value);

public:
HardShoulderStatus_template();
HardShoulderStatus_template(template_sel other_value);
HardShoulderStatus_template(int other_value);
HardShoulderStatus_template(HardShoulderStatus::enum_type other_value);
HardShoulderStatus_template(const HardShoulderStatus& other_value);
HardShoulderStatus_template(const OPTIONAL<HardShoulderStatus>& other_value);
HardShoulderStatus_template(const HardShoulderStatus_template& other_value);
~HardShoulderStatus_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
HardShoulderStatus_template& operator=(template_sel other_value);
HardShoulderStatus_template& operator=(int other_value);
HardShoulderStatus_template& operator=(HardShoulderStatus::enum_type other_value);
HardShoulderStatus_template& operator=(const HardShoulderStatus& other_value);
HardShoulderStatus_template& operator=(const OPTIONAL<HardShoulderStatus>& other_value);
HardShoulderStatus_template& operator=(const HardShoulderStatus_template& other_value);

boolean match(HardShoulderStatus::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const HardShoulderStatus& other_value, boolean legacy = FALSE) const;
HardShoulderStatus::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HardShoulderStatus_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HardShoulderStatus& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Speed : public Base_Type {
  INTEGER field_speedValue;
  INTEGER field_speedConfidence;
  boolean bound_flag;
public:
  Speed();
  Speed(const INTEGER& par_speedValue,
    const INTEGER& par_speedConfidence);
  Speed(const Speed& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Speed& operator=(const Speed& other_value);
  boolean operator==(const Speed& other_value) const;
  inline boolean operator!=(const Speed& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& speedValue()
    {return field_speedValue;}
  inline const INTEGER& speedValue() const
    {return field_speedValue;}
  inline INTEGER& speedConfidence()
    {return field_speedConfidence;}
  inline const INTEGER& speedConfidence() const
    {return field_speedConfidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Speed_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Speed_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Speed& other_value);
void copy_template(const Speed_template& other_value);

public:
Speed_template();
Speed_template(template_sel other_value);
Speed_template(const Speed& other_value);
Speed_template(const OPTIONAL<Speed>& other_value);
Speed_template(const Speed_template& other_value);
~Speed_template();
Speed_template& operator=(template_sel other_value);
Speed_template& operator=(const Speed& other_value);
Speed_template& operator=(const OPTIONAL<Speed>& other_value);
Speed_template& operator=(const Speed_template& other_value);
boolean match(const Speed& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Speed valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Speed_template& list_item(unsigned int list_index) const;
INTEGER_template& speedValue();
const INTEGER_template& speedValue() const;
INTEGER_template& speedConfidence();
const INTEGER_template& speedConfidence() const;
int size_of() const;
void log() const;
void log_match(const Speed& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DriveDirection : public Base_Type { // enum
friend class DriveDirection_template;
public:
enum enum_type { forward = 0, backward = 1, unavailable = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
DriveDirection();
DriveDirection(int other_value);
DriveDirection(enum_type other_value);
DriveDirection(const DriveDirection& other_value);

DriveDirection& operator=(int other_value);
DriveDirection& operator=(enum_type other_value);
DriveDirection& operator=(const DriveDirection& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const DriveDirection& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DriveDirection& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const DriveDirection& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const DriveDirection& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const DriveDirection& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const DriveDirection& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const DriveDirection& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DriveDirection_template : public Base_Template {
union {
DriveDirection::enum_type single_value;
struct {
unsigned int n_values;
DriveDirection_template *list_value;
} value_list;
};

void copy_template(const DriveDirection_template& other_value);

public:
DriveDirection_template();
DriveDirection_template(template_sel other_value);
DriveDirection_template(int other_value);
DriveDirection_template(DriveDirection::enum_type other_value);
DriveDirection_template(const DriveDirection& other_value);
DriveDirection_template(const OPTIONAL<DriveDirection>& other_value);
DriveDirection_template(const DriveDirection_template& other_value);
~DriveDirection_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
DriveDirection_template& operator=(template_sel other_value);
DriveDirection_template& operator=(int other_value);
DriveDirection_template& operator=(DriveDirection::enum_type other_value);
DriveDirection_template& operator=(const DriveDirection& other_value);
DriveDirection_template& operator=(const OPTIONAL<DriveDirection>& other_value);
DriveDirection_template& operator=(const DriveDirection_template& other_value);

boolean match(DriveDirection::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const DriveDirection& other_value, boolean legacy = FALSE) const;
DriveDirection::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DriveDirection_template& list_item(unsigned int list_index);
void log() const;
void log_match(const DriveDirection& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class LongitudinalAcceleration : public Base_Type {
  INTEGER field_longitudinalAccelerationValue;
  INTEGER field_longitudinalAccelerationConfidence;
  boolean bound_flag;
public:
  LongitudinalAcceleration();
  LongitudinalAcceleration(const INTEGER& par_longitudinalAccelerationValue,
    const INTEGER& par_longitudinalAccelerationConfidence);
  LongitudinalAcceleration(const LongitudinalAcceleration& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LongitudinalAcceleration& operator=(const LongitudinalAcceleration& other_value);
  boolean operator==(const LongitudinalAcceleration& other_value) const;
  inline boolean operator!=(const LongitudinalAcceleration& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& longitudinalAccelerationValue()
    {return field_longitudinalAccelerationValue;}
  inline const INTEGER& longitudinalAccelerationValue() const
    {return field_longitudinalAccelerationValue;}
  inline INTEGER& longitudinalAccelerationConfidence()
    {return field_longitudinalAccelerationConfidence;}
  inline const INTEGER& longitudinalAccelerationConfidence() const
    {return field_longitudinalAccelerationConfidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LongitudinalAcceleration_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LongitudinalAcceleration_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LongitudinalAcceleration& other_value);
void copy_template(const LongitudinalAcceleration_template& other_value);

public:
LongitudinalAcceleration_template();
LongitudinalAcceleration_template(template_sel other_value);
LongitudinalAcceleration_template(const LongitudinalAcceleration& other_value);
LongitudinalAcceleration_template(const OPTIONAL<LongitudinalAcceleration>& other_value);
LongitudinalAcceleration_template(const LongitudinalAcceleration_template& other_value);
~LongitudinalAcceleration_template();
LongitudinalAcceleration_template& operator=(template_sel other_value);
LongitudinalAcceleration_template& operator=(const LongitudinalAcceleration& other_value);
LongitudinalAcceleration_template& operator=(const OPTIONAL<LongitudinalAcceleration>& other_value);
LongitudinalAcceleration_template& operator=(const LongitudinalAcceleration_template& other_value);
boolean match(const LongitudinalAcceleration& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LongitudinalAcceleration valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LongitudinalAcceleration_template& list_item(unsigned int list_index) const;
INTEGER_template& longitudinalAccelerationValue();
const INTEGER_template& longitudinalAccelerationValue() const;
INTEGER_template& longitudinalAccelerationConfidence();
const INTEGER_template& longitudinalAccelerationConfidence() const;
int size_of() const;
void log() const;
void log_match(const LongitudinalAcceleration& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LateralAcceleration : public Base_Type {
  INTEGER field_lateralAccelerationValue;
  INTEGER field_lateralAccelerationConfidence;
  boolean bound_flag;
public:
  LateralAcceleration();
  LateralAcceleration(const INTEGER& par_lateralAccelerationValue,
    const INTEGER& par_lateralAccelerationConfidence);
  LateralAcceleration(const LateralAcceleration& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LateralAcceleration& operator=(const LateralAcceleration& other_value);
  boolean operator==(const LateralAcceleration& other_value) const;
  inline boolean operator!=(const LateralAcceleration& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& lateralAccelerationValue()
    {return field_lateralAccelerationValue;}
  inline const INTEGER& lateralAccelerationValue() const
    {return field_lateralAccelerationValue;}
  inline INTEGER& lateralAccelerationConfidence()
    {return field_lateralAccelerationConfidence;}
  inline const INTEGER& lateralAccelerationConfidence() const
    {return field_lateralAccelerationConfidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LateralAcceleration_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LateralAcceleration_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LateralAcceleration& other_value);
void copy_template(const LateralAcceleration_template& other_value);

public:
LateralAcceleration_template();
LateralAcceleration_template(template_sel other_value);
LateralAcceleration_template(const LateralAcceleration& other_value);
LateralAcceleration_template(const OPTIONAL<LateralAcceleration>& other_value);
LateralAcceleration_template(const LateralAcceleration_template& other_value);
~LateralAcceleration_template();
LateralAcceleration_template& operator=(template_sel other_value);
LateralAcceleration_template& operator=(const LateralAcceleration& other_value);
LateralAcceleration_template& operator=(const OPTIONAL<LateralAcceleration>& other_value);
LateralAcceleration_template& operator=(const LateralAcceleration_template& other_value);
boolean match(const LateralAcceleration& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LateralAcceleration valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LateralAcceleration_template& list_item(unsigned int list_index) const;
INTEGER_template& lateralAccelerationValue();
const INTEGER_template& lateralAccelerationValue() const;
INTEGER_template& lateralAccelerationConfidence();
const INTEGER_template& lateralAccelerationConfidence() const;
int size_of() const;
void log() const;
void log_match(const LateralAcceleration& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class VerticalAcceleration : public Base_Type {
  INTEGER field_verticalAccelerationValue;
  INTEGER field_verticalAccelerationConfidence;
  boolean bound_flag;
public:
  VerticalAcceleration();
  VerticalAcceleration(const INTEGER& par_verticalAccelerationValue,
    const INTEGER& par_verticalAccelerationConfidence);
  VerticalAcceleration(const VerticalAcceleration& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  VerticalAcceleration& operator=(const VerticalAcceleration& other_value);
  boolean operator==(const VerticalAcceleration& other_value) const;
  inline boolean operator!=(const VerticalAcceleration& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& verticalAccelerationValue()
    {return field_verticalAccelerationValue;}
  inline const INTEGER& verticalAccelerationValue() const
    {return field_verticalAccelerationValue;}
  inline INTEGER& verticalAccelerationConfidence()
    {return field_verticalAccelerationConfidence;}
  inline const INTEGER& verticalAccelerationConfidence() const
    {return field_verticalAccelerationConfidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class VerticalAcceleration_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
VerticalAcceleration_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const VerticalAcceleration& other_value);
void copy_template(const VerticalAcceleration_template& other_value);

public:
VerticalAcceleration_template();
VerticalAcceleration_template(template_sel other_value);
VerticalAcceleration_template(const VerticalAcceleration& other_value);
VerticalAcceleration_template(const OPTIONAL<VerticalAcceleration>& other_value);
VerticalAcceleration_template(const VerticalAcceleration_template& other_value);
~VerticalAcceleration_template();
VerticalAcceleration_template& operator=(template_sel other_value);
VerticalAcceleration_template& operator=(const VerticalAcceleration& other_value);
VerticalAcceleration_template& operator=(const OPTIONAL<VerticalAcceleration>& other_value);
VerticalAcceleration_template& operator=(const VerticalAcceleration_template& other_value);
boolean match(const VerticalAcceleration& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
VerticalAcceleration valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
VerticalAcceleration_template& list_item(unsigned int list_index) const;
INTEGER_template& verticalAccelerationValue();
const INTEGER_template& verticalAccelerationValue() const;
INTEGER_template& verticalAccelerationConfidence();
const INTEGER_template& verticalAccelerationConfidence() const;
int size_of() const;
void log() const;
void log_match(const VerticalAcceleration& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DangerousGoodsBasic : public Base_Type { // enum
friend class DangerousGoodsBasic_template;
public:
enum enum_type { explosives1 = 0, explosives2 = 1, explosives3 = 2, explosives4 = 3, explosives5 = 4, explosives6 = 5, flammableGases = 6, nonFlammableGases = 7, toxicGases = 8, flammableLiquids = 9, flammableSolids = 10, substancesLiableToSpontaneousCombustion = 11, substancesEmittingFlammableGasesUponContactWithWater = 12, oxidizingSubstances = 13, organicPeroxides = 14, toxicSubstances = 15, infectiousSubstances = 16, radioactiveMaterial = 17, corrosiveSubstances = 18, miscellaneousDangerousSubstances = 19, UNKNOWN_VALUE = 20, UNBOUND_VALUE = 21 };
private:
enum_type enum_value;

public:
DangerousGoodsBasic();
DangerousGoodsBasic(int other_value);
DangerousGoodsBasic(enum_type other_value);
DangerousGoodsBasic(const DangerousGoodsBasic& other_value);

DangerousGoodsBasic& operator=(int other_value);
DangerousGoodsBasic& operator=(enum_type other_value);
DangerousGoodsBasic& operator=(const DangerousGoodsBasic& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const DangerousGoodsBasic& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DangerousGoodsBasic& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const DangerousGoodsBasic& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const DangerousGoodsBasic& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const DangerousGoodsBasic& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const DangerousGoodsBasic& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const DangerousGoodsBasic& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DangerousGoodsBasic_template : public Base_Template {
union {
DangerousGoodsBasic::enum_type single_value;
struct {
unsigned int n_values;
DangerousGoodsBasic_template *list_value;
} value_list;
};

void copy_template(const DangerousGoodsBasic_template& other_value);

public:
DangerousGoodsBasic_template();
DangerousGoodsBasic_template(template_sel other_value);
DangerousGoodsBasic_template(int other_value);
DangerousGoodsBasic_template(DangerousGoodsBasic::enum_type other_value);
DangerousGoodsBasic_template(const DangerousGoodsBasic& other_value);
DangerousGoodsBasic_template(const OPTIONAL<DangerousGoodsBasic>& other_value);
DangerousGoodsBasic_template(const DangerousGoodsBasic_template& other_value);
~DangerousGoodsBasic_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
DangerousGoodsBasic_template& operator=(template_sel other_value);
DangerousGoodsBasic_template& operator=(int other_value);
DangerousGoodsBasic_template& operator=(DangerousGoodsBasic::enum_type other_value);
DangerousGoodsBasic_template& operator=(const DangerousGoodsBasic& other_value);
DangerousGoodsBasic_template& operator=(const OPTIONAL<DangerousGoodsBasic>& other_value);
DangerousGoodsBasic_template& operator=(const DangerousGoodsBasic_template& other_value);

boolean match(DangerousGoodsBasic::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const DangerousGoodsBasic& other_value, boolean legacy = FALSE) const;
DangerousGoodsBasic::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DangerousGoodsBasic_template& list_item(unsigned int list_index);
void log() const;
void log_match(const DangerousGoodsBasic& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class DangerousGoodsExtended : public Base_Type {
  DangerousGoodsBasic field_dangerousGoodsType;
  INTEGER field_unNumber;
  BOOLEAN field_elevatedTemperature;
  BOOLEAN field_tunnelsRestricted;
  BOOLEAN field_limitedQuantity;
  OPTIONAL<CHARSTRING> field_emergencyActionCode;
  OPTIONAL<CHARSTRING> field_phoneNumber;
  OPTIONAL<UNIVERSAL_CHARSTRING> field_companyName;
  boolean bound_flag;
public:
  DangerousGoodsExtended();
  DangerousGoodsExtended(const DangerousGoodsBasic& par_dangerousGoodsType,
    const INTEGER& par_unNumber,
    const BOOLEAN& par_elevatedTemperature,
    const BOOLEAN& par_tunnelsRestricted,
    const BOOLEAN& par_limitedQuantity,
    const OPTIONAL<CHARSTRING>& par_emergencyActionCode,
    const OPTIONAL<CHARSTRING>& par_phoneNumber,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_companyName);
  DangerousGoodsExtended(const DangerousGoodsExtended& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DangerousGoodsExtended& operator=(const DangerousGoodsExtended& other_value);
  boolean operator==(const DangerousGoodsExtended& other_value) const;
  inline boolean operator!=(const DangerousGoodsExtended& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline DangerousGoodsBasic& dangerousGoodsType()
    {return field_dangerousGoodsType;}
  inline const DangerousGoodsBasic& dangerousGoodsType() const
    {return field_dangerousGoodsType;}
  inline INTEGER& unNumber()
    {return field_unNumber;}
  inline const INTEGER& unNumber() const
    {return field_unNumber;}
  inline BOOLEAN& elevatedTemperature()
    {return field_elevatedTemperature;}
  inline const BOOLEAN& elevatedTemperature() const
    {return field_elevatedTemperature;}
  inline BOOLEAN& tunnelsRestricted()
    {return field_tunnelsRestricted;}
  inline const BOOLEAN& tunnelsRestricted() const
    {return field_tunnelsRestricted;}
  inline BOOLEAN& limitedQuantity()
    {return field_limitedQuantity;}
  inline const BOOLEAN& limitedQuantity() const
    {return field_limitedQuantity;}
  inline OPTIONAL<CHARSTRING>& emergencyActionCode()
    {return field_emergencyActionCode;}
  inline const OPTIONAL<CHARSTRING>& emergencyActionCode() const
    {return field_emergencyActionCode;}
  inline OPTIONAL<CHARSTRING>& phoneNumber()
    {return field_phoneNumber;}
  inline const OPTIONAL<CHARSTRING>& phoneNumber() const
    {return field_phoneNumber;}
  inline OPTIONAL<UNIVERSAL_CHARSTRING>& companyName()
    {return field_companyName;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& companyName() const
    {return field_companyName;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DangerousGoodsExtended_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DangerousGoodsExtended_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DangerousGoodsExtended& other_value);
void copy_template(const DangerousGoodsExtended_template& other_value);

public:
DangerousGoodsExtended_template();
DangerousGoodsExtended_template(template_sel other_value);
DangerousGoodsExtended_template(const DangerousGoodsExtended& other_value);
DangerousGoodsExtended_template(const OPTIONAL<DangerousGoodsExtended>& other_value);
DangerousGoodsExtended_template(const DangerousGoodsExtended_template& other_value);
~DangerousGoodsExtended_template();
DangerousGoodsExtended_template& operator=(template_sel other_value);
DangerousGoodsExtended_template& operator=(const DangerousGoodsExtended& other_value);
DangerousGoodsExtended_template& operator=(const OPTIONAL<DangerousGoodsExtended>& other_value);
DangerousGoodsExtended_template& operator=(const DangerousGoodsExtended_template& other_value);
boolean match(const DangerousGoodsExtended& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DangerousGoodsExtended valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DangerousGoodsExtended_template& list_item(unsigned int list_index) const;
DangerousGoodsBasic_template& dangerousGoodsType();
const DangerousGoodsBasic_template& dangerousGoodsType() const;
INTEGER_template& unNumber();
const INTEGER_template& unNumber() const;
BOOLEAN_template& elevatedTemperature();
const BOOLEAN_template& elevatedTemperature() const;
BOOLEAN_template& tunnelsRestricted();
const BOOLEAN_template& tunnelsRestricted() const;
BOOLEAN_template& limitedQuantity();
const BOOLEAN_template& limitedQuantity() const;
CHARSTRING_template& emergencyActionCode();
const CHARSTRING_template& emergencyActionCode() const;
CHARSTRING_template& phoneNumber();
const CHARSTRING_template& phoneNumber() const;
UNIVERSAL_CHARSTRING_template& companyName();
const UNIVERSAL_CHARSTRING_template& companyName() const;
int size_of() const;
void log() const;
void log_match(const DangerousGoodsExtended& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RequestResponseIndication : public Base_Type { // enum
friend class RequestResponseIndication_template;
public:
enum enum_type { request = 0, response = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
RequestResponseIndication();
RequestResponseIndication(int other_value);
RequestResponseIndication(enum_type other_value);
RequestResponseIndication(const RequestResponseIndication& other_value);

RequestResponseIndication& operator=(int other_value);
RequestResponseIndication& operator=(enum_type other_value);
RequestResponseIndication& operator=(const RequestResponseIndication& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const RequestResponseIndication& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RequestResponseIndication& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const RequestResponseIndication& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const RequestResponseIndication& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const RequestResponseIndication& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const RequestResponseIndication& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const RequestResponseIndication& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RequestResponseIndication_template : public Base_Template {
union {
RequestResponseIndication::enum_type single_value;
struct {
unsigned int n_values;
RequestResponseIndication_template *list_value;
} value_list;
};

void copy_template(const RequestResponseIndication_template& other_value);

public:
RequestResponseIndication_template();
RequestResponseIndication_template(template_sel other_value);
RequestResponseIndication_template(int other_value);
RequestResponseIndication_template(RequestResponseIndication::enum_type other_value);
RequestResponseIndication_template(const RequestResponseIndication& other_value);
RequestResponseIndication_template(const OPTIONAL<RequestResponseIndication>& other_value);
RequestResponseIndication_template(const RequestResponseIndication_template& other_value);
~RequestResponseIndication_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
RequestResponseIndication_template& operator=(template_sel other_value);
RequestResponseIndication_template& operator=(int other_value);
RequestResponseIndication_template& operator=(RequestResponseIndication::enum_type other_value);
RequestResponseIndication_template& operator=(const RequestResponseIndication& other_value);
RequestResponseIndication_template& operator=(const OPTIONAL<RequestResponseIndication>& other_value);
RequestResponseIndication_template& operator=(const RequestResponseIndication_template& other_value);

boolean match(RequestResponseIndication::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const RequestResponseIndication& other_value, boolean legacy = FALSE) const;
RequestResponseIndication::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RequestResponseIndication_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RequestResponseIndication& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class StationarySince : public Base_Type { // enum
friend class StationarySince_template;
public:
enum enum_type { lessThan1Minute = 0, lessThan2Minutes = 1, lessThan15Minutes = 2, equalOrGreater15Minutes = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
StationarySince();
StationarySince(int other_value);
StationarySince(enum_type other_value);
StationarySince(const StationarySince& other_value);

StationarySince& operator=(int other_value);
StationarySince& operator=(enum_type other_value);
StationarySince& operator=(const StationarySince& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const StationarySince& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const StationarySince& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const StationarySince& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const StationarySince& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const StationarySince& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const StationarySince& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const StationarySince& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class StationarySince_template : public Base_Template {
union {
StationarySince::enum_type single_value;
struct {
unsigned int n_values;
StationarySince_template *list_value;
} value_list;
};

void copy_template(const StationarySince_template& other_value);

public:
StationarySince_template();
StationarySince_template(template_sel other_value);
StationarySince_template(int other_value);
StationarySince_template(StationarySince::enum_type other_value);
StationarySince_template(const StationarySince& other_value);
StationarySince_template(const OPTIONAL<StationarySince>& other_value);
StationarySince_template(const StationarySince_template& other_value);
~StationarySince_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
StationarySince_template& operator=(template_sel other_value);
StationarySince_template& operator=(int other_value);
StationarySince_template& operator=(StationarySince::enum_type other_value);
StationarySince_template& operator=(const StationarySince& other_value);
StationarySince_template& operator=(const OPTIONAL<StationarySince>& other_value);
StationarySince_template& operator=(const StationarySince_template& other_value);

boolean match(StationarySince::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const StationarySince& other_value, boolean legacy = FALSE) const;
StationarySince::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
StationarySince_template& list_item(unsigned int list_index);
void log() const;
void log_match(const StationarySince& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TrafficRule : public Base_Type { // enum
friend class TrafficRule_template;
public:
enum enum_type { noPassing = 0, noPassingForTrucks = 1, passToRight = 2, passToLeft = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
TrafficRule();
TrafficRule(int other_value);
TrafficRule(enum_type other_value);
TrafficRule(const TrafficRule& other_value);

TrafficRule& operator=(int other_value);
TrafficRule& operator=(enum_type other_value);
TrafficRule& operator=(const TrafficRule& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const TrafficRule& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TrafficRule& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const TrafficRule& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const TrafficRule& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const TrafficRule& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const TrafficRule& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const TrafficRule& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TrafficRule_template : public Base_Template {
union {
TrafficRule::enum_type single_value;
struct {
unsigned int n_values;
TrafficRule_template *list_value;
} value_list;
};

void copy_template(const TrafficRule_template& other_value);

public:
TrafficRule_template();
TrafficRule_template(template_sel other_value);
TrafficRule_template(int other_value);
TrafficRule_template(TrafficRule::enum_type other_value);
TrafficRule_template(const TrafficRule& other_value);
TrafficRule_template(const OPTIONAL<TrafficRule>& other_value);
TrafficRule_template(const TrafficRule_template& other_value);
~TrafficRule_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
TrafficRule_template& operator=(template_sel other_value);
TrafficRule_template& operator=(int other_value);
TrafficRule_template& operator=(TrafficRule::enum_type other_value);
TrafficRule_template& operator=(const TrafficRule& other_value);
TrafficRule_template& operator=(const OPTIONAL<TrafficRule>& other_value);
TrafficRule_template& operator=(const TrafficRule_template& other_value);

boolean match(TrafficRule::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const TrafficRule& other_value, boolean legacy = FALSE) const;
TrafficRule::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TrafficRule_template& list_item(unsigned int list_index);
void log() const;
void log_match(const TrafficRule& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class PositioningSolutionType : public Base_Type { // enum
friend class PositioningSolutionType_template;
public:
enum enum_type { noPositioningSolution = 0, sGNSS = 1, dGNSS = 2, sGNSSplusDR = 3, dGNSSplusDR = 4, dR = 5, UNKNOWN_VALUE = 6, UNBOUND_VALUE = 7 };
private:
enum_type enum_value;

public:
PositioningSolutionType();
PositioningSolutionType(int other_value);
PositioningSolutionType(enum_type other_value);
PositioningSolutionType(const PositioningSolutionType& other_value);

PositioningSolutionType& operator=(int other_value);
PositioningSolutionType& operator=(enum_type other_value);
PositioningSolutionType& operator=(const PositioningSolutionType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const PositioningSolutionType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PositioningSolutionType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const PositioningSolutionType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const PositioningSolutionType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const PositioningSolutionType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const PositioningSolutionType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const PositioningSolutionType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PositioningSolutionType_template : public Base_Template {
union {
PositioningSolutionType::enum_type single_value;
struct {
unsigned int n_values;
PositioningSolutionType_template *list_value;
} value_list;
};

void copy_template(const PositioningSolutionType_template& other_value);

public:
PositioningSolutionType_template();
PositioningSolutionType_template(template_sel other_value);
PositioningSolutionType_template(int other_value);
PositioningSolutionType_template(PositioningSolutionType::enum_type other_value);
PositioningSolutionType_template(const PositioningSolutionType& other_value);
PositioningSolutionType_template(const OPTIONAL<PositioningSolutionType>& other_value);
PositioningSolutionType_template(const PositioningSolutionType_template& other_value);
~PositioningSolutionType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
PositioningSolutionType_template& operator=(template_sel other_value);
PositioningSolutionType_template& operator=(int other_value);
PositioningSolutionType_template& operator=(PositioningSolutionType::enum_type other_value);
PositioningSolutionType_template& operator=(const PositioningSolutionType& other_value);
PositioningSolutionType_template& operator=(const OPTIONAL<PositioningSolutionType>& other_value);
PositioningSolutionType_template& operator=(const PositioningSolutionType_template& other_value);

boolean match(PositioningSolutionType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const PositioningSolutionType& other_value, boolean legacy = FALSE) const;
PositioningSolutionType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PositioningSolutionType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PositioningSolutionType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class VehicleIdentification : public Base_Type {
  OPTIONAL<CHARSTRING> field_wMInumber;
  OPTIONAL<CHARSTRING> field_vDS;
  boolean bound_flag;
public:
  VehicleIdentification();
  VehicleIdentification(const OPTIONAL<CHARSTRING>& par_wMInumber,
    const OPTIONAL<CHARSTRING>& par_vDS);
  VehicleIdentification(const VehicleIdentification& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  VehicleIdentification& operator=(const VehicleIdentification& other_value);
  boolean operator==(const VehicleIdentification& other_value) const;
  inline boolean operator!=(const VehicleIdentification& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& wMInumber()
    {return field_wMInumber;}
  inline const OPTIONAL<CHARSTRING>& wMInumber() const
    {return field_wMInumber;}
  inline OPTIONAL<CHARSTRING>& vDS()
    {return field_vDS;}
  inline const OPTIONAL<CHARSTRING>& vDS() const
    {return field_vDS;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class VehicleIdentification_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
VehicleIdentification_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const VehicleIdentification& other_value);
void copy_template(const VehicleIdentification_template& other_value);

public:
VehicleIdentification_template();
VehicleIdentification_template(template_sel other_value);
VehicleIdentification_template(const VehicleIdentification& other_value);
VehicleIdentification_template(const OPTIONAL<VehicleIdentification>& other_value);
VehicleIdentification_template(const VehicleIdentification_template& other_value);
~VehicleIdentification_template();
VehicleIdentification_template& operator=(template_sel other_value);
VehicleIdentification_template& operator=(const VehicleIdentification& other_value);
VehicleIdentification_template& operator=(const OPTIONAL<VehicleIdentification>& other_value);
VehicleIdentification_template& operator=(const VehicleIdentification_template& other_value);
boolean match(const VehicleIdentification& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
VehicleIdentification valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
VehicleIdentification_template& list_item(unsigned int list_index) const;
CHARSTRING_template& wMInumber();
const CHARSTRING_template& wMInumber() const;
CHARSTRING_template& vDS();
const CHARSTRING_template& vDS() const;
int size_of() const;
void log() const;
void log_match(const VehicleIdentification& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class VehicleLengthConfidenceIndication : public Base_Type { // enum
friend class VehicleLengthConfidenceIndication_template;
public:
enum enum_type { noTrailerPresent = 0, trailerPresentWithKnownLength = 1, trailerPresentWithUnknownLength = 2, trailerPresenceIsUnknown = 3, unavailable = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
VehicleLengthConfidenceIndication();
VehicleLengthConfidenceIndication(int other_value);
VehicleLengthConfidenceIndication(enum_type other_value);
VehicleLengthConfidenceIndication(const VehicleLengthConfidenceIndication& other_value);

VehicleLengthConfidenceIndication& operator=(int other_value);
VehicleLengthConfidenceIndication& operator=(enum_type other_value);
VehicleLengthConfidenceIndication& operator=(const VehicleLengthConfidenceIndication& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const VehicleLengthConfidenceIndication& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const VehicleLengthConfidenceIndication& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const VehicleLengthConfidenceIndication& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const VehicleLengthConfidenceIndication& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const VehicleLengthConfidenceIndication& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const VehicleLengthConfidenceIndication& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const VehicleLengthConfidenceIndication& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class VehicleLengthConfidenceIndication_template : public Base_Template {
union {
VehicleLengthConfidenceIndication::enum_type single_value;
struct {
unsigned int n_values;
VehicleLengthConfidenceIndication_template *list_value;
} value_list;
};

void copy_template(const VehicleLengthConfidenceIndication_template& other_value);

public:
VehicleLengthConfidenceIndication_template();
VehicleLengthConfidenceIndication_template(template_sel other_value);
VehicleLengthConfidenceIndication_template(int other_value);
VehicleLengthConfidenceIndication_template(VehicleLengthConfidenceIndication::enum_type other_value);
VehicleLengthConfidenceIndication_template(const VehicleLengthConfidenceIndication& other_value);
VehicleLengthConfidenceIndication_template(const OPTIONAL<VehicleLengthConfidenceIndication>& other_value);
VehicleLengthConfidenceIndication_template(const VehicleLengthConfidenceIndication_template& other_value);
~VehicleLengthConfidenceIndication_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
VehicleLengthConfidenceIndication_template& operator=(template_sel other_value);
VehicleLengthConfidenceIndication_template& operator=(int other_value);
VehicleLengthConfidenceIndication_template& operator=(VehicleLengthConfidenceIndication::enum_type other_value);
VehicleLengthConfidenceIndication_template& operator=(const VehicleLengthConfidenceIndication& other_value);
VehicleLengthConfidenceIndication_template& operator=(const OPTIONAL<VehicleLengthConfidenceIndication>& other_value);
VehicleLengthConfidenceIndication_template& operator=(const VehicleLengthConfidenceIndication_template& other_value);

boolean match(VehicleLengthConfidenceIndication::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const VehicleLengthConfidenceIndication& other_value, boolean legacy = FALSE) const;
VehicleLengthConfidenceIndication::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
VehicleLengthConfidenceIndication_template& list_item(unsigned int list_index);
void log() const;
void log_match(const VehicleLengthConfidenceIndication& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class VehicleLength : public Base_Type {
  INTEGER field_vehicleLengthValue;
  VehicleLengthConfidenceIndication field_vehicleLengthConfidenceIndication;
  boolean bound_flag;
public:
  VehicleLength();
  VehicleLength(const INTEGER& par_vehicleLengthValue,
    const VehicleLengthConfidenceIndication& par_vehicleLengthConfidenceIndication);
  VehicleLength(const VehicleLength& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  VehicleLength& operator=(const VehicleLength& other_value);
  boolean operator==(const VehicleLength& other_value) const;
  inline boolean operator!=(const VehicleLength& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& vehicleLengthValue()
    {return field_vehicleLengthValue;}
  inline const INTEGER& vehicleLengthValue() const
    {return field_vehicleLengthValue;}
  inline VehicleLengthConfidenceIndication& vehicleLengthConfidenceIndication()
    {return field_vehicleLengthConfidenceIndication;}
  inline const VehicleLengthConfidenceIndication& vehicleLengthConfidenceIndication() const
    {return field_vehicleLengthConfidenceIndication;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class VehicleLength_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
VehicleLength_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const VehicleLength& other_value);
void copy_template(const VehicleLength_template& other_value);

public:
VehicleLength_template();
VehicleLength_template(template_sel other_value);
VehicleLength_template(const VehicleLength& other_value);
VehicleLength_template(const OPTIONAL<VehicleLength>& other_value);
VehicleLength_template(const VehicleLength_template& other_value);
~VehicleLength_template();
VehicleLength_template& operator=(template_sel other_value);
VehicleLength_template& operator=(const VehicleLength& other_value);
VehicleLength_template& operator=(const OPTIONAL<VehicleLength>& other_value);
VehicleLength_template& operator=(const VehicleLength_template& other_value);
boolean match(const VehicleLength& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
VehicleLength valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
VehicleLength_template& list_item(unsigned int list_index) const;
INTEGER_template& vehicleLengthValue();
const INTEGER_template& vehicleLengthValue() const;
VehicleLengthConfidenceIndication_template& vehicleLengthConfidenceIndication();
const VehicleLengthConfidenceIndication_template& vehicleLengthConfidenceIndication() const;
int size_of() const;
void log() const;
void log_match(const VehicleLength& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PathHistory : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
PathPoint **value_elements;
} *val_ptr;

static const PathPoint UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PathHistory& other_value);

public:
  typedef PathPoint of_type;
PathHistory();
PathHistory(null_type other_value);
PathHistory(const PathHistory& other_value);
~PathHistory();

void clean_up();
PathHistory& operator=(null_type other_value);
PathHistory& operator=(const PathHistory& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PathHistory& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PathHistory& other_value) const { return !(*this == other_value); }

PathPoint& operator[](int index_value);
PathPoint& operator[](const INTEGER& index_value);
const PathPoint& operator[](int index_value) const;
const PathPoint& operator[](const INTEGER& index_value) const;

PathHistory operator<<=(int rotate_count) const;
PathHistory operator<<=(const INTEGER& rotate_count) const;
PathHistory operator>>=(int rotate_count) const;
PathHistory operator>>=(const INTEGER& rotate_count) const;

PathHistory operator+(const PathHistory& other_value) const;

PathHistory substr(int index, int returncount) const;

PathHistory replace(int index, int len, const PathHistory& repl) const;

PathHistory replace(int index, int len, const PathHistory_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PathHistory_template : public Record_Of_Template {
union {
struct {
int n_elements;
PathPoint_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PathHistory_template *list_value;
} value_list;
};
void copy_value(const PathHistory& other_value);
void copy_template(const PathHistory_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
PathHistory_template();
PathHistory_template(template_sel other_value);
PathHistory_template(null_type other_value);
PathHistory_template(const PathHistory& other_value);
PathHistory_template(const OPTIONAL<PathHistory>& other_value);
PathHistory_template(const PathHistory_template& other_value);
~PathHistory_template();

void clean_up();
PathHistory_template& operator=(template_sel other_value);
PathHistory_template& operator=(null_type other_value);
PathHistory_template& operator=(const PathHistory& other_value);
PathHistory_template& operator=(const OPTIONAL<PathHistory>& other_value);
PathHistory_template& operator=(const PathHistory_template& other_value);

PathPoint_template& operator[](int index_value);
PathPoint_template& operator[](const INTEGER& index_value);
const PathPoint_template& operator[](int index_value) const;
const PathPoint_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PathHistory& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PathHistory valueof() const;
PathHistory substr(int index, int returncount) const;

PathHistory replace(int index, int len, const PathHistory_template& repl) const;

PathHistory replace(int index, int len, const PathHistory& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PathHistory_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PathHistory& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RoadType : public Base_Type { // enum
friend class RoadType_template;
public:
enum enum_type { urban__NoStructuralSeparationToOppositeLanes = 0, urban__WithStructuralSeparationToOppositeLanes = 1, nonUrban__NoStructuralSeparationToOppositeLanes = 2, nonUrban__WithStructuralSeparationToOppositeLanes = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
RoadType();
RoadType(int other_value);
RoadType(enum_type other_value);
RoadType(const RoadType& other_value);

RoadType& operator=(int other_value);
RoadType& operator=(enum_type other_value);
RoadType& operator=(const RoadType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const RoadType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RoadType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const RoadType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const RoadType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const RoadType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const RoadType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const RoadType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RoadType_template : public Base_Template {
union {
RoadType::enum_type single_value;
struct {
unsigned int n_values;
RoadType_template *list_value;
} value_list;
};

void copy_template(const RoadType_template& other_value);

public:
RoadType_template();
RoadType_template(template_sel other_value);
RoadType_template(int other_value);
RoadType_template(RoadType::enum_type other_value);
RoadType_template(const RoadType& other_value);
RoadType_template(const OPTIONAL<RoadType>& other_value);
RoadType_template(const RoadType_template& other_value);
~RoadType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
RoadType_template& operator=(template_sel other_value);
RoadType_template& operator=(int other_value);
RoadType_template& operator=(RoadType::enum_type other_value);
RoadType_template& operator=(const RoadType& other_value);
RoadType_template& operator=(const OPTIONAL<RoadType>& other_value);
RoadType_template& operator=(const RoadType_template& other_value);

boolean match(RoadType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const RoadType& other_value, boolean legacy = FALSE) const;
RoadType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RoadType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RoadType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SteeringWheelAngle : public Base_Type {
  INTEGER field_steeringWheelAngleValue;
  INTEGER field_steeringWheelAngleConfidence;
  boolean bound_flag;
public:
  SteeringWheelAngle();
  SteeringWheelAngle(const INTEGER& par_steeringWheelAngleValue,
    const INTEGER& par_steeringWheelAngleConfidence);
  SteeringWheelAngle(const SteeringWheelAngle& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SteeringWheelAngle& operator=(const SteeringWheelAngle& other_value);
  boolean operator==(const SteeringWheelAngle& other_value) const;
  inline boolean operator!=(const SteeringWheelAngle& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& steeringWheelAngleValue()
    {return field_steeringWheelAngleValue;}
  inline const INTEGER& steeringWheelAngleValue() const
    {return field_steeringWheelAngleValue;}
  inline INTEGER& steeringWheelAngleConfidence()
    {return field_steeringWheelAngleConfidence;}
  inline const INTEGER& steeringWheelAngleConfidence() const
    {return field_steeringWheelAngleConfidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SteeringWheelAngle_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SteeringWheelAngle_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SteeringWheelAngle& other_value);
void copy_template(const SteeringWheelAngle_template& other_value);

public:
SteeringWheelAngle_template();
SteeringWheelAngle_template(template_sel other_value);
SteeringWheelAngle_template(const SteeringWheelAngle& other_value);
SteeringWheelAngle_template(const OPTIONAL<SteeringWheelAngle>& other_value);
SteeringWheelAngle_template(const SteeringWheelAngle_template& other_value);
~SteeringWheelAngle_template();
SteeringWheelAngle_template& operator=(template_sel other_value);
SteeringWheelAngle_template& operator=(const SteeringWheelAngle& other_value);
SteeringWheelAngle_template& operator=(const OPTIONAL<SteeringWheelAngle>& other_value);
SteeringWheelAngle_template& operator=(const SteeringWheelAngle_template& other_value);
boolean match(const SteeringWheelAngle& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SteeringWheelAngle valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SteeringWheelAngle_template& list_item(unsigned int list_index) const;
INTEGER_template& steeringWheelAngleValue();
const INTEGER_template& steeringWheelAngleValue() const;
INTEGER_template& steeringWheelAngleConfidence();
const INTEGER_template& steeringWheelAngleConfidence() const;
int size_of() const;
void log() const;
void log_match(const SteeringWheelAngle& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class VehicleRole : public Base_Type { // enum
friend class VehicleRole_template;
public:
enum enum_type { default__ = 0, publicTransport = 1, specialTransport = 2, dangerousGoods = 3, roadWork = 4, rescue = 5, emergency = 6, safetyCar = 7, agriculture = 8, commercial = 9, military = 10, roadOperator = 11, taxi = 12, reserved1 = 13, reserved2 = 14, reserved3 = 15, UNKNOWN_VALUE = 16, UNBOUND_VALUE = 17 };
private:
enum_type enum_value;

public:
VehicleRole();
VehicleRole(int other_value);
VehicleRole(enum_type other_value);
VehicleRole(const VehicleRole& other_value);

VehicleRole& operator=(int other_value);
VehicleRole& operator=(enum_type other_value);
VehicleRole& operator=(const VehicleRole& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const VehicleRole& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const VehicleRole& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const VehicleRole& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const VehicleRole& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const VehicleRole& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const VehicleRole& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const VehicleRole& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class VehicleRole_template : public Base_Template {
union {
VehicleRole::enum_type single_value;
struct {
unsigned int n_values;
VehicleRole_template *list_value;
} value_list;
};

void copy_template(const VehicleRole_template& other_value);

public:
VehicleRole_template();
VehicleRole_template(template_sel other_value);
VehicleRole_template(int other_value);
VehicleRole_template(VehicleRole::enum_type other_value);
VehicleRole_template(const VehicleRole& other_value);
VehicleRole_template(const OPTIONAL<VehicleRole>& other_value);
VehicleRole_template(const VehicleRole_template& other_value);
~VehicleRole_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
VehicleRole_template& operator=(template_sel other_value);
VehicleRole_template& operator=(int other_value);
VehicleRole_template& operator=(VehicleRole::enum_type other_value);
VehicleRole_template& operator=(const VehicleRole& other_value);
VehicleRole_template& operator=(const OPTIONAL<VehicleRole>& other_value);
VehicleRole_template& operator=(const VehicleRole_template& other_value);

boolean match(VehicleRole::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const VehicleRole& other_value, boolean legacy = FALSE) const;
VehicleRole::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
VehicleRole_template& list_item(unsigned int list_index);
void log() const;
void log_match(const VehicleRole& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class YawRateConfidence : public Base_Type { // enum
friend class YawRateConfidence_template;
public:
enum enum_type { degSec__000__01 = 0, degSec__000__05 = 1, degSec__000__10 = 2, degSec__001__00 = 3, degSec__005__00 = 4, degSec__010__00 = 5, degSec__100__00 = 6, outOfRange = 7, unavailable = 8, UNKNOWN_VALUE = 9, UNBOUND_VALUE = 10 };
private:
enum_type enum_value;

public:
YawRateConfidence();
YawRateConfidence(int other_value);
YawRateConfidence(enum_type other_value);
YawRateConfidence(const YawRateConfidence& other_value);

YawRateConfidence& operator=(int other_value);
YawRateConfidence& operator=(enum_type other_value);
YawRateConfidence& operator=(const YawRateConfidence& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const YawRateConfidence& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const YawRateConfidence& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const YawRateConfidence& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const YawRateConfidence& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const YawRateConfidence& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const YawRateConfidence& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const YawRateConfidence& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class YawRateConfidence_template : public Base_Template {
union {
YawRateConfidence::enum_type single_value;
struct {
unsigned int n_values;
YawRateConfidence_template *list_value;
} value_list;
};

void copy_template(const YawRateConfidence_template& other_value);

public:
YawRateConfidence_template();
YawRateConfidence_template(template_sel other_value);
YawRateConfidence_template(int other_value);
YawRateConfidence_template(YawRateConfidence::enum_type other_value);
YawRateConfidence_template(const YawRateConfidence& other_value);
YawRateConfidence_template(const OPTIONAL<YawRateConfidence>& other_value);
YawRateConfidence_template(const YawRateConfidence_template& other_value);
~YawRateConfidence_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
YawRateConfidence_template& operator=(template_sel other_value);
YawRateConfidence_template& operator=(int other_value);
YawRateConfidence_template& operator=(YawRateConfidence::enum_type other_value);
YawRateConfidence_template& operator=(const YawRateConfidence& other_value);
YawRateConfidence_template& operator=(const OPTIONAL<YawRateConfidence>& other_value);
YawRateConfidence_template& operator=(const YawRateConfidence_template& other_value);

boolean match(YawRateConfidence::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const YawRateConfidence& other_value, boolean legacy = FALSE) const;
YawRateConfidence::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
YawRateConfidence_template& list_item(unsigned int list_index);
void log() const;
void log_match(const YawRateConfidence& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class YawRate : public Base_Type {
  INTEGER field_yawRateValue;
  YawRateConfidence field_yawRateConfidence;
  boolean bound_flag;
public:
  YawRate();
  YawRate(const INTEGER& par_yawRateValue,
    const YawRateConfidence& par_yawRateConfidence);
  YawRate(const YawRate& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  YawRate& operator=(const YawRate& other_value);
  boolean operator==(const YawRate& other_value) const;
  inline boolean operator!=(const YawRate& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& yawRateValue()
    {return field_yawRateValue;}
  inline const INTEGER& yawRateValue() const
    {return field_yawRateValue;}
  inline YawRateConfidence& yawRateConfidence()
    {return field_yawRateConfidence;}
  inline const YawRateConfidence& yawRateConfidence() const
    {return field_yawRateConfidence;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class YawRate_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
YawRate_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const YawRate& other_value);
void copy_template(const YawRate_template& other_value);

public:
YawRate_template();
YawRate_template(template_sel other_value);
YawRate_template(const YawRate& other_value);
YawRate_template(const OPTIONAL<YawRate>& other_value);
YawRate_template(const YawRate_template& other_value);
~YawRate_template();
YawRate_template& operator=(template_sel other_value);
YawRate_template& operator=(const YawRate& other_value);
YawRate_template& operator=(const OPTIONAL<YawRate>& other_value);
YawRate_template& operator=(const YawRate_template& other_value);
boolean match(const YawRate& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
YawRate valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
YawRate_template& list_item(unsigned int list_index) const;
INTEGER_template& yawRateValue();
const INTEGER_template& yawRateValue() const;
YawRateConfidence_template& yawRateConfidence();
const YawRateConfidence_template& yawRateConfidence() const;
int size_of() const;
void log() const;
void log_match(const YawRate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ProtectedZoneType : public Base_Type { // enum
friend class ProtectedZoneType_template;
public:
enum enum_type { cenDsrcTolling = 0, UNKNOWN_VALUE = 1, UNBOUND_VALUE = 2 };
private:
enum_type enum_value;

public:
ProtectedZoneType();
ProtectedZoneType(int other_value);
ProtectedZoneType(enum_type other_value);
ProtectedZoneType(const ProtectedZoneType& other_value);

ProtectedZoneType& operator=(int other_value);
ProtectedZoneType& operator=(enum_type other_value);
ProtectedZoneType& operator=(const ProtectedZoneType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ProtectedZoneType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ProtectedZoneType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ProtectedZoneType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ProtectedZoneType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ProtectedZoneType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ProtectedZoneType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ProtectedZoneType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ProtectedZoneType_template : public Base_Template {
union {
ProtectedZoneType::enum_type single_value;
struct {
unsigned int n_values;
ProtectedZoneType_template *list_value;
} value_list;
};

void copy_template(const ProtectedZoneType_template& other_value);

public:
ProtectedZoneType_template();
ProtectedZoneType_template(template_sel other_value);
ProtectedZoneType_template(int other_value);
ProtectedZoneType_template(ProtectedZoneType::enum_type other_value);
ProtectedZoneType_template(const ProtectedZoneType& other_value);
ProtectedZoneType_template(const OPTIONAL<ProtectedZoneType>& other_value);
ProtectedZoneType_template(const ProtectedZoneType_template& other_value);
~ProtectedZoneType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ProtectedZoneType_template& operator=(template_sel other_value);
ProtectedZoneType_template& operator=(int other_value);
ProtectedZoneType_template& operator=(ProtectedZoneType::enum_type other_value);
ProtectedZoneType_template& operator=(const ProtectedZoneType& other_value);
ProtectedZoneType_template& operator=(const OPTIONAL<ProtectedZoneType>& other_value);
ProtectedZoneType_template& operator=(const ProtectedZoneType_template& other_value);

boolean match(ProtectedZoneType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const ProtectedZoneType& other_value, boolean legacy = FALSE) const;
ProtectedZoneType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ProtectedZoneType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ProtectedZoneType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RelevanceDistance : public Base_Type { // enum
friend class RelevanceDistance_template;
public:
enum enum_type { lessThan50m = 0, lessThan100m = 1, lessThan200m = 2, lessThan500m = 3, lessThan1000m = 4, lessThan5km = 5, lessThan10km = 6, over10km = 7, UNKNOWN_VALUE = 8, UNBOUND_VALUE = 9 };
private:
enum_type enum_value;

public:
RelevanceDistance();
RelevanceDistance(int other_value);
RelevanceDistance(enum_type other_value);
RelevanceDistance(const RelevanceDistance& other_value);

RelevanceDistance& operator=(int other_value);
RelevanceDistance& operator=(enum_type other_value);
RelevanceDistance& operator=(const RelevanceDistance& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const RelevanceDistance& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RelevanceDistance& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const RelevanceDistance& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const RelevanceDistance& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const RelevanceDistance& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const RelevanceDistance& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const RelevanceDistance& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RelevanceDistance_template : public Base_Template {
union {
RelevanceDistance::enum_type single_value;
struct {
unsigned int n_values;
RelevanceDistance_template *list_value;
} value_list;
};

void copy_template(const RelevanceDistance_template& other_value);

public:
RelevanceDistance_template();
RelevanceDistance_template(template_sel other_value);
RelevanceDistance_template(int other_value);
RelevanceDistance_template(RelevanceDistance::enum_type other_value);
RelevanceDistance_template(const RelevanceDistance& other_value);
RelevanceDistance_template(const OPTIONAL<RelevanceDistance>& other_value);
RelevanceDistance_template(const RelevanceDistance_template& other_value);
~RelevanceDistance_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
RelevanceDistance_template& operator=(template_sel other_value);
RelevanceDistance_template& operator=(int other_value);
RelevanceDistance_template& operator=(RelevanceDistance::enum_type other_value);
RelevanceDistance_template& operator=(const RelevanceDistance& other_value);
RelevanceDistance_template& operator=(const OPTIONAL<RelevanceDistance>& other_value);
RelevanceDistance_template& operator=(const RelevanceDistance_template& other_value);

boolean match(RelevanceDistance::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const RelevanceDistance& other_value, boolean legacy = FALSE) const;
RelevanceDistance::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RelevanceDistance_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RelevanceDistance& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RelevanceTrafficDirection : public Base_Type { // enum
friend class RelevanceTrafficDirection_template;
public:
enum enum_type { allTrafficDirections = 0, upstreamTraffic = 1, downstreamTraffic = 2, oppositeTraffic = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
RelevanceTrafficDirection();
RelevanceTrafficDirection(int other_value);
RelevanceTrafficDirection(enum_type other_value);
RelevanceTrafficDirection(const RelevanceTrafficDirection& other_value);

RelevanceTrafficDirection& operator=(int other_value);
RelevanceTrafficDirection& operator=(enum_type other_value);
RelevanceTrafficDirection& operator=(const RelevanceTrafficDirection& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const RelevanceTrafficDirection& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RelevanceTrafficDirection& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const RelevanceTrafficDirection& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const RelevanceTrafficDirection& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const RelevanceTrafficDirection& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const RelevanceTrafficDirection& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const RelevanceTrafficDirection& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RelevanceTrafficDirection_template : public Base_Template {
union {
RelevanceTrafficDirection::enum_type single_value;
struct {
unsigned int n_values;
RelevanceTrafficDirection_template *list_value;
} value_list;
};

void copy_template(const RelevanceTrafficDirection_template& other_value);

public:
RelevanceTrafficDirection_template();
RelevanceTrafficDirection_template(template_sel other_value);
RelevanceTrafficDirection_template(int other_value);
RelevanceTrafficDirection_template(RelevanceTrafficDirection::enum_type other_value);
RelevanceTrafficDirection_template(const RelevanceTrafficDirection& other_value);
RelevanceTrafficDirection_template(const OPTIONAL<RelevanceTrafficDirection>& other_value);
RelevanceTrafficDirection_template(const RelevanceTrafficDirection_template& other_value);
~RelevanceTrafficDirection_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
RelevanceTrafficDirection_template& operator=(template_sel other_value);
RelevanceTrafficDirection_template& operator=(int other_value);
RelevanceTrafficDirection_template& operator=(RelevanceTrafficDirection::enum_type other_value);
RelevanceTrafficDirection_template& operator=(const RelevanceTrafficDirection& other_value);
RelevanceTrafficDirection_template& operator=(const OPTIONAL<RelevanceTrafficDirection>& other_value);
RelevanceTrafficDirection_template& operator=(const RelevanceTrafficDirection_template& other_value);

boolean match(RelevanceTrafficDirection::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const RelevanceTrafficDirection& other_value, boolean legacy = FALSE) const;
RelevanceTrafficDirection::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RelevanceTrafficDirection_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RelevanceTrafficDirection& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ActionID : public Base_Type {
  INTEGER field_originatingStationID;
  INTEGER field_sequenceNumber;
  boolean bound_flag;
public:
  ActionID();
  ActionID(const INTEGER& par_originatingStationID,
    const INTEGER& par_sequenceNumber);
  ActionID(const ActionID& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ActionID& operator=(const ActionID& other_value);
  boolean operator==(const ActionID& other_value) const;
  inline boolean operator!=(const ActionID& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& originatingStationID()
    {return field_originatingStationID;}
  inline const INTEGER& originatingStationID() const
    {return field_originatingStationID;}
  inline INTEGER& sequenceNumber()
    {return field_sequenceNumber;}
  inline const INTEGER& sequenceNumber() const
    {return field_sequenceNumber;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ActionID_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ActionID_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ActionID& other_value);
void copy_template(const ActionID_template& other_value);

public:
ActionID_template();
ActionID_template(template_sel other_value);
ActionID_template(const ActionID& other_value);
ActionID_template(const OPTIONAL<ActionID>& other_value);
ActionID_template(const ActionID_template& other_value);
~ActionID_template();
ActionID_template& operator=(template_sel other_value);
ActionID_template& operator=(const ActionID& other_value);
ActionID_template& operator=(const OPTIONAL<ActionID>& other_value);
ActionID_template& operator=(const ActionID_template& other_value);
boolean match(const ActionID& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ActionID valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ActionID_template& list_item(unsigned int list_index) const;
INTEGER_template& originatingStationID();
const INTEGER_template& originatingStationID() const;
INTEGER_template& sequenceNumber();
const INTEGER_template& sequenceNumber() const;
int size_of() const;
void log() const;
void log_match(const ActionID& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ItineraryPath : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ReferencePosition **value_elements;
} *val_ptr;

static const ReferencePosition UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ItineraryPath& other_value);

public:
  typedef ReferencePosition of_type;
ItineraryPath();
ItineraryPath(null_type other_value);
ItineraryPath(const ItineraryPath& other_value);
~ItineraryPath();

void clean_up();
ItineraryPath& operator=(null_type other_value);
ItineraryPath& operator=(const ItineraryPath& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ItineraryPath& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ItineraryPath& other_value) const { return !(*this == other_value); }

ReferencePosition& operator[](int index_value);
ReferencePosition& operator[](const INTEGER& index_value);
const ReferencePosition& operator[](int index_value) const;
const ReferencePosition& operator[](const INTEGER& index_value) const;

ItineraryPath operator<<=(int rotate_count) const;
ItineraryPath operator<<=(const INTEGER& rotate_count) const;
ItineraryPath operator>>=(int rotate_count) const;
ItineraryPath operator>>=(const INTEGER& rotate_count) const;

ItineraryPath operator+(const ItineraryPath& other_value) const;

ItineraryPath substr(int index, int returncount) const;

ItineraryPath replace(int index, int len, const ItineraryPath& repl) const;

ItineraryPath replace(int index, int len, const ItineraryPath_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ItineraryPath_template : public Record_Of_Template {
union {
struct {
int n_elements;
ReferencePosition_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ItineraryPath_template *list_value;
} value_list;
};
void copy_value(const ItineraryPath& other_value);
void copy_template(const ItineraryPath_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ItineraryPath_template();
ItineraryPath_template(template_sel other_value);
ItineraryPath_template(null_type other_value);
ItineraryPath_template(const ItineraryPath& other_value);
ItineraryPath_template(const OPTIONAL<ItineraryPath>& other_value);
ItineraryPath_template(const ItineraryPath_template& other_value);
~ItineraryPath_template();

void clean_up();
ItineraryPath_template& operator=(template_sel other_value);
ItineraryPath_template& operator=(null_type other_value);
ItineraryPath_template& operator=(const ItineraryPath& other_value);
ItineraryPath_template& operator=(const OPTIONAL<ItineraryPath>& other_value);
ItineraryPath_template& operator=(const ItineraryPath_template& other_value);

ReferencePosition_template& operator[](int index_value);
ReferencePosition_template& operator[](const INTEGER& index_value);
const ReferencePosition_template& operator[](int index_value) const;
const ReferencePosition_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ItineraryPath& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ItineraryPath valueof() const;
ItineraryPath substr(int index, int returncount) const;

ItineraryPath replace(int index, int len, const ItineraryPath_template& repl) const;

ItineraryPath replace(int index, int len, const ItineraryPath& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ItineraryPath_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ItineraryPath& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ProtectedCommunicationZone : public Base_Type {
  ProtectedZoneType field_protectedZoneType;
  OPTIONAL<INTEGER> field_expiryTime;
  INTEGER field_protectedZoneLatitude;
  INTEGER field_protectedZoneLongitude;
  OPTIONAL<INTEGER> field_protectedZoneRadius;
  OPTIONAL<INTEGER> field_protectedZoneID;
  boolean bound_flag;
public:
  ProtectedCommunicationZone();
  ProtectedCommunicationZone(const ProtectedZoneType& par_protectedZoneType,
    const OPTIONAL<INTEGER>& par_expiryTime,
    const INTEGER& par_protectedZoneLatitude,
    const INTEGER& par_protectedZoneLongitude,
    const OPTIONAL<INTEGER>& par_protectedZoneRadius,
    const OPTIONAL<INTEGER>& par_protectedZoneID);
  ProtectedCommunicationZone(const ProtectedCommunicationZone& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ProtectedCommunicationZone& operator=(const ProtectedCommunicationZone& other_value);
  boolean operator==(const ProtectedCommunicationZone& other_value) const;
  inline boolean operator!=(const ProtectedCommunicationZone& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ProtectedZoneType& protectedZoneType()
    {return field_protectedZoneType;}
  inline const ProtectedZoneType& protectedZoneType() const
    {return field_protectedZoneType;}
  inline OPTIONAL<INTEGER>& expiryTime()
    {return field_expiryTime;}
  inline const OPTIONAL<INTEGER>& expiryTime() const
    {return field_expiryTime;}
  inline INTEGER& protectedZoneLatitude()
    {return field_protectedZoneLatitude;}
  inline const INTEGER& protectedZoneLatitude() const
    {return field_protectedZoneLatitude;}
  inline INTEGER& protectedZoneLongitude()
    {return field_protectedZoneLongitude;}
  inline const INTEGER& protectedZoneLongitude() const
    {return field_protectedZoneLongitude;}
  inline OPTIONAL<INTEGER>& protectedZoneRadius()
    {return field_protectedZoneRadius;}
  inline const OPTIONAL<INTEGER>& protectedZoneRadius() const
    {return field_protectedZoneRadius;}
  inline OPTIONAL<INTEGER>& protectedZoneID()
    {return field_protectedZoneID;}
  inline const OPTIONAL<INTEGER>& protectedZoneID() const
    {return field_protectedZoneID;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ProtectedCommunicationZone_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ProtectedCommunicationZone_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ProtectedCommunicationZone& other_value);
void copy_template(const ProtectedCommunicationZone_template& other_value);

public:
ProtectedCommunicationZone_template();
ProtectedCommunicationZone_template(template_sel other_value);
ProtectedCommunicationZone_template(const ProtectedCommunicationZone& other_value);
ProtectedCommunicationZone_template(const OPTIONAL<ProtectedCommunicationZone>& other_value);
ProtectedCommunicationZone_template(const ProtectedCommunicationZone_template& other_value);
~ProtectedCommunicationZone_template();
ProtectedCommunicationZone_template& operator=(template_sel other_value);
ProtectedCommunicationZone_template& operator=(const ProtectedCommunicationZone& other_value);
ProtectedCommunicationZone_template& operator=(const OPTIONAL<ProtectedCommunicationZone>& other_value);
ProtectedCommunicationZone_template& operator=(const ProtectedCommunicationZone_template& other_value);
boolean match(const ProtectedCommunicationZone& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ProtectedCommunicationZone valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ProtectedCommunicationZone_template& list_item(unsigned int list_index) const;
ProtectedZoneType_template& protectedZoneType();
const ProtectedZoneType_template& protectedZoneType() const;
INTEGER_template& expiryTime();
const INTEGER_template& expiryTime() const;
INTEGER_template& protectedZoneLatitude();
const INTEGER_template& protectedZoneLatitude() const;
INTEGER_template& protectedZoneLongitude();
const INTEGER_template& protectedZoneLongitude() const;
INTEGER_template& protectedZoneRadius();
const INTEGER_template& protectedZoneRadius() const;
INTEGER_template& protectedZoneID();
const INTEGER_template& protectedZoneID() const;
int size_of() const;
void log() const;
void log_match(const ProtectedCommunicationZone& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Traces : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
PathHistory **value_elements;
} *val_ptr;

static const PathHistory UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const Traces& other_value);

public:
  typedef PathHistory of_type;
Traces();
Traces(null_type other_value);
Traces(const Traces& other_value);
~Traces();

void clean_up();
Traces& operator=(null_type other_value);
Traces& operator=(const Traces& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const Traces& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Traces& other_value) const { return !(*this == other_value); }

PathHistory& operator[](int index_value);
PathHistory& operator[](const INTEGER& index_value);
const PathHistory& operator[](int index_value) const;
const PathHistory& operator[](const INTEGER& index_value) const;

Traces operator<<=(int rotate_count) const;
Traces operator<<=(const INTEGER& rotate_count) const;
Traces operator>>=(int rotate_count) const;
Traces operator>>=(const INTEGER& rotate_count) const;

Traces operator+(const Traces& other_value) const;

Traces substr(int index, int returncount) const;

Traces replace(int index, int len, const Traces& repl) const;

Traces replace(int index, int len, const Traces_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Traces_template : public Record_Of_Template {
union {
struct {
int n_elements;
PathHistory_template **value_elements;
} single_value;
struct {
unsigned int n_values;
Traces_template *list_value;
} value_list;
};
void copy_value(const Traces& other_value);
void copy_template(const Traces_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
Traces_template();
Traces_template(template_sel other_value);
Traces_template(null_type other_value);
Traces_template(const Traces& other_value);
Traces_template(const OPTIONAL<Traces>& other_value);
Traces_template(const Traces_template& other_value);
~Traces_template();

void clean_up();
Traces_template& operator=(template_sel other_value);
Traces_template& operator=(null_type other_value);
Traces_template& operator=(const Traces& other_value);
Traces_template& operator=(const OPTIONAL<Traces>& other_value);
Traces_template& operator=(const Traces_template& other_value);

PathHistory_template& operator[](int index_value);
PathHistory_template& operator[](const INTEGER& index_value);
const PathHistory_template& operator[](int index_value) const;
const PathHistory_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const Traces& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
Traces valueof() const;
Traces substr(int index, int returncount) const;

Traces replace(int index, int len, const Traces_template& repl) const;

Traces replace(int index, int len, const Traces& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
Traces_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Traces& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class EventHistory : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
EventPoint **value_elements;
} *val_ptr;

static const EventPoint UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const EventHistory& other_value);

public:
  typedef EventPoint of_type;
EventHistory();
EventHistory(null_type other_value);
EventHistory(const EventHistory& other_value);
~EventHistory();

void clean_up();
EventHistory& operator=(null_type other_value);
EventHistory& operator=(const EventHistory& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const EventHistory& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const EventHistory& other_value) const { return !(*this == other_value); }

EventPoint& operator[](int index_value);
EventPoint& operator[](const INTEGER& index_value);
const EventPoint& operator[](int index_value) const;
const EventPoint& operator[](const INTEGER& index_value) const;

EventHistory operator<<=(int rotate_count) const;
EventHistory operator<<=(const INTEGER& rotate_count) const;
EventHistory operator>>=(int rotate_count) const;
EventHistory operator>>=(const INTEGER& rotate_count) const;

EventHistory operator+(const EventHistory& other_value) const;

EventHistory substr(int index, int returncount) const;

EventHistory replace(int index, int len, const EventHistory& repl) const;

EventHistory replace(int index, int len, const EventHistory_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EventHistory_template : public Record_Of_Template {
union {
struct {
int n_elements;
EventPoint_template **value_elements;
} single_value;
struct {
unsigned int n_values;
EventHistory_template *list_value;
} value_list;
};
void copy_value(const EventHistory& other_value);
void copy_template(const EventHistory_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
EventHistory_template();
EventHistory_template(template_sel other_value);
EventHistory_template(null_type other_value);
EventHistory_template(const EventHistory& other_value);
EventHistory_template(const OPTIONAL<EventHistory>& other_value);
EventHistory_template(const EventHistory_template& other_value);
~EventHistory_template();

void clean_up();
EventHistory_template& operator=(template_sel other_value);
EventHistory_template& operator=(null_type other_value);
EventHistory_template& operator=(const EventHistory& other_value);
EventHistory_template& operator=(const OPTIONAL<EventHistory>& other_value);
EventHistory_template& operator=(const EventHistory_template& other_value);

EventPoint_template& operator[](int index_value);
EventPoint_template& operator[](const INTEGER& index_value);
const EventPoint_template& operator[](int index_value) const;
const EventPoint_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const EventHistory& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
EventHistory valueof() const;
EventHistory substr(int index, int returncount) const;

EventHistory replace(int index, int len, const EventHistory_template& repl) const;

EventHistory replace(int index, int len, const EventHistory& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
EventHistory_template& list_item(unsigned int list_index);
void log() const;
void log_match(const EventHistory& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class EventPoint : public Base_Type {
  DeltaReferencePosition field_eventPosition;
  OPTIONAL<INTEGER> field_eventDeltaTime;
  INTEGER field_informationQuality;
  boolean bound_flag;
public:
  EventPoint();
  EventPoint(const DeltaReferencePosition& par_eventPosition,
    const OPTIONAL<INTEGER>& par_eventDeltaTime,
    const INTEGER& par_informationQuality);
  EventPoint(const EventPoint& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EventPoint& operator=(const EventPoint& other_value);
  boolean operator==(const EventPoint& other_value) const;
  inline boolean operator!=(const EventPoint& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline DeltaReferencePosition& eventPosition()
    {return field_eventPosition;}
  inline const DeltaReferencePosition& eventPosition() const
    {return field_eventPosition;}
  inline OPTIONAL<INTEGER>& eventDeltaTime()
    {return field_eventDeltaTime;}
  inline const OPTIONAL<INTEGER>& eventDeltaTime() const
    {return field_eventDeltaTime;}
  inline INTEGER& informationQuality()
    {return field_informationQuality;}
  inline const INTEGER& informationQuality() const
    {return field_informationQuality;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EventPoint_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EventPoint_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EventPoint& other_value);
void copy_template(const EventPoint_template& other_value);

public:
EventPoint_template();
EventPoint_template(template_sel other_value);
EventPoint_template(const EventPoint& other_value);
EventPoint_template(const OPTIONAL<EventPoint>& other_value);
EventPoint_template(const EventPoint_template& other_value);
~EventPoint_template();
EventPoint_template& operator=(template_sel other_value);
EventPoint_template& operator=(const EventPoint& other_value);
EventPoint_template& operator=(const OPTIONAL<EventPoint>& other_value);
EventPoint_template& operator=(const EventPoint_template& other_value);
boolean match(const EventPoint& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EventPoint valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EventPoint_template& list_item(unsigned int list_index) const;
DeltaReferencePosition_template& eventPosition();
const DeltaReferencePosition_template& eventPosition() const;
INTEGER_template& eventDeltaTime();
const INTEGER_template& eventDeltaTime() const;
INTEGER_template& informationQuality();
const INTEGER_template& informationQuality() const;
int size_of() const;
void log() const;
void log_match(const EventPoint& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ProtectedCommunicationZonesRSU : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ProtectedCommunicationZone **value_elements;
} *val_ptr;

static const ProtectedCommunicationZone UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ProtectedCommunicationZonesRSU& other_value);

public:
  typedef ProtectedCommunicationZone of_type;
ProtectedCommunicationZonesRSU();
ProtectedCommunicationZonesRSU(null_type other_value);
ProtectedCommunicationZonesRSU(const ProtectedCommunicationZonesRSU& other_value);
~ProtectedCommunicationZonesRSU();

void clean_up();
ProtectedCommunicationZonesRSU& operator=(null_type other_value);
ProtectedCommunicationZonesRSU& operator=(const ProtectedCommunicationZonesRSU& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ProtectedCommunicationZonesRSU& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ProtectedCommunicationZonesRSU& other_value) const { return !(*this == other_value); }

ProtectedCommunicationZone& operator[](int index_value);
ProtectedCommunicationZone& operator[](const INTEGER& index_value);
const ProtectedCommunicationZone& operator[](int index_value) const;
const ProtectedCommunicationZone& operator[](const INTEGER& index_value) const;

ProtectedCommunicationZonesRSU operator<<=(int rotate_count) const;
ProtectedCommunicationZonesRSU operator<<=(const INTEGER& rotate_count) const;
ProtectedCommunicationZonesRSU operator>>=(int rotate_count) const;
ProtectedCommunicationZonesRSU operator>>=(const INTEGER& rotate_count) const;

ProtectedCommunicationZonesRSU operator+(const ProtectedCommunicationZonesRSU& other_value) const;

ProtectedCommunicationZonesRSU substr(int index, int returncount) const;

ProtectedCommunicationZonesRSU replace(int index, int len, const ProtectedCommunicationZonesRSU& repl) const;

ProtectedCommunicationZonesRSU replace(int index, int len, const ProtectedCommunicationZonesRSU_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ProtectedCommunicationZonesRSU_template : public Record_Of_Template {
union {
struct {
int n_elements;
ProtectedCommunicationZone_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ProtectedCommunicationZonesRSU_template *list_value;
} value_list;
};
void copy_value(const ProtectedCommunicationZonesRSU& other_value);
void copy_template(const ProtectedCommunicationZonesRSU_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ProtectedCommunicationZonesRSU_template();
ProtectedCommunicationZonesRSU_template(template_sel other_value);
ProtectedCommunicationZonesRSU_template(null_type other_value);
ProtectedCommunicationZonesRSU_template(const ProtectedCommunicationZonesRSU& other_value);
ProtectedCommunicationZonesRSU_template(const OPTIONAL<ProtectedCommunicationZonesRSU>& other_value);
ProtectedCommunicationZonesRSU_template(const ProtectedCommunicationZonesRSU_template& other_value);
~ProtectedCommunicationZonesRSU_template();

void clean_up();
ProtectedCommunicationZonesRSU_template& operator=(template_sel other_value);
ProtectedCommunicationZonesRSU_template& operator=(null_type other_value);
ProtectedCommunicationZonesRSU_template& operator=(const ProtectedCommunicationZonesRSU& other_value);
ProtectedCommunicationZonesRSU_template& operator=(const OPTIONAL<ProtectedCommunicationZonesRSU>& other_value);
ProtectedCommunicationZonesRSU_template& operator=(const ProtectedCommunicationZonesRSU_template& other_value);

ProtectedCommunicationZone_template& operator[](int index_value);
ProtectedCommunicationZone_template& operator[](const INTEGER& index_value);
const ProtectedCommunicationZone_template& operator[](int index_value) const;
const ProtectedCommunicationZone_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ProtectedCommunicationZonesRSU& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ProtectedCommunicationZonesRSU valueof() const;
ProtectedCommunicationZonesRSU substr(int index, int returncount) const;

ProtectedCommunicationZonesRSU replace(int index, int len, const ProtectedCommunicationZonesRSU_template& repl) const;

ProtectedCommunicationZonesRSU replace(int index, int len, const ProtectedCommunicationZonesRSU& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ProtectedCommunicationZonesRSU_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ProtectedCommunicationZonesRSU& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class CenDsrcTollingZone : public Base_Type {
  INTEGER field_protectedZoneLatitude;
  INTEGER field_protectedZoneLongitude;
  OPTIONAL<INTEGER> field_cenDsrcTollingZoneID;
  boolean bound_flag;
public:
  CenDsrcTollingZone();
  CenDsrcTollingZone(const INTEGER& par_protectedZoneLatitude,
    const INTEGER& par_protectedZoneLongitude,
    const OPTIONAL<INTEGER>& par_cenDsrcTollingZoneID);
  CenDsrcTollingZone(const CenDsrcTollingZone& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CenDsrcTollingZone& operator=(const CenDsrcTollingZone& other_value);
  boolean operator==(const CenDsrcTollingZone& other_value) const;
  inline boolean operator!=(const CenDsrcTollingZone& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& protectedZoneLatitude()
    {return field_protectedZoneLatitude;}
  inline const INTEGER& protectedZoneLatitude() const
    {return field_protectedZoneLatitude;}
  inline INTEGER& protectedZoneLongitude()
    {return field_protectedZoneLongitude;}
  inline const INTEGER& protectedZoneLongitude() const
    {return field_protectedZoneLongitude;}
  inline OPTIONAL<INTEGER>& cenDsrcTollingZoneID()
    {return field_cenDsrcTollingZoneID;}
  inline const OPTIONAL<INTEGER>& cenDsrcTollingZoneID() const
    {return field_cenDsrcTollingZoneID;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CenDsrcTollingZone_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CenDsrcTollingZone_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CenDsrcTollingZone& other_value);
void copy_template(const CenDsrcTollingZone_template& other_value);

public:
CenDsrcTollingZone_template();
CenDsrcTollingZone_template(template_sel other_value);
CenDsrcTollingZone_template(const CenDsrcTollingZone& other_value);
CenDsrcTollingZone_template(const OPTIONAL<CenDsrcTollingZone>& other_value);
CenDsrcTollingZone_template(const CenDsrcTollingZone_template& other_value);
~CenDsrcTollingZone_template();
CenDsrcTollingZone_template& operator=(template_sel other_value);
CenDsrcTollingZone_template& operator=(const CenDsrcTollingZone& other_value);
CenDsrcTollingZone_template& operator=(const OPTIONAL<CenDsrcTollingZone>& other_value);
CenDsrcTollingZone_template& operator=(const CenDsrcTollingZone_template& other_value);
boolean match(const CenDsrcTollingZone& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CenDsrcTollingZone valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CenDsrcTollingZone_template& list_item(unsigned int list_index) const;
INTEGER_template& protectedZoneLatitude();
const INTEGER_template& protectedZoneLatitude() const;
INTEGER_template& protectedZoneLongitude();
const INTEGER_template& protectedZoneLongitude() const;
INTEGER_template& cenDsrcTollingZoneID();
const INTEGER_template& cenDsrcTollingZoneID() const;
int size_of() const;
void log() const;
void log_match(const CenDsrcTollingZone& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const PathHistory& other_value);
inline boolean operator!=(null_type null_value, const PathHistory& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ItineraryPath& other_value);
inline boolean operator!=(null_type null_value, const ItineraryPath& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Traces& other_value);
inline boolean operator!=(null_type null_value, const Traces& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const EventHistory& other_value);
inline boolean operator!=(null_type null_value, const EventHistory& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ProtectedCommunicationZonesRSU& other_value);
inline boolean operator!=(null_type null_value, const ProtectedCommunicationZonesRSU& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const ASN_BERdescriptor_t ItsPduHeader_protocolVersion_ber_;
extern const TTCN_Typedescriptor_t ItsPduHeader_protocolVersion_descr_;
extern const ASN_BERdescriptor_t ItsPduHeader_messageID_ber_;
extern const TTCN_Typedescriptor_t ItsPduHeader_messageID_descr_;
extern const TTCN_Typedescriptor_t& StationID_descr_;
extern const ASN_BERdescriptor_t ItsPduHeader_stationID_ber_;
extern const TTCN_Typedescriptor_t ItsPduHeader_stationID_descr_;
extern const TTCN_JSONdescriptor_t ItsPduHeader_json_;
extern const TTCN_Typedescriptor_t ItsPduHeader_descr_;
extern const TTCN_Typedescriptor_t& Latitude_descr_;
extern const ASN_BERdescriptor_t ReferencePosition_latitude_ber_;
extern const TTCN_Typedescriptor_t ReferencePosition_latitude_descr_;
extern const TTCN_Typedescriptor_t& Longitude_descr_;
extern const ASN_BERdescriptor_t ReferencePosition_longitude_ber_;
extern const TTCN_Typedescriptor_t ReferencePosition_longitude_descr_;
extern const TTCN_Typedescriptor_t& SemiAxisLength_descr_;
extern const ASN_BERdescriptor_t PosConfidenceEllipse_semiMajorConfidence_ber_;
extern const TTCN_Typedescriptor_t PosConfidenceEllipse_semiMajorConfidence_descr_;
extern const ASN_BERdescriptor_t PosConfidenceEllipse_semiMinorConfidence_ber_;
extern const TTCN_Typedescriptor_t PosConfidenceEllipse_semiMinorConfidence_descr_;
extern const TTCN_Typedescriptor_t& HeadingValue_descr_;
extern const ASN_BERdescriptor_t PosConfidenceEllipse_semiMajorOrientation_ber_;
extern const TTCN_Typedescriptor_t PosConfidenceEllipse_semiMajorOrientation_descr_;
extern const TTCN_JSONdescriptor_t PosConfidenceEllipse_json_;
extern const TTCN_Typedescriptor_t PosConfidenceEllipse_descr_;
extern const ASN_BERdescriptor_t ReferencePosition_positionConfidenceEllipse_ber_;
extern const TTCN_Typedescriptor_t ReferencePosition_positionConfidenceEllipse_descr_;
extern const TTCN_Typedescriptor_t& AltitudeValue_descr_;
extern const ASN_BERdescriptor_t Altitude_altitudeValue_ber_;
extern const TTCN_Typedescriptor_t Altitude_altitudeValue_descr_;
extern const TTCN_JSONdescriptor_t AltitudeConfidence_json_;
extern const TTCN_Typedescriptor_t AltitudeConfidence_descr_;
extern const ASN_BERdescriptor_t Altitude_altitudeConfidence_ber_;
extern const TTCN_Typedescriptor_t Altitude_altitudeConfidence_descr_;
extern const TTCN_JSONdescriptor_t Altitude_json_;
extern const TTCN_Typedescriptor_t Altitude_descr_;
extern const ASN_BERdescriptor_t ReferencePosition_altitude_ber_;
extern const TTCN_Typedescriptor_t ReferencePosition_altitude_descr_;
extern const TTCN_JSONdescriptor_t ReferencePosition_json_;
extern const TTCN_Typedescriptor_t ReferencePosition_descr_;
extern const TTCN_Typedescriptor_t& DeltaLatitude_descr_;
extern const ASN_BERdescriptor_t DeltaReferencePosition_deltaLatitude_ber_;
extern const TTCN_Typedescriptor_t DeltaReferencePosition_deltaLatitude_descr_;
extern const TTCN_Typedescriptor_t& DeltaLongitude_descr_;
extern const ASN_BERdescriptor_t DeltaReferencePosition_deltaLongitude_ber_;
extern const TTCN_Typedescriptor_t DeltaReferencePosition_deltaLongitude_descr_;
extern const TTCN_Typedescriptor_t& DeltaAltitude_descr_;
extern const ASN_BERdescriptor_t DeltaReferencePosition_deltaAltitude_ber_;
extern const TTCN_Typedescriptor_t DeltaReferencePosition_deltaAltitude_descr_;
extern const TTCN_JSONdescriptor_t DeltaReferencePosition_json_;
extern const TTCN_Typedescriptor_t DeltaReferencePosition_descr_;
extern const ASN_BERdescriptor_t PathPoint_pathPosition_ber_;
extern const TTCN_Typedescriptor_t PathPoint_pathPosition_descr_;
extern const TTCN_JSONdescriptor_t PathPoint_json_;
extern const TTCN_Typedescriptor_t PathPoint_descr_;
extern const TTCN_Typedescriptor_t& PathDeltaTime_descr_;
extern const ASN_BERdescriptor_t PathPoint_pathDeltaTime_ber_;
extern const TTCN_Typedescriptor_t PathPoint_pathDeltaTime_descr_;
extern const TTCN_Typedescriptor_t& PtActivationType_descr_;
extern const ASN_BERdescriptor_t PtActivation_ptActivationType_ber_;
extern const TTCN_Typedescriptor_t PtActivation_ptActivationType_descr_;
extern const TTCN_Typedescriptor_t& PtActivationData_descr_;
extern const ASN_BERdescriptor_t PtActivation_ptActivationData_ber_;
extern const TTCN_Typedescriptor_t PtActivation_ptActivationData_descr_;
extern const TTCN_JSONdescriptor_t PtActivation_json_;
extern const TTCN_Typedescriptor_t PtActivation_descr_;
extern const TTCN_Typedescriptor_t& AccelerationControl_descr_;
extern const TTCN_Typedescriptor_t& CauseCodeType_descr_;
extern const ASN_BERdescriptor_t CauseCode_causeCode_ber_;
extern const TTCN_Typedescriptor_t CauseCode_causeCode_descr_;
extern const TTCN_Typedescriptor_t& SubCauseCodeType_descr_;
extern const ASN_BERdescriptor_t CauseCode_subCauseCode_ber_;
extern const TTCN_Typedescriptor_t CauseCode_subCauseCode_descr_;
extern const TTCN_JSONdescriptor_t CauseCode_json_;
extern const TTCN_Typedescriptor_t CauseCode_descr_;
extern const TTCN_Typedescriptor_t& TrafficConditionSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& AccidentSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& RoadworksSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& HumanPresenceOnTheRoadSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& WrongWayDrivingSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& AdverseWeatherCondition__ExtremeWeatherConditionSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& AdverseWeatherCondition__AdhesionSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& AdverseWeatherCondition__VisibilitySubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& AdverseWeatherCondition__PrecipitationSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& SlowVehicleSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& StationaryVehicleSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& HumanProblemSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& EmergencyVehicleApproachingSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& HazardousLocation__DangerousCurveSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& HazardousLocation__SurfaceConditionSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& HazardousLocation__ObstacleOnTheRoadSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& HazardousLocation__AnimalOnTheRoadSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& CollisionRiskSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& SignalViolationSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& RescueAndRecoveryWorkInProgressSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& DangerousEndOfQueueSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& DangerousSituationSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& VehicleBreakdownSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& PostCrashSubCauseCode_descr_;
extern const TTCN_Typedescriptor_t& CurvatureValue_descr_;
extern const ASN_BERdescriptor_t Curvature_curvatureValue_ber_;
extern const TTCN_Typedescriptor_t Curvature_curvatureValue_descr_;
extern const TTCN_JSONdescriptor_t CurvatureConfidence_json_;
extern const TTCN_Typedescriptor_t CurvatureConfidence_descr_;
extern const ASN_BERdescriptor_t Curvature_curvatureConfidence_ber_;
extern const TTCN_Typedescriptor_t Curvature_curvatureConfidence_descr_;
extern const TTCN_JSONdescriptor_t Curvature_json_;
extern const TTCN_Typedescriptor_t Curvature_descr_;
extern const TTCN_JSONdescriptor_t CurvatureCalculationMode_json_;
extern const TTCN_Typedescriptor_t CurvatureCalculationMode_descr_;
extern const ASN_BERdescriptor_t Heading_headingValue_ber_;
extern const TTCN_Typedescriptor_t Heading_headingValue_descr_;
extern const TTCN_Typedescriptor_t& HeadingConfidence_descr_;
extern const ASN_BERdescriptor_t Heading_headingConfidence_ber_;
extern const TTCN_Typedescriptor_t Heading_headingConfidence_descr_;
extern const TTCN_JSONdescriptor_t Heading_json_;
extern const TTCN_Typedescriptor_t Heading_descr_;
extern const TTCN_Typedescriptor_t& LanePosition_descr_;
extern const TTCN_Typedescriptor_t& DrivingLaneStatus_descr_;
extern const ASN_BERdescriptor_t ClosedLanes_drivingLaneStatus_ber_;
extern const TTCN_Typedescriptor_t ClosedLanes_drivingLaneStatus_descr_;
extern const TTCN_JSONdescriptor_t ClosedLanes_json_;
extern const TTCN_Typedescriptor_t ClosedLanes_descr_;
extern const TTCN_JSONdescriptor_t HardShoulderStatus_json_;
extern const TTCN_Typedescriptor_t HardShoulderStatus_descr_;
extern const ASN_BERdescriptor_t ClosedLanes_hardShoulderStatus_ber_;
extern const TTCN_Typedescriptor_t ClosedLanes_hardShoulderStatus_descr_;
extern const TTCN_Typedescriptor_t& PerformanceClass_descr_;
extern const TTCN_Typedescriptor_t& SpeedValue_descr_;
extern const TTCN_Typedescriptor_t& SpeedConfidence_descr_;
extern const TTCN_Typedescriptor_t& VehicleMass_descr_;
extern const ASN_BERdescriptor_t Speed_speedValue_ber_;
extern const TTCN_Typedescriptor_t Speed_speedValue_descr_;
extern const ASN_BERdescriptor_t Speed_speedConfidence_ber_;
extern const TTCN_Typedescriptor_t Speed_speedConfidence_descr_;
extern const TTCN_JSONdescriptor_t Speed_json_;
extern const TTCN_Typedescriptor_t Speed_descr_;
extern const TTCN_JSONdescriptor_t DriveDirection_json_;
extern const TTCN_Typedescriptor_t DriveDirection_descr_;
extern const TTCN_Typedescriptor_t& EmbarkationStatus_descr_;
extern const TTCN_Typedescriptor_t& LongitudinalAccelerationValue_descr_;
extern const ASN_BERdescriptor_t LongitudinalAcceleration_longitudinalAccelerationValue_ber_;
extern const TTCN_Typedescriptor_t LongitudinalAcceleration_longitudinalAccelerationValue_descr_;
extern const TTCN_Typedescriptor_t& AccelerationConfidence_descr_;
extern const ASN_BERdescriptor_t LongitudinalAcceleration_longitudinalAccelerationConfidence_ber_;
extern const TTCN_Typedescriptor_t LongitudinalAcceleration_longitudinalAccelerationConfidence_descr_;
extern const TTCN_JSONdescriptor_t LongitudinalAcceleration_json_;
extern const TTCN_Typedescriptor_t LongitudinalAcceleration_descr_;
extern const TTCN_Typedescriptor_t& LateralAccelerationValue_descr_;
extern const ASN_BERdescriptor_t LateralAcceleration_lateralAccelerationValue_ber_;
extern const TTCN_Typedescriptor_t LateralAcceleration_lateralAccelerationValue_descr_;
extern const ASN_BERdescriptor_t LateralAcceleration_lateralAccelerationConfidence_ber_;
extern const TTCN_Typedescriptor_t LateralAcceleration_lateralAccelerationConfidence_descr_;
extern const TTCN_JSONdescriptor_t LateralAcceleration_json_;
extern const TTCN_Typedescriptor_t LateralAcceleration_descr_;
extern const TTCN_Typedescriptor_t& VerticalAccelerationValue_descr_;
extern const ASN_BERdescriptor_t VerticalAcceleration_verticalAccelerationValue_ber_;
extern const TTCN_Typedescriptor_t VerticalAcceleration_verticalAccelerationValue_descr_;
extern const ASN_BERdescriptor_t VerticalAcceleration_verticalAccelerationConfidence_ber_;
extern const TTCN_Typedescriptor_t VerticalAcceleration_verticalAccelerationConfidence_descr_;
extern const TTCN_JSONdescriptor_t VerticalAcceleration_json_;
extern const TTCN_Typedescriptor_t VerticalAcceleration_descr_;
extern const TTCN_Typedescriptor_t& StationType_descr_;
extern const TTCN_Typedescriptor_t& ExteriorLights_descr_;
extern const TTCN_JSONdescriptor_t DangerousGoodsBasic_json_;
extern const TTCN_Typedescriptor_t DangerousGoodsBasic_descr_;
extern const ASN_BERdescriptor_t DangerousGoodsExtended_dangerousGoodsType_ber_;
extern const TTCN_Typedescriptor_t DangerousGoodsExtended_dangerousGoodsType_descr_;
extern const ASN_BERdescriptor_t DangerousGoodsExtended_unNumber_ber_;
extern const TTCN_Typedescriptor_t DangerousGoodsExtended_unNumber_descr_;
extern const ASN_BERdescriptor_t DangerousGoodsExtended_elevatedTemperature_ber_;
extern const TTCN_Typedescriptor_t DangerousGoodsExtended_elevatedTemperature_descr_;
extern const ASN_BERdescriptor_t DangerousGoodsExtended_tunnelsRestricted_ber_;
extern const TTCN_Typedescriptor_t DangerousGoodsExtended_tunnelsRestricted_descr_;
extern const ASN_BERdescriptor_t DangerousGoodsExtended_limitedQuantity_ber_;
extern const TTCN_Typedescriptor_t DangerousGoodsExtended_limitedQuantity_descr_;
extern const TTCN_JSONdescriptor_t DangerousGoodsExtended_json_;
extern const TTCN_Typedescriptor_t DangerousGoodsExtended_descr_;
extern const ASN_BERdescriptor_t DangerousGoodsExtended_emergencyActionCode_ber_;
extern const TTCN_Typedescriptor_t DangerousGoodsExtended_emergencyActionCode_descr_;
extern const ASN_BERdescriptor_t DangerousGoodsExtended_phoneNumber_ber_;
extern const TTCN_Typedescriptor_t DangerousGoodsExtended_phoneNumber_descr_;
extern const ASN_BERdescriptor_t DangerousGoodsExtended_companyName_ber_;
extern const TTCN_Typedescriptor_t DangerousGoodsExtended_companyName_descr_;
extern const TTCN_Typedescriptor_t& SpecialTransportType_descr_;
extern const TTCN_Typedescriptor_t& LightBarSirenInUse_descr_;
extern const TTCN_Typedescriptor_t& HeightLonCarr_descr_;
extern const TTCN_Typedescriptor_t& PosLonCarr_descr_;
extern const TTCN_Typedescriptor_t& PosPillar_descr_;
extern const TTCN_Typedescriptor_t& PosCentMass_descr_;
extern const TTCN_JSONdescriptor_t RequestResponseIndication_json_;
extern const TTCN_Typedescriptor_t RequestResponseIndication_descr_;
extern const TTCN_Typedescriptor_t& SpeedLimit_descr_;
extern const TTCN_JSONdescriptor_t StationarySince_json_;
extern const TTCN_Typedescriptor_t StationarySince_descr_;
extern const TTCN_Typedescriptor_t& Temperature_descr_;
extern const TTCN_JSONdescriptor_t TrafficRule_json_;
extern const TTCN_Typedescriptor_t TrafficRule_descr_;
extern const TTCN_Typedescriptor_t& WheelBaseVehicle_descr_;
extern const TTCN_Typedescriptor_t& TurningRadius_descr_;
extern const TTCN_Typedescriptor_t& PosFrontAx_descr_;
extern const TTCN_Typedescriptor_t& PositionOfOccupants_descr_;
extern const TTCN_JSONdescriptor_t PositioningSolutionType_json_;
extern const TTCN_Typedescriptor_t PositioningSolutionType_descr_;
extern const TTCN_JSONdescriptor_t VehicleIdentification_json_;
extern const TTCN_Typedescriptor_t VehicleIdentification_descr_;
extern const TTCN_Typedescriptor_t& WMInumber_descr_;
extern const ASN_BERdescriptor_t VehicleIdentification_wMInumber_ber_;
extern const TTCN_Typedescriptor_t VehicleIdentification_wMInumber_descr_;
extern const TTCN_Typedescriptor_t& VDS_descr_;
extern const ASN_BERdescriptor_t VehicleIdentification_vDS_ber_;
extern const TTCN_Typedescriptor_t VehicleIdentification_vDS_descr_;
extern const TTCN_Typedescriptor_t& EnergyStorageType_descr_;
extern const TTCN_Typedescriptor_t& VehicleLengthValue_descr_;
extern const ASN_BERdescriptor_t VehicleLength_vehicleLengthValue_ber_;
extern const TTCN_Typedescriptor_t VehicleLength_vehicleLengthValue_descr_;
extern const TTCN_JSONdescriptor_t VehicleLengthConfidenceIndication_json_;
extern const TTCN_Typedescriptor_t VehicleLengthConfidenceIndication_descr_;
extern const ASN_BERdescriptor_t VehicleLength_vehicleLengthConfidenceIndication_ber_;
extern const TTCN_Typedescriptor_t VehicleLength_vehicleLengthConfidenceIndication_descr_;
extern const TTCN_JSONdescriptor_t VehicleLength_json_;
extern const TTCN_Typedescriptor_t VehicleLength_descr_;
extern const TTCN_Typedescriptor_t& VehicleWidth_descr_;
extern const TTCN_JSONdescriptor_t PathHistory_json_;
extern const TTCN_Typedescriptor_t PathHistory_descr_;
extern const TTCN_Typedescriptor_t& EmergencyPriority_descr_;
extern const TTCN_Typedescriptor_t& InformationQuality_descr_;
extern const TTCN_JSONdescriptor_t RoadType_json_;
extern const TTCN_Typedescriptor_t RoadType_descr_;
extern const TTCN_Typedescriptor_t& SteeringWheelAngleValue_descr_;
extern const ASN_BERdescriptor_t SteeringWheelAngle_steeringWheelAngleValue_ber_;
extern const TTCN_Typedescriptor_t SteeringWheelAngle_steeringWheelAngleValue_descr_;
extern const TTCN_Typedescriptor_t& SteeringWheelAngleConfidence_descr_;
extern const ASN_BERdescriptor_t SteeringWheelAngle_steeringWheelAngleConfidence_ber_;
extern const TTCN_Typedescriptor_t SteeringWheelAngle_steeringWheelAngleConfidence_descr_;
extern const TTCN_JSONdescriptor_t SteeringWheelAngle_json_;
extern const TTCN_Typedescriptor_t SteeringWheelAngle_descr_;
extern const TTCN_Typedescriptor_t& TimestampIts_descr_;
extern const TTCN_JSONdescriptor_t VehicleRole_json_;
extern const TTCN_Typedescriptor_t VehicleRole_descr_;
extern const TTCN_Typedescriptor_t& YawRateValue_descr_;
extern const ASN_BERdescriptor_t YawRate_yawRateValue_ber_;
extern const TTCN_Typedescriptor_t YawRate_yawRateValue_descr_;
extern const TTCN_JSONdescriptor_t YawRateConfidence_json_;
extern const TTCN_Typedescriptor_t YawRateConfidence_descr_;
extern const ASN_BERdescriptor_t YawRate_yawRateConfidence_ber_;
extern const TTCN_Typedescriptor_t YawRate_yawRateConfidence_descr_;
extern const TTCN_JSONdescriptor_t YawRate_json_;
extern const TTCN_Typedescriptor_t YawRate_descr_;
extern const TTCN_JSONdescriptor_t ProtectedZoneType_json_;
extern const TTCN_Typedescriptor_t ProtectedZoneType_descr_;
extern const TTCN_JSONdescriptor_t RelevanceDistance_json_;
extern const TTCN_Typedescriptor_t RelevanceDistance_descr_;
extern const TTCN_JSONdescriptor_t RelevanceTrafficDirection_json_;
extern const TTCN_Typedescriptor_t RelevanceTrafficDirection_descr_;
extern const TTCN_Typedescriptor_t& TransmissionInterval_descr_;
extern const TTCN_Typedescriptor_t& ValidityDuration_descr_;
extern const ASN_BERdescriptor_t ActionID_originatingStationID_ber_;
extern const TTCN_Typedescriptor_t ActionID_originatingStationID_descr_;
extern const TTCN_Typedescriptor_t& SequenceNumber_descr_;
extern const ASN_BERdescriptor_t ActionID_sequenceNumber_ber_;
extern const TTCN_Typedescriptor_t ActionID_sequenceNumber_descr_;
extern const TTCN_JSONdescriptor_t ActionID_json_;
extern const TTCN_Typedescriptor_t ActionID_descr_;
extern const TTCN_JSONdescriptor_t ItineraryPath_json_;
extern const TTCN_Typedescriptor_t ItineraryPath_descr_;
extern const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneType_ber_;
extern const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneType_descr_;
extern const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneLatitude_ber_;
extern const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneLatitude_descr_;
extern const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneLongitude_ber_;
extern const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneLongitude_descr_;
extern const TTCN_JSONdescriptor_t ProtectedCommunicationZone_json_;
extern const TTCN_Typedescriptor_t ProtectedCommunicationZone_descr_;
extern const ASN_BERdescriptor_t ProtectedCommunicationZone_expiryTime_ber_;
extern const TTCN_Typedescriptor_t ProtectedCommunicationZone_expiryTime_descr_;
extern const TTCN_Typedescriptor_t& ProtectedZoneRadius_descr_;
extern const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneRadius_ber_;
extern const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneRadius_descr_;
extern const TTCN_Typedescriptor_t& ProtectedZoneID_descr_;
extern const ASN_BERdescriptor_t ProtectedCommunicationZone_protectedZoneID_ber_;
extern const TTCN_Typedescriptor_t ProtectedCommunicationZone_protectedZoneID_descr_;
extern const TTCN_JSONdescriptor_t Traces_json_;
extern const TTCN_Typedescriptor_t Traces_descr_;
extern const TTCN_Typedescriptor_t& NumberOfOccupants_descr_;
extern const TTCN_JSONdescriptor_t PositionOfPillars_json_;
extern const TTCN_Typedescriptor_t PositionOfPillars_descr_;
extern const TTCN_JSONdescriptor_t RestrictedTypes_json_;
extern const TTCN_Typedescriptor_t RestrictedTypes_descr_;
extern const TTCN_JSONdescriptor_t EventHistory_json_;
extern const TTCN_Typedescriptor_t EventHistory_descr_;
extern const ASN_BERdescriptor_t EventPoint_eventPosition_ber_;
extern const TTCN_Typedescriptor_t EventPoint_eventPosition_descr_;
extern const ASN_BERdescriptor_t EventPoint_informationQuality_ber_;
extern const TTCN_Typedescriptor_t EventPoint_informationQuality_descr_;
extern const TTCN_JSONdescriptor_t EventPoint_json_;
extern const TTCN_Typedescriptor_t EventPoint_descr_;
extern const ASN_BERdescriptor_t EventPoint_eventDeltaTime_ber_;
extern const TTCN_Typedescriptor_t EventPoint_eventDeltaTime_descr_;
extern const TTCN_JSONdescriptor_t ProtectedCommunicationZonesRSU_json_;
extern const TTCN_Typedescriptor_t ProtectedCommunicationZonesRSU_descr_;
extern const ASN_BERdescriptor_t CenDsrcTollingZone_protectedZoneLatitude_ber_;
extern const TTCN_Typedescriptor_t CenDsrcTollingZone_protectedZoneLatitude_descr_;
extern const ASN_BERdescriptor_t CenDsrcTollingZone_protectedZoneLongitude_ber_;
extern const TTCN_Typedescriptor_t CenDsrcTollingZone_protectedZoneLongitude_descr_;
extern const TTCN_JSONdescriptor_t CenDsrcTollingZone_json_;
extern const TTCN_Typedescriptor_t CenDsrcTollingZone_descr_;
extern const TTCN_Typedescriptor_t& CenDsrcTollingZoneID_descr_;
extern const ASN_BERdescriptor_t CenDsrcTollingZone_cenDsrcTollingZoneID_ber_;
extern const TTCN_Typedescriptor_t CenDsrcTollingZone_cenDsrcTollingZoneID_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
