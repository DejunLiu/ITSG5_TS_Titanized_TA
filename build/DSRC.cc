// This C++ source file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "DSRC.hh"

namespace DSRC {

/* Prototypes of static functions */

static void pre_init_module();

/* Global variable definitions */

const TTCN_Typedescriptor_t& DSRCmsgID2_descr_ = INTEGER_descr_;
static const ASN_Tag_t MapData_msgID_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t MapData_msgID_ber_ = { 1u, MapData_msgID_tag_ };
// No XER for MapData_msgID
const TTCN_Typedescriptor_t MapData_msgID_descr_ = { "@DSRC.MapData.msgID", &MapData_msgID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& MsgCount_descr_ = INTEGER_descr_;
static const ASN_Tag_t MapData_msgIssueRevision_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t MapData_msgIssueRevision_ber_ = { 1u, MapData_msgIssueRevision_tag_ };
// No XER for MapData_msgIssueRevision
const TTCN_Typedescriptor_t MapData_msgIssueRevision_descr_ = { "@DSRC.MapData.msgIssueRevision", &MapData_msgIssueRevision_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MapData
const TTCN_JSONdescriptor_t MapData_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t MapData_descr_ = { "@DSRC.MapData", &SEQUENCE_ber_, NULL, NULL, NULL, &MapData_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& DSRCmsgSubID_descr_ = INTEGER_descr_;
static const ASN_Tag_t MapData_msgSubID_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t MapData_msgSubID_ber_ = { 1u, MapData_msgSubID_tag_ };
// No XER for MapData_msgSubID
const TTCN_Typedescriptor_t MapData_msgSubID_descr_ = { "@DSRC.MapData.msgSubID", &MapData_msgSubID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LayerType
const TTCN_JSONdescriptor_t LayerType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LayerType_descr_ = { "@DSRC.LayerType", &ENUMERATED_ber_, NULL, NULL, NULL, &LayerType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MapData_layerType_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t MapData_layerType_ber_ = { 1u, MapData_layerType_tag_ };
// No XER for MapData_layerType
const TTCN_Typedescriptor_t MapData_layerType_descr_ = { "@DSRC.MapData.layerType", &MapData_layerType_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LayerID_descr_ = INTEGER_descr_;
static const ASN_Tag_t MapData_layerID_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t MapData_layerID_ber_ = { 1u, MapData_layerID_tag_ };
// No XER for MapData_layerID
const TTCN_Typedescriptor_t MapData_layerID_descr_ = { "@DSRC.MapData.layerID", &MapData_layerID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IntersectionGeometryList
const TTCN_JSONdescriptor_t IntersectionGeometryList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t IntersectionGeometryList_descr_ = { "@DSRC.IntersectionGeometryList", &SEQUENCE_ber_, NULL, NULL, NULL, &IntersectionGeometryList_json_, &IntersectionGeometry_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& IntersectionID_descr_ = INTEGER_descr_;
static const ASN_Tag_t IntersectionReferenceID_id_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t IntersectionReferenceID_id_ber_ = { 1u, IntersectionReferenceID_id_tag_ };
// No XER for IntersectionReferenceID_id
const TTCN_Typedescriptor_t IntersectionReferenceID_id_descr_ = { "@DSRC.IntersectionReferenceID.id", &IntersectionReferenceID_id_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IntersectionReferenceID
const TTCN_JSONdescriptor_t IntersectionReferenceID_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t IntersectionReferenceID_descr_ = { "@DSRC.IntersectionReferenceID", &SEQUENCE_ber_, NULL, NULL, NULL, &IntersectionReferenceID_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RoadRegulatorID_descr_ = INTEGER_descr_;
static const ASN_Tag_t IntersectionReferenceID_region_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t IntersectionReferenceID_region_ber_ = { 1u, IntersectionReferenceID_region_tag_ };
// No XER for IntersectionReferenceID_region
const TTCN_Typedescriptor_t IntersectionReferenceID_region_descr_ = { "@DSRC.IntersectionReferenceID.region", &IntersectionReferenceID_region_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionGeometry_id_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t IntersectionGeometry_id_ber_ = { 1u, IntersectionGeometry_id_tag_ };
// No XER for IntersectionGeometry_id
const TTCN_Typedescriptor_t IntersectionGeometry_id_descr_ = { "@DSRC.IntersectionGeometry.id", &IntersectionGeometry_id_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionGeometry_revision_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t IntersectionGeometry_revision_ber_ = { 1u, IntersectionGeometry_revision_tag_ };
// No XER for IntersectionGeometry_revision
const TTCN_Typedescriptor_t IntersectionGeometry_revision_descr_ = { "@DSRC.IntersectionGeometry.revision", &IntersectionGeometry_revision_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Position3D__2_lat_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t Position3D__2_lat_ber_ = { 1u, Position3D__2_lat_tag_ };
// No XER for Position3D__2_lat
const TTCN_Typedescriptor_t Position3D__2_lat_descr_ = { "@DSRC.Position3D-2.lat", &Position3D__2_lat_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Position3D__2_long__tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t Position3D__2_long__ber_ = { 1u, Position3D__2_long__tag_ };
// No XER for Position3D__2_long_
const TTCN_Typedescriptor_t Position3D__2_long__descr_ = { "@DSRC.Position3D-2.long", &Position3D__2_long__ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Position3D__2
const TTCN_JSONdescriptor_t Position3D__2_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Position3D__2_descr_ = { "@DSRC.Position3D-2", &SEQUENCE_ber_, NULL, NULL, NULL, &Position3D__2_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& Elevation2_descr_ = INTEGER_descr_;
static const ASN_Tag_t Position3D__2_elevation_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t Position3D__2_elevation_ber_ = { 1u, Position3D__2_elevation_tag_ };
// No XER for Position3D__2_elevation
const TTCN_Typedescriptor_t Position3D__2_elevation_descr_ = { "@DSRC.Position3D-2.elevation", &Position3D__2_elevation_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalPosition3D_descr_ = REG__D::Reg__Position3D_descr_;
static const ASN_Tag_t Position3D__2_regional_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t Position3D__2_regional_ber_ = { 1u, Position3D__2_regional_tag_ };
// No XER for Position3D__2_regional
const TTCN_Typedescriptor_t Position3D__2_regional_descr_ = { "@DSRC.Position3D-2.regional", &Position3D__2_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionGeometry_refPoint_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t IntersectionGeometry_refPoint_ber_ = { 1u, IntersectionGeometry_refPoint_tag_ };
// No XER for IntersectionGeometry_refPoint
const TTCN_Typedescriptor_t IntersectionGeometry_refPoint_descr_ = { "@DSRC.IntersectionGeometry.refPoint", &IntersectionGeometry_refPoint_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LaneList
const TTCN_JSONdescriptor_t LaneList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LaneList_descr_ = { "@DSRC.LaneList", &SEQUENCE_ber_, NULL, NULL, NULL, &LaneList_json_, &GenericLane_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t GenericLane_laneID_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t GenericLane_laneID_ber_ = { 1u, GenericLane_laneID_tag_ };
// No XER for GenericLane_laneID
const TTCN_Typedescriptor_t GenericLane_laneID_descr_ = { "@DSRC.GenericLane.laneID", &GenericLane_laneID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneDirection_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneAttributes_directionalUse_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t LaneAttributes_directionalUse_ber_ = { 1u, LaneAttributes_directionalUse_tag_ };
// No XER for LaneAttributes_directionalUse
const TTCN_Typedescriptor_t LaneAttributes_directionalUse_descr_ = { "@DSRC.LaneAttributes.directionalUse", &LaneAttributes_directionalUse_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneSharing_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneAttributes_sharedWith_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t LaneAttributes_sharedWith_ber_ = { 1u, LaneAttributes_sharedWith_tag_ };
// No XER for LaneAttributes_sharedWith
const TTCN_Typedescriptor_t LaneAttributes_sharedWith_descr_ = { "@DSRC.LaneAttributes.sharedWith", &LaneAttributes_sharedWith_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LaneTypeAttributes
const TTCN_JSONdescriptor_t LaneTypeAttributes_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LaneTypeAttributes_descr_ = { "@DSRC.LaneTypeAttributes", &CHOICE_ber_, NULL, NULL, NULL, &LaneTypeAttributes_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneAttributes__Vehicle_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneTypeAttributes_vehicle_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t LaneTypeAttributes_vehicle_ber_ = { 1u, LaneTypeAttributes_vehicle_tag_ };
// No XER for LaneTypeAttributes_vehicle
const TTCN_Typedescriptor_t LaneTypeAttributes_vehicle_descr_ = { "@DSRC.LaneTypeAttributes.vehicle", &LaneTypeAttributes_vehicle_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneAttributes__Crosswalk_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneTypeAttributes_crosswalk_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t LaneTypeAttributes_crosswalk_ber_ = { 1u, LaneTypeAttributes_crosswalk_tag_ };
// No XER for LaneTypeAttributes_crosswalk
const TTCN_Typedescriptor_t LaneTypeAttributes_crosswalk_descr_ = { "@DSRC.LaneTypeAttributes.crosswalk", &LaneTypeAttributes_crosswalk_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneAttributes__Bike_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneTypeAttributes_bikeLane_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t LaneTypeAttributes_bikeLane_ber_ = { 1u, LaneTypeAttributes_bikeLane_tag_ };
// No XER for LaneTypeAttributes_bikeLane
const TTCN_Typedescriptor_t LaneTypeAttributes_bikeLane_descr_ = { "@DSRC.LaneTypeAttributes.bikeLane", &LaneTypeAttributes_bikeLane_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneAttributes__Sidewalk_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneTypeAttributes_sidewalk_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t LaneTypeAttributes_sidewalk_ber_ = { 1u, LaneTypeAttributes_sidewalk_tag_ };
// No XER for LaneTypeAttributes_sidewalk
const TTCN_Typedescriptor_t LaneTypeAttributes_sidewalk_descr_ = { "@DSRC.LaneTypeAttributes.sidewalk", &LaneTypeAttributes_sidewalk_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneAttributes__Barrier_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneTypeAttributes_median_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t LaneTypeAttributes_median_ber_ = { 1u, LaneTypeAttributes_median_tag_ };
// No XER for LaneTypeAttributes_median
const TTCN_Typedescriptor_t LaneTypeAttributes_median_descr_ = { "@DSRC.LaneTypeAttributes.median", &LaneTypeAttributes_median_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneAttributes__Striping_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneTypeAttributes_striping_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t LaneTypeAttributes_striping_ber_ = { 1u, LaneTypeAttributes_striping_tag_ };
// No XER for LaneTypeAttributes_striping
const TTCN_Typedescriptor_t LaneTypeAttributes_striping_descr_ = { "@DSRC.LaneTypeAttributes.striping", &LaneTypeAttributes_striping_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneAttributes__TrackedVehicle_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneTypeAttributes_trackedVehicle_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t LaneTypeAttributes_trackedVehicle_ber_ = { 1u, LaneTypeAttributes_trackedVehicle_tag_ };
// No XER for LaneTypeAttributes_trackedVehicle
const TTCN_Typedescriptor_t LaneTypeAttributes_trackedVehicle_descr_ = { "@DSRC.LaneTypeAttributes.trackedVehicle", &LaneTypeAttributes_trackedVehicle_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneAttributes__Parking_descr_ = BITSTRING_descr_;
static const ASN_Tag_t LaneTypeAttributes_parking_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t LaneTypeAttributes_parking_ber_ = { 1u, LaneTypeAttributes_parking_tag_ };
// No XER for LaneTypeAttributes_parking
const TTCN_Typedescriptor_t LaneTypeAttributes_parking_descr_ = { "@DSRC.LaneTypeAttributes.parking", &LaneTypeAttributes_parking_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LaneAttributes_laneType_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t LaneAttributes_laneType_ber_ = { 1u, LaneAttributes_laneType_tag_ };
// No XER for LaneAttributes_laneType
const TTCN_Typedescriptor_t LaneAttributes_laneType_descr_ = { "@DSRC.LaneAttributes.laneType", &LaneAttributes_laneType_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LaneAttributes
const TTCN_JSONdescriptor_t LaneAttributes_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LaneAttributes_descr_ = { "@DSRC.LaneAttributes", &SEQUENCE_ber_, NULL, NULL, NULL, &LaneAttributes_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalLaneAttributes_descr_ = REGION::Reg__LaneAttributes_descr_;
static const ASN_Tag_t LaneAttributes_regional_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t LaneAttributes_regional_ber_ = { 1u, LaneAttributes_regional_tag_ };
// No XER for LaneAttributes_regional
const TTCN_Typedescriptor_t LaneAttributes_regional_descr_ = { "@DSRC.LaneAttributes.regional", &LaneAttributes_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t GenericLane_laneAttributes_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t GenericLane_laneAttributes_ber_ = { 1u, GenericLane_laneAttributes_tag_ };
// No XER for GenericLane_laneAttributes
const TTCN_Typedescriptor_t GenericLane_laneAttributes_descr_ = { "@DSRC.GenericLane.laneAttributes", &GenericLane_laneAttributes_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for NodeList2
const TTCN_JSONdescriptor_t NodeList2_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t NodeList2_descr_ = { "@DSRC.NodeList2", &CHOICE_ber_, NULL, NULL, NULL, &NodeList2_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for NodeSet
const TTCN_JSONdescriptor_t NodeSet_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t NodeSet_descr_ = { "@DSRC.NodeSet", &SEQUENCE_ber_, NULL, NULL, NULL, &NodeSet_json_, &Node_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Node_delta_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t Node_delta_ber_ = { 1u, Node_delta_tag_ };
// No XER for Node_delta
const TTCN_Typedescriptor_t Node_delta_descr_ = { "@DSRC.Node.delta", &Node_delta_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Node
const TTCN_JSONdescriptor_t Node_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Node_descr_ = { "@DSRC.Node", &SEQUENCE_ber_, NULL, NULL, NULL, &Node_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for NodeAttributeSet
const TTCN_JSONdescriptor_t NodeAttributeSet_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t NodeAttributeSet_descr_ = { "@DSRC.NodeAttributeSet", &SEQUENCE_ber_, NULL, NULL, NULL, &NodeAttributeSet_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for NodeAttributeList
const TTCN_JSONdescriptor_t NodeAttributeList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t NodeAttributeList_descr_ = { "@DSRC.NodeAttributeList", &SEQUENCE_ber_, NULL, NULL, NULL, &NodeAttributeList_json_, &NodeAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for NodeAttribute
const TTCN_JSONdescriptor_t NodeAttribute_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t NodeAttribute_descr_ = { "@DSRC.NodeAttribute", &ENUMERATED_ber_, NULL, NULL, NULL, &NodeAttribute_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t NodeAttributeSet_localNode_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t NodeAttributeSet_localNode_ber_ = { 1u, NodeAttributeSet_localNode_tag_ };
// No XER for NodeAttributeSet_localNode
const TTCN_Typedescriptor_t NodeAttributeSet_localNode_descr_ = { "@DSRC.NodeAttributeSet.localNode", &NodeAttributeSet_localNode_ber_, NULL, NULL, NULL, NULL, &NodeAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SegmentAttributeList
const TTCN_JSONdescriptor_t SegmentAttributeList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SegmentAttributeList_descr_ = { "@DSRC.SegmentAttributeList", &SEQUENCE_ber_, NULL, NULL, NULL, &SegmentAttributeList_json_, &SegmentAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SegmentAttribute
const TTCN_JSONdescriptor_t SegmentAttribute_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SegmentAttribute_descr_ = { "@DSRC.SegmentAttribute", &ENUMERATED_ber_, NULL, NULL, NULL, &SegmentAttribute_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t NodeAttributeSet_disabled_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t NodeAttributeSet_disabled_ber_ = { 1u, NodeAttributeSet_disabled_tag_ };
// No XER for NodeAttributeSet_disabled
const TTCN_Typedescriptor_t NodeAttributeSet_disabled_descr_ = { "@DSRC.NodeAttributeSet.disabled", &NodeAttributeSet_disabled_ber_, NULL, NULL, NULL, NULL, &SegmentAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t NodeAttributeSet_enabled_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t NodeAttributeSet_enabled_ber_ = { 1u, NodeAttributeSet_enabled_tag_ };
// No XER for NodeAttributeSet_enabled
const TTCN_Typedescriptor_t NodeAttributeSet_enabled_descr_ = { "@DSRC.NodeAttributeSet.enabled", &NodeAttributeSet_enabled_ber_, NULL, NULL, NULL, NULL, &SegmentAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LaneDataAttributeList
const TTCN_JSONdescriptor_t LaneDataAttributeList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LaneDataAttributeList_descr_ = { "@DSRC.LaneDataAttributeList", &SEQUENCE_ber_, NULL, NULL, NULL, &LaneDataAttributeList_json_, &LaneDataAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LaneDataAttribute
const TTCN_JSONdescriptor_t LaneDataAttribute_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LaneDataAttribute_descr_ = { "@DSRC.LaneDataAttribute", &CHOICE_ber_, NULL, NULL, NULL, &LaneDataAttribute_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& DeltaAngle_descr_ = INTEGER_descr_;
static const ASN_Tag_t LaneDataAttribute_pathEndPointAngle_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t LaneDataAttribute_pathEndPointAngle_ber_ = { 1u, LaneDataAttribute_pathEndPointAngle_tag_ };
// No XER for LaneDataAttribute_pathEndPointAngle
const TTCN_Typedescriptor_t LaneDataAttribute_pathEndPointAngle_descr_ = { "@DSRC.LaneDataAttribute.pathEndPointAngle", &LaneDataAttribute_pathEndPointAngle_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RoadwayCrownAngle_descr_ = INTEGER_descr_;
static const ASN_Tag_t LaneDataAttribute_laneCrownPointCenter_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t LaneDataAttribute_laneCrownPointCenter_ber_ = { 1u, LaneDataAttribute_laneCrownPointCenter_tag_ };
// No XER for LaneDataAttribute_laneCrownPointCenter
const TTCN_Typedescriptor_t LaneDataAttribute_laneCrownPointCenter_descr_ = { "@DSRC.LaneDataAttribute.laneCrownPointCenter", &LaneDataAttribute_laneCrownPointCenter_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LaneDataAttribute_laneCrownPointLeft_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t LaneDataAttribute_laneCrownPointLeft_ber_ = { 1u, LaneDataAttribute_laneCrownPointLeft_tag_ };
// No XER for LaneDataAttribute_laneCrownPointLeft
const TTCN_Typedescriptor_t LaneDataAttribute_laneCrownPointLeft_descr_ = { "@DSRC.LaneDataAttribute.laneCrownPointLeft", &LaneDataAttribute_laneCrownPointLeft_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LaneDataAttribute_laneCrownPointRight_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t LaneDataAttribute_laneCrownPointRight_ber_ = { 1u, LaneDataAttribute_laneCrownPointRight_tag_ };
// No XER for LaneDataAttribute_laneCrownPointRight
const TTCN_Typedescriptor_t LaneDataAttribute_laneCrownPointRight_descr_ = { "@DSRC.LaneDataAttribute.laneCrownPointRight", &LaneDataAttribute_laneCrownPointRight_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& MergeDivergeNodeAngle_descr_ = INTEGER_descr_;
static const ASN_Tag_t LaneDataAttribute_laneAngle_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t LaneDataAttribute_laneAngle_ber_ = { 1u, LaneDataAttribute_laneAngle_tag_ };
// No XER for LaneDataAttribute_laneAngle
const TTCN_Typedescriptor_t LaneDataAttribute_laneAngle_descr_ = { "@DSRC.LaneDataAttribute.laneAngle", &LaneDataAttribute_laneAngle_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SpeedLimitList
const TTCN_JSONdescriptor_t SpeedLimitList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SpeedLimitList_descr_ = { "@DSRC.SpeedLimitList", &SEQUENCE_ber_, NULL, NULL, NULL, &SpeedLimitList_json_, &RegulatorySpeedLimit_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SpeedLimitType
const TTCN_JSONdescriptor_t SpeedLimitType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SpeedLimitType_descr_ = { "@DSRC.SpeedLimitType", &ENUMERATED_ber_, NULL, NULL, NULL, &SpeedLimitType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RegulatorySpeedLimit_type___tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t RegulatorySpeedLimit_type___ber_ = { 1u, RegulatorySpeedLimit_type___tag_ };
// No XER for RegulatorySpeedLimit_type__
const TTCN_Typedescriptor_t RegulatorySpeedLimit_type___descr_ = { "@DSRC.RegulatorySpeedLimit.type", &RegulatorySpeedLimit_type___ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& Velocity_descr_ = INTEGER_descr_;
static const ASN_Tag_t RegulatorySpeedLimit_speed_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t RegulatorySpeedLimit_speed_ber_ = { 1u, RegulatorySpeedLimit_speed_tag_ };
// No XER for RegulatorySpeedLimit_speed
const TTCN_Typedescriptor_t RegulatorySpeedLimit_speed_descr_ = { "@DSRC.RegulatorySpeedLimit.speed", &RegulatorySpeedLimit_speed_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RegulatorySpeedLimit
const TTCN_JSONdescriptor_t RegulatorySpeedLimit_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RegulatorySpeedLimit_descr_ = { "@DSRC.RegulatorySpeedLimit", &SEQUENCE_ber_, NULL, NULL, NULL, &RegulatorySpeedLimit_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LaneDataAttribute_speedLimits_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t LaneDataAttribute_speedLimits_ber_ = { 1u, LaneDataAttribute_speedLimits_tag_ };
// No XER for LaneDataAttribute_speedLimits
const TTCN_Typedescriptor_t LaneDataAttribute_speedLimits_descr_ = { "@DSRC.LaneDataAttribute.speedLimits", &LaneDataAttribute_speedLimits_ber_, NULL, NULL, NULL, NULL, &RegulatorySpeedLimit_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalLaneDataAttribute_descr_ = REGION::Reg__LaneDataAttribute_descr_;
static const ASN_Tag_t LaneDataAttribute_regional_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t LaneDataAttribute_regional_ber_ = { 1u, LaneDataAttribute_regional_tag_ };
// No XER for LaneDataAttribute_regional
const TTCN_Typedescriptor_t LaneDataAttribute_regional_descr_ = { "@DSRC.LaneDataAttribute.regional", &LaneDataAttribute_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t NodeAttributeSet_data_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t NodeAttributeSet_data_ber_ = { 1u, NodeAttributeSet_data_tag_ };
// No XER for NodeAttributeSet_data
const TTCN_Typedescriptor_t NodeAttributeSet_data_descr_ = { "@DSRC.NodeAttributeSet.data", &NodeAttributeSet_data_ber_, NULL, NULL, NULL, NULL, &LaneDataAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RegionalNodeAttributeList
const TTCN_JSONdescriptor_t RegionalNodeAttributeList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RegionalNodeAttributeList_descr_ = { "@DSRC.RegionalNodeAttributeList", &SEQUENCE_ber_, NULL, NULL, NULL, &RegionalNodeAttributeList_json_, &REGION::Reg__NodeAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalNodeAttribute_descr_ = REGION::Reg__NodeAttribute_descr_;
static const ASN_Tag_t NodeAttributeSet_regional_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t NodeAttributeSet_regional_ber_ = { 1u, NodeAttributeSet_regional_tag_ };
// No XER for NodeAttributeSet_regional
const TTCN_Typedescriptor_t NodeAttributeSet_regional_descr_ = { "@DSRC.NodeAttributeSet.regional", &NodeAttributeSet_regional_ber_, NULL, NULL, NULL, NULL, &REGION::Reg__NodeAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t NodeAttributeSet_dWidth_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t NodeAttributeSet_dWidth_ber_ = { 1u, NodeAttributeSet_dWidth_tag_ };
// No XER for NodeAttributeSet_dWidth
const TTCN_Typedescriptor_t NodeAttributeSet_dWidth_descr_ = { "@DSRC.NodeAttributeSet.dWidth", &NodeAttributeSet_dWidth_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t NodeAttributeSet_dElevation_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t NodeAttributeSet_dElevation_ber_ = { 1u, NodeAttributeSet_dElevation_tag_ };
// No XER for NodeAttributeSet_dElevation
const TTCN_Typedescriptor_t NodeAttributeSet_dElevation_descr_ = { "@DSRC.NodeAttributeSet.dElevation", &NodeAttributeSet_dElevation_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Node_attributes_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t Node_attributes_ber_ = { 1u, Node_attributes_tag_ };
// No XER for Node_attributes
const TTCN_Typedescriptor_t Node_attributes_descr_ = { "@DSRC.Node.attributes", &Node_attributes_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t NodeList2_nodes_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t NodeList2_nodes_ber_ = { 1u, NodeList2_nodes_tag_ };
// No XER for NodeList2_nodes
const TTCN_Typedescriptor_t NodeList2_nodes_descr_ = { "@DSRC.NodeList2.nodes", &NodeList2_nodes_ber_, NULL, NULL, NULL, NULL, &Node_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ComputedLane_referenceLaneId_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ComputedLane_referenceLaneId_ber_ = { 1u, ComputedLane_referenceLaneId_tag_ };
// No XER for ComputedLane_referenceLaneId
const TTCN_Typedescriptor_t ComputedLane_referenceLaneId_descr_ = { "@DSRC.ComputedLane.referenceLaneId", &ComputedLane_referenceLaneId_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ComputedLane_offsetXaxis_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ComputedLane_offsetXaxis_ber_ = { 1u, ComputedLane_offsetXaxis_tag_ };
// No XER for ComputedLane_offsetXaxis
const TTCN_JSONdescriptor_t ComputedLane_offsetXaxis_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ComputedLane_offsetXaxis_descr_ = { "@DSRC.ComputedLane.offsetXaxis", &ComputedLane_offsetXaxis_ber_, NULL, NULL, NULL, &ComputedLane_offsetXaxis_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& DrivenLineOffsetSm_descr_ = INTEGER_descr_;
static const ASN_Tag_t ComputedLane_offsetXaxis_small_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ComputedLane_offsetXaxis_small_ber_ = { 1u, ComputedLane_offsetXaxis_small_tag_ };
// No XER for ComputedLane_offsetXaxis_small
const TTCN_Typedescriptor_t ComputedLane_offsetXaxis_small_descr_ = { "@DSRC.ComputedLane.offsetXaxis.small", &ComputedLane_offsetXaxis_small_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& DrivenLineOffsetLg_descr_ = INTEGER_descr_;
static const ASN_Tag_t ComputedLane_offsetXaxis_large_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ComputedLane_offsetXaxis_large_ber_ = { 1u, ComputedLane_offsetXaxis_large_tag_ };
// No XER for ComputedLane_offsetXaxis_large
const TTCN_Typedescriptor_t ComputedLane_offsetXaxis_large_descr_ = { "@DSRC.ComputedLane.offsetXaxis.large", &ComputedLane_offsetXaxis_large_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ComputedLane_offsetYaxis_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t ComputedLane_offsetYaxis_ber_ = { 1u, ComputedLane_offsetYaxis_tag_ };
// No XER for ComputedLane_offsetYaxis
const TTCN_JSONdescriptor_t ComputedLane_offsetYaxis_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ComputedLane_offsetYaxis_descr_ = { "@DSRC.ComputedLane.offsetYaxis", &ComputedLane_offsetYaxis_ber_, NULL, NULL, NULL, &ComputedLane_offsetYaxis_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ComputedLane_offsetYaxis_small_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ComputedLane_offsetYaxis_small_ber_ = { 1u, ComputedLane_offsetYaxis_small_tag_ };
// No XER for ComputedLane_offsetYaxis_small
const TTCN_Typedescriptor_t ComputedLane_offsetYaxis_small_descr_ = { "@DSRC.ComputedLane.offsetYaxis.small", &ComputedLane_offsetYaxis_small_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ComputedLane_offsetYaxis_large_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ComputedLane_offsetYaxis_large_ber_ = { 1u, ComputedLane_offsetYaxis_large_tag_ };
// No XER for ComputedLane_offsetYaxis_large
const TTCN_Typedescriptor_t ComputedLane_offsetYaxis_large_descr_ = { "@DSRC.ComputedLane.offsetYaxis.large", &ComputedLane_offsetYaxis_large_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ComputedLane
const TTCN_JSONdescriptor_t ComputedLane_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ComputedLane_descr_ = { "@DSRC.ComputedLane", &SEQUENCE_ber_, NULL, NULL, NULL, &ComputedLane_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& Angle_descr_ = INTEGER_descr_;
static const ASN_Tag_t ComputedLane_rotateXY_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t ComputedLane_rotateXY_ber_ = { 1u, ComputedLane_rotateXY_tag_ };
// No XER for ComputedLane_rotateXY
const TTCN_Typedescriptor_t ComputedLane_rotateXY_descr_ = { "@DSRC.ComputedLane.rotateXY", &ComputedLane_rotateXY_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& Scale__B12_descr_ = INTEGER_descr_;
static const ASN_Tag_t ComputedLane_scaleXaxis_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t ComputedLane_scaleXaxis_ber_ = { 1u, ComputedLane_scaleXaxis_tag_ };
// No XER for ComputedLane_scaleXaxis
const TTCN_Typedescriptor_t ComputedLane_scaleXaxis_descr_ = { "@DSRC.ComputedLane.scaleXaxis", &ComputedLane_scaleXaxis_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ComputedLane_scaleYaxis_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t ComputedLane_scaleYaxis_ber_ = { 1u, ComputedLane_scaleYaxis_tag_ };
// No XER for ComputedLane_scaleYaxis
const TTCN_Typedescriptor_t ComputedLane_scaleYaxis_descr_ = { "@DSRC.ComputedLane.scaleYaxis", &ComputedLane_scaleYaxis_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalComputedLane_descr_ = REGION::Reg__ComputedLane_descr_;
static const ASN_Tag_t ComputedLane_regional_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t ComputedLane_regional_ber_ = { 1u, ComputedLane_regional_tag_ };
// No XER for ComputedLane_regional
const TTCN_Typedescriptor_t ComputedLane_regional_descr_ = { "@DSRC.ComputedLane.regional", &ComputedLane_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t NodeList2_computed_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t NodeList2_computed_ber_ = { 1u, NodeList2_computed_tag_ };
// No XER for NodeList2_computed
const TTCN_Typedescriptor_t NodeList2_computed_descr_ = { "@DSRC.NodeList2.computed", &NodeList2_computed_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t GenericLane_nodeList_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t GenericLane_nodeList_ber_ = { 1u, GenericLane_nodeList_tag_ };
// No XER for GenericLane_nodeList
const TTCN_Typedescriptor_t GenericLane_nodeList_descr_ = { "@DSRC.GenericLane.nodeList", &GenericLane_nodeList_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for GenericLane
const TTCN_JSONdescriptor_t GenericLane_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GenericLane_descr_ = { "@DSRC.GenericLane", &SEQUENCE_ber_, NULL, NULL, NULL, &GenericLane_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& DescriptiveName_descr_ = IA5String_descr_;
static const ASN_Tag_t GenericLane_name_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t GenericLane_name_ber_ = { 1u, GenericLane_name_tag_ };
// No XER for GenericLane_name
const TTCN_Typedescriptor_t GenericLane_name_descr_ = { "@DSRC.GenericLane.name", &GenericLane_name_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& ApproachID_descr_ = INTEGER_descr_;
static const ASN_Tag_t GenericLane_ingressApproach_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t GenericLane_ingressApproach_ber_ = { 1u, GenericLane_ingressApproach_tag_ };
// No XER for GenericLane_ingressApproach
const TTCN_Typedescriptor_t GenericLane_ingressApproach_descr_ = { "@DSRC.GenericLane.ingressApproach", &GenericLane_ingressApproach_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t GenericLane_egressApproach_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t GenericLane_egressApproach_ber_ = { 1u, GenericLane_egressApproach_tag_ };
// No XER for GenericLane_egressApproach
const TTCN_Typedescriptor_t GenericLane_egressApproach_descr_ = { "@DSRC.GenericLane.egressApproach", &GenericLane_egressApproach_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& AllowedManeuvers_descr_ = BITSTRING_descr_;
static const ASN_Tag_t GenericLane_maneuvers_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t GenericLane_maneuvers_ber_ = { 1u, GenericLane_maneuvers_tag_ };
// No XER for GenericLane_maneuvers
const TTCN_Typedescriptor_t GenericLane_maneuvers_descr_ = { "@DSRC.GenericLane.maneuvers", &GenericLane_maneuvers_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ConnectsToList
const TTCN_JSONdescriptor_t ConnectsToList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ConnectsToList_descr_ = { "@DSRC.ConnectsToList", &SEQUENCE_ber_, NULL, NULL, NULL, &ConnectsToList_json_, &Connection_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ConnectingLane_lane_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ConnectingLane_lane_ber_ = { 1u, ConnectingLane_lane_tag_ };
// No XER for ConnectingLane_lane
const TTCN_Typedescriptor_t ConnectingLane_lane_descr_ = { "@DSRC.ConnectingLane.lane", &ConnectingLane_lane_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ConnectingLane
const TTCN_JSONdescriptor_t ConnectingLane_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ConnectingLane_descr_ = { "@DSRC.ConnectingLane", &SEQUENCE_ber_, NULL, NULL, NULL, &ConnectingLane_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ConnectingLane_maneuver_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ConnectingLane_maneuver_ber_ = { 1u, ConnectingLane_maneuver_tag_ };
// No XER for ConnectingLane_maneuver
const TTCN_Typedescriptor_t ConnectingLane_maneuver_descr_ = { "@DSRC.ConnectingLane.maneuver", &ConnectingLane_maneuver_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Connection_connectingLane_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t Connection_connectingLane_ber_ = { 1u, Connection_connectingLane_tag_ };
// No XER for Connection_connectingLane
const TTCN_Typedescriptor_t Connection_connectingLane_descr_ = { "@DSRC.Connection.connectingLane", &Connection_connectingLane_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Connection
const TTCN_JSONdescriptor_t Connection_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Connection_descr_ = { "@DSRC.Connection", &SEQUENCE_ber_, NULL, NULL, NULL, &Connection_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Connection_remoteIntersection_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t Connection_remoteIntersection_ber_ = { 1u, Connection_remoteIntersection_tag_ };
// No XER for Connection_remoteIntersection
const TTCN_Typedescriptor_t Connection_remoteIntersection_descr_ = { "@DSRC.Connection.remoteIntersection", &Connection_remoteIntersection_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t Connection_signalGroup_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t Connection_signalGroup_ber_ = { 1u, Connection_signalGroup_tag_ };
// No XER for Connection_signalGroup
const TTCN_Typedescriptor_t Connection_signalGroup_descr_ = { "@DSRC.Connection.signalGroup", &Connection_signalGroup_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RestrictionClassID_descr_ = INTEGER_descr_;
static const ASN_Tag_t Connection_userClass_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t Connection_userClass_ber_ = { 1u, Connection_userClass_tag_ };
// No XER for Connection_userClass
const TTCN_Typedescriptor_t Connection_userClass_descr_ = { "@DSRC.Connection.userClass", &Connection_userClass_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneConnectionID_descr_ = INTEGER_descr_;
static const ASN_Tag_t Connection_connectionID_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t Connection_connectionID_ber_ = { 1u, Connection_connectionID_tag_ };
// No XER for Connection_connectionID
const TTCN_Typedescriptor_t Connection_connectionID_descr_ = { "@DSRC.Connection.connectionID", &Connection_connectionID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t GenericLane_connectsTo_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t GenericLane_connectsTo_ber_ = { 1u, GenericLane_connectsTo_tag_ };
// No XER for GenericLane_connectsTo
const TTCN_Typedescriptor_t GenericLane_connectsTo_descr_ = { "@DSRC.GenericLane.connectsTo", &GenericLane_connectsTo_ber_, NULL, NULL, NULL, NULL, &Connection_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for OverlayLaneList
const TTCN_JSONdescriptor_t OverlayLaneList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t OverlayLaneList_descr_ = { "@DSRC.OverlayLaneList", &SEQUENCE_ber_, NULL, NULL, NULL, &OverlayLaneList_json_, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t GenericLane_overlays_tag_[] = { { ASN_TAG_CONT, 8u }};
const ASN_BERdescriptor_t GenericLane_overlays_ber_ = { 1u, GenericLane_overlays_tag_ };
// No XER for GenericLane_overlays
const TTCN_Typedescriptor_t GenericLane_overlays_descr_ = { "@DSRC.GenericLane.overlays", &GenericLane_overlays_ber_, NULL, NULL, NULL, NULL, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalGenericLane_descr_ = REGION::Reg__GenericLane_descr_;
static const ASN_Tag_t GenericLane_regional_tag_[] = { { ASN_TAG_CONT, 9u }};
const ASN_BERdescriptor_t GenericLane_regional_ber_ = { 1u, GenericLane_regional_tag_ };
// No XER for GenericLane_regional
const TTCN_Typedescriptor_t GenericLane_regional_descr_ = { "@DSRC.GenericLane.regional", &GenericLane_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionGeometry_laneSet_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t IntersectionGeometry_laneSet_ber_ = { 1u, IntersectionGeometry_laneSet_tag_ };
// No XER for IntersectionGeometry_laneSet
const TTCN_Typedescriptor_t IntersectionGeometry_laneSet_descr_ = { "@DSRC.IntersectionGeometry.laneSet", &IntersectionGeometry_laneSet_ber_, NULL, NULL, NULL, NULL, &GenericLane_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IntersectionGeometry
const TTCN_JSONdescriptor_t IntersectionGeometry_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t IntersectionGeometry_descr_ = { "@DSRC.IntersectionGeometry", &SEQUENCE_ber_, NULL, NULL, NULL, &IntersectionGeometry_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionGeometry_name_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t IntersectionGeometry_name_ber_ = { 1u, IntersectionGeometry_name_tag_ };
// No XER for IntersectionGeometry_name
const TTCN_Typedescriptor_t IntersectionGeometry_name_descr_ = { "@DSRC.IntersectionGeometry.name", &IntersectionGeometry_name_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& LaneWidth_descr_ = INTEGER_descr_;
static const ASN_Tag_t IntersectionGeometry_laneWidth_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t IntersectionGeometry_laneWidth_ber_ = { 1u, IntersectionGeometry_laneWidth_tag_ };
// No XER for IntersectionGeometry_laneWidth
const TTCN_Typedescriptor_t IntersectionGeometry_laneWidth_descr_ = { "@DSRC.IntersectionGeometry.laneWidth", &IntersectionGeometry_laneWidth_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionGeometry_speedLimits_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t IntersectionGeometry_speedLimits_ber_ = { 1u, IntersectionGeometry_speedLimits_tag_ };
// No XER for IntersectionGeometry_speedLimits
const TTCN_Typedescriptor_t IntersectionGeometry_speedLimits_descr_ = { "@DSRC.IntersectionGeometry.speedLimits", &IntersectionGeometry_speedLimits_ber_, NULL, NULL, NULL, NULL, &RegulatorySpeedLimit_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for PreemptPriorityList
const TTCN_JSONdescriptor_t PreemptPriorityList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PreemptPriorityList_descr_ = { "@DSRC.PreemptPriorityList", &SEQUENCE_ber_, NULL, NULL, NULL, &PreemptPriorityList_json_, &REGION::Reg__SignalControlZone_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalSignalControlZone_descr_ = REGION::Reg__SignalControlZone_descr_;
static const ASN_Tag_t IntersectionGeometry_preemptPriorityData_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t IntersectionGeometry_preemptPriorityData_ber_ = { 1u, IntersectionGeometry_preemptPriorityData_tag_ };
// No XER for IntersectionGeometry_preemptPriorityData
const TTCN_Typedescriptor_t IntersectionGeometry_preemptPriorityData_descr_ = { "@DSRC.IntersectionGeometry.preemptPriorityData", &IntersectionGeometry_preemptPriorityData_ber_, NULL, NULL, NULL, NULL, &REGION::Reg__SignalControlZone_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalIntersection_descr_ = REGION::Reg__Intersection_descr_;
static const ASN_Tag_t IntersectionGeometry_regional_tag_[] = { { ASN_TAG_CONT, 8u }};
const ASN_BERdescriptor_t IntersectionGeometry_regional_ber_ = { 1u, IntersectionGeometry_regional_tag_ };
// No XER for IntersectionGeometry_regional
const TTCN_Typedescriptor_t IntersectionGeometry_regional_descr_ = { "@DSRC.IntersectionGeometry.regional", &IntersectionGeometry_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MapData_intersections_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t MapData_intersections_ber_ = { 1u, MapData_intersections_tag_ };
// No XER for MapData_intersections
const TTCN_Typedescriptor_t MapData_intersections_descr_ = { "@DSRC.MapData.intersections", &MapData_intersections_ber_, NULL, NULL, NULL, NULL, &IntersectionGeometry_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RoadSegmentList
const TTCN_JSONdescriptor_t RoadSegmentList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RoadSegmentList_descr_ = { "@DSRC.RoadSegmentList", &SEQUENCE_ber_, NULL, NULL, NULL, &RoadSegmentList_json_, &RoadSegment_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RoadSegmentID_descr_ = INTEGER_descr_;
static const ASN_Tag_t RoadSegmentReferenceID_id_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t RoadSegmentReferenceID_id_ber_ = { 1u, RoadSegmentReferenceID_id_tag_ };
// No XER for RoadSegmentReferenceID_id
const TTCN_Typedescriptor_t RoadSegmentReferenceID_id_descr_ = { "@DSRC.RoadSegmentReferenceID.id", &RoadSegmentReferenceID_id_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RoadSegmentReferenceID
const TTCN_JSONdescriptor_t RoadSegmentReferenceID_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RoadSegmentReferenceID_descr_ = { "@DSRC.RoadSegmentReferenceID", &SEQUENCE_ber_, NULL, NULL, NULL, &RoadSegmentReferenceID_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadSegmentReferenceID_region_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t RoadSegmentReferenceID_region_ber_ = { 1u, RoadSegmentReferenceID_region_tag_ };
// No XER for RoadSegmentReferenceID_region
const TTCN_Typedescriptor_t RoadSegmentReferenceID_region_descr_ = { "@DSRC.RoadSegmentReferenceID.region", &RoadSegmentReferenceID_region_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadSegment_id_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t RoadSegment_id_ber_ = { 1u, RoadSegment_id_tag_ };
// No XER for RoadSegment_id
const TTCN_Typedescriptor_t RoadSegment_id_descr_ = { "@DSRC.RoadSegment.id", &RoadSegment_id_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadSegment_revision_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t RoadSegment_revision_ber_ = { 1u, RoadSegment_revision_tag_ };
// No XER for RoadSegment_revision
const TTCN_Typedescriptor_t RoadSegment_revision_descr_ = { "@DSRC.RoadSegment.revision", &RoadSegment_revision_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadSegment_refPoint_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t RoadSegment_refPoint_ber_ = { 1u, RoadSegment_refPoint_tag_ };
// No XER for RoadSegment_refPoint
const TTCN_Typedescriptor_t RoadSegment_refPoint_descr_ = { "@DSRC.RoadSegment.refPoint", &RoadSegment_refPoint_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RoadLaneSetList
const TTCN_JSONdescriptor_t RoadLaneSetList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RoadLaneSetList_descr_ = { "@DSRC.RoadLaneSetList", &SEQUENCE_ber_, NULL, NULL, NULL, &RoadLaneSetList_json_, &GenericLane_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadSegment_roadLaneSet_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t RoadSegment_roadLaneSet_ber_ = { 1u, RoadSegment_roadLaneSet_tag_ };
// No XER for RoadSegment_roadLaneSet
const TTCN_Typedescriptor_t RoadSegment_roadLaneSet_descr_ = { "@DSRC.RoadSegment.roadLaneSet", &RoadSegment_roadLaneSet_ber_, NULL, NULL, NULL, NULL, &GenericLane_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RoadSegment
const TTCN_JSONdescriptor_t RoadSegment_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RoadSegment_descr_ = { "@DSRC.RoadSegment", &SEQUENCE_ber_, NULL, NULL, NULL, &RoadSegment_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadSegment_name_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t RoadSegment_name_ber_ = { 1u, RoadSegment_name_tag_ };
// No XER for RoadSegment_name
const TTCN_Typedescriptor_t RoadSegment_name_descr_ = { "@DSRC.RoadSegment.name", &RoadSegment_name_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadSegment_laneWidth_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t RoadSegment_laneWidth_ber_ = { 1u, RoadSegment_laneWidth_tag_ };
// No XER for RoadSegment_laneWidth
const TTCN_Typedescriptor_t RoadSegment_laneWidth_descr_ = { "@DSRC.RoadSegment.laneWidth", &RoadSegment_laneWidth_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadSegment_speedLimits_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t RoadSegment_speedLimits_ber_ = { 1u, RoadSegment_speedLimits_tag_ };
// No XER for RoadSegment_speedLimits
const TTCN_Typedescriptor_t RoadSegment_speedLimits_descr_ = { "@DSRC.RoadSegment.speedLimits", &RoadSegment_speedLimits_ber_, NULL, NULL, NULL, NULL, &RegulatorySpeedLimit_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalRoadSegment_descr_ = REGION::Reg__RoadSegment_descr_;
static const ASN_Tag_t RoadSegment_regional_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t RoadSegment_regional_ber_ = { 1u, RoadSegment_regional_tag_ };
// No XER for RoadSegment_regional
const TTCN_Typedescriptor_t RoadSegment_regional_descr_ = { "@DSRC.RoadSegment.regional", &RoadSegment_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MapData_roadSegments_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t MapData_roadSegments_ber_ = { 1u, MapData_roadSegments_tag_ };
// No XER for MapData_roadSegments
const TTCN_Typedescriptor_t MapData_roadSegments_descr_ = { "@DSRC.MapData.roadSegments", &MapData_roadSegments_ber_, NULL, NULL, NULL, NULL, &RoadSegment_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for DataParameters
const TTCN_JSONdescriptor_t DataParameters_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DataParameters_descr_ = { "@DSRC.DataParameters", &SEQUENCE_ber_, NULL, NULL, NULL, &DataParameters_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DataParameters_processMethod_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t DataParameters_processMethod_ber_ = { 1u, DataParameters_processMethod_tag_ };
// No XER for DataParameters_processMethod
const TTCN_Typedescriptor_t DataParameters_processMethod_descr_ = { "@DSRC.DataParameters.processMethod", &DataParameters_processMethod_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DataParameters_processAgency_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t DataParameters_processAgency_ber_ = { 1u, DataParameters_processAgency_tag_ };
// No XER for DataParameters_processAgency
const TTCN_Typedescriptor_t DataParameters_processAgency_descr_ = { "@DSRC.DataParameters.processAgency", &DataParameters_processAgency_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DataParameters_lastCheckedDate_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t DataParameters_lastCheckedDate_ber_ = { 1u, DataParameters_lastCheckedDate_tag_ };
// No XER for DataParameters_lastCheckedDate
const TTCN_Typedescriptor_t DataParameters_lastCheckedDate_descr_ = { "@DSRC.DataParameters.lastCheckedDate", &DataParameters_lastCheckedDate_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DataParameters_geoidUsed_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t DataParameters_geoidUsed_ber_ = { 1u, DataParameters_geoidUsed_tag_ };
// No XER for DataParameters_geoidUsed
const TTCN_Typedescriptor_t DataParameters_geoidUsed_descr_ = { "@DSRC.DataParameters.geoidUsed", &DataParameters_geoidUsed_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MapData_dataParameters_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t MapData_dataParameters_ber_ = { 1u, MapData_dataParameters_tag_ };
// No XER for MapData_dataParameters
const TTCN_Typedescriptor_t MapData_dataParameters_descr_ = { "@DSRC.MapData.dataParameters", &MapData_dataParameters_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RestrictionClassList
const TTCN_JSONdescriptor_t RestrictionClassList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RestrictionClassList_descr_ = { "@DSRC.RestrictionClassList", &SEQUENCE_ber_, NULL, NULL, NULL, &RestrictionClassList_json_, &RestrictionClassAssignment_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RestrictionClassAssignment_id_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t RestrictionClassAssignment_id_ber_ = { 1u, RestrictionClassAssignment_id_tag_ };
// No XER for RestrictionClassAssignment_id
const TTCN_Typedescriptor_t RestrictionClassAssignment_id_descr_ = { "@DSRC.RestrictionClassAssignment.id", &RestrictionClassAssignment_id_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RestrictionUserTypeList
const TTCN_JSONdescriptor_t RestrictionUserTypeList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RestrictionUserTypeList_descr_ = { "@DSRC.RestrictionUserTypeList", &SEQUENCE_ber_, NULL, NULL, NULL, &RestrictionUserTypeList_json_, &RestrictionUserType_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RestrictionUserType
const TTCN_JSONdescriptor_t RestrictionUserType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RestrictionUserType_descr_ = { "@DSRC.RestrictionUserType", &CHOICE_ber_, NULL, NULL, NULL, &RestrictionUserType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RestrictionAppliesTo
const TTCN_JSONdescriptor_t RestrictionAppliesTo_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RestrictionAppliesTo_descr_ = { "@DSRC.RestrictionAppliesTo", &ENUMERATED_ber_, NULL, NULL, NULL, &RestrictionAppliesTo_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RestrictionUserType_basicType_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t RestrictionUserType_basicType_ber_ = { 1u, RestrictionUserType_basicType_tag_ };
// No XER for RestrictionUserType_basicType
const TTCN_Typedescriptor_t RestrictionUserType_basicType_descr_ = { "@DSRC.RestrictionUserType.basicType", &RestrictionUserType_basicType_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalRestrictionUserType_descr_ = REG__D::Reg__RestrictionUserType_descr_;
static const ASN_Tag_t RestrictionUserType_regional_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t RestrictionUserType_regional_ber_ = { 1u, RestrictionUserType_regional_tag_ };
// No XER for RestrictionUserType_regional
const TTCN_Typedescriptor_t RestrictionUserType_regional_descr_ = { "@DSRC.RestrictionUserType.regional", &RestrictionUserType_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RestrictionClassAssignment_users_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t RestrictionClassAssignment_users_ber_ = { 1u, RestrictionClassAssignment_users_tag_ };
// No XER for RestrictionClassAssignment_users
const TTCN_Typedescriptor_t RestrictionClassAssignment_users_descr_ = { "@DSRC.RestrictionClassAssignment.users", &RestrictionClassAssignment_users_ber_, NULL, NULL, NULL, NULL, &RestrictionUserType_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RestrictionClassAssignment
const TTCN_JSONdescriptor_t RestrictionClassAssignment_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RestrictionClassAssignment_descr_ = { "@DSRC.RestrictionClassAssignment", &SEQUENCE_ber_, NULL, NULL, NULL, &RestrictionClassAssignment_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MapData_restrictionList_tag_[] = { { ASN_TAG_CONT, 8u }};
const ASN_BERdescriptor_t MapData_restrictionList_ber_ = { 1u, MapData_restrictionList_tag_ };
// No XER for MapData_restrictionList
const TTCN_Typedescriptor_t MapData_restrictionList_descr_ = { "@DSRC.MapData.restrictionList", &MapData_restrictionList_ber_, NULL, NULL, NULL, NULL, &RestrictionClassAssignment_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalMapData_descr_ = REG__D::Reg__MapData_descr_;
static const ASN_Tag_t MapData_regional_tag_[] = { { ASN_TAG_CONT, 9u }};
const ASN_BERdescriptor_t MapData_regional_ber_ = { 1u, MapData_regional_tag_ };
// No XER for MapData_regional
const TTCN_Typedescriptor_t MapData_regional_descr_ = { "@DSRC.MapData.regional", &MapData_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& MsgCRC_descr_ = OCTETSTRING_descr_;
static const ASN_Tag_t MapData_crc_tag_[] = { { ASN_TAG_CONT, 10u }};
const ASN_BERdescriptor_t MapData_crc_ber_ = { 1u, MapData_crc_tag_ };
// No XER for MapData_crc
const TTCN_Typedescriptor_t MapData_crc_descr_ = { "@DSRC.MapData.crc", &MapData_crc_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, NULL, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SPAT_msgID_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t SPAT_msgID_ber_ = { 1u, SPAT_msgID_tag_ };
// No XER for SPAT_msgID
const TTCN_Typedescriptor_t SPAT_msgID_descr_ = { "@DSRC.SPAT.msgID", &SPAT_msgID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IntersectionStateList
const TTCN_JSONdescriptor_t IntersectionStateList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t IntersectionStateList_descr_ = { "@DSRC.IntersectionStateList", &SEQUENCE_ber_, NULL, NULL, NULL, &IntersectionStateList_json_, &IntersectionState_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionState_id_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t IntersectionState_id_ber_ = { 1u, IntersectionState_id_tag_ };
// No XER for IntersectionState_id
const TTCN_Typedescriptor_t IntersectionState_id_descr_ = { "@DSRC.IntersectionState.id", &IntersectionState_id_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionState_revision_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t IntersectionState_revision_ber_ = { 1u, IntersectionState_revision_tag_ };
// No XER for IntersectionState_revision
const TTCN_Typedescriptor_t IntersectionState_revision_descr_ = { "@DSRC.IntersectionState.revision", &IntersectionState_revision_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& IntersectionStatusObject_descr_ = BITSTRING_descr_;
static const ASN_Tag_t IntersectionState_status_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t IntersectionState_status_ber_ = { 1u, IntersectionState_status_tag_ };
// No XER for IntersectionState_status
const TTCN_Typedescriptor_t IntersectionState_status_descr_ = { "@DSRC.IntersectionState.status", &IntersectionState_status_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MovementList
const TTCN_JSONdescriptor_t MovementList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t MovementList_descr_ = { "@DSRC.MovementList", &SEQUENCE_ber_, NULL, NULL, NULL, &MovementList_json_, &MovementState_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MovementState_signalGroup_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t MovementState_signalGroup_ber_ = { 1u, MovementState_signalGroup_tag_ };
// No XER for MovementState_signalGroup
const TTCN_Typedescriptor_t MovementState_signalGroup_descr_ = { "@DSRC.MovementState.signalGroup", &MovementState_signalGroup_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MovementEventList
const TTCN_JSONdescriptor_t MovementEventList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t MovementEventList_descr_ = { "@DSRC.MovementEventList", &SEQUENCE_ber_, NULL, NULL, NULL, &MovementEventList_json_, &MovementEvent_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MovementPhaseState
const TTCN_JSONdescriptor_t MovementPhaseState_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t MovementPhaseState_descr_ = { "@DSRC.MovementPhaseState", &ENUMERATED_ber_, NULL, NULL, NULL, &MovementPhaseState_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MovementEvent_eventState_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t MovementEvent_eventState_ber_ = { 1u, MovementEvent_eventState_tag_ };
// No XER for MovementEvent_eventState
const TTCN_Typedescriptor_t MovementEvent_eventState_descr_ = { "@DSRC.MovementEvent.eventState", &MovementEvent_eventState_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MovementEvent
const TTCN_JSONdescriptor_t MovementEvent_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t MovementEvent_descr_ = { "@DSRC.MovementEvent", &SEQUENCE_ber_, NULL, NULL, NULL, &MovementEvent_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& TimeMark_descr_ = INTEGER_descr_;
static const ASN_Tag_t TimeChangeDetails_minEndTime_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t TimeChangeDetails_minEndTime_ber_ = { 1u, TimeChangeDetails_minEndTime_tag_ };
// No XER for TimeChangeDetails_minEndTime
const TTCN_Typedescriptor_t TimeChangeDetails_minEndTime_descr_ = { "@DSRC.TimeChangeDetails.minEndTime", &TimeChangeDetails_minEndTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for TimeChangeDetails
const TTCN_JSONdescriptor_t TimeChangeDetails_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TimeChangeDetails_descr_ = { "@DSRC.TimeChangeDetails", &SEQUENCE_ber_, NULL, NULL, NULL, &TimeChangeDetails_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t TimeChangeDetails_startTime_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t TimeChangeDetails_startTime_ber_ = { 1u, TimeChangeDetails_startTime_tag_ };
// No XER for TimeChangeDetails_startTime
const TTCN_Typedescriptor_t TimeChangeDetails_startTime_descr_ = { "@DSRC.TimeChangeDetails.startTime", &TimeChangeDetails_startTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t TimeChangeDetails_maxEndTime_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t TimeChangeDetails_maxEndTime_ber_ = { 1u, TimeChangeDetails_maxEndTime_tag_ };
// No XER for TimeChangeDetails_maxEndTime
const TTCN_Typedescriptor_t TimeChangeDetails_maxEndTime_descr_ = { "@DSRC.TimeChangeDetails.maxEndTime", &TimeChangeDetails_maxEndTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t TimeChangeDetails_likelyTime_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t TimeChangeDetails_likelyTime_ber_ = { 1u, TimeChangeDetails_likelyTime_tag_ };
// No XER for TimeChangeDetails_likelyTime
const TTCN_Typedescriptor_t TimeChangeDetails_likelyTime_descr_ = { "@DSRC.TimeChangeDetails.likelyTime", &TimeChangeDetails_likelyTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& TimeIntervalConfidence_descr_ = INTEGER_descr_;
static const ASN_Tag_t TimeChangeDetails_confidence_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t TimeChangeDetails_confidence_ber_ = { 1u, TimeChangeDetails_confidence_tag_ };
// No XER for TimeChangeDetails_confidence
const TTCN_Typedescriptor_t TimeChangeDetails_confidence_descr_ = { "@DSRC.TimeChangeDetails.confidence", &TimeChangeDetails_confidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t TimeChangeDetails_nextTime_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t TimeChangeDetails_nextTime_ber_ = { 1u, TimeChangeDetails_nextTime_tag_ };
// No XER for TimeChangeDetails_nextTime
const TTCN_Typedescriptor_t TimeChangeDetails_nextTime_descr_ = { "@DSRC.TimeChangeDetails.nextTime", &TimeChangeDetails_nextTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MovementEvent_timing_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t MovementEvent_timing_ber_ = { 1u, MovementEvent_timing_tag_ };
// No XER for MovementEvent_timing
const TTCN_Typedescriptor_t MovementEvent_timing_descr_ = { "@DSRC.MovementEvent.timing", &MovementEvent_timing_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for AdvisorySpeedList
const TTCN_JSONdescriptor_t AdvisorySpeedList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AdvisorySpeedList_descr_ = { "@DSRC.AdvisorySpeedList", &SEQUENCE_ber_, NULL, NULL, NULL, &AdvisorySpeedList_json_, &AdvisorySpeed_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for AdvisorySpeedType
const TTCN_JSONdescriptor_t AdvisorySpeedType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AdvisorySpeedType_descr_ = { "@DSRC.AdvisorySpeedType", &ENUMERATED_ber_, NULL, NULL, NULL, &AdvisorySpeedType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t AdvisorySpeed_type___tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t AdvisorySpeed_type___ber_ = { 1u, AdvisorySpeed_type___tag_ };
// No XER for AdvisorySpeed_type__
const TTCN_Typedescriptor_t AdvisorySpeed_type___descr_ = { "@DSRC.AdvisorySpeed.type", &AdvisorySpeed_type___ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for AdvisorySpeed
const TTCN_JSONdescriptor_t AdvisorySpeed_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AdvisorySpeed_descr_ = { "@DSRC.AdvisorySpeed", &SEQUENCE_ber_, NULL, NULL, NULL, &AdvisorySpeed_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& SpeedAdvice_descr_ = INTEGER_descr_;
static const ASN_Tag_t AdvisorySpeed_speed_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t AdvisorySpeed_speed_ber_ = { 1u, AdvisorySpeed_speed_tag_ };
// No XER for AdvisorySpeed_speed
const TTCN_Typedescriptor_t AdvisorySpeed_speed_descr_ = { "@DSRC.AdvisorySpeed.speed", &AdvisorySpeed_speed_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t AdvisorySpeed_confidence_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t AdvisorySpeed_confidence_ber_ = { 1u, AdvisorySpeed_confidence_tag_ };
// No XER for AdvisorySpeed_confidence
const TTCN_Typedescriptor_t AdvisorySpeed_confidence_descr_ = { "@DSRC.AdvisorySpeed.confidence", &AdvisorySpeed_confidence_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& ZoneLength_descr_ = INTEGER_descr_;
static const ASN_Tag_t AdvisorySpeed_distance_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t AdvisorySpeed_distance_ber_ = { 1u, AdvisorySpeed_distance_tag_ };
// No XER for AdvisorySpeed_distance
const TTCN_Typedescriptor_t AdvisorySpeed_distance_descr_ = { "@DSRC.AdvisorySpeed.distance", &AdvisorySpeed_distance_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t AdvisorySpeed_class__tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t AdvisorySpeed_class__ber_ = { 1u, AdvisorySpeed_class__tag_ };
// No XER for AdvisorySpeed_class_
const TTCN_Typedescriptor_t AdvisorySpeed_class__descr_ = { "@DSRC.AdvisorySpeed.class", &AdvisorySpeed_class__ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalAdvisorySpeed_descr_ = REGION::Reg__AdvisorySpeed_descr_;
static const ASN_Tag_t AdvisorySpeed_regional_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t AdvisorySpeed_regional_ber_ = { 1u, AdvisorySpeed_regional_tag_ };
// No XER for AdvisorySpeed_regional
const TTCN_Typedescriptor_t AdvisorySpeed_regional_descr_ = { "@DSRC.AdvisorySpeed.regional", &AdvisorySpeed_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MovementEvent_speeds_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t MovementEvent_speeds_ber_ = { 1u, MovementEvent_speeds_tag_ };
// No XER for MovementEvent_speeds
const TTCN_Typedescriptor_t MovementEvent_speeds_descr_ = { "@DSRC.MovementEvent.speeds", &MovementEvent_speeds_ber_, NULL, NULL, NULL, NULL, &AdvisorySpeed_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalMovementEvent_descr_ = REGION::Reg__MovementEvent_descr_;
static const ASN_Tag_t MovementEvent_regional_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t MovementEvent_regional_ber_ = { 1u, MovementEvent_regional_tag_ };
// No XER for MovementEvent_regional
const TTCN_Typedescriptor_t MovementEvent_regional_descr_ = { "@DSRC.MovementEvent.regional", &MovementEvent_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MovementState_state__time__speed_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t MovementState_state__time__speed_ber_ = { 1u, MovementState_state__time__speed_tag_ };
// No XER for MovementState_state__time__speed
const TTCN_Typedescriptor_t MovementState_state__time__speed_descr_ = { "@DSRC.MovementState.state-time-speed", &MovementState_state__time__speed_ber_, NULL, NULL, NULL, NULL, &MovementEvent_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MovementState
const TTCN_JSONdescriptor_t MovementState_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t MovementState_descr_ = { "@DSRC.MovementState", &SEQUENCE_ber_, NULL, NULL, NULL, &MovementState_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MovementState_movementName_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t MovementState_movementName_ber_ = { 1u, MovementState_movementName_tag_ };
// No XER for MovementState_movementName
const TTCN_Typedescriptor_t MovementState_movementName_descr_ = { "@DSRC.MovementState.movementName", &MovementState_movementName_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ManeuverAssistList
const TTCN_JSONdescriptor_t ManeuverAssistList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ManeuverAssistList_descr_ = { "@DSRC.ManeuverAssistList", &SEQUENCE_ber_, NULL, NULL, NULL, &ManeuverAssistList_json_, &ConnectionManeuverAssist_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ConnectionManeuverAssist_connectionID_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ConnectionManeuverAssist_connectionID_ber_ = { 1u, ConnectionManeuverAssist_connectionID_tag_ };
// No XER for ConnectionManeuverAssist_connectionID
const TTCN_Typedescriptor_t ConnectionManeuverAssist_connectionID_descr_ = { "@DSRC.ConnectionManeuverAssist.connectionID", &ConnectionManeuverAssist_connectionID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ConnectionManeuverAssist
const TTCN_JSONdescriptor_t ConnectionManeuverAssist_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ConnectionManeuverAssist_descr_ = { "@DSRC.ConnectionManeuverAssist", &SEQUENCE_ber_, NULL, NULL, NULL, &ConnectionManeuverAssist_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ConnectionManeuverAssist_queueLength_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ConnectionManeuverAssist_queueLength_ber_ = { 1u, ConnectionManeuverAssist_queueLength_tag_ };
// No XER for ConnectionManeuverAssist_queueLength
const TTCN_Typedescriptor_t ConnectionManeuverAssist_queueLength_descr_ = { "@DSRC.ConnectionManeuverAssist.queueLength", &ConnectionManeuverAssist_queueLength_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ConnectionManeuverAssist_availableStorageLength_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t ConnectionManeuverAssist_availableStorageLength_ber_ = { 1u, ConnectionManeuverAssist_availableStorageLength_tag_ };
// No XER for ConnectionManeuverAssist_availableStorageLength
const TTCN_Typedescriptor_t ConnectionManeuverAssist_availableStorageLength_descr_ = { "@DSRC.ConnectionManeuverAssist.availableStorageLength", &ConnectionManeuverAssist_availableStorageLength_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& WaitOnStopline_descr_ = BOOLEAN_descr_;
static const ASN_Tag_t ConnectionManeuverAssist_waitOnStop_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t ConnectionManeuverAssist_waitOnStop_ber_ = { 1u, ConnectionManeuverAssist_waitOnStop_tag_ };
// No XER for ConnectionManeuverAssist_waitOnStop
const TTCN_Typedescriptor_t ConnectionManeuverAssist_waitOnStop_descr_ = { "@DSRC.ConnectionManeuverAssist.waitOnStop", &ConnectionManeuverAssist_waitOnStop_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, NULL, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& PedestrianBicycleDetect_descr_ = BOOLEAN_descr_;
static const ASN_Tag_t ConnectionManeuverAssist_pedBicycleDetect_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t ConnectionManeuverAssist_pedBicycleDetect_ber_ = { 1u, ConnectionManeuverAssist_pedBicycleDetect_tag_ };
// No XER for ConnectionManeuverAssist_pedBicycleDetect
const TTCN_Typedescriptor_t ConnectionManeuverAssist_pedBicycleDetect_descr_ = { "@DSRC.ConnectionManeuverAssist.pedBicycleDetect", &ConnectionManeuverAssist_pedBicycleDetect_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, NULL, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalConnectionManeuverAssist_descr_ = REG__D::Reg__ConnectionManeuverAssist_descr_;
static const ASN_Tag_t ConnectionManeuverAssist_regional_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t ConnectionManeuverAssist_regional_ber_ = { 1u, ConnectionManeuverAssist_regional_tag_ };
// No XER for ConnectionManeuverAssist_regional
const TTCN_Typedescriptor_t ConnectionManeuverAssist_regional_descr_ = { "@DSRC.ConnectionManeuverAssist.regional", &ConnectionManeuverAssist_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t MovementState_maneuverAssistList_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t MovementState_maneuverAssistList_ber_ = { 1u, MovementState_maneuverAssistList_tag_ };
// No XER for MovementState_maneuverAssistList
const TTCN_Typedescriptor_t MovementState_maneuverAssistList_descr_ = { "@DSRC.MovementState.maneuverAssistList", &MovementState_maneuverAssistList_ber_, NULL, NULL, NULL, NULL, &ConnectionManeuverAssist_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalMovementState_descr_ = REGION::Reg__MovementState_descr_;
static const ASN_Tag_t MovementState_regional_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t MovementState_regional_ber_ = { 1u, MovementState_regional_tag_ };
// No XER for MovementState_regional
const TTCN_Typedescriptor_t MovementState_regional_descr_ = { "@DSRC.MovementState.regional", &MovementState_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionState_states_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t IntersectionState_states_ber_ = { 1u, IntersectionState_states_tag_ };
// No XER for IntersectionState_states
const TTCN_Typedescriptor_t IntersectionState_states_descr_ = { "@DSRC.IntersectionState.states", &IntersectionState_states_ber_, NULL, NULL, NULL, NULL, &MovementState_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IntersectionState
const TTCN_JSONdescriptor_t IntersectionState_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t IntersectionState_descr_ = { "@DSRC.IntersectionState", &SEQUENCE_ber_, NULL, NULL, NULL, &IntersectionState_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionState_name_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t IntersectionState_name_ber_ = { 1u, IntersectionState_name_tag_ };
// No XER for IntersectionState_name
const TTCN_Typedescriptor_t IntersectionState_name_descr_ = { "@DSRC.IntersectionState.name", &IntersectionState_name_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& MinuteOfTheYear_descr_ = INTEGER_descr_;
static const ASN_Tag_t IntersectionState_moy_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t IntersectionState_moy_ber_ = { 1u, IntersectionState_moy_tag_ };
// No XER for IntersectionState_moy
const TTCN_Typedescriptor_t IntersectionState_moy_descr_ = { "@DSRC.IntersectionState.moy", &IntersectionState_moy_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& DSecond2_descr_ = INTEGER_descr_;
static const ASN_Tag_t IntersectionState_timeStamp_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t IntersectionState_timeStamp_ber_ = { 1u, IntersectionState_timeStamp_tag_ };
// No XER for IntersectionState_timeStamp
const TTCN_Typedescriptor_t IntersectionState_timeStamp_descr_ = { "@DSRC.IntersectionState.timeStamp", &IntersectionState_timeStamp_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for EnabledLaneList
const TTCN_JSONdescriptor_t EnabledLaneList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EnabledLaneList_descr_ = { "@DSRC.EnabledLaneList", &SEQUENCE_ber_, NULL, NULL, NULL, &EnabledLaneList_json_, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionState_enabledLanes_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t IntersectionState_enabledLanes_ber_ = { 1u, IntersectionState_enabledLanes_tag_ };
// No XER for IntersectionState_enabledLanes
const TTCN_Typedescriptor_t IntersectionState_enabledLanes_descr_ = { "@DSRC.IntersectionState.enabledLanes", &IntersectionState_enabledLanes_ber_, NULL, NULL, NULL, NULL, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionState_maneuverAssistList_tag_[] = { { ASN_TAG_CONT, 8u }};
const ASN_BERdescriptor_t IntersectionState_maneuverAssistList_ber_ = { 1u, IntersectionState_maneuverAssistList_tag_ };
// No XER for IntersectionState_maneuverAssistList
const TTCN_Typedescriptor_t IntersectionState_maneuverAssistList_descr_ = { "@DSRC.IntersectionState.maneuverAssistList", &IntersectionState_maneuverAssistList_ber_, NULL, NULL, NULL, NULL, &ConnectionManeuverAssist_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& SignalControlState_descr_ = OCTETSTRING_descr_;
static const ASN_Tag_t IntersectionState_priority_tag_[] = { { ASN_TAG_CONT, 9u }};
const ASN_BERdescriptor_t IntersectionState_priority_ber_ = { 1u, IntersectionState_priority_tag_ };
// No XER for IntersectionState_priority
const TTCN_Typedescriptor_t IntersectionState_priority_descr_ = { "@DSRC.IntersectionState.priority", &IntersectionState_priority_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, NULL, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t IntersectionState_preempt_tag_[] = { { ASN_TAG_CONT, 10u }};
const ASN_BERdescriptor_t IntersectionState_preempt_ber_ = { 1u, IntersectionState_preempt_tag_ };
// No XER for IntersectionState_preempt
const TTCN_Typedescriptor_t IntersectionState_preempt_descr_ = { "@DSRC.IntersectionState.preempt", &IntersectionState_preempt_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, NULL, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalIntersectionState_descr_ = REG__D::Reg__IntersectionState_descr_;
static const ASN_Tag_t IntersectionState_regional_tag_[] = { { ASN_TAG_CONT, 11u }};
const ASN_BERdescriptor_t IntersectionState_regional_ber_ = { 1u, IntersectionState_regional_tag_ };
// No XER for IntersectionState_regional
const TTCN_Typedescriptor_t IntersectionState_regional_descr_ = { "@DSRC.IntersectionState.regional", &IntersectionState_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SPAT_intersections_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t SPAT_intersections_ber_ = { 1u, SPAT_intersections_tag_ };
// No XER for SPAT_intersections
const TTCN_Typedescriptor_t SPAT_intersections_descr_ = { "@DSRC.SPAT.intersections", &SPAT_intersections_ber_, NULL, NULL, NULL, NULL, &IntersectionState_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SPAT
const TTCN_JSONdescriptor_t SPAT_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SPAT_descr_ = { "@DSRC.SPAT", &SEQUENCE_ber_, NULL, NULL, NULL, &SPAT_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SPAT_msgSubID_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t SPAT_msgSubID_ber_ = { 1u, SPAT_msgSubID_tag_ };
// No XER for SPAT_msgSubID
const TTCN_Typedescriptor_t SPAT_msgSubID_descr_ = { "@DSRC.SPAT.msgSubID", &SPAT_msgSubID_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SPAT_name_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t SPAT_name_ber_ = { 1u, SPAT_name_tag_ };
// No XER for SPAT_name
const TTCN_Typedescriptor_t SPAT_name_descr_ = { "@DSRC.SPAT.name", &SPAT_name_ber_, NULL, NULL, NULL, &IA5String_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& RegionalSPAT_descr_ = REGION::Reg__SPAT_descr_;
static const ASN_Tag_t SPAT_regional_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t SPAT_regional_ber_ = { 1u, SPAT_regional_tag_ };
// No XER for SPAT_regional
const TTCN_Typedescriptor_t SPAT_regional_descr_ = { "@DSRC.SPAT.regional", &SPAT_regional_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static INTEGER const_mapData__P;
const INTEGER& mapData__P = const_mapData__P;
static INTEGER const_signalPhaseAndTimingMessage__P;
const INTEGER& signalPhaseAndTimingMessage__P = const_signalPhaseAndTimingMessage__P;
TTCN_Module module_object("DSRC", __DATE__, __TIME__, NULL, pre_init_module);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

MapData::MapData()
{
  bound_flag = FALSE;
}

MapData::MapData(const INTEGER& par_msgID,
    const OPTIONAL<INTEGER>& par_msgSubID,
    const INTEGER& par_msgIssueRevision,
    const OPTIONAL<LayerType>& par_layerType,
    const OPTIONAL<INTEGER>& par_layerID,
    const OPTIONAL<IntersectionGeometryList>& par_intersections,
    const OPTIONAL<RoadSegmentList>& par_roadSegments,
    const OPTIONAL<DataParameters>& par_dataParameters,
    const OPTIONAL<RestrictionClassList>& par_restrictionList,
    const OPTIONAL<REG__D::Reg__MapData>& par_regional,
    const OPTIONAL<OCTETSTRING>& par_crc)
  :   field_msgID(par_msgID),
  field_msgSubID(par_msgSubID),
  field_msgIssueRevision(par_msgIssueRevision),
  field_layerType(par_layerType),
  field_layerID(par_layerID),
  field_intersections(par_intersections),
  field_roadSegments(par_roadSegments),
  field_dataParameters(par_dataParameters),
  field_restrictionList(par_restrictionList),
  field_regional(par_regional),
  field_crc(par_crc)
{
  bound_flag = TRUE;
}

MapData::MapData(const MapData& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.MapData.");
bound_flag = TRUE;
if (other_value.msgID().is_bound()) field_msgID = other_value.msgID();
else field_msgID.clean_up();
if (other_value.msgSubID().is_bound()) field_msgSubID = other_value.msgSubID();
else field_msgSubID.clean_up();
if (other_value.msgIssueRevision().is_bound()) field_msgIssueRevision = other_value.msgIssueRevision();
else field_msgIssueRevision.clean_up();
if (other_value.layerType().is_bound()) field_layerType = other_value.layerType();
else field_layerType.clean_up();
if (other_value.layerID().is_bound()) field_layerID = other_value.layerID();
else field_layerID.clean_up();
if (other_value.intersections().is_bound()) field_intersections = other_value.intersections();
else field_intersections.clean_up();
if (other_value.roadSegments().is_bound()) field_roadSegments = other_value.roadSegments();
else field_roadSegments.clean_up();
if (other_value.dataParameters().is_bound()) field_dataParameters = other_value.dataParameters();
else field_dataParameters.clean_up();
if (other_value.restrictionList().is_bound()) field_restrictionList = other_value.restrictionList();
else field_restrictionList.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
if (other_value.crc().is_bound()) field_crc = other_value.crc();
else field_crc.clean_up();
}

void MapData::clean_up()
{
field_msgID.clean_up();
field_msgSubID.clean_up();
field_msgIssueRevision.clean_up();
field_layerType.clean_up();
field_layerID.clean_up();
field_intersections.clean_up();
field_roadSegments.clean_up();
field_dataParameters.clean_up();
field_restrictionList.clean_up();
field_regional.clean_up();
field_crc.clean_up();
bound_flag = FALSE;
}

MapData& MapData::operator=(const MapData& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.MapData.");
  bound_flag = TRUE;
  if (other_value.msgID().is_bound()) field_msgID = other_value.msgID();
  else field_msgID.clean_up();
  if (other_value.msgSubID().is_bound()) field_msgSubID = other_value.msgSubID();
  else field_msgSubID.clean_up();
  if (other_value.msgIssueRevision().is_bound()) field_msgIssueRevision = other_value.msgIssueRevision();
  else field_msgIssueRevision.clean_up();
  if (other_value.layerType().is_bound()) field_layerType = other_value.layerType();
  else field_layerType.clean_up();
  if (other_value.layerID().is_bound()) field_layerID = other_value.layerID();
  else field_layerID.clean_up();
  if (other_value.intersections().is_bound()) field_intersections = other_value.intersections();
  else field_intersections.clean_up();
  if (other_value.roadSegments().is_bound()) field_roadSegments = other_value.roadSegments();
  else field_roadSegments.clean_up();
  if (other_value.dataParameters().is_bound()) field_dataParameters = other_value.dataParameters();
  else field_dataParameters.clean_up();
  if (other_value.restrictionList().is_bound()) field_restrictionList = other_value.restrictionList();
  else field_restrictionList.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
  if (other_value.crc().is_bound()) field_crc = other_value.crc();
  else field_crc.clean_up();
}
return *this;
}

boolean MapData::operator==(const MapData& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgID==other_value.field_msgID
  && field_msgSubID==other_value.field_msgSubID
  && field_msgIssueRevision==other_value.field_msgIssueRevision
  && field_layerType==other_value.field_layerType
  && field_layerID==other_value.field_layerID
  && field_intersections==other_value.field_intersections
  && field_roadSegments==other_value.field_roadSegments
  && field_dataParameters==other_value.field_dataParameters
  && field_restrictionList==other_value.field_restrictionList
  && field_regional==other_value.field_regional
  && field_crc==other_value.field_crc;
}

boolean MapData::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgID.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_msgSubID.get_selection() || field_msgSubID.is_bound()) return TRUE;
if(field_msgIssueRevision.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_layerType.get_selection() || field_layerType.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_layerID.get_selection() || field_layerID.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_intersections.get_selection() || field_intersections.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_roadSegments.get_selection() || field_roadSegments.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_dataParameters.get_selection() || field_dataParameters.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_restrictionList.get_selection() || field_restrictionList.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_crc.get_selection() || field_crc.is_bound()) return TRUE;
return FALSE;
}
boolean MapData::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgID.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_msgSubID.get_selection() && !field_msgSubID.is_value()) return FALSE;
if(!field_msgIssueRevision.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_layerType.get_selection() && !field_layerType.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_layerID.get_selection() && !field_layerID.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_intersections.get_selection() && !field_intersections.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_roadSegments.get_selection() && !field_roadSegments.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_dataParameters.get_selection() && !field_dataParameters.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_restrictionList.get_selection() && !field_restrictionList.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_crc.get_selection() && !field_crc.is_value()) return FALSE;
return TRUE;
}
int MapData::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.MapData");
  int ret_val = 2;
  if (field_msgSubID.ispresent()) ret_val++;
  if (field_layerType.ispresent()) ret_val++;
  if (field_layerID.ispresent()) ret_val++;
  if (field_intersections.ispresent()) ret_val++;
  if (field_roadSegments.ispresent()) ret_val++;
  if (field_dataParameters.ispresent()) ret_val++;
  if (field_restrictionList.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  if (field_crc.ispresent()) ret_val++;
  return ret_val;
}

void MapData::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgID := ");
field_msgID.log();
TTCN_Logger::log_event_str(", msgSubID := ");
field_msgSubID.log();
TTCN_Logger::log_event_str(", msgIssueRevision := ");
field_msgIssueRevision.log();
TTCN_Logger::log_event_str(", layerType := ");
field_layerType.log();
TTCN_Logger::log_event_str(", layerID := ");
field_layerID.log();
TTCN_Logger::log_event_str(", intersections := ");
field_intersections.log();
TTCN_Logger::log_event_str(", roadSegments := ");
field_roadSegments.log();
TTCN_Logger::log_event_str(", dataParameters := ");
field_dataParameters.log();
TTCN_Logger::log_event_str(", restrictionList := ");
field_restrictionList.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(", crc := ");
field_crc.log();
TTCN_Logger::log_event_str(" }");
}

void MapData::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.MapData'");
    }
    if (strcmp("msgID", param_field) == 0) {
      msgID().set_param(param);
      return;
    } else if (strcmp("msgSubID", param_field) == 0) {
      msgSubID().set_param(param);
      return;
    } else if (strcmp("msgIssueRevision", param_field) == 0) {
      msgIssueRevision().set_param(param);
      return;
    } else if (strcmp("layerType", param_field) == 0) {
      layerType().set_param(param);
      return;
    } else if (strcmp("layerID", param_field) == 0) {
      layerID().set_param(param);
      return;
    } else if (strcmp("intersections", param_field) == 0) {
      intersections().set_param(param);
      return;
    } else if (strcmp("roadSegments", param_field) == 0) {
      roadSegments().set_param(param);
      return;
    } else if (strcmp("dataParameters", param_field) == 0) {
      dataParameters().set_param(param);
      return;
    } else if (strcmp("restrictionList", param_field) == 0) {
      restrictionList().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else if (strcmp("crc", param_field) == 0) {
      crc().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.MapData'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (11<mp->get_size()) {
      param.error("record value of type @DSRC.MapData has 11 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) msgSubID().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) msgIssueRevision().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) layerType().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) layerID().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) intersections().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) roadSegments().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) dataParameters().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) restrictionList().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) crc().set_param(*mp->get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgSubID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgSubID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIssueRevision")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIssueRevision().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "layerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          layerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "layerID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          layerID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "intersections")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          intersections().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadSegments")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadSegments().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dataParameters")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dataParameters().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "restrictionList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          restrictionList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "crc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          crc().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.MapData: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.MapData");
  }
}

Module_Param* MapData::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.MapData'");
    }
    if (strcmp("msgID", param_field) == 0) {
      return msgID().get_param(param_name);
    } else if (strcmp("msgSubID", param_field) == 0) {
      return msgSubID().get_param(param_name);
    } else if (strcmp("msgIssueRevision", param_field) == 0) {
      return msgIssueRevision().get_param(param_name);
    } else if (strcmp("layerType", param_field) == 0) {
      return layerType().get_param(param_name);
    } else if (strcmp("layerID", param_field) == 0) {
      return layerID().get_param(param_name);
    } else if (strcmp("intersections", param_field) == 0) {
      return intersections().get_param(param_name);
    } else if (strcmp("roadSegments", param_field) == 0) {
      return roadSegments().get_param(param_name);
    } else if (strcmp("dataParameters", param_field) == 0) {
      return dataParameters().get_param(param_name);
    } else if (strcmp("restrictionList", param_field) == 0) {
      return restrictionList().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else if (strcmp("crc", param_field) == 0) {
      return crc().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.MapData'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgID = field_msgID.get_param(param_name);
  mp_field_msgID->set_id(new Module_Param_FieldName(mcopystr("msgID")));
  mp->add_elem(mp_field_msgID);
  Module_Param* mp_field_msgSubID = field_msgSubID.get_param(param_name);
  mp_field_msgSubID->set_id(new Module_Param_FieldName(mcopystr("msgSubID")));
  mp->add_elem(mp_field_msgSubID);
  Module_Param* mp_field_msgIssueRevision = field_msgIssueRevision.get_param(param_name);
  mp_field_msgIssueRevision->set_id(new Module_Param_FieldName(mcopystr("msgIssueRevision")));
  mp->add_elem(mp_field_msgIssueRevision);
  Module_Param* mp_field_layerType = field_layerType.get_param(param_name);
  mp_field_layerType->set_id(new Module_Param_FieldName(mcopystr("layerType")));
  mp->add_elem(mp_field_layerType);
  Module_Param* mp_field_layerID = field_layerID.get_param(param_name);
  mp_field_layerID->set_id(new Module_Param_FieldName(mcopystr("layerID")));
  mp->add_elem(mp_field_layerID);
  Module_Param* mp_field_intersections = field_intersections.get_param(param_name);
  mp_field_intersections->set_id(new Module_Param_FieldName(mcopystr("intersections")));
  mp->add_elem(mp_field_intersections);
  Module_Param* mp_field_roadSegments = field_roadSegments.get_param(param_name);
  mp_field_roadSegments->set_id(new Module_Param_FieldName(mcopystr("roadSegments")));
  mp->add_elem(mp_field_roadSegments);
  Module_Param* mp_field_dataParameters = field_dataParameters.get_param(param_name);
  mp_field_dataParameters->set_id(new Module_Param_FieldName(mcopystr("dataParameters")));
  mp->add_elem(mp_field_dataParameters);
  Module_Param* mp_field_restrictionList = field_restrictionList.get_param(param_name);
  mp_field_restrictionList->set_id(new Module_Param_FieldName(mcopystr("restrictionList")));
  mp->add_elem(mp_field_restrictionList);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  Module_Param* mp_field_crc = field_crc.get_param(param_name);
  mp_field_crc->set_id(new Module_Param_FieldName(mcopystr("crc")));
  mp->add_elem(mp_field_crc);
  return mp;
  }

void MapData::set_implicit_omit()
{
if (msgID().is_bound()) msgID().set_implicit_omit();
if (!msgSubID().is_bound()) msgSubID() = OMIT_VALUE;
else msgSubID().set_implicit_omit();
if (msgIssueRevision().is_bound()) msgIssueRevision().set_implicit_omit();
if (!layerType().is_bound()) layerType() = OMIT_VALUE;
else layerType().set_implicit_omit();
if (!layerID().is_bound()) layerID() = OMIT_VALUE;
else layerID().set_implicit_omit();
if (!intersections().is_bound()) intersections() = OMIT_VALUE;
else intersections().set_implicit_omit();
if (!roadSegments().is_bound()) roadSegments() = OMIT_VALUE;
else roadSegments().set_implicit_omit();
if (!dataParameters().is_bound()) dataParameters() = OMIT_VALUE;
else dataParameters().set_implicit_omit();
if (!restrictionList().is_bound()) restrictionList() = OMIT_VALUE;
else restrictionList().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
if (!crc().is_bound()) crc() = OMIT_VALUE;
else crc().set_implicit_omit();
}

void MapData::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.MapData.");
field_msgID.encode_text(text_buf);
field_msgSubID.encode_text(text_buf);
field_msgIssueRevision.encode_text(text_buf);
field_layerType.encode_text(text_buf);
field_layerID.encode_text(text_buf);
field_intersections.encode_text(text_buf);
field_roadSegments.encode_text(text_buf);
field_dataParameters.encode_text(text_buf);
field_restrictionList.encode_text(text_buf);
field_regional.encode_text(text_buf);
field_crc.encode_text(text_buf);
}

void MapData::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgID.decode_text(text_buf);
field_msgSubID.decode_text(text_buf);
field_msgIssueRevision.decode_text(text_buf);
field_layerType.decode_text(text_buf);
field_layerID.decode_text(text_buf);
field_intersections.decode_text(text_buf);
field_roadSegments.decode_text(text_buf);
field_dataParameters.decode_text(text_buf);
field_restrictionList.decode_text(text_buf);
field_regional.decode_text(text_buf);
field_crc.decode_text(text_buf);
}

void MapData::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MapData::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* MapData::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("msgID': ");
  new_tlv->add_TLV(field_msgID.BER_encode_TLV(MapData_msgID_descr_, p_coding));
  ec_1.set_msg("msgSubID': ");
  new_tlv->add_TLV(field_msgSubID.BER_encode_TLV(MapData_msgSubID_descr_, p_coding));
  ec_1.set_msg("msgIssueRevision': ");
  new_tlv->add_TLV(field_msgIssueRevision.BER_encode_TLV(MapData_msgIssueRevision_descr_, p_coding));
  ec_1.set_msg("layerType': ");
  new_tlv->add_TLV(field_layerType.BER_encode_TLV(MapData_layerType_descr_, p_coding));
  ec_1.set_msg("layerID': ");
  new_tlv->add_TLV(field_layerID.BER_encode_TLV(MapData_layerID_descr_, p_coding));
  ec_1.set_msg("intersections': ");
  new_tlv->add_TLV(field_intersections.BER_encode_TLV(MapData_intersections_descr_, p_coding));
  ec_1.set_msg("roadSegments': ");
  new_tlv->add_TLV(field_roadSegments.BER_encode_TLV(MapData_roadSegments_descr_, p_coding));
  ec_1.set_msg("dataParameters': ");
  new_tlv->add_TLV(field_dataParameters.BER_encode_TLV(MapData_dataParameters_descr_, p_coding));
  ec_1.set_msg("restrictionList': ");
  new_tlv->add_TLV(field_restrictionList.BER_encode_TLV(MapData_restrictionList_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(MapData_regional_descr_, p_coding));
  ec_1.set_msg("crc': ");
  new_tlv->add_TLV(field_crc.BER_encode_TLV(MapData_crc_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean MapData::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.MapData' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("msgID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_msgID.BER_decode_TLV(MapData_msgID_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("msgSubID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_msgSubID=OMIT_VALUE;
    else {
      field_msgSubID.BER_decode_TLV(MapData_msgSubID_descr_, tmp_tlv, L_form);
      if(field_msgSubID.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("msgIssueRevision': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_msgIssueRevision.BER_decode_TLV(MapData_msgIssueRevision_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("layerType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_layerType=OMIT_VALUE;
    else {
      field_layerType.BER_decode_TLV(MapData_layerType_descr_, tmp_tlv, L_form);
      if(field_layerType.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("layerID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_layerID=OMIT_VALUE;
    else {
      field_layerID.BER_decode_TLV(MapData_layerID_descr_, tmp_tlv, L_form);
      if(field_layerID.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("intersections': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_intersections=OMIT_VALUE;
    else {
      field_intersections.BER_decode_TLV(MapData_intersections_descr_, tmp_tlv, L_form);
      if(field_intersections.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("roadSegments': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_roadSegments=OMIT_VALUE;
    else {
      field_roadSegments.BER_decode_TLV(MapData_roadSegments_descr_, tmp_tlv, L_form);
      if(field_roadSegments.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("dataParameters': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_dataParameters=OMIT_VALUE;
    else {
      field_dataParameters.BER_decode_TLV(MapData_dataParameters_descr_, tmp_tlv, L_form);
      if(field_dataParameters.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("restrictionList': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_restrictionList=OMIT_VALUE;
    else {
      field_restrictionList.BER_decode_TLV(MapData_restrictionList_descr_, tmp_tlv, L_form);
      if(field_restrictionList.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(MapData_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("crc': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_crc=OMIT_VALUE;
    else {
      field_crc.BER_decode_TLV(MapData_crc_descr_, tmp_tlv, L_form);
      if(field_crc.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int MapData::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.MapData.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "msgID");
    enc_len += field_msgID.JSON_encode(MapData_msgID_descr_, p_tok);
  }

  if (field_msgSubID.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "msgSubID");
    enc_len += field_msgSubID.JSON_encode(MapData_msgSubID_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "msgIssueRevision");
    enc_len += field_msgIssueRevision.JSON_encode(MapData_msgIssueRevision_descr_, p_tok);
  }

  if (field_layerType.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "layerType");
    enc_len += field_layerType.JSON_encode(MapData_layerType_descr_, p_tok);
  }

  if (field_layerID.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "layerID");
    enc_len += field_layerID.JSON_encode(MapData_layerID_descr_, p_tok);
  }

  if (field_intersections.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "intersections");
    enc_len += field_intersections.JSON_encode(MapData_intersections_descr_, p_tok);
  }

  if (field_roadSegments.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "roadSegments");
    enc_len += field_roadSegments.JSON_encode(MapData_roadSegments_descr_, p_tok);
  }

  if (field_dataParameters.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dataParameters");
    enc_len += field_dataParameters.JSON_encode(MapData_dataParameters_descr_, p_tok);
  }

  if (field_restrictionList.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "restrictionList");
    enc_len += field_restrictionList.JSON_encode(MapData_restrictionList_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(MapData_regional_descr_, p_tok);
  }

  if (field_crc.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "crc");
    enc_len += field_crc.JSON_encode(MapData_crc_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int MapData::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "msgID", name_len)) {
         int ret_val = field_msgID.JSON_decode(MapData_msgID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "msgID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "msgSubID", name_len)) {
         int ret_val = field_msgSubID.JSON_decode(MapData_msgSubID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "msgSubID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "msgIssueRevision", name_len)) {
         int ret_val = field_msgIssueRevision.JSON_decode(MapData_msgIssueRevision_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "msgIssueRevision");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "layerType", name_len)) {
         int ret_val = field_layerType.JSON_decode(MapData_layerType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "layerType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "layerID", name_len)) {
         int ret_val = field_layerID.JSON_decode(MapData_layerID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "layerID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "intersections", name_len)) {
         int ret_val = field_intersections.JSON_decode(MapData_intersections_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "intersections");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "roadSegments", name_len)) {
         int ret_val = field_roadSegments.JSON_decode(MapData_roadSegments_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "roadSegments");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "dataParameters", name_len)) {
         int ret_val = field_dataParameters.JSON_decode(MapData_dataParameters_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dataParameters");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "restrictionList", name_len)) {
         int ret_val = field_restrictionList.JSON_decode(MapData_restrictionList_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "restrictionList");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(MapData_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (3 == name_len && 0 == strncmp(fld_name, "crc", name_len)) {
         int ret_val = field_crc.JSON_decode(MapData_crc_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "crc");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_msgID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "msgID");
    return JSON_ERROR_FATAL;
  }
if (!field_msgSubID.is_bound()) {
    field_msgSubID = OMIT_VALUE;
  }
if (!field_msgIssueRevision.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "msgIssueRevision");
    return JSON_ERROR_FATAL;
  }
if (!field_layerType.is_bound()) {
    field_layerType = OMIT_VALUE;
  }
if (!field_layerID.is_bound()) {
    field_layerID = OMIT_VALUE;
  }
if (!field_intersections.is_bound()) {
    field_intersections = OMIT_VALUE;
  }
if (!field_roadSegments.is_bound()) {
    field_roadSegments = OMIT_VALUE;
  }
if (!field_dataParameters.is_bound()) {
    field_dataParameters = OMIT_VALUE;
  }
if (!field_restrictionList.is_bound()) {
    field_restrictionList = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }
if (!field_crc.is_bound()) {
    field_crc = OMIT_VALUE;
  }

  return dec_len;
}

struct MapData_template::single_value_struct {
INTEGER_template field_msgID;
INTEGER_template field_msgSubID;
INTEGER_template field_msgIssueRevision;
LayerType_template field_layerType;
INTEGER_template field_layerID;
IntersectionGeometryList_template field_intersections;
RoadSegmentList_template field_roadSegments;
DataParameters_template field_dataParameters;
RestrictionClassList_template field_restrictionList;
REG__D::Reg__MapData_template field_regional;
OCTETSTRING_template field_crc;
};

void MapData_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgID = ANY_VALUE;
single_value->field_msgSubID = ANY_OR_OMIT;
single_value->field_msgIssueRevision = ANY_VALUE;
single_value->field_layerType = ANY_OR_OMIT;
single_value->field_layerID = ANY_OR_OMIT;
single_value->field_intersections = ANY_OR_OMIT;
single_value->field_roadSegments = ANY_OR_OMIT;
single_value->field_dataParameters = ANY_OR_OMIT;
single_value->field_restrictionList = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
single_value->field_crc = ANY_OR_OMIT;
}
}
}

void MapData_template::copy_value(const MapData& other_value)
{
single_value = new single_value_struct;
if (other_value.msgID().is_bound()) {
  single_value->field_msgID = other_value.msgID();
} else {
  single_value->field_msgID.clean_up();
}
if (other_value.msgSubID().is_bound()) {
  if (other_value.msgSubID().ispresent()) single_value->field_msgSubID = other_value.msgSubID()();
  else single_value->field_msgSubID = OMIT_VALUE;
} else {
  single_value->field_msgSubID.clean_up();
}
if (other_value.msgIssueRevision().is_bound()) {
  single_value->field_msgIssueRevision = other_value.msgIssueRevision();
} else {
  single_value->field_msgIssueRevision.clean_up();
}
if (other_value.layerType().is_bound()) {
  if (other_value.layerType().ispresent()) single_value->field_layerType = other_value.layerType()();
  else single_value->field_layerType = OMIT_VALUE;
} else {
  single_value->field_layerType.clean_up();
}
if (other_value.layerID().is_bound()) {
  if (other_value.layerID().ispresent()) single_value->field_layerID = other_value.layerID()();
  else single_value->field_layerID = OMIT_VALUE;
} else {
  single_value->field_layerID.clean_up();
}
if (other_value.intersections().is_bound()) {
  if (other_value.intersections().ispresent()) single_value->field_intersections = other_value.intersections()();
  else single_value->field_intersections = OMIT_VALUE;
} else {
  single_value->field_intersections.clean_up();
}
if (other_value.roadSegments().is_bound()) {
  if (other_value.roadSegments().ispresent()) single_value->field_roadSegments = other_value.roadSegments()();
  else single_value->field_roadSegments = OMIT_VALUE;
} else {
  single_value->field_roadSegments.clean_up();
}
if (other_value.dataParameters().is_bound()) {
  if (other_value.dataParameters().ispresent()) single_value->field_dataParameters = other_value.dataParameters()();
  else single_value->field_dataParameters = OMIT_VALUE;
} else {
  single_value->field_dataParameters.clean_up();
}
if (other_value.restrictionList().is_bound()) {
  if (other_value.restrictionList().ispresent()) single_value->field_restrictionList = other_value.restrictionList()();
  else single_value->field_restrictionList = OMIT_VALUE;
} else {
  single_value->field_restrictionList.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
if (other_value.crc().is_bound()) {
  if (other_value.crc().ispresent()) single_value->field_crc = other_value.crc()();
  else single_value->field_crc = OMIT_VALUE;
} else {
  single_value->field_crc.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MapData_template::copy_template(const MapData_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgID().get_selection()) {
single_value->field_msgID = other_value.msgID();
} else {
single_value->field_msgID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.msgSubID().get_selection()) {
single_value->field_msgSubID = other_value.msgSubID();
} else {
single_value->field_msgSubID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.msgIssueRevision().get_selection()) {
single_value->field_msgIssueRevision = other_value.msgIssueRevision();
} else {
single_value->field_msgIssueRevision.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.layerType().get_selection()) {
single_value->field_layerType = other_value.layerType();
} else {
single_value->field_layerType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.layerID().get_selection()) {
single_value->field_layerID = other_value.layerID();
} else {
single_value->field_layerID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.intersections().get_selection()) {
single_value->field_intersections = other_value.intersections();
} else {
single_value->field_intersections.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.roadSegments().get_selection()) {
single_value->field_roadSegments = other_value.roadSegments();
} else {
single_value->field_roadSegments.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dataParameters().get_selection()) {
single_value->field_dataParameters = other_value.dataParameters();
} else {
single_value->field_dataParameters.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.restrictionList().get_selection()) {
single_value->field_restrictionList = other_value.restrictionList();
} else {
single_value->field_restrictionList.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.crc().get_selection()) {
single_value->field_crc = other_value.crc();
} else {
single_value->field_crc.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MapData_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.MapData.");
break;
}
set_selection(other_value);
}

MapData_template::MapData_template()
{
}

MapData_template::MapData_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MapData_template::MapData_template(const MapData& other_value)
{
copy_value(other_value);
}

MapData_template::MapData_template(const OPTIONAL<MapData>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapData&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.MapData from an unbound optional field.");
}
}

MapData_template::MapData_template(const MapData_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MapData_template::~MapData_template()
{
clean_up();
}

MapData_template& MapData_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MapData_template& MapData_template::operator=(const MapData& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MapData_template& MapData_template::operator=(const OPTIONAL<MapData>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapData&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.MapData.");
}
return *this;
}

MapData_template& MapData_template::operator=(const MapData_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MapData_template::match(const MapData& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgID().is_bound()) return FALSE;
if(!single_value->field_msgID.match(other_value.msgID(), legacy))return FALSE;
if(!other_value.msgSubID().is_bound()) return FALSE;
if((other_value.msgSubID().ispresent() ? !single_value->field_msgSubID.match((const INTEGER&)other_value.msgSubID(), legacy) : !single_value->field_msgSubID.match_omit(legacy)))return FALSE;
if(!other_value.msgIssueRevision().is_bound()) return FALSE;
if(!single_value->field_msgIssueRevision.match(other_value.msgIssueRevision(), legacy))return FALSE;
if(!other_value.layerType().is_bound()) return FALSE;
if((other_value.layerType().ispresent() ? !single_value->field_layerType.match((const LayerType&)other_value.layerType(), legacy) : !single_value->field_layerType.match_omit(legacy)))return FALSE;
if(!other_value.layerID().is_bound()) return FALSE;
if((other_value.layerID().ispresent() ? !single_value->field_layerID.match((const INTEGER&)other_value.layerID(), legacy) : !single_value->field_layerID.match_omit(legacy)))return FALSE;
if(!other_value.intersections().is_bound()) return FALSE;
if((other_value.intersections().ispresent() ? !single_value->field_intersections.match((const IntersectionGeometryList&)other_value.intersections(), legacy) : !single_value->field_intersections.match_omit(legacy)))return FALSE;
if(!other_value.roadSegments().is_bound()) return FALSE;
if((other_value.roadSegments().ispresent() ? !single_value->field_roadSegments.match((const RoadSegmentList&)other_value.roadSegments(), legacy) : !single_value->field_roadSegments.match_omit(legacy)))return FALSE;
if(!other_value.dataParameters().is_bound()) return FALSE;
if((other_value.dataParameters().ispresent() ? !single_value->field_dataParameters.match((const DataParameters&)other_value.dataParameters(), legacy) : !single_value->field_dataParameters.match_omit(legacy)))return FALSE;
if(!other_value.restrictionList().is_bound()) return FALSE;
if((other_value.restrictionList().ispresent() ? !single_value->field_restrictionList.match((const RestrictionClassList&)other_value.restrictionList(), legacy) : !single_value->field_restrictionList.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REG__D::Reg__MapData&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
if(!other_value.crc().is_bound()) return FALSE;
if((other_value.crc().ispresent() ? !single_value->field_crc.match((const OCTETSTRING&)other_value.crc(), legacy) : !single_value->field_crc.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.MapData.");
}
return FALSE;
}

boolean MapData_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgID.is_bound()) return TRUE;
if (single_value->field_msgSubID.is_omit() || single_value->field_msgSubID.is_bound()) return TRUE;
if (single_value->field_msgIssueRevision.is_bound()) return TRUE;
if (single_value->field_layerType.is_omit() || single_value->field_layerType.is_bound()) return TRUE;
if (single_value->field_layerID.is_omit() || single_value->field_layerID.is_bound()) return TRUE;
if (single_value->field_intersections.is_omit() || single_value->field_intersections.is_bound()) return TRUE;
if (single_value->field_roadSegments.is_omit() || single_value->field_roadSegments.is_bound()) return TRUE;
if (single_value->field_dataParameters.is_omit() || single_value->field_dataParameters.is_bound()) return TRUE;
if (single_value->field_restrictionList.is_omit() || single_value->field_restrictionList.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
if (single_value->field_crc.is_omit() || single_value->field_crc.is_bound()) return TRUE;
return FALSE;
}

boolean MapData_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgID.is_value()) return FALSE;
if (!single_value->field_msgSubID.is_omit() && !single_value->field_msgSubID.is_value()) return FALSE;
if (!single_value->field_msgIssueRevision.is_value()) return FALSE;
if (!single_value->field_layerType.is_omit() && !single_value->field_layerType.is_value()) return FALSE;
if (!single_value->field_layerID.is_omit() && !single_value->field_layerID.is_value()) return FALSE;
if (!single_value->field_intersections.is_omit() && !single_value->field_intersections.is_value()) return FALSE;
if (!single_value->field_roadSegments.is_omit() && !single_value->field_roadSegments.is_value()) return FALSE;
if (!single_value->field_dataParameters.is_omit() && !single_value->field_dataParameters.is_value()) return FALSE;
if (!single_value->field_restrictionList.is_omit() && !single_value->field_restrictionList.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
if (!single_value->field_crc.is_omit() && !single_value->field_crc.is_value()) return FALSE;
return TRUE;
}

void MapData_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MapData MapData_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.MapData.");
MapData ret_val;
if (single_value->field_msgID.is_bound()) {
ret_val.msgID() = single_value->field_msgID.valueof();
}
if (single_value->field_msgSubID.is_omit()) ret_val.msgSubID() = OMIT_VALUE;
else if (single_value->field_msgSubID.is_bound()) {
ret_val.msgSubID() = single_value->field_msgSubID.valueof();
}
if (single_value->field_msgIssueRevision.is_bound()) {
ret_val.msgIssueRevision() = single_value->field_msgIssueRevision.valueof();
}
if (single_value->field_layerType.is_omit()) ret_val.layerType() = OMIT_VALUE;
else if (single_value->field_layerType.is_bound()) {
ret_val.layerType() = single_value->field_layerType.valueof();
}
if (single_value->field_layerID.is_omit()) ret_val.layerID() = OMIT_VALUE;
else if (single_value->field_layerID.is_bound()) {
ret_val.layerID() = single_value->field_layerID.valueof();
}
if (single_value->field_intersections.is_omit()) ret_val.intersections() = OMIT_VALUE;
else if (single_value->field_intersections.is_bound()) {
ret_val.intersections() = single_value->field_intersections.valueof();
}
if (single_value->field_roadSegments.is_omit()) ret_val.roadSegments() = OMIT_VALUE;
else if (single_value->field_roadSegments.is_bound()) {
ret_val.roadSegments() = single_value->field_roadSegments.valueof();
}
if (single_value->field_dataParameters.is_omit()) ret_val.dataParameters() = OMIT_VALUE;
else if (single_value->field_dataParameters.is_bound()) {
ret_val.dataParameters() = single_value->field_dataParameters.valueof();
}
if (single_value->field_restrictionList.is_omit()) ret_val.restrictionList() = OMIT_VALUE;
else if (single_value->field_restrictionList.is_bound()) {
ret_val.restrictionList() = single_value->field_restrictionList.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
if (single_value->field_crc.is_omit()) ret_val.crc() = OMIT_VALUE;
else if (single_value->field_crc.is_bound()) {
ret_val.crc() = single_value->field_crc.valueof();
}
return ret_val;
}

void MapData_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.MapData.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MapData_template[list_length];
}

MapData_template& MapData_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.MapData.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.MapData.");
return value_list.list_value[list_index];
}

INTEGER_template& MapData_template::msgID()
{
set_specific();
return single_value->field_msgID;
}

const INTEGER_template& MapData_template::msgID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgID of a non-specific template of type @DSRC.MapData.");
return single_value->field_msgID;
}

INTEGER_template& MapData_template::msgSubID()
{
set_specific();
return single_value->field_msgSubID;
}

const INTEGER_template& MapData_template::msgSubID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgSubID of a non-specific template of type @DSRC.MapData.");
return single_value->field_msgSubID;
}

INTEGER_template& MapData_template::msgIssueRevision()
{
set_specific();
return single_value->field_msgIssueRevision;
}

const INTEGER_template& MapData_template::msgIssueRevision() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgIssueRevision of a non-specific template of type @DSRC.MapData.");
return single_value->field_msgIssueRevision;
}

LayerType_template& MapData_template::layerType()
{
set_specific();
return single_value->field_layerType;
}

const LayerType_template& MapData_template::layerType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field layerType of a non-specific template of type @DSRC.MapData.");
return single_value->field_layerType;
}

INTEGER_template& MapData_template::layerID()
{
set_specific();
return single_value->field_layerID;
}

const INTEGER_template& MapData_template::layerID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field layerID of a non-specific template of type @DSRC.MapData.");
return single_value->field_layerID;
}

IntersectionGeometryList_template& MapData_template::intersections()
{
set_specific();
return single_value->field_intersections;
}

const IntersectionGeometryList_template& MapData_template::intersections() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field intersections of a non-specific template of type @DSRC.MapData.");
return single_value->field_intersections;
}

RoadSegmentList_template& MapData_template::roadSegments()
{
set_specific();
return single_value->field_roadSegments;
}

const RoadSegmentList_template& MapData_template::roadSegments() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field roadSegments of a non-specific template of type @DSRC.MapData.");
return single_value->field_roadSegments;
}

DataParameters_template& MapData_template::dataParameters()
{
set_specific();
return single_value->field_dataParameters;
}

const DataParameters_template& MapData_template::dataParameters() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dataParameters of a non-specific template of type @DSRC.MapData.");
return single_value->field_dataParameters;
}

RestrictionClassList_template& MapData_template::restrictionList()
{
set_specific();
return single_value->field_restrictionList;
}

const RestrictionClassList_template& MapData_template::restrictionList() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field restrictionList of a non-specific template of type @DSRC.MapData.");
return single_value->field_restrictionList;
}

REG__D::Reg__MapData_template& MapData_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REG__D::Reg__MapData_template& MapData_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.MapData.");
return single_value->field_regional;
}

OCTETSTRING_template& MapData_template::crc()
{
set_specific();
return single_value->field_crc;
}

const OCTETSTRING_template& MapData_template::crc() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field crc of a non-specific template of type @DSRC.MapData.");
return single_value->field_crc;
}

int MapData_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.MapData which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_msgSubID.is_present()) ret_val++;
      if (single_value->field_layerType.is_present()) ret_val++;
      if (single_value->field_layerID.is_present()) ret_val++;
      if (single_value->field_intersections.is_present()) ret_val++;
      if (single_value->field_roadSegments.is_present()) ret_val++;
      if (single_value->field_dataParameters.is_present()) ret_val++;
      if (single_value->field_restrictionList.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      if (single_value->field_crc.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.MapData containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.MapData containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.MapData containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.MapData containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.MapData containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.MapData.");
  }
  return 0;
}

void MapData_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgID := ");
single_value->field_msgID.log();
TTCN_Logger::log_event_str(", msgSubID := ");
single_value->field_msgSubID.log();
TTCN_Logger::log_event_str(", msgIssueRevision := ");
single_value->field_msgIssueRevision.log();
TTCN_Logger::log_event_str(", layerType := ");
single_value->field_layerType.log();
TTCN_Logger::log_event_str(", layerID := ");
single_value->field_layerID.log();
TTCN_Logger::log_event_str(", intersections := ");
single_value->field_intersections.log();
TTCN_Logger::log_event_str(", roadSegments := ");
single_value->field_roadSegments.log();
TTCN_Logger::log_event_str(", dataParameters := ");
single_value->field_dataParameters.log();
TTCN_Logger::log_event_str(", restrictionList := ");
single_value->field_restrictionList.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(", crc := ");
single_value->field_crc.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MapData_template::log_match(const MapData& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgID.match(match_value.msgID(), legacy)){
TTCN_Logger::log_logmatch_info(".msgID");
single_value->field_msgID.log_match(match_value.msgID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.msgSubID().ispresent()){
if(!single_value->field_msgSubID.match(match_value.msgSubID(), legacy)){
TTCN_Logger::log_logmatch_info(".msgSubID");
single_value->field_msgSubID.log_match(match_value.msgSubID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_msgSubID.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".msgSubID := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_msgSubID.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_msgIssueRevision.match(match_value.msgIssueRevision(), legacy)){
TTCN_Logger::log_logmatch_info(".msgIssueRevision");
single_value->field_msgIssueRevision.log_match(match_value.msgIssueRevision(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.layerType().ispresent()){
if(!single_value->field_layerType.match(match_value.layerType(), legacy)){
TTCN_Logger::log_logmatch_info(".layerType");
single_value->field_layerType.log_match(match_value.layerType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_layerType.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".layerType := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_layerType.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.layerID().ispresent()){
if(!single_value->field_layerID.match(match_value.layerID(), legacy)){
TTCN_Logger::log_logmatch_info(".layerID");
single_value->field_layerID.log_match(match_value.layerID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_layerID.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".layerID := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_layerID.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.intersections().ispresent()){
if(!single_value->field_intersections.match(match_value.intersections(), legacy)){
TTCN_Logger::log_logmatch_info(".intersections");
single_value->field_intersections.log_match(match_value.intersections(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_intersections.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".intersections := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_intersections.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.roadSegments().ispresent()){
if(!single_value->field_roadSegments.match(match_value.roadSegments(), legacy)){
TTCN_Logger::log_logmatch_info(".roadSegments");
single_value->field_roadSegments.log_match(match_value.roadSegments(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_roadSegments.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".roadSegments := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_roadSegments.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.dataParameters().ispresent()){
if(!single_value->field_dataParameters.match(match_value.dataParameters(), legacy)){
TTCN_Logger::log_logmatch_info(".dataParameters");
single_value->field_dataParameters.log_match(match_value.dataParameters(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_dataParameters.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".dataParameters := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_dataParameters.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.restrictionList().ispresent()){
if(!single_value->field_restrictionList.match(match_value.restrictionList(), legacy)){
TTCN_Logger::log_logmatch_info(".restrictionList");
single_value->field_restrictionList.log_match(match_value.restrictionList(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_restrictionList.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".restrictionList := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_restrictionList.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.crc().ispresent()){
if(!single_value->field_crc.match(match_value.crc(), legacy)){
TTCN_Logger::log_logmatch_info(".crc");
single_value->field_crc.log_match(match_value.crc(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_crc.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".crc := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_crc.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgID := ");
single_value->field_msgID.log_match(match_value.msgID(), legacy);
TTCN_Logger::log_event_str(", msgSubID := ");
if (match_value.msgSubID().ispresent()) single_value->field_msgSubID.log_match(match_value.msgSubID(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_msgSubID.log();
if (single_value->field_msgSubID.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", msgIssueRevision := ");
single_value->field_msgIssueRevision.log_match(match_value.msgIssueRevision(), legacy);
TTCN_Logger::log_event_str(", layerType := ");
if (match_value.layerType().ispresent()) single_value->field_layerType.log_match(match_value.layerType(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_layerType.log();
if (single_value->field_layerType.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", layerID := ");
if (match_value.layerID().ispresent()) single_value->field_layerID.log_match(match_value.layerID(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_layerID.log();
if (single_value->field_layerID.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", intersections := ");
if (match_value.intersections().ispresent()) single_value->field_intersections.log_match(match_value.intersections(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_intersections.log();
if (single_value->field_intersections.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", roadSegments := ");
if (match_value.roadSegments().ispresent()) single_value->field_roadSegments.log_match(match_value.roadSegments(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_roadSegments.log();
if (single_value->field_roadSegments.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", dataParameters := ");
if (match_value.dataParameters().ispresent()) single_value->field_dataParameters.log_match(match_value.dataParameters(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_dataParameters.log();
if (single_value->field_dataParameters.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", restrictionList := ");
if (match_value.restrictionList().ispresent()) single_value->field_restrictionList.log_match(match_value.restrictionList(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_restrictionList.log();
if (single_value->field_restrictionList.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", crc := ");
if (match_value.crc().ispresent()) single_value->field_crc.log_match(match_value.crc(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_crc.log();
if (single_value->field_crc.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MapData_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgID.encode_text(text_buf);
single_value->field_msgSubID.encode_text(text_buf);
single_value->field_msgIssueRevision.encode_text(text_buf);
single_value->field_layerType.encode_text(text_buf);
single_value->field_layerID.encode_text(text_buf);
single_value->field_intersections.encode_text(text_buf);
single_value->field_roadSegments.encode_text(text_buf);
single_value->field_dataParameters.encode_text(text_buf);
single_value->field_restrictionList.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
single_value->field_crc.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.MapData.");
}
}

void MapData_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgID.decode_text(text_buf);
single_value->field_msgSubID.decode_text(text_buf);
single_value->field_msgIssueRevision.decode_text(text_buf);
single_value->field_layerType.decode_text(text_buf);
single_value->field_layerID.decode_text(text_buf);
single_value->field_intersections.decode_text(text_buf);
single_value->field_roadSegments.decode_text(text_buf);
single_value->field_dataParameters.decode_text(text_buf);
single_value->field_restrictionList.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
single_value->field_crc.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MapData_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.MapData.");
}
}

void MapData_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.MapData'");
    }
    if (strcmp("msgID", param_field) == 0) {
      msgID().set_param(param);
      return;
    } else if (strcmp("msgSubID", param_field) == 0) {
      msgSubID().set_param(param);
      return;
    } else if (strcmp("msgIssueRevision", param_field) == 0) {
      msgIssueRevision().set_param(param);
      return;
    } else if (strcmp("layerType", param_field) == 0) {
      layerType().set_param(param);
      return;
    } else if (strcmp("layerID", param_field) == 0) {
      layerID().set_param(param);
      return;
    } else if (strcmp("intersections", param_field) == 0) {
      intersections().set_param(param);
      return;
    } else if (strcmp("roadSegments", param_field) == 0) {
      roadSegments().set_param(param);
      return;
    } else if (strcmp("dataParameters", param_field) == 0) {
      dataParameters().set_param(param);
      return;
    } else if (strcmp("restrictionList", param_field) == 0) {
      restrictionList().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else if (strcmp("crc", param_field) == 0) {
      crc().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.MapData'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MapData_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (11<mp->get_size()) {
      param.error("record template of type @DSRC.MapData has 11 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) msgSubID().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) msgIssueRevision().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) layerType().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) layerID().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) intersections().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) roadSegments().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) dataParameters().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) restrictionList().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) crc().set_param(*mp->get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgSubID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgSubID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIssueRevision")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIssueRevision().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "layerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          layerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "layerID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          layerID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "intersections")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          intersections().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadSegments")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadSegments().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dataParameters")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dataParameters().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "restrictionList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          restrictionList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "crc")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          crc().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.MapData: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.MapData");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* MapData_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.MapData'");
    }
    if (strcmp("msgID", param_field) == 0) {
      return msgID().get_param(param_name);
    } else if (strcmp("msgSubID", param_field) == 0) {
      return msgSubID().get_param(param_name);
    } else if (strcmp("msgIssueRevision", param_field) == 0) {
      return msgIssueRevision().get_param(param_name);
    } else if (strcmp("layerType", param_field) == 0) {
      return layerType().get_param(param_name);
    } else if (strcmp("layerID", param_field) == 0) {
      return layerID().get_param(param_name);
    } else if (strcmp("intersections", param_field) == 0) {
      return intersections().get_param(param_name);
    } else if (strcmp("roadSegments", param_field) == 0) {
      return roadSegments().get_param(param_name);
    } else if (strcmp("dataParameters", param_field) == 0) {
      return dataParameters().get_param(param_name);
    } else if (strcmp("restrictionList", param_field) == 0) {
      return restrictionList().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else if (strcmp("crc", param_field) == 0) {
      return crc().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.MapData'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgID = single_value->field_msgID.get_param(param_name);
    mp_field_msgID->set_id(new Module_Param_FieldName(mcopystr("msgID")));
    mp->add_elem(mp_field_msgID);
    Module_Param* mp_field_msgSubID = single_value->field_msgSubID.get_param(param_name);
    mp_field_msgSubID->set_id(new Module_Param_FieldName(mcopystr("msgSubID")));
    mp->add_elem(mp_field_msgSubID);
    Module_Param* mp_field_msgIssueRevision = single_value->field_msgIssueRevision.get_param(param_name);
    mp_field_msgIssueRevision->set_id(new Module_Param_FieldName(mcopystr("msgIssueRevision")));
    mp->add_elem(mp_field_msgIssueRevision);
    Module_Param* mp_field_layerType = single_value->field_layerType.get_param(param_name);
    mp_field_layerType->set_id(new Module_Param_FieldName(mcopystr("layerType")));
    mp->add_elem(mp_field_layerType);
    Module_Param* mp_field_layerID = single_value->field_layerID.get_param(param_name);
    mp_field_layerID->set_id(new Module_Param_FieldName(mcopystr("layerID")));
    mp->add_elem(mp_field_layerID);
    Module_Param* mp_field_intersections = single_value->field_intersections.get_param(param_name);
    mp_field_intersections->set_id(new Module_Param_FieldName(mcopystr("intersections")));
    mp->add_elem(mp_field_intersections);
    Module_Param* mp_field_roadSegments = single_value->field_roadSegments.get_param(param_name);
    mp_field_roadSegments->set_id(new Module_Param_FieldName(mcopystr("roadSegments")));
    mp->add_elem(mp_field_roadSegments);
    Module_Param* mp_field_dataParameters = single_value->field_dataParameters.get_param(param_name);
    mp_field_dataParameters->set_id(new Module_Param_FieldName(mcopystr("dataParameters")));
    mp->add_elem(mp_field_dataParameters);
    Module_Param* mp_field_restrictionList = single_value->field_restrictionList.get_param(param_name);
    mp_field_restrictionList->set_id(new Module_Param_FieldName(mcopystr("restrictionList")));
    mp->add_elem(mp_field_restrictionList);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    Module_Param* mp_field_crc = single_value->field_crc.get_param(param_name);
    mp_field_crc->set_id(new Module_Param_FieldName(mcopystr("crc")));
    mp->add_elem(mp_field_crc);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void MapData_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgID.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_msgSubID.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_msgIssueRevision.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_layerType.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_layerID.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_intersections.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_roadSegments.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_dataParameters.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_restrictionList.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
single_value->field_crc.check_restriction(t_res, t_name ? t_name : "@DSRC.MapData");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.MapData");
}

boolean MapData_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MapData_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

LayerType::LayerType()
{
enum_value = UNBOUND_VALUE;
}

LayerType::LayerType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @DSRC.LayerType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

LayerType::LayerType(enum_type other_value)
{
enum_value = other_value;
}

LayerType::LayerType(const LayerType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @DSRC.LayerType.");
enum_value = other_value.enum_value;
}

LayerType& LayerType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @DSRC.LayerType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

LayerType& LayerType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

LayerType& LayerType::operator=(const LayerType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.LayerType.");
enum_value = other_value.enum_value;
return *this;
}

boolean LayerType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.LayerType.");
return enum_value == other_value;
}

boolean LayerType::operator==(const LayerType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.LayerType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.LayerType.");
return enum_value == other_value.enum_value;
}

boolean LayerType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.LayerType.");
return enum_value < other_value;
}

boolean LayerType::operator<(const LayerType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.LayerType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.LayerType.");
return enum_value < other_value.enum_value;
}

boolean LayerType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.LayerType.");
return enum_value > other_value;
}

boolean LayerType::operator>(const LayerType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.LayerType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.LayerType.");
return enum_value > other_value.enum_value;
}

const char *LayerType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case none__: return "none_";
case mixedContent: return "mixedContent";
case generalMapData: return "generalMapData";
case intersectionData: return "intersectionData";
case curveData: return "curveData";
case roadwaySectionData: return "roadwaySectionData";
case parkingAreaData: return "parkingAreaData";
case sharedLaneData: return "sharedLaneData";
default: return "<unknown>";
}
}

LayerType::enum_type LayerType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "none_")) return none__;
else if (!strcmp(str_par, "mixedContent")) return mixedContent;
else if (!strcmp(str_par, "generalMapData")) return generalMapData;
else if (!strcmp(str_par, "intersectionData")) return intersectionData;
else if (!strcmp(str_par, "curveData")) return curveData;
else if (!strcmp(str_par, "roadwaySectionData")) return roadwaySectionData;
else if (!strcmp(str_par, "parkingAreaData")) return parkingAreaData;
else if (!strcmp(str_par, "sharedLaneData")) return sharedLaneData;
else return UNKNOWN_VALUE;
}

boolean LayerType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
return TRUE;
default:
return FALSE;
}
}

int LayerType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.LayerType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int LayerType::enum2int(const LayerType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.LayerType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void LayerType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @DSRC.LayerType.", int_val);
enum_value = (enum_type)int_val;
}

LayerType::operator LayerType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @DSRC.LayerType.");
return enum_value;
}

void LayerType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void LayerType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@DSRC.LayerType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @DSRC.LayerType.");
  }
}

Module_Param* LayerType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void LayerType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @DSRC.LayerType.");
text_buf.push_int(enum_value);
}

void LayerType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @DSRC.LayerType.", enum_value);
}

void LayerType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LayerType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* LayerType::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean LayerType::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @DSRC.LayerType: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int LayerType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @DSRC.LayerType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int LayerType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void LayerType_template::copy_template(const LayerType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LayerType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @DSRC.LayerType.");
}
}

LayerType_template::LayerType_template()
{
}

LayerType_template::LayerType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LayerType_template::LayerType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!LayerType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @DSRC.LayerType with unknown numeric value %d.", other_value);
single_value = (LayerType::enum_type)other_value;
}

LayerType_template::LayerType_template(LayerType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

LayerType_template::LayerType_template(const LayerType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == LayerType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @DSRC.LayerType.");
single_value = other_value.enum_value;
}

LayerType_template::LayerType_template(const OPTIONAL<LayerType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (LayerType::enum_type)(const LayerType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @DSRC.LayerType from an unbound optional field.");
}
}

LayerType_template::LayerType_template(const LayerType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

LayerType_template::~LayerType_template()
{
clean_up();
}

boolean LayerType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean LayerType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != LayerType::UNBOUND_VALUE;
}

void LayerType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

LayerType_template& LayerType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LayerType_template& LayerType_template::operator=(int other_value)
{
if (!LayerType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @DSRC.LayerType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (LayerType::enum_type)other_value;
return *this;
}

LayerType_template& LayerType_template::operator=(LayerType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

LayerType_template& LayerType_template::operator=(const LayerType& other_value)
{
if (other_value.enum_value == LayerType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.LayerType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

LayerType_template& LayerType_template::operator=(const OPTIONAL<LayerType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (LayerType::enum_type)(const LayerType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @DSRC.LayerType.");
}
return *this;
}

LayerType_template& LayerType_template::operator=(const LayerType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LayerType_template::match(LayerType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @DSRC.LayerType.");
}
return FALSE;
}

boolean LayerType_template::match(const LayerType& other_value, boolean) const
{
if (other_value.enum_value == LayerType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @DSRC.LayerType with an unbound value.");
return match(other_value.enum_value);
}

LayerType::enum_type LayerType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @DSRC.LayerType.");
return single_value;
}

void LayerType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @DSRC.LayerType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LayerType_template[list_length];
}

LayerType_template& LayerType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @DSRC.LayerType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @DSRC.LayerType.");
return value_list.list_value[list_index];
}

void LayerType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(LayerType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LayerType_template::log_match(const LayerType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void LayerType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @DSRC.LayerType.");
}
}

void LayerType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (LayerType::enum_type)text_buf.pull_int().get_val();
if (!LayerType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @DSRC.LayerType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LayerType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @DSRC.LayerType.");
}
}

boolean LayerType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LayerType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void LayerType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    LayerType::enum_type enum_val = (enum_name != NULL) ? LayerType::str_to_enum(enum_name) : LayerType::UNKNOWN_VALUE;
    if (LayerType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LayerType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    LayerType::enum_type enum_val = LayerType::str_to_enum(mp->get_enumerated());
    if (!LayerType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @DSRC.LayerType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@DSRC.LayerType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LayerType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(LayerType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LayerType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.LayerType");
}


const IntersectionGeometry IntersectionGeometryList::UNBOUND_ELEM;
IntersectionGeometryList::IntersectionGeometryList()
{
val_ptr = NULL;
}

IntersectionGeometryList::IntersectionGeometryList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

IntersectionGeometryList::IntersectionGeometryList(const IntersectionGeometryList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.IntersectionGeometryList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

IntersectionGeometryList::~IntersectionGeometryList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void IntersectionGeometryList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

IntersectionGeometryList& IntersectionGeometryList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

IntersectionGeometryList& IntersectionGeometryList::operator=(const IntersectionGeometryList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.IntersectionGeometryList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean IntersectionGeometryList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.IntersectionGeometryList.");
return val_ptr->n_elements == 0 ;
}

boolean IntersectionGeometryList::operator==(const IntersectionGeometryList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.IntersectionGeometryList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.IntersectionGeometryList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

IntersectionGeometry& IntersectionGeometryList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.IntersectionGeometryList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (IntersectionGeometry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new IntersectionGeometry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new IntersectionGeometry;
}
return *val_ptr->value_elements[index_value];
}

IntersectionGeometry& IntersectionGeometryList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.IntersectionGeometryList.");
return (*this)[(int)index_value];
}

const IntersectionGeometry& IntersectionGeometryList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.IntersectionGeometryList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.IntersectionGeometryList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.IntersectionGeometryList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const IntersectionGeometry& IntersectionGeometryList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.IntersectionGeometryList.");
return (*this)[(int)index_value];
}

IntersectionGeometryList IntersectionGeometryList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

IntersectionGeometryList IntersectionGeometryList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

IntersectionGeometryList IntersectionGeometryList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

IntersectionGeometryList IntersectionGeometryList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.IntersectionGeometryList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
IntersectionGeometryList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new IntersectionGeometry(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

IntersectionGeometryList IntersectionGeometryList::operator+(const IntersectionGeometryList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.IntersectionGeometryList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
IntersectionGeometryList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new IntersectionGeometry(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new IntersectionGeometry(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

IntersectionGeometryList IntersectionGeometryList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.IntersectionGeometryList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.IntersectionGeometryList","element");
IntersectionGeometryList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new IntersectionGeometry(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

IntersectionGeometryList IntersectionGeometryList::replace(int index, int len, const IntersectionGeometryList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.IntersectionGeometryList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.IntersectionGeometryList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.IntersectionGeometryList","element");
IntersectionGeometryList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new IntersectionGeometry(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new IntersectionGeometry(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new IntersectionGeometry(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

IntersectionGeometryList IntersectionGeometryList::replace(int index, int len, const IntersectionGeometryList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void IntersectionGeometryList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.IntersectionGeometryList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (IntersectionGeometry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new IntersectionGeometry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (IntersectionGeometry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.IntersectionGeometryList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (IntersectionGeometry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean IntersectionGeometryList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int IntersectionGeometryList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.IntersectionGeometryList.");
return val_ptr->n_elements;
}

int IntersectionGeometryList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.IntersectionGeometryList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void IntersectionGeometryList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void IntersectionGeometryList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.IntersectionGeometryList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.IntersectionGeometryList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.IntersectionGeometryList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* IntersectionGeometryList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.IntersectionGeometryList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void IntersectionGeometryList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void IntersectionGeometryList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.IntersectionGeometryList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void IntersectionGeometryList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.IntersectionGeometryList.");
val_ptr->value_elements = (IntersectionGeometry**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new IntersectionGeometry;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void IntersectionGeometryList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IntersectionGeometryList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* IntersectionGeometryList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean IntersectionGeometryList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (IntersectionGeometry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new IntersectionGeometry;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int IntersectionGeometryList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.IntersectionGeometryList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int IntersectionGeometryList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    IntersectionGeometry* val = new IntersectionGeometry;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (IntersectionGeometry**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void IntersectionGeometryList_template::copy_value(const IntersectionGeometryList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.IntersectionGeometryList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (IntersectionGeometry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new IntersectionGeometry_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new IntersectionGeometry_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void IntersectionGeometryList_template::copy_template(const IntersectionGeometryList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (IntersectionGeometry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new IntersectionGeometry_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new IntersectionGeometry_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IntersectionGeometryList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.IntersectionGeometryList.");
break;
}
set_selection(other_value);
}

boolean IntersectionGeometryList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const IntersectionGeometryList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const IntersectionGeometryList*)value_ptr)[value_index], legacy);
else return ((const IntersectionGeometryList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

IntersectionGeometryList_template::IntersectionGeometryList_template()
{
}

IntersectionGeometryList_template::IntersectionGeometryList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

IntersectionGeometryList_template::IntersectionGeometryList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

IntersectionGeometryList_template::IntersectionGeometryList_template(const IntersectionGeometryList& other_value)
{
copy_value(other_value);
}

IntersectionGeometryList_template::IntersectionGeometryList_template(const OPTIONAL<IntersectionGeometryList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionGeometryList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.IntersectionGeometryList from an unbound optional field.");
}
}

IntersectionGeometryList_template::IntersectionGeometryList_template(const IntersectionGeometryList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

IntersectionGeometryList_template::~IntersectionGeometryList_template()
{
clean_up();
}

void IntersectionGeometryList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IntersectionGeometryList_template& IntersectionGeometryList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IntersectionGeometryList_template& IntersectionGeometryList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

IntersectionGeometryList_template& IntersectionGeometryList_template::operator=(const IntersectionGeometryList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IntersectionGeometryList_template& IntersectionGeometryList_template::operator=(const OPTIONAL<IntersectionGeometryList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionGeometryList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.IntersectionGeometryList.");
}
return *this;
}

IntersectionGeometryList_template& IntersectionGeometryList_template::operator=(const IntersectionGeometryList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

IntersectionGeometry_template& IntersectionGeometryList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.IntersectionGeometryList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.IntersectionGeometryList.");
    break;
}
return *single_value.value_elements[index_value];
}

IntersectionGeometry_template& IntersectionGeometryList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.IntersectionGeometryList.");
return (*this)[(int)index_value];
}

const IntersectionGeometry_template& IntersectionGeometryList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.IntersectionGeometryList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.IntersectionGeometryList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.IntersectionGeometryList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const IntersectionGeometry_template& IntersectionGeometryList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.IntersectionGeometryList.");
return (*this)[(int)index_value];
}

void IntersectionGeometryList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.IntersectionGeometryList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (IntersectionGeometry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new IntersectionGeometry_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new IntersectionGeometry_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (IntersectionGeometry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int IntersectionGeometryList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int IntersectionGeometryList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionGeometryList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionGeometryList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionGeometryList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionGeometryList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionGeometryList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionGeometryList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.IntersectionGeometryList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.IntersectionGeometryList");
}

boolean IntersectionGeometryList_template::match(const IntersectionGeometryList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.IntersectionGeometryList.");
}
return FALSE;
}

boolean IntersectionGeometryList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

IntersectionGeometryList IntersectionGeometryList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.IntersectionGeometryList.");
IntersectionGeometryList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

IntersectionGeometryList IntersectionGeometryList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

IntersectionGeometryList IntersectionGeometryList_template::replace(int index, int len, const IntersectionGeometryList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

IntersectionGeometryList IntersectionGeometryList_template::replace(int index, int len, const IntersectionGeometryList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void IntersectionGeometryList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new IntersectionGeometryList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.IntersectionGeometryList.");
}
set_selection(template_type);
}

IntersectionGeometryList_template& IntersectionGeometryList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.IntersectionGeometryList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.IntersectionGeometryList.");
return value_list.list_value[list_index];
}

void IntersectionGeometryList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void IntersectionGeometryList_template::log_match(const IntersectionGeometryList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IntersectionGeometryList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.IntersectionGeometryList.");
}
}

void IntersectionGeometryList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.IntersectionGeometryList.");
single_value.value_elements = (IntersectionGeometry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new IntersectionGeometry_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IntersectionGeometryList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.IntersectionGeometryList.");
}
}

boolean IntersectionGeometryList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IntersectionGeometryList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void IntersectionGeometryList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.IntersectionGeometryList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IntersectionGeometryList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.IntersectionGeometryList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* IntersectionGeometryList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.IntersectionGeometryList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void IntersectionGeometryList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometryList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.IntersectionGeometryList");
}

IntersectionReferenceID::IntersectionReferenceID()
{
  bound_flag = FALSE;
}

IntersectionReferenceID::IntersectionReferenceID(const OPTIONAL<INTEGER>& par_region,
    const INTEGER& par_id)
  :   field_region(par_region),
  field_id(par_id)
{
  bound_flag = TRUE;
}

IntersectionReferenceID::IntersectionReferenceID(const IntersectionReferenceID& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.IntersectionReferenceID.");
bound_flag = TRUE;
if (other_value.region().is_bound()) field_region = other_value.region();
else field_region.clean_up();
if (other_value.id().is_bound()) field_id = other_value.id();
else field_id.clean_up();
}

void IntersectionReferenceID::clean_up()
{
field_region.clean_up();
field_id.clean_up();
bound_flag = FALSE;
}

IntersectionReferenceID& IntersectionReferenceID::operator=(const IntersectionReferenceID& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.IntersectionReferenceID.");
  bound_flag = TRUE;
  if (other_value.region().is_bound()) field_region = other_value.region();
  else field_region.clean_up();
  if (other_value.id().is_bound()) field_id = other_value.id();
  else field_id.clean_up();
}
return *this;
}

boolean IntersectionReferenceID::operator==(const IntersectionReferenceID& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_region==other_value.field_region
  && field_id==other_value.field_id;
}

boolean IntersectionReferenceID::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_region.get_selection() || field_region.is_bound()) return TRUE;
if(field_id.is_bound()) return TRUE;
return FALSE;
}
boolean IntersectionReferenceID::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_region.get_selection() && !field_region.is_value()) return FALSE;
if(!field_id.is_value()) return FALSE;
return TRUE;
}
int IntersectionReferenceID::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.IntersectionReferenceID");
  int ret_val = 1;
  if (field_region.ispresent()) ret_val++;
  return ret_val;
}

void IntersectionReferenceID::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ region := ");
field_region.log();
TTCN_Logger::log_event_str(", id := ");
field_id.log();
TTCN_Logger::log_event_str(" }");
}

void IntersectionReferenceID::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.IntersectionReferenceID'");
    }
    if (strcmp("region", param_field) == 0) {
      region().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.IntersectionReferenceID'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @DSRC.IntersectionReferenceID has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) region().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.IntersectionReferenceID: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.IntersectionReferenceID");
  }
}

Module_Param* IntersectionReferenceID::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.IntersectionReferenceID'");
    }
    if (strcmp("region", param_field) == 0) {
      return region().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.IntersectionReferenceID'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_region = field_region.get_param(param_name);
  mp_field_region->set_id(new Module_Param_FieldName(mcopystr("region")));
  mp->add_elem(mp_field_region);
  Module_Param* mp_field_id = field_id.get_param(param_name);
  mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
  mp->add_elem(mp_field_id);
  return mp;
  }

void IntersectionReferenceID::set_implicit_omit()
{
if (!region().is_bound()) region() = OMIT_VALUE;
else region().set_implicit_omit();
if (id().is_bound()) id().set_implicit_omit();
}

void IntersectionReferenceID::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.IntersectionReferenceID.");
field_region.encode_text(text_buf);
field_id.encode_text(text_buf);
}

void IntersectionReferenceID::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_region.decode_text(text_buf);
field_id.decode_text(text_buf);
}

void IntersectionReferenceID::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IntersectionReferenceID::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* IntersectionReferenceID::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("region': ");
  new_tlv->add_TLV(field_region.BER_encode_TLV(IntersectionReferenceID_region_descr_, p_coding));
  ec_1.set_msg("id': ");
  new_tlv->add_TLV(field_id.BER_encode_TLV(IntersectionReferenceID_id_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean IntersectionReferenceID::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.IntersectionReferenceID' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("region': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_region=OMIT_VALUE;
    else {
      field_region.BER_decode_TLV(IntersectionReferenceID_region_descr_, tmp_tlv, L_form);
      if(field_region.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("id': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_id.BER_decode_TLV(IntersectionReferenceID_id_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int IntersectionReferenceID::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.IntersectionReferenceID.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_region.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "region");
    enc_len += field_region.JSON_encode(IntersectionReferenceID_region_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "id");
    enc_len += field_id.JSON_encode(IntersectionReferenceID_id_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IntersectionReferenceID::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "region", name_len)) {
         int ret_val = field_region.JSON_decode(IntersectionReferenceID_region_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "region");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (2 == name_len && 0 == strncmp(fld_name, "id", name_len)) {
         int ret_val = field_id.JSON_decode(IntersectionReferenceID_id_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "id");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_region.is_bound()) {
    field_region = OMIT_VALUE;
  }
if (!field_id.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "id");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IntersectionReferenceID_template::single_value_struct {
INTEGER_template field_region;
INTEGER_template field_id;
};

void IntersectionReferenceID_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_region = ANY_OR_OMIT;
single_value->field_id = ANY_VALUE;
}
}
}

void IntersectionReferenceID_template::copy_value(const IntersectionReferenceID& other_value)
{
single_value = new single_value_struct;
if (other_value.region().is_bound()) {
  if (other_value.region().ispresent()) single_value->field_region = other_value.region()();
  else single_value->field_region = OMIT_VALUE;
} else {
  single_value->field_region.clean_up();
}
if (other_value.id().is_bound()) {
  single_value->field_id = other_value.id();
} else {
  single_value->field_id.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IntersectionReferenceID_template::copy_template(const IntersectionReferenceID_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.region().get_selection()) {
single_value->field_region = other_value.region();
} else {
single_value->field_region.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.id().get_selection()) {
single_value->field_id = other_value.id();
} else {
single_value->field_id.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IntersectionReferenceID_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.IntersectionReferenceID.");
break;
}
set_selection(other_value);
}

IntersectionReferenceID_template::IntersectionReferenceID_template()
{
}

IntersectionReferenceID_template::IntersectionReferenceID_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IntersectionReferenceID_template::IntersectionReferenceID_template(const IntersectionReferenceID& other_value)
{
copy_value(other_value);
}

IntersectionReferenceID_template::IntersectionReferenceID_template(const OPTIONAL<IntersectionReferenceID>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionReferenceID&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.IntersectionReferenceID from an unbound optional field.");
}
}

IntersectionReferenceID_template::IntersectionReferenceID_template(const IntersectionReferenceID_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IntersectionReferenceID_template::~IntersectionReferenceID_template()
{
clean_up();
}

IntersectionReferenceID_template& IntersectionReferenceID_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IntersectionReferenceID_template& IntersectionReferenceID_template::operator=(const IntersectionReferenceID& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IntersectionReferenceID_template& IntersectionReferenceID_template::operator=(const OPTIONAL<IntersectionReferenceID>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionReferenceID&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.IntersectionReferenceID.");
}
return *this;
}

IntersectionReferenceID_template& IntersectionReferenceID_template::operator=(const IntersectionReferenceID_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IntersectionReferenceID_template::match(const IntersectionReferenceID& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.region().is_bound()) return FALSE;
if((other_value.region().ispresent() ? !single_value->field_region.match((const INTEGER&)other_value.region(), legacy) : !single_value->field_region.match_omit(legacy)))return FALSE;
if(!other_value.id().is_bound()) return FALSE;
if(!single_value->field_id.match(other_value.id(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.IntersectionReferenceID.");
}
return FALSE;
}

boolean IntersectionReferenceID_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_region.is_omit() || single_value->field_region.is_bound()) return TRUE;
if (single_value->field_id.is_bound()) return TRUE;
return FALSE;
}

boolean IntersectionReferenceID_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_region.is_omit() && !single_value->field_region.is_value()) return FALSE;
if (!single_value->field_id.is_value()) return FALSE;
return TRUE;
}

void IntersectionReferenceID_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IntersectionReferenceID IntersectionReferenceID_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.IntersectionReferenceID.");
IntersectionReferenceID ret_val;
if (single_value->field_region.is_omit()) ret_val.region() = OMIT_VALUE;
else if (single_value->field_region.is_bound()) {
ret_val.region() = single_value->field_region.valueof();
}
if (single_value->field_id.is_bound()) {
ret_val.id() = single_value->field_id.valueof();
}
return ret_val;
}

void IntersectionReferenceID_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.IntersectionReferenceID.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IntersectionReferenceID_template[list_length];
}

IntersectionReferenceID_template& IntersectionReferenceID_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.IntersectionReferenceID.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.IntersectionReferenceID.");
return value_list.list_value[list_index];
}

INTEGER_template& IntersectionReferenceID_template::region()
{
set_specific();
return single_value->field_region;
}

const INTEGER_template& IntersectionReferenceID_template::region() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field region of a non-specific template of type @DSRC.IntersectionReferenceID.");
return single_value->field_region;
}

INTEGER_template& IntersectionReferenceID_template::id()
{
set_specific();
return single_value->field_id;
}

const INTEGER_template& IntersectionReferenceID_template::id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field id of a non-specific template of type @DSRC.IntersectionReferenceID.");
return single_value->field_id;
}

int IntersectionReferenceID_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionReferenceID which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_region.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.IntersectionReferenceID containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionReferenceID containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionReferenceID containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionReferenceID containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionReferenceID containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.IntersectionReferenceID.");
  }
  return 0;
}

void IntersectionReferenceID_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ region := ");
single_value->field_region.log();
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IntersectionReferenceID_template::log_match(const IntersectionReferenceID& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.region().ispresent()){
if(!single_value->field_region.match(match_value.region(), legacy)){
TTCN_Logger::log_logmatch_info(".region");
single_value->field_region.log_match(match_value.region(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_region.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".region := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_region.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_id.match(match_value.id(), legacy)){
TTCN_Logger::log_logmatch_info(".id");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ region := ");
if (match_value.region().ispresent()) single_value->field_region.log_match(match_value.region(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_region.log();
if (single_value->field_region.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IntersectionReferenceID_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_region.encode_text(text_buf);
single_value->field_id.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.IntersectionReferenceID.");
}
}

void IntersectionReferenceID_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_region.decode_text(text_buf);
single_value->field_id.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IntersectionReferenceID_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.IntersectionReferenceID.");
}
}

void IntersectionReferenceID_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.IntersectionReferenceID'");
    }
    if (strcmp("region", param_field) == 0) {
      region().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.IntersectionReferenceID'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IntersectionReferenceID_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @DSRC.IntersectionReferenceID has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) region().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.IntersectionReferenceID: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.IntersectionReferenceID");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* IntersectionReferenceID_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.IntersectionReferenceID'");
    }
    if (strcmp("region", param_field) == 0) {
      return region().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.IntersectionReferenceID'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_region = single_value->field_region.get_param(param_name);
    mp_field_region->set_id(new Module_Param_FieldName(mcopystr("region")));
    mp->add_elem(mp_field_region);
    Module_Param* mp_field_id = single_value->field_id.get_param(param_name);
    mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
    mp->add_elem(mp_field_id);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void IntersectionReferenceID_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_region.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionReferenceID");
single_value->field_id.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionReferenceID");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.IntersectionReferenceID");
}

boolean IntersectionReferenceID_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IntersectionReferenceID_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Position3D__2::Position3D__2()
{
  bound_flag = FALSE;
}

Position3D__2::Position3D__2(const INTEGER& par_lat,
    const INTEGER& par_long_,
    const OPTIONAL<INTEGER>& par_elevation,
    const OPTIONAL<REG__D::Reg__Position3D>& par_regional)
  :   field_lat(par_lat),
  field_long_(par_long_),
  field_elevation(par_elevation),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

Position3D__2::Position3D__2(const Position3D__2& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.Position3D-2.");
bound_flag = TRUE;
if (other_value.lat().is_bound()) field_lat = other_value.lat();
else field_lat.clean_up();
if (other_value.long_().is_bound()) field_long_ = other_value.long_();
else field_long_.clean_up();
if (other_value.elevation().is_bound()) field_elevation = other_value.elevation();
else field_elevation.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void Position3D__2::clean_up()
{
field_lat.clean_up();
field_long_.clean_up();
field_elevation.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

Position3D__2& Position3D__2::operator=(const Position3D__2& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.Position3D-2.");
  bound_flag = TRUE;
  if (other_value.lat().is_bound()) field_lat = other_value.lat();
  else field_lat.clean_up();
  if (other_value.long_().is_bound()) field_long_ = other_value.long_();
  else field_long_.clean_up();
  if (other_value.elevation().is_bound()) field_elevation = other_value.elevation();
  else field_elevation.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean Position3D__2::operator==(const Position3D__2& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lat==other_value.field_lat
  && field_long_==other_value.field_long_
  && field_elevation==other_value.field_elevation
  && field_regional==other_value.field_regional;
}

boolean Position3D__2::is_bound() const
{
if (bound_flag) return TRUE;
if(field_lat.is_bound()) return TRUE;
if(field_long_.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_elevation.get_selection() || field_elevation.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean Position3D__2::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_lat.is_value()) return FALSE;
if(!field_long_.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_elevation.get_selection() && !field_elevation.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int Position3D__2::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.Position3D-2");
  int ret_val = 2;
  if (field_elevation.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void Position3D__2::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lat := ");
field_lat.log();
TTCN_Logger::log_event_str(", long := ");
field_long_.log();
TTCN_Logger::log_event_str(", elevation := ");
field_elevation.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void Position3D__2::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.Position3D-2'");
    }
    if (strcmp("lat", param_field) == 0) {
      lat().set_param(param);
      return;
    } else if (strcmp("long", param_field) == 0) {
      long_().set_param(param);
      return;
    } else if (strcmp("elevation", param_field) == 0) {
      elevation().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.Position3D-2'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @DSRC.Position3D-2 has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lat().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) long_().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) elevation().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lat")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lat().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "long")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          long_().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "elevation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          elevation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.Position3D-2: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.Position3D-2");
  }
}

Module_Param* Position3D__2::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.Position3D-2'");
    }
    if (strcmp("lat", param_field) == 0) {
      return lat().get_param(param_name);
    } else if (strcmp("long", param_field) == 0) {
      return long_().get_param(param_name);
    } else if (strcmp("elevation", param_field) == 0) {
      return elevation().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.Position3D-2'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_lat = field_lat.get_param(param_name);
  mp_field_lat->set_id(new Module_Param_FieldName(mcopystr("lat")));
  mp->add_elem(mp_field_lat);
  Module_Param* mp_field_long_ = field_long_.get_param(param_name);
  mp_field_long_->set_id(new Module_Param_FieldName(mcopystr("long")));
  mp->add_elem(mp_field_long_);
  Module_Param* mp_field_elevation = field_elevation.get_param(param_name);
  mp_field_elevation->set_id(new Module_Param_FieldName(mcopystr("elevation")));
  mp->add_elem(mp_field_elevation);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void Position3D__2::set_implicit_omit()
{
if (lat().is_bound()) lat().set_implicit_omit();
if (long_().is_bound()) long_().set_implicit_omit();
if (!elevation().is_bound()) elevation() = OMIT_VALUE;
else elevation().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void Position3D__2::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.Position3D-2.");
field_lat.encode_text(text_buf);
field_long_.encode_text(text_buf);
field_elevation.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void Position3D__2::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lat.decode_text(text_buf);
field_long_.decode_text(text_buf);
field_elevation.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void Position3D__2::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Position3D__2::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* Position3D__2::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("lat': ");
  new_tlv->add_TLV(field_lat.BER_encode_TLV(Position3D__2_lat_descr_, p_coding));
  ec_1.set_msg("long': ");
  new_tlv->add_TLV(field_long_.BER_encode_TLV(Position3D__2_long__descr_, p_coding));
  ec_1.set_msg("elevation': ");
  new_tlv->add_TLV(field_elevation.BER_encode_TLV(Position3D__2_elevation_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(Position3D__2_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean Position3D__2::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.Position3D-2' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("lat': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_lat.BER_decode_TLV(Position3D__2_lat_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("long': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_long_.BER_decode_TLV(Position3D__2_long__descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("elevation': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_elevation=OMIT_VALUE;
    else {
      field_elevation.BER_decode_TLV(Position3D__2_elevation_descr_, tmp_tlv, L_form);
      if(field_elevation.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(Position3D__2_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int Position3D__2::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.Position3D-2.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lat");
    enc_len += field_lat.JSON_encode(Position3D__2_lat_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "long");
    enc_len += field_long_.JSON_encode(Position3D__2_long__descr_, p_tok);
  }

  if (field_elevation.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "elevation");
    enc_len += field_elevation.JSON_encode(Position3D__2_elevation_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(Position3D__2_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Position3D__2::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "lat", name_len)) {
         int ret_val = field_lat.JSON_decode(Position3D__2_lat_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lat");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "long", name_len)) {
         int ret_val = field_long_.JSON_decode(Position3D__2_long__descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "long");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "elevation", name_len)) {
         int ret_val = field_elevation.JSON_decode(Position3D__2_elevation_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "elevation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(Position3D__2_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lat.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lat");
    return JSON_ERROR_FATAL;
  }
if (!field_long_.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "long");
    return JSON_ERROR_FATAL;
  }
if (!field_elevation.is_bound()) {
    field_elevation = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct Position3D__2_template::single_value_struct {
INTEGER_template field_lat;
INTEGER_template field_long_;
INTEGER_template field_elevation;
REG__D::Reg__Position3D_template field_regional;
};

void Position3D__2_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lat = ANY_VALUE;
single_value->field_long_ = ANY_VALUE;
single_value->field_elevation = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void Position3D__2_template::copy_value(const Position3D__2& other_value)
{
single_value = new single_value_struct;
if (other_value.lat().is_bound()) {
  single_value->field_lat = other_value.lat();
} else {
  single_value->field_lat.clean_up();
}
if (other_value.long_().is_bound()) {
  single_value->field_long_ = other_value.long_();
} else {
  single_value->field_long_.clean_up();
}
if (other_value.elevation().is_bound()) {
  if (other_value.elevation().ispresent()) single_value->field_elevation = other_value.elevation()();
  else single_value->field_elevation = OMIT_VALUE;
} else {
  single_value->field_elevation.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Position3D__2_template::copy_template(const Position3D__2_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lat().get_selection()) {
single_value->field_lat = other_value.lat();
} else {
single_value->field_lat.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.long_().get_selection()) {
single_value->field_long_ = other_value.long_();
} else {
single_value->field_long_.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.elevation().get_selection()) {
single_value->field_elevation = other_value.elevation();
} else {
single_value->field_elevation.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Position3D__2_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.Position3D-2.");
break;
}
set_selection(other_value);
}

Position3D__2_template::Position3D__2_template()
{
}

Position3D__2_template::Position3D__2_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Position3D__2_template::Position3D__2_template(const Position3D__2& other_value)
{
copy_value(other_value);
}

Position3D__2_template::Position3D__2_template(const OPTIONAL<Position3D__2>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Position3D__2&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.Position3D-2 from an unbound optional field.");
}
}

Position3D__2_template::Position3D__2_template(const Position3D__2_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Position3D__2_template::~Position3D__2_template()
{
clean_up();
}

Position3D__2_template& Position3D__2_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Position3D__2_template& Position3D__2_template::operator=(const Position3D__2& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Position3D__2_template& Position3D__2_template::operator=(const OPTIONAL<Position3D__2>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Position3D__2&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.Position3D-2.");
}
return *this;
}

Position3D__2_template& Position3D__2_template::operator=(const Position3D__2_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Position3D__2_template::match(const Position3D__2& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lat().is_bound()) return FALSE;
if(!single_value->field_lat.match(other_value.lat(), legacy))return FALSE;
if(!other_value.long_().is_bound()) return FALSE;
if(!single_value->field_long_.match(other_value.long_(), legacy))return FALSE;
if(!other_value.elevation().is_bound()) return FALSE;
if((other_value.elevation().ispresent() ? !single_value->field_elevation.match((const INTEGER&)other_value.elevation(), legacy) : !single_value->field_elevation.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REG__D::Reg__Position3D&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.Position3D-2.");
}
return FALSE;
}

boolean Position3D__2_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lat.is_bound()) return TRUE;
if (single_value->field_long_.is_bound()) return TRUE;
if (single_value->field_elevation.is_omit() || single_value->field_elevation.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean Position3D__2_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lat.is_value()) return FALSE;
if (!single_value->field_long_.is_value()) return FALSE;
if (!single_value->field_elevation.is_omit() && !single_value->field_elevation.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void Position3D__2_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Position3D__2 Position3D__2_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.Position3D-2.");
Position3D__2 ret_val;
if (single_value->field_lat.is_bound()) {
ret_val.lat() = single_value->field_lat.valueof();
}
if (single_value->field_long_.is_bound()) {
ret_val.long_() = single_value->field_long_.valueof();
}
if (single_value->field_elevation.is_omit()) ret_val.elevation() = OMIT_VALUE;
else if (single_value->field_elevation.is_bound()) {
ret_val.elevation() = single_value->field_elevation.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void Position3D__2_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.Position3D-2.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Position3D__2_template[list_length];
}

Position3D__2_template& Position3D__2_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.Position3D-2.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.Position3D-2.");
return value_list.list_value[list_index];
}

INTEGER_template& Position3D__2_template::lat()
{
set_specific();
return single_value->field_lat;
}

const INTEGER_template& Position3D__2_template::lat() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lat of a non-specific template of type @DSRC.Position3D-2.");
return single_value->field_lat;
}

INTEGER_template& Position3D__2_template::long_()
{
set_specific();
return single_value->field_long_;
}

const INTEGER_template& Position3D__2_template::long_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field long of a non-specific template of type @DSRC.Position3D-2.");
return single_value->field_long_;
}

INTEGER_template& Position3D__2_template::elevation()
{
set_specific();
return single_value->field_elevation;
}

const INTEGER_template& Position3D__2_template::elevation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field elevation of a non-specific template of type @DSRC.Position3D-2.");
return single_value->field_elevation;
}

REG__D::Reg__Position3D_template& Position3D__2_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REG__D::Reg__Position3D_template& Position3D__2_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.Position3D-2.");
return single_value->field_regional;
}

int Position3D__2_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.Position3D-2 which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_elevation.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.Position3D-2 containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.Position3D-2 containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.Position3D-2 containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.Position3D-2 containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.Position3D-2 containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.Position3D-2.");
  }
  return 0;
}

void Position3D__2_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lat := ");
single_value->field_lat.log();
TTCN_Logger::log_event_str(", long := ");
single_value->field_long_.log();
TTCN_Logger::log_event_str(", elevation := ");
single_value->field_elevation.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Position3D__2_template::log_match(const Position3D__2& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_lat.match(match_value.lat(), legacy)){
TTCN_Logger::log_logmatch_info(".lat");
single_value->field_lat.log_match(match_value.lat(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_long_.match(match_value.long_(), legacy)){
TTCN_Logger::log_logmatch_info(".long");
single_value->field_long_.log_match(match_value.long_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.elevation().ispresent()){
if(!single_value->field_elevation.match(match_value.elevation(), legacy)){
TTCN_Logger::log_logmatch_info(".elevation");
single_value->field_elevation.log_match(match_value.elevation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_elevation.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".elevation := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_elevation.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lat := ");
single_value->field_lat.log_match(match_value.lat(), legacy);
TTCN_Logger::log_event_str(", long := ");
single_value->field_long_.log_match(match_value.long_(), legacy);
TTCN_Logger::log_event_str(", elevation := ");
if (match_value.elevation().ispresent()) single_value->field_elevation.log_match(match_value.elevation(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_elevation.log();
if (single_value->field_elevation.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Position3D__2_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lat.encode_text(text_buf);
single_value->field_long_.encode_text(text_buf);
single_value->field_elevation.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.Position3D-2.");
}
}

void Position3D__2_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lat.decode_text(text_buf);
single_value->field_long_.decode_text(text_buf);
single_value->field_elevation.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Position3D__2_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.Position3D-2.");
}
}

void Position3D__2_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.Position3D-2'");
    }
    if (strcmp("lat", param_field) == 0) {
      lat().set_param(param);
      return;
    } else if (strcmp("long", param_field) == 0) {
      long_().set_param(param);
      return;
    } else if (strcmp("elevation", param_field) == 0) {
      elevation().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.Position3D-2'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Position3D__2_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @DSRC.Position3D-2 has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lat().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) long_().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) elevation().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lat")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lat().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "long")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          long_().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "elevation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          elevation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.Position3D-2: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.Position3D-2");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Position3D__2_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.Position3D-2'");
    }
    if (strcmp("lat", param_field) == 0) {
      return lat().get_param(param_name);
    } else if (strcmp("long", param_field) == 0) {
      return long_().get_param(param_name);
    } else if (strcmp("elevation", param_field) == 0) {
      return elevation().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.Position3D-2'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_lat = single_value->field_lat.get_param(param_name);
    mp_field_lat->set_id(new Module_Param_FieldName(mcopystr("lat")));
    mp->add_elem(mp_field_lat);
    Module_Param* mp_field_long_ = single_value->field_long_.get_param(param_name);
    mp_field_long_->set_id(new Module_Param_FieldName(mcopystr("long")));
    mp->add_elem(mp_field_long_);
    Module_Param* mp_field_elevation = single_value->field_elevation.get_param(param_name);
    mp_field_elevation->set_id(new Module_Param_FieldName(mcopystr("elevation")));
    mp->add_elem(mp_field_elevation);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Position3D__2_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lat.check_restriction(t_res, t_name ? t_name : "@DSRC.Position3D-2");
single_value->field_long_.check_restriction(t_res, t_name ? t_name : "@DSRC.Position3D-2");
single_value->field_elevation.check_restriction(t_res, t_name ? t_name : "@DSRC.Position3D-2");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.Position3D-2");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.Position3D-2");
}

boolean Position3D__2_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Position3D__2_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const GenericLane LaneList::UNBOUND_ELEM;
LaneList::LaneList()
{
val_ptr = NULL;
}

LaneList::LaneList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

LaneList::LaneList(const LaneList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.LaneList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

LaneList::~LaneList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void LaneList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

LaneList& LaneList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

LaneList& LaneList::operator=(const LaneList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.LaneList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean LaneList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.LaneList.");
return val_ptr->n_elements == 0 ;
}

boolean LaneList::operator==(const LaneList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.LaneList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.LaneList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

GenericLane& LaneList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.LaneList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (GenericLane**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new GenericLane(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new GenericLane;
}
return *val_ptr->value_elements[index_value];
}

GenericLane& LaneList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.LaneList.");
return (*this)[(int)index_value];
}

const GenericLane& LaneList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.LaneList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.LaneList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.LaneList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const GenericLane& LaneList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.LaneList.");
return (*this)[(int)index_value];
}

LaneList LaneList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

LaneList LaneList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

LaneList LaneList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

LaneList LaneList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.LaneList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
LaneList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new GenericLane(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

LaneList LaneList::operator+(const LaneList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.LaneList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
LaneList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new GenericLane(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new GenericLane(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

LaneList LaneList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.LaneList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.LaneList","element");
LaneList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new GenericLane(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

LaneList LaneList::replace(int index, int len, const LaneList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.LaneList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.LaneList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.LaneList","element");
LaneList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new GenericLane(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new GenericLane(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new GenericLane(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

LaneList LaneList::replace(int index, int len, const LaneList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void LaneList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.LaneList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (GenericLane**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new GenericLane(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (GenericLane**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.LaneList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (GenericLane**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean LaneList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int LaneList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.LaneList.");
return val_ptr->n_elements;
}

int LaneList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.LaneList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void LaneList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void LaneList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.LaneList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.LaneList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.LaneList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* LaneList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.LaneList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void LaneList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void LaneList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.LaneList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void LaneList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.LaneList.");
val_ptr->value_elements = (GenericLane**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new GenericLane;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void LaneList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LaneList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* LaneList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean LaneList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (GenericLane**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new GenericLane;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int LaneList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.LaneList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int LaneList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    GenericLane* val = new GenericLane;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (GenericLane**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void LaneList_template::copy_value(const LaneList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.LaneList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (GenericLane_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new GenericLane_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new GenericLane_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void LaneList_template::copy_template(const LaneList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (GenericLane_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new GenericLane_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new GenericLane_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LaneList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.LaneList.");
break;
}
set_selection(other_value);
}

boolean LaneList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const LaneList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const LaneList*)value_ptr)[value_index], legacy);
else return ((const LaneList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

LaneList_template::LaneList_template()
{
}

LaneList_template::LaneList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

LaneList_template::LaneList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

LaneList_template::LaneList_template(const LaneList& other_value)
{
copy_value(other_value);
}

LaneList_template::LaneList_template(const OPTIONAL<LaneList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.LaneList from an unbound optional field.");
}
}

LaneList_template::LaneList_template(const LaneList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

LaneList_template::~LaneList_template()
{
clean_up();
}

void LaneList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LaneList_template& LaneList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LaneList_template& LaneList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

LaneList_template& LaneList_template::operator=(const LaneList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LaneList_template& LaneList_template::operator=(const OPTIONAL<LaneList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.LaneList.");
}
return *this;
}

LaneList_template& LaneList_template::operator=(const LaneList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

GenericLane_template& LaneList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.LaneList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.LaneList.");
    break;
}
return *single_value.value_elements[index_value];
}

GenericLane_template& LaneList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.LaneList.");
return (*this)[(int)index_value];
}

const GenericLane_template& LaneList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.LaneList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.LaneList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.LaneList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const GenericLane_template& LaneList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.LaneList.");
return (*this)[(int)index_value];
}

void LaneList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.LaneList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (GenericLane_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new GenericLane_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new GenericLane_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (GenericLane_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int LaneList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int LaneList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.LaneList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.LaneList");
}

boolean LaneList_template::match(const LaneList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.LaneList.");
}
return FALSE;
}

boolean LaneList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

LaneList LaneList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.LaneList.");
LaneList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

LaneList LaneList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

LaneList LaneList_template::replace(int index, int len, const LaneList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

LaneList LaneList_template::replace(int index, int len, const LaneList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void LaneList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new LaneList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.LaneList.");
}
set_selection(template_type);
}

LaneList_template& LaneList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.LaneList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.LaneList.");
return value_list.list_value[list_index];
}

void LaneList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void LaneList_template::log_match(const LaneList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LaneList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.LaneList.");
}
}

void LaneList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.LaneList.");
single_value.value_elements = (GenericLane_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new GenericLane_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LaneList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.LaneList.");
}
}

boolean LaneList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LaneList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void LaneList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.LaneList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LaneList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.LaneList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* LaneList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.LaneList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void LaneList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.LaneList");
}

void LaneTypeAttributes::copy_value(const LaneTypeAttributes& other_value)
{
switch (other_value.union_selection) {
case ALT_vehicle:
field_vehicle = new BITSTRING(*other_value.field_vehicle);
break;
case ALT_crosswalk:
field_crosswalk = new BITSTRING(*other_value.field_crosswalk);
break;
case ALT_bikeLane:
field_bikeLane = new BITSTRING(*other_value.field_bikeLane);
break;
case ALT_sidewalk:
field_sidewalk = new BITSTRING(*other_value.field_sidewalk);
break;
case ALT_median:
field_median = new BITSTRING(*other_value.field_median);
break;
case ALT_striping:
field_striping = new BITSTRING(*other_value.field_striping);
break;
case ALT_trackedVehicle:
field_trackedVehicle = new BITSTRING(*other_value.field_trackedVehicle);
break;
case ALT_parking:
field_parking = new BITSTRING(*other_value.field_parking);
break;
default:
TTCN_error("Assignment of an unbound union value of type @DSRC.LaneTypeAttributes.");
}
union_selection = other_value.union_selection;
}

LaneTypeAttributes::LaneTypeAttributes()
{
union_selection = UNBOUND_VALUE;
}

LaneTypeAttributes::LaneTypeAttributes(const LaneTypeAttributes& other_value)
: Base_Type(){
copy_value(other_value);
}

LaneTypeAttributes::~LaneTypeAttributes()
{
clean_up();
}

LaneTypeAttributes& LaneTypeAttributes::operator=(const LaneTypeAttributes& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean LaneTypeAttributes::operator==(const LaneTypeAttributes& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @DSRC.LaneTypeAttributes.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @DSRC.LaneTypeAttributes.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_vehicle:
return *field_vehicle == *other_value.field_vehicle;
case ALT_crosswalk:
return *field_crosswalk == *other_value.field_crosswalk;
case ALT_bikeLane:
return *field_bikeLane == *other_value.field_bikeLane;
case ALT_sidewalk:
return *field_sidewalk == *other_value.field_sidewalk;
case ALT_median:
return *field_median == *other_value.field_median;
case ALT_striping:
return *field_striping == *other_value.field_striping;
case ALT_trackedVehicle:
return *field_trackedVehicle == *other_value.field_trackedVehicle;
case ALT_parking:
return *field_parking == *other_value.field_parking;
default:
return FALSE;
}
}

BITSTRING& LaneTypeAttributes::vehicle()
{
if (union_selection != ALT_vehicle) {
clean_up();
field_vehicle = new BITSTRING;
union_selection = ALT_vehicle;
}
return *field_vehicle;
}

const BITSTRING& LaneTypeAttributes::vehicle() const
{
if (union_selection != ALT_vehicle) TTCN_error("Using non-selected field vehicle in a value of union type @DSRC.LaneTypeAttributes.");
return *field_vehicle;
}

BITSTRING& LaneTypeAttributes::crosswalk()
{
if (union_selection != ALT_crosswalk) {
clean_up();
field_crosswalk = new BITSTRING;
union_selection = ALT_crosswalk;
}
return *field_crosswalk;
}

const BITSTRING& LaneTypeAttributes::crosswalk() const
{
if (union_selection != ALT_crosswalk) TTCN_error("Using non-selected field crosswalk in a value of union type @DSRC.LaneTypeAttributes.");
return *field_crosswalk;
}

BITSTRING& LaneTypeAttributes::bikeLane()
{
if (union_selection != ALT_bikeLane) {
clean_up();
field_bikeLane = new BITSTRING;
union_selection = ALT_bikeLane;
}
return *field_bikeLane;
}

const BITSTRING& LaneTypeAttributes::bikeLane() const
{
if (union_selection != ALT_bikeLane) TTCN_error("Using non-selected field bikeLane in a value of union type @DSRC.LaneTypeAttributes.");
return *field_bikeLane;
}

BITSTRING& LaneTypeAttributes::sidewalk()
{
if (union_selection != ALT_sidewalk) {
clean_up();
field_sidewalk = new BITSTRING;
union_selection = ALT_sidewalk;
}
return *field_sidewalk;
}

const BITSTRING& LaneTypeAttributes::sidewalk() const
{
if (union_selection != ALT_sidewalk) TTCN_error("Using non-selected field sidewalk in a value of union type @DSRC.LaneTypeAttributes.");
return *field_sidewalk;
}

BITSTRING& LaneTypeAttributes::median()
{
if (union_selection != ALT_median) {
clean_up();
field_median = new BITSTRING;
union_selection = ALT_median;
}
return *field_median;
}

const BITSTRING& LaneTypeAttributes::median() const
{
if (union_selection != ALT_median) TTCN_error("Using non-selected field median in a value of union type @DSRC.LaneTypeAttributes.");
return *field_median;
}

BITSTRING& LaneTypeAttributes::striping()
{
if (union_selection != ALT_striping) {
clean_up();
field_striping = new BITSTRING;
union_selection = ALT_striping;
}
return *field_striping;
}

const BITSTRING& LaneTypeAttributes::striping() const
{
if (union_selection != ALT_striping) TTCN_error("Using non-selected field striping in a value of union type @DSRC.LaneTypeAttributes.");
return *field_striping;
}

BITSTRING& LaneTypeAttributes::trackedVehicle()
{
if (union_selection != ALT_trackedVehicle) {
clean_up();
field_trackedVehicle = new BITSTRING;
union_selection = ALT_trackedVehicle;
}
return *field_trackedVehicle;
}

const BITSTRING& LaneTypeAttributes::trackedVehicle() const
{
if (union_selection != ALT_trackedVehicle) TTCN_error("Using non-selected field trackedVehicle in a value of union type @DSRC.LaneTypeAttributes.");
return *field_trackedVehicle;
}

BITSTRING& LaneTypeAttributes::parking()
{
if (union_selection != ALT_parking) {
clean_up();
field_parking = new BITSTRING;
union_selection = ALT_parking;
}
return *field_parking;
}

const BITSTRING& LaneTypeAttributes::parking() const
{
if (union_selection != ALT_parking) TTCN_error("Using non-selected field parking in a value of union type @DSRC.LaneTypeAttributes.");
return *field_parking;
}

boolean LaneTypeAttributes::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.LaneTypeAttributes.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @DSRC.LaneTypeAttributes.");
return union_selection == checked_selection;
}

boolean LaneTypeAttributes::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean LaneTypeAttributes::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_vehicle: return field_vehicle->is_value();
case ALT_crosswalk: return field_crosswalk->is_value();
case ALT_bikeLane: return field_bikeLane->is_value();
case ALT_sidewalk: return field_sidewalk->is_value();
case ALT_median: return field_median->is_value();
case ALT_striping: return field_striping->is_value();
case ALT_trackedVehicle: return field_trackedVehicle->is_value();
case ALT_parking: return field_parking->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void LaneTypeAttributes::clean_up()
{
switch (union_selection) {
case ALT_vehicle:
  delete field_vehicle;
  break;
case ALT_crosswalk:
  delete field_crosswalk;
  break;
case ALT_bikeLane:
  delete field_bikeLane;
  break;
case ALT_sidewalk:
  delete field_sidewalk;
  break;
case ALT_median:
  delete field_median;
  break;
case ALT_striping:
  delete field_striping;
  break;
case ALT_trackedVehicle:
  delete field_trackedVehicle;
  break;
case ALT_parking:
  delete field_parking;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void LaneTypeAttributes::log() const
{
switch (union_selection) {
case ALT_vehicle:
TTCN_Logger::log_event_str("{ vehicle := ");
field_vehicle->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_crosswalk:
TTCN_Logger::log_event_str("{ crosswalk := ");
field_crosswalk->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_bikeLane:
TTCN_Logger::log_event_str("{ bikeLane := ");
field_bikeLane->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sidewalk:
TTCN_Logger::log_event_str("{ sidewalk := ");
field_sidewalk->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_median:
TTCN_Logger::log_event_str("{ median := ");
field_median->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_striping:
TTCN_Logger::log_event_str("{ striping := ");
field_striping->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_trackedVehicle:
TTCN_Logger::log_event_str("{ trackedVehicle := ");
field_trackedVehicle->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_parking:
TTCN_Logger::log_event_str("{ parking := ");
field_parking->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void LaneTypeAttributes::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@DSRC.LaneTypeAttributes'");
    }
    if (strcmp("vehicle", param_field) == 0) {
      vehicle().set_param(param);
      return;
    } else if (strcmp("crosswalk", param_field) == 0) {
      crosswalk().set_param(param);
      return;
    } else if (strcmp("bikeLane", param_field) == 0) {
      bikeLane().set_param(param);
      return;
    } else if (strcmp("sidewalk", param_field) == 0) {
      sidewalk().set_param(param);
      return;
    } else if (strcmp("median", param_field) == 0) {
      median().set_param(param);
      return;
    } else if (strcmp("striping", param_field) == 0) {
      striping().set_param(param);
      return;
    } else if (strcmp("trackedVehicle", param_field) == 0) {
      trackedVehicle().set_param(param);
      return;
    } else if (strcmp("parking", param_field) == 0) {
      parking().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@DSRC.LaneTypeAttributes'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "vehicle")) {
    vehicle().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "crosswalk")) {
    crosswalk().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "bikeLane")) {
    bikeLane().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sidewalk")) {
    sidewalk().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "median")) {
    median().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "striping")) {
    striping().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "trackedVehicle")) {
    trackedVehicle().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "parking")) {
    parking().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @DSRC.LaneTypeAttributes.", mp_last->get_id()->get_name());
}

Module_Param* LaneTypeAttributes::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@DSRC.LaneTypeAttributes'");
    }
    if (strcmp("vehicle", param_field) == 0) {
      return vehicle().get_param(param_name);
    } else if (strcmp("crosswalk", param_field) == 0) {
      return crosswalk().get_param(param_name);
    } else if (strcmp("bikeLane", param_field) == 0) {
      return bikeLane().get_param(param_name);
    } else if (strcmp("sidewalk", param_field) == 0) {
      return sidewalk().get_param(param_name);
    } else if (strcmp("median", param_field) == 0) {
      return median().get_param(param_name);
    } else if (strcmp("striping", param_field) == 0) {
      return striping().get_param(param_name);
    } else if (strcmp("trackedVehicle", param_field) == 0) {
      return trackedVehicle().get_param(param_name);
    } else if (strcmp("parking", param_field) == 0) {
      return parking().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `LaneTypeAttributes'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_vehicle:
    mp_field = field_vehicle->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("vehicle")));
    break;
  case ALT_crosswalk:
    mp_field = field_crosswalk->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("crosswalk")));
    break;
  case ALT_bikeLane:
    mp_field = field_bikeLane->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("bikeLane")));
    break;
  case ALT_sidewalk:
    mp_field = field_sidewalk->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("sidewalk")));
    break;
  case ALT_median:
    mp_field = field_median->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("median")));
    break;
  case ALT_striping:
    mp_field = field_striping->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("striping")));
    break;
  case ALT_trackedVehicle:
    mp_field = field_trackedVehicle->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("trackedVehicle")));
    break;
  case ALT_parking:
    mp_field = field_parking->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("parking")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void LaneTypeAttributes::set_implicit_omit()
{
switch (union_selection) {
case ALT_vehicle:
field_vehicle->set_implicit_omit(); break;
case ALT_crosswalk:
field_crosswalk->set_implicit_omit(); break;
case ALT_bikeLane:
field_bikeLane->set_implicit_omit(); break;
case ALT_sidewalk:
field_sidewalk->set_implicit_omit(); break;
case ALT_median:
field_median->set_implicit_omit(); break;
case ALT_striping:
field_striping->set_implicit_omit(); break;
case ALT_trackedVehicle:
field_trackedVehicle->set_implicit_omit(); break;
case ALT_parking:
field_parking->set_implicit_omit(); break;
default: break;
}
}

void LaneTypeAttributes::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_vehicle:
field_vehicle->encode_text(text_buf);
break;
case ALT_crosswalk:
field_crosswalk->encode_text(text_buf);
break;
case ALT_bikeLane:
field_bikeLane->encode_text(text_buf);
break;
case ALT_sidewalk:
field_sidewalk->encode_text(text_buf);
break;
case ALT_median:
field_median->encode_text(text_buf);
break;
case ALT_striping:
field_striping->encode_text(text_buf);
break;
case ALT_trackedVehicle:
field_trackedVehicle->encode_text(text_buf);
break;
case ALT_parking:
field_parking->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @DSRC.LaneTypeAttributes.");
}
}

void LaneTypeAttributes::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_vehicle:
vehicle().decode_text(text_buf);
break;
case ALT_crosswalk:
crosswalk().decode_text(text_buf);
break;
case ALT_bikeLane:
bikeLane().decode_text(text_buf);
break;
case ALT_sidewalk:
sidewalk().decode_text(text_buf);
break;
case ALT_median:
median().decode_text(text_buf);
break;
case ALT_striping:
striping().decode_text(text_buf);
break;
case ALT_trackedVehicle:
trackedVehicle().decode_text(text_buf);
break;
case ALT_parking:
parking().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @DSRC.LaneTypeAttributes.");
}
}

void LaneTypeAttributes::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LaneTypeAttributes::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t *LaneTypeAttributes::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv;
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  switch (union_selection) {
  case ALT_vehicle:
    ec_1.set_msg("vehicle': ");
    new_tlv = field_vehicle->BER_encode_TLV(LaneTypeAttributes_vehicle_descr_, p_coding);
    break;
  case ALT_crosswalk:
    ec_1.set_msg("crosswalk': ");
    new_tlv = field_crosswalk->BER_encode_TLV(LaneTypeAttributes_crosswalk_descr_, p_coding);
    break;
  case ALT_bikeLane:
    ec_1.set_msg("bikeLane': ");
    new_tlv = field_bikeLane->BER_encode_TLV(LaneTypeAttributes_bikeLane_descr_, p_coding);
    break;
  case ALT_sidewalk:
    ec_1.set_msg("sidewalk': ");
    new_tlv = field_sidewalk->BER_encode_TLV(LaneTypeAttributes_sidewalk_descr_, p_coding);
    break;
  case ALT_median:
    ec_1.set_msg("median': ");
    new_tlv = field_median->BER_encode_TLV(LaneTypeAttributes_median_descr_, p_coding);
    break;
  case ALT_striping:
    ec_1.set_msg("striping': ");
    new_tlv = field_striping->BER_encode_TLV(LaneTypeAttributes_striping_descr_, p_coding);
    break;
  case ALT_trackedVehicle:
    ec_1.set_msg("trackedVehicle': ");
    new_tlv = field_trackedVehicle->BER_encode_TLV(LaneTypeAttributes_trackedVehicle_descr_, p_coding);
    break;
  case ALT_parking:
    ec_1.set_msg("parking': ");
    new_tlv = field_parking->BER_encode_TLV(LaneTypeAttributes_parking_descr_, p_coding);
    break;
  case UNBOUND_VALUE:
    new_tlv = BER_encode_chk_bound(FALSE);
    break;
  default:
    TTCN_EncDec_ErrorContext::error_internal("Unknown selection.");
    new_tlv = NULL;
  }
  return ASN_BER_V2TLV(new_tlv, p_td, p_coding);
}

boolean LaneTypeAttributes::BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv)
{
  clean_up();
  field_vehicle = new BITSTRING;
  union_selection = ALT_vehicle;
  if (field_vehicle->BER_decode_isMyMsg(LaneTypeAttributes_vehicle_descr_, p_tlv)) return TRUE;
  delete field_vehicle;
  field_crosswalk = new BITSTRING;
  union_selection = ALT_crosswalk;
  if (field_crosswalk->BER_decode_isMyMsg(LaneTypeAttributes_crosswalk_descr_, p_tlv)) return TRUE;
  delete field_crosswalk;
  field_bikeLane = new BITSTRING;
  union_selection = ALT_bikeLane;
  if (field_bikeLane->BER_decode_isMyMsg(LaneTypeAttributes_bikeLane_descr_, p_tlv)) return TRUE;
  delete field_bikeLane;
  field_sidewalk = new BITSTRING;
  union_selection = ALT_sidewalk;
  if (field_sidewalk->BER_decode_isMyMsg(LaneTypeAttributes_sidewalk_descr_, p_tlv)) return TRUE;
  delete field_sidewalk;
  field_median = new BITSTRING;
  union_selection = ALT_median;
  if (field_median->BER_decode_isMyMsg(LaneTypeAttributes_median_descr_, p_tlv)) return TRUE;
  delete field_median;
  field_striping = new BITSTRING;
  union_selection = ALT_striping;
  if (field_striping->BER_decode_isMyMsg(LaneTypeAttributes_striping_descr_, p_tlv)) return TRUE;
  delete field_striping;
  field_trackedVehicle = new BITSTRING;
  union_selection = ALT_trackedVehicle;
  if (field_trackedVehicle->BER_decode_isMyMsg(LaneTypeAttributes_trackedVehicle_descr_, p_tlv)) return TRUE;
  delete field_trackedVehicle;
  field_parking = new BITSTRING;
  union_selection = ALT_parking;
  if (field_parking->BER_decode_isMyMsg(LaneTypeAttributes_parking_descr_, p_tlv)) return TRUE;
  delete field_parking;
  union_selection = UNBOUND_VALUE;
  return FALSE;
}

boolean LaneTypeAttributes::BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv)
{
  if (p_td.ber->n_tags == 0) {
    LaneTypeAttributes tmp_type;
    return tmp_type.BER_decode_set_selection(p_tlv);
  } else return Base_Type::BER_decode_isMyMsg(p_td, p_tlv);
}

boolean LaneTypeAttributes::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.LaneTypeAttributes' type: ");
  ASN_BER_TLV_t tmp_tlv;
  if (!BER_decode_TLV_CHOICE(*p_td.ber, stripped_tlv, L_form, tmp_tlv) || !BER_decode_CHOICE_selection(BER_decode_set_selection(tmp_tlv), tmp_tlv)) return FALSE;
  TTCN_EncDec_ErrorContext ec_1("Alternative '");
  TTCN_EncDec_ErrorContext ec_2;
  switch (union_selection) {
  case ALT_vehicle:
    ec_2.set_msg("vehicle': ");
    field_vehicle->BER_decode_TLV(LaneTypeAttributes_vehicle_descr_, tmp_tlv, L_form);
    break;
  case ALT_crosswalk:
    ec_2.set_msg("crosswalk': ");
    field_crosswalk->BER_decode_TLV(LaneTypeAttributes_crosswalk_descr_, tmp_tlv, L_form);
    break;
  case ALT_bikeLane:
    ec_2.set_msg("bikeLane': ");
    field_bikeLane->BER_decode_TLV(LaneTypeAttributes_bikeLane_descr_, tmp_tlv, L_form);
    break;
  case ALT_sidewalk:
    ec_2.set_msg("sidewalk': ");
    field_sidewalk->BER_decode_TLV(LaneTypeAttributes_sidewalk_descr_, tmp_tlv, L_form);
    break;
  case ALT_median:
    ec_2.set_msg("median': ");
    field_median->BER_decode_TLV(LaneTypeAttributes_median_descr_, tmp_tlv, L_form);
    break;
  case ALT_striping:
    ec_2.set_msg("striping': ");
    field_striping->BER_decode_TLV(LaneTypeAttributes_striping_descr_, tmp_tlv, L_form);
    break;
  case ALT_trackedVehicle:
    ec_2.set_msg("trackedVehicle': ");
    field_trackedVehicle->BER_decode_TLV(LaneTypeAttributes_trackedVehicle_descr_, tmp_tlv, L_form);
    break;
  case ALT_parking:
    ec_2.set_msg("parking': ");
    field_parking->BER_decode_TLV(LaneTypeAttributes_parking_descr_, tmp_tlv, L_form);
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

int LaneTypeAttributes::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_vehicle:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vehicle");
    enc_len += field_vehicle->JSON_encode(LaneTypeAttributes_vehicle_descr_, p_tok);
    break;
  case ALT_crosswalk:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "crosswalk");
    enc_len += field_crosswalk->JSON_encode(LaneTypeAttributes_crosswalk_descr_, p_tok);
    break;
  case ALT_bikeLane:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "bikeLane");
    enc_len += field_bikeLane->JSON_encode(LaneTypeAttributes_bikeLane_descr_, p_tok);
    break;
  case ALT_sidewalk:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sidewalk");
    enc_len += field_sidewalk->JSON_encode(LaneTypeAttributes_sidewalk_descr_, p_tok);
    break;
  case ALT_median:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "median");
    enc_len += field_median->JSON_encode(LaneTypeAttributes_median_descr_, p_tok);
    break;
  case ALT_striping:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "striping");
    enc_len += field_striping->JSON_encode(LaneTypeAttributes_striping_descr_, p_tok);
    break;
  case ALT_trackedVehicle:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trackedVehicle");
    enc_len += field_trackedVehicle->JSON_encode(LaneTypeAttributes_trackedVehicle_descr_, p_tok);
    break;
  case ALT_parking:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "parking");
    enc_len += field_parking->JSON_encode(LaneTypeAttributes_parking_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @DSRC.LaneTypeAttributes.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LaneTypeAttributes::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "vehicle", name_len)) {
      int ret_val = vehicle().JSON_decode(LaneTypeAttributes_vehicle_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vehicle");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "crosswalk", name_len)) {
      int ret_val = crosswalk().JSON_decode(LaneTypeAttributes_crosswalk_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "crosswalk");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "bikeLane", name_len)) {
      int ret_val = bikeLane().JSON_decode(LaneTypeAttributes_bikeLane_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "bikeLane");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "sidewalk", name_len)) {
      int ret_val = sidewalk().JSON_decode(LaneTypeAttributes_sidewalk_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sidewalk");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "median", name_len)) {
      int ret_val = median().JSON_decode(LaneTypeAttributes_median_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "median");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "striping", name_len)) {
      int ret_val = striping().JSON_decode(LaneTypeAttributes_striping_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "striping");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "trackedVehicle", name_len)) {
      int ret_val = trackedVehicle().JSON_decode(LaneTypeAttributes_trackedVehicle_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trackedVehicle");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "parking", name_len)) {
      int ret_val = parking().JSON_decode(LaneTypeAttributes_parking_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "parking");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void LaneTypeAttributes_template::copy_value(const LaneTypeAttributes& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case LaneTypeAttributes::ALT_vehicle:
single_value.field_vehicle = new BITSTRING_template(other_value.vehicle());
break;
case LaneTypeAttributes::ALT_crosswalk:
single_value.field_crosswalk = new BITSTRING_template(other_value.crosswalk());
break;
case LaneTypeAttributes::ALT_bikeLane:
single_value.field_bikeLane = new BITSTRING_template(other_value.bikeLane());
break;
case LaneTypeAttributes::ALT_sidewalk:
single_value.field_sidewalk = new BITSTRING_template(other_value.sidewalk());
break;
case LaneTypeAttributes::ALT_median:
single_value.field_median = new BITSTRING_template(other_value.median());
break;
case LaneTypeAttributes::ALT_striping:
single_value.field_striping = new BITSTRING_template(other_value.striping());
break;
case LaneTypeAttributes::ALT_trackedVehicle:
single_value.field_trackedVehicle = new BITSTRING_template(other_value.trackedVehicle());
break;
case LaneTypeAttributes::ALT_parking:
single_value.field_parking = new BITSTRING_template(other_value.parking());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @DSRC.LaneTypeAttributes.");
}
set_selection(SPECIFIC_VALUE);
}

void LaneTypeAttributes_template::copy_template(const LaneTypeAttributes_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case LaneTypeAttributes::ALT_vehicle:
single_value.field_vehicle = new BITSTRING_template(*other_value.single_value.field_vehicle);
break;
case LaneTypeAttributes::ALT_crosswalk:
single_value.field_crosswalk = new BITSTRING_template(*other_value.single_value.field_crosswalk);
break;
case LaneTypeAttributes::ALT_bikeLane:
single_value.field_bikeLane = new BITSTRING_template(*other_value.single_value.field_bikeLane);
break;
case LaneTypeAttributes::ALT_sidewalk:
single_value.field_sidewalk = new BITSTRING_template(*other_value.single_value.field_sidewalk);
break;
case LaneTypeAttributes::ALT_median:
single_value.field_median = new BITSTRING_template(*other_value.single_value.field_median);
break;
case LaneTypeAttributes::ALT_striping:
single_value.field_striping = new BITSTRING_template(*other_value.single_value.field_striping);
break;
case LaneTypeAttributes::ALT_trackedVehicle:
single_value.field_trackedVehicle = new BITSTRING_template(*other_value.single_value.field_trackedVehicle);
break;
case LaneTypeAttributes::ALT_parking:
single_value.field_parking = new BITSTRING_template(*other_value.single_value.field_parking);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @DSRC.LaneTypeAttributes.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LaneTypeAttributes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @DSRC.LaneTypeAttributes.");
}
set_selection(other_value);
}

LaneTypeAttributes_template::LaneTypeAttributes_template()
{
}

LaneTypeAttributes_template::LaneTypeAttributes_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LaneTypeAttributes_template::LaneTypeAttributes_template(const LaneTypeAttributes& other_value)
{
copy_value(other_value);
}

LaneTypeAttributes_template::LaneTypeAttributes_template(const OPTIONAL<LaneTypeAttributes>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneTypeAttributes&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @DSRC.LaneTypeAttributes from an unbound optional field.");
}
}

LaneTypeAttributes_template::LaneTypeAttributes_template(const LaneTypeAttributes_template& other_value)
: Base_Template(){
copy_template(other_value);
}

LaneTypeAttributes_template::~LaneTypeAttributes_template()
{
clean_up();
}

void LaneTypeAttributes_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case LaneTypeAttributes::ALT_vehicle:
delete single_value.field_vehicle;
break;
case LaneTypeAttributes::ALT_crosswalk:
delete single_value.field_crosswalk;
break;
case LaneTypeAttributes::ALT_bikeLane:
delete single_value.field_bikeLane;
break;
case LaneTypeAttributes::ALT_sidewalk:
delete single_value.field_sidewalk;
break;
case LaneTypeAttributes::ALT_median:
delete single_value.field_median;
break;
case LaneTypeAttributes::ALT_striping:
delete single_value.field_striping;
break;
case LaneTypeAttributes::ALT_trackedVehicle:
delete single_value.field_trackedVehicle;
break;
case LaneTypeAttributes::ALT_parking:
delete single_value.field_parking;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LaneTypeAttributes_template& LaneTypeAttributes_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LaneTypeAttributes_template& LaneTypeAttributes_template::operator=(const LaneTypeAttributes& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LaneTypeAttributes_template& LaneTypeAttributes_template::operator=(const OPTIONAL<LaneTypeAttributes>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneTypeAttributes&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @DSRC.LaneTypeAttributes.");
}
return *this;
}

LaneTypeAttributes_template& LaneTypeAttributes_template::operator=(const LaneTypeAttributes_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LaneTypeAttributes_template::match(const LaneTypeAttributes& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
LaneTypeAttributes::union_selection_type value_selection = other_value.get_selection();
if (value_selection == LaneTypeAttributes::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case LaneTypeAttributes::ALT_vehicle:
return single_value.field_vehicle->match(other_value.vehicle(), legacy);
case LaneTypeAttributes::ALT_crosswalk:
return single_value.field_crosswalk->match(other_value.crosswalk(), legacy);
case LaneTypeAttributes::ALT_bikeLane:
return single_value.field_bikeLane->match(other_value.bikeLane(), legacy);
case LaneTypeAttributes::ALT_sidewalk:
return single_value.field_sidewalk->match(other_value.sidewalk(), legacy);
case LaneTypeAttributes::ALT_median:
return single_value.field_median->match(other_value.median(), legacy);
case LaneTypeAttributes::ALT_striping:
return single_value.field_striping->match(other_value.striping(), legacy);
case LaneTypeAttributes::ALT_trackedVehicle:
return single_value.field_trackedVehicle->match(other_value.trackedVehicle(), legacy);
case LaneTypeAttributes::ALT_parking:
return single_value.field_parking->match(other_value.parking(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @DSRC.LaneTypeAttributes.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @DSRC.LaneTypeAttributes.");
}
return FALSE;
}

boolean LaneTypeAttributes_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case LaneTypeAttributes::ALT_vehicle:
return single_value.field_vehicle->is_value();
case LaneTypeAttributes::ALT_crosswalk:
return single_value.field_crosswalk->is_value();
case LaneTypeAttributes::ALT_bikeLane:
return single_value.field_bikeLane->is_value();
case LaneTypeAttributes::ALT_sidewalk:
return single_value.field_sidewalk->is_value();
case LaneTypeAttributes::ALT_median:
return single_value.field_median->is_value();
case LaneTypeAttributes::ALT_striping:
return single_value.field_striping->is_value();
case LaneTypeAttributes::ALT_trackedVehicle:
return single_value.field_trackedVehicle->is_value();
case LaneTypeAttributes::ALT_parking:
return single_value.field_parking->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @DSRC.LaneTypeAttributes.");
}
}

LaneTypeAttributes LaneTypeAttributes_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @DSRC.LaneTypeAttributes.");
LaneTypeAttributes ret_val;
switch (single_value.union_selection) {
case LaneTypeAttributes::ALT_vehicle:
ret_val.vehicle() = single_value.field_vehicle->valueof();
break;
case LaneTypeAttributes::ALT_crosswalk:
ret_val.crosswalk() = single_value.field_crosswalk->valueof();
break;
case LaneTypeAttributes::ALT_bikeLane:
ret_val.bikeLane() = single_value.field_bikeLane->valueof();
break;
case LaneTypeAttributes::ALT_sidewalk:
ret_val.sidewalk() = single_value.field_sidewalk->valueof();
break;
case LaneTypeAttributes::ALT_median:
ret_val.median() = single_value.field_median->valueof();
break;
case LaneTypeAttributes::ALT_striping:
ret_val.striping() = single_value.field_striping->valueof();
break;
case LaneTypeAttributes::ALT_trackedVehicle:
ret_val.trackedVehicle() = single_value.field_trackedVehicle->valueof();
break;
case LaneTypeAttributes::ALT_parking:
ret_val.parking() = single_value.field_parking->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @DSRC.LaneTypeAttributes.");
}
return ret_val;
}

LaneTypeAttributes_template& LaneTypeAttributes_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @DSRC.LaneTypeAttributes.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @DSRC.LaneTypeAttributes.");
return value_list.list_value[list_index];
}
void LaneTypeAttributes_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @DSRC.LaneTypeAttributes.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LaneTypeAttributes_template[list_length];
}

BITSTRING_template& LaneTypeAttributes_template::vehicle()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneTypeAttributes::ALT_vehicle) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_vehicle = new BITSTRING_template(ANY_VALUE);
else single_value.field_vehicle = new BITSTRING_template;
single_value.union_selection = LaneTypeAttributes::ALT_vehicle;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_vehicle;
}

const BITSTRING_template& LaneTypeAttributes_template::vehicle() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field vehicle in a non-specific template of union type @DSRC.LaneTypeAttributes.");
if (single_value.union_selection != LaneTypeAttributes::ALT_vehicle) TTCN_error("Accessing non-selected field vehicle in a template of union type @DSRC.LaneTypeAttributes.");
return *single_value.field_vehicle;
}

BITSTRING_template& LaneTypeAttributes_template::crosswalk()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneTypeAttributes::ALT_crosswalk) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_crosswalk = new BITSTRING_template(ANY_VALUE);
else single_value.field_crosswalk = new BITSTRING_template;
single_value.union_selection = LaneTypeAttributes::ALT_crosswalk;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_crosswalk;
}

const BITSTRING_template& LaneTypeAttributes_template::crosswalk() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field crosswalk in a non-specific template of union type @DSRC.LaneTypeAttributes.");
if (single_value.union_selection != LaneTypeAttributes::ALT_crosswalk) TTCN_error("Accessing non-selected field crosswalk in a template of union type @DSRC.LaneTypeAttributes.");
return *single_value.field_crosswalk;
}

BITSTRING_template& LaneTypeAttributes_template::bikeLane()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneTypeAttributes::ALT_bikeLane) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_bikeLane = new BITSTRING_template(ANY_VALUE);
else single_value.field_bikeLane = new BITSTRING_template;
single_value.union_selection = LaneTypeAttributes::ALT_bikeLane;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_bikeLane;
}

const BITSTRING_template& LaneTypeAttributes_template::bikeLane() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field bikeLane in a non-specific template of union type @DSRC.LaneTypeAttributes.");
if (single_value.union_selection != LaneTypeAttributes::ALT_bikeLane) TTCN_error("Accessing non-selected field bikeLane in a template of union type @DSRC.LaneTypeAttributes.");
return *single_value.field_bikeLane;
}

BITSTRING_template& LaneTypeAttributes_template::sidewalk()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneTypeAttributes::ALT_sidewalk) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sidewalk = new BITSTRING_template(ANY_VALUE);
else single_value.field_sidewalk = new BITSTRING_template;
single_value.union_selection = LaneTypeAttributes::ALT_sidewalk;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sidewalk;
}

const BITSTRING_template& LaneTypeAttributes_template::sidewalk() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sidewalk in a non-specific template of union type @DSRC.LaneTypeAttributes.");
if (single_value.union_selection != LaneTypeAttributes::ALT_sidewalk) TTCN_error("Accessing non-selected field sidewalk in a template of union type @DSRC.LaneTypeAttributes.");
return *single_value.field_sidewalk;
}

BITSTRING_template& LaneTypeAttributes_template::median()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneTypeAttributes::ALT_median) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_median = new BITSTRING_template(ANY_VALUE);
else single_value.field_median = new BITSTRING_template;
single_value.union_selection = LaneTypeAttributes::ALT_median;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_median;
}

const BITSTRING_template& LaneTypeAttributes_template::median() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field median in a non-specific template of union type @DSRC.LaneTypeAttributes.");
if (single_value.union_selection != LaneTypeAttributes::ALT_median) TTCN_error("Accessing non-selected field median in a template of union type @DSRC.LaneTypeAttributes.");
return *single_value.field_median;
}

BITSTRING_template& LaneTypeAttributes_template::striping()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneTypeAttributes::ALT_striping) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_striping = new BITSTRING_template(ANY_VALUE);
else single_value.field_striping = new BITSTRING_template;
single_value.union_selection = LaneTypeAttributes::ALT_striping;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_striping;
}

const BITSTRING_template& LaneTypeAttributes_template::striping() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field striping in a non-specific template of union type @DSRC.LaneTypeAttributes.");
if (single_value.union_selection != LaneTypeAttributes::ALT_striping) TTCN_error("Accessing non-selected field striping in a template of union type @DSRC.LaneTypeAttributes.");
return *single_value.field_striping;
}

BITSTRING_template& LaneTypeAttributes_template::trackedVehicle()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneTypeAttributes::ALT_trackedVehicle) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_trackedVehicle = new BITSTRING_template(ANY_VALUE);
else single_value.field_trackedVehicle = new BITSTRING_template;
single_value.union_selection = LaneTypeAttributes::ALT_trackedVehicle;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_trackedVehicle;
}

const BITSTRING_template& LaneTypeAttributes_template::trackedVehicle() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field trackedVehicle in a non-specific template of union type @DSRC.LaneTypeAttributes.");
if (single_value.union_selection != LaneTypeAttributes::ALT_trackedVehicle) TTCN_error("Accessing non-selected field trackedVehicle in a template of union type @DSRC.LaneTypeAttributes.");
return *single_value.field_trackedVehicle;
}

BITSTRING_template& LaneTypeAttributes_template::parking()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneTypeAttributes::ALT_parking) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_parking = new BITSTRING_template(ANY_VALUE);
else single_value.field_parking = new BITSTRING_template;
single_value.union_selection = LaneTypeAttributes::ALT_parking;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_parking;
}

const BITSTRING_template& LaneTypeAttributes_template::parking() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field parking in a non-specific template of union type @DSRC.LaneTypeAttributes.");
if (single_value.union_selection != LaneTypeAttributes::ALT_parking) TTCN_error("Accessing non-selected field parking in a template of union type @DSRC.LaneTypeAttributes.");
return *single_value.field_parking;
}

boolean LaneTypeAttributes_template::ischosen(LaneTypeAttributes::union_selection_type checked_selection) const
{
if (checked_selection == LaneTypeAttributes::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.LaneTypeAttributes.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == LaneTypeAttributes::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @DSRC.LaneTypeAttributes.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @DSRC.LaneTypeAttributes containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @DSRC.LaneTypeAttributes, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @DSRC.LaneTypeAttributes");
}
return FALSE;
}

void LaneTypeAttributes_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case LaneTypeAttributes::ALT_vehicle:
TTCN_Logger::log_event_str("{ vehicle := ");
single_value.field_vehicle->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneTypeAttributes::ALT_crosswalk:
TTCN_Logger::log_event_str("{ crosswalk := ");
single_value.field_crosswalk->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneTypeAttributes::ALT_bikeLane:
TTCN_Logger::log_event_str("{ bikeLane := ");
single_value.field_bikeLane->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneTypeAttributes::ALT_sidewalk:
TTCN_Logger::log_event_str("{ sidewalk := ");
single_value.field_sidewalk->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneTypeAttributes::ALT_median:
TTCN_Logger::log_event_str("{ median := ");
single_value.field_median->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneTypeAttributes::ALT_striping:
TTCN_Logger::log_event_str("{ striping := ");
single_value.field_striping->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneTypeAttributes::ALT_trackedVehicle:
TTCN_Logger::log_event_str("{ trackedVehicle := ");
single_value.field_trackedVehicle->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneTypeAttributes::ALT_parking:
TTCN_Logger::log_event_str("{ parking := ");
single_value.field_parking->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LaneTypeAttributes_template::log_match(const LaneTypeAttributes& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case LaneTypeAttributes::ALT_vehicle:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".vehicle");
single_value.field_vehicle->log_match(match_value.vehicle(), legacy);
} else {
TTCN_Logger::log_event_str("{ vehicle := ");
single_value.field_vehicle->log_match(match_value.vehicle(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneTypeAttributes::ALT_crosswalk:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".crosswalk");
single_value.field_crosswalk->log_match(match_value.crosswalk(), legacy);
} else {
TTCN_Logger::log_event_str("{ crosswalk := ");
single_value.field_crosswalk->log_match(match_value.crosswalk(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneTypeAttributes::ALT_bikeLane:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".bikeLane");
single_value.field_bikeLane->log_match(match_value.bikeLane(), legacy);
} else {
TTCN_Logger::log_event_str("{ bikeLane := ");
single_value.field_bikeLane->log_match(match_value.bikeLane(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneTypeAttributes::ALT_sidewalk:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sidewalk");
single_value.field_sidewalk->log_match(match_value.sidewalk(), legacy);
} else {
TTCN_Logger::log_event_str("{ sidewalk := ");
single_value.field_sidewalk->log_match(match_value.sidewalk(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneTypeAttributes::ALT_median:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".median");
single_value.field_median->log_match(match_value.median(), legacy);
} else {
TTCN_Logger::log_event_str("{ median := ");
single_value.field_median->log_match(match_value.median(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneTypeAttributes::ALT_striping:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".striping");
single_value.field_striping->log_match(match_value.striping(), legacy);
} else {
TTCN_Logger::log_event_str("{ striping := ");
single_value.field_striping->log_match(match_value.striping(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneTypeAttributes::ALT_trackedVehicle:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".trackedVehicle");
single_value.field_trackedVehicle->log_match(match_value.trackedVehicle(), legacy);
} else {
TTCN_Logger::log_event_str("{ trackedVehicle := ");
single_value.field_trackedVehicle->log_match(match_value.trackedVehicle(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneTypeAttributes::ALT_parking:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".parking");
single_value.field_parking->log_match(match_value.parking(), legacy);
} else {
TTCN_Logger::log_event_str("{ parking := ");
single_value.field_parking->log_match(match_value.parking(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LaneTypeAttributes_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case LaneTypeAttributes::ALT_vehicle:
single_value.field_vehicle->encode_text(text_buf);
break;
case LaneTypeAttributes::ALT_crosswalk:
single_value.field_crosswalk->encode_text(text_buf);
break;
case LaneTypeAttributes::ALT_bikeLane:
single_value.field_bikeLane->encode_text(text_buf);
break;
case LaneTypeAttributes::ALT_sidewalk:
single_value.field_sidewalk->encode_text(text_buf);
break;
case LaneTypeAttributes::ALT_median:
single_value.field_median->encode_text(text_buf);
break;
case LaneTypeAttributes::ALT_striping:
single_value.field_striping->encode_text(text_buf);
break;
case LaneTypeAttributes::ALT_trackedVehicle:
single_value.field_trackedVehicle->encode_text(text_buf);
break;
case LaneTypeAttributes::ALT_parking:
single_value.field_parking->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @DSRC.LaneTypeAttributes.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @DSRC.LaneTypeAttributes.");
}
}

void LaneTypeAttributes_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = LaneTypeAttributes::UNBOUND_VALUE;
LaneTypeAttributes::union_selection_type new_selection = (LaneTypeAttributes::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case LaneTypeAttributes::ALT_vehicle:
single_value.field_vehicle = new BITSTRING_template;
single_value.field_vehicle->decode_text(text_buf);
break;
case LaneTypeAttributes::ALT_crosswalk:
single_value.field_crosswalk = new BITSTRING_template;
single_value.field_crosswalk->decode_text(text_buf);
break;
case LaneTypeAttributes::ALT_bikeLane:
single_value.field_bikeLane = new BITSTRING_template;
single_value.field_bikeLane->decode_text(text_buf);
break;
case LaneTypeAttributes::ALT_sidewalk:
single_value.field_sidewalk = new BITSTRING_template;
single_value.field_sidewalk->decode_text(text_buf);
break;
case LaneTypeAttributes::ALT_median:
single_value.field_median = new BITSTRING_template;
single_value.field_median->decode_text(text_buf);
break;
case LaneTypeAttributes::ALT_striping:
single_value.field_striping = new BITSTRING_template;
single_value.field_striping->decode_text(text_buf);
break;
case LaneTypeAttributes::ALT_trackedVehicle:
single_value.field_trackedVehicle = new BITSTRING_template;
single_value.field_trackedVehicle->decode_text(text_buf);
break;
case LaneTypeAttributes::ALT_parking:
single_value.field_parking = new BITSTRING_template;
single_value.field_parking->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @DSRC.LaneTypeAttributes.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LaneTypeAttributes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @DSRC.LaneTypeAttributes.");
}
}

boolean LaneTypeAttributes_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LaneTypeAttributes_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void LaneTypeAttributes_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@DSRC.LaneTypeAttributes'");
    }
    if (strcmp("vehicle", param_field) == 0) {
      vehicle().set_param(param);
      return;
    } else if (strcmp("crosswalk", param_field) == 0) {
      crosswalk().set_param(param);
      return;
    } else if (strcmp("bikeLane", param_field) == 0) {
      bikeLane().set_param(param);
      return;
    } else if (strcmp("sidewalk", param_field) == 0) {
      sidewalk().set_param(param);
      return;
    } else if (strcmp("median", param_field) == 0) {
      median().set_param(param);
      return;
    } else if (strcmp("striping", param_field) == 0) {
      striping().set_param(param);
      return;
    } else if (strcmp("trackedVehicle", param_field) == 0) {
      trackedVehicle().set_param(param);
      return;
    } else if (strcmp("parking", param_field) == 0) {
      parking().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@DSRC.LaneTypeAttributes'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LaneTypeAttributes_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@DSRC.LaneTypeAttributes");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "vehicle")) {
      vehicle().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "crosswalk")) {
      crosswalk().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "bikeLane")) {
      bikeLane().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sidewalk")) {
      sidewalk().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "median")) {
      median().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "striping")) {
      striping().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "trackedVehicle")) {
      trackedVehicle().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "parking")) {
      parking().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @DSRC.LaneTypeAttributes.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@DSRC.LaneTypeAttributes");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LaneTypeAttributes_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@DSRC.LaneTypeAttributes'");
    }
    if (strcmp("vehicle", param_field) == 0) {
      return vehicle().get_param(param_name);
    } else if (strcmp("crosswalk", param_field) == 0) {
      return crosswalk().get_param(param_name);
    } else if (strcmp("bikeLane", param_field) == 0) {
      return bikeLane().get_param(param_name);
    } else if (strcmp("sidewalk", param_field) == 0) {
      return sidewalk().get_param(param_name);
    } else if (strcmp("median", param_field) == 0) {
      return median().get_param(param_name);
    } else if (strcmp("striping", param_field) == 0) {
      return striping().get_param(param_name);
    } else if (strcmp("trackedVehicle", param_field) == 0) {
      return trackedVehicle().get_param(param_name);
    } else if (strcmp("parking", param_field) == 0) {
      return parking().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `LaneTypeAttributes'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case LaneTypeAttributes::ALT_vehicle:
      mp_field = single_value.field_vehicle->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("vehicle")));
      break;
    case LaneTypeAttributes::ALT_crosswalk:
      mp_field = single_value.field_crosswalk->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("crosswalk")));
      break;
    case LaneTypeAttributes::ALT_bikeLane:
      mp_field = single_value.field_bikeLane->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("bikeLane")));
      break;
    case LaneTypeAttributes::ALT_sidewalk:
      mp_field = single_value.field_sidewalk->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("sidewalk")));
      break;
    case LaneTypeAttributes::ALT_median:
      mp_field = single_value.field_median->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("median")));
      break;
    case LaneTypeAttributes::ALT_striping:
      mp_field = single_value.field_striping->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("striping")));
      break;
    case LaneTypeAttributes::ALT_trackedVehicle:
      mp_field = single_value.field_trackedVehicle->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("trackedVehicle")));
      break;
    case LaneTypeAttributes::ALT_parking:
      mp_field = single_value.field_parking->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("parking")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LaneTypeAttributes_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case LaneTypeAttributes::ALT_vehicle:
single_value.field_vehicle->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneTypeAttributes");
return;
case LaneTypeAttributes::ALT_crosswalk:
single_value.field_crosswalk->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneTypeAttributes");
return;
case LaneTypeAttributes::ALT_bikeLane:
single_value.field_bikeLane->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneTypeAttributes");
return;
case LaneTypeAttributes::ALT_sidewalk:
single_value.field_sidewalk->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneTypeAttributes");
return;
case LaneTypeAttributes::ALT_median:
single_value.field_median->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneTypeAttributes");
return;
case LaneTypeAttributes::ALT_striping:
single_value.field_striping->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneTypeAttributes");
return;
case LaneTypeAttributes::ALT_trackedVehicle:
single_value.field_trackedVehicle->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneTypeAttributes");
return;
case LaneTypeAttributes::ALT_parking:
single_value.field_parking->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneTypeAttributes");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @DSRC.LaneTypeAttributes.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.LaneTypeAttributes");
}

LaneAttributes::LaneAttributes()
{
  bound_flag = FALSE;
}

LaneAttributes::LaneAttributes(const BITSTRING& par_directionalUse,
    const BITSTRING& par_sharedWith,
    const LaneTypeAttributes& par_laneType,
    const OPTIONAL<REGION::Reg__LaneAttributes>& par_regional)
  :   field_directionalUse(par_directionalUse),
  field_sharedWith(par_sharedWith),
  field_laneType(par_laneType),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

LaneAttributes::LaneAttributes(const LaneAttributes& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.LaneAttributes.");
bound_flag = TRUE;
if (other_value.directionalUse().is_bound()) field_directionalUse = other_value.directionalUse();
else field_directionalUse.clean_up();
if (other_value.sharedWith().is_bound()) field_sharedWith = other_value.sharedWith();
else field_sharedWith.clean_up();
if (other_value.laneType().is_bound()) field_laneType = other_value.laneType();
else field_laneType.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void LaneAttributes::clean_up()
{
field_directionalUse.clean_up();
field_sharedWith.clean_up();
field_laneType.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

LaneAttributes& LaneAttributes::operator=(const LaneAttributes& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.LaneAttributes.");
  bound_flag = TRUE;
  if (other_value.directionalUse().is_bound()) field_directionalUse = other_value.directionalUse();
  else field_directionalUse.clean_up();
  if (other_value.sharedWith().is_bound()) field_sharedWith = other_value.sharedWith();
  else field_sharedWith.clean_up();
  if (other_value.laneType().is_bound()) field_laneType = other_value.laneType();
  else field_laneType.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean LaneAttributes::operator==(const LaneAttributes& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_directionalUse==other_value.field_directionalUse
  && field_sharedWith==other_value.field_sharedWith
  && field_laneType==other_value.field_laneType
  && field_regional==other_value.field_regional;
}

boolean LaneAttributes::is_bound() const
{
if (bound_flag) return TRUE;
if(field_directionalUse.is_bound()) return TRUE;
if(field_sharedWith.is_bound()) return TRUE;
if(field_laneType.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean LaneAttributes::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_directionalUse.is_value()) return FALSE;
if(!field_sharedWith.is_value()) return FALSE;
if(!field_laneType.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int LaneAttributes::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.LaneAttributes");
  int ret_val = 3;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void LaneAttributes::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ directionalUse := ");
field_directionalUse.log();
TTCN_Logger::log_event_str(", sharedWith := ");
field_sharedWith.log();
TTCN_Logger::log_event_str(", laneType := ");
field_laneType.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void LaneAttributes::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.LaneAttributes'");
    }
    if (strcmp("directionalUse", param_field) == 0) {
      directionalUse().set_param(param);
      return;
    } else if (strcmp("sharedWith", param_field) == 0) {
      sharedWith().set_param(param);
      return;
    } else if (strcmp("laneType", param_field) == 0) {
      laneType().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.LaneAttributes'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @DSRC.LaneAttributes has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) directionalUse().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sharedWith().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) laneType().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "directionalUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          directionalUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sharedWith")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sharedWith().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.LaneAttributes: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.LaneAttributes");
  }
}

Module_Param* LaneAttributes::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.LaneAttributes'");
    }
    if (strcmp("directionalUse", param_field) == 0) {
      return directionalUse().get_param(param_name);
    } else if (strcmp("sharedWith", param_field) == 0) {
      return sharedWith().get_param(param_name);
    } else if (strcmp("laneType", param_field) == 0) {
      return laneType().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.LaneAttributes'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_directionalUse = field_directionalUse.get_param(param_name);
  mp_field_directionalUse->set_id(new Module_Param_FieldName(mcopystr("directionalUse")));
  mp->add_elem(mp_field_directionalUse);
  Module_Param* mp_field_sharedWith = field_sharedWith.get_param(param_name);
  mp_field_sharedWith->set_id(new Module_Param_FieldName(mcopystr("sharedWith")));
  mp->add_elem(mp_field_sharedWith);
  Module_Param* mp_field_laneType = field_laneType.get_param(param_name);
  mp_field_laneType->set_id(new Module_Param_FieldName(mcopystr("laneType")));
  mp->add_elem(mp_field_laneType);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void LaneAttributes::set_implicit_omit()
{
if (directionalUse().is_bound()) directionalUse().set_implicit_omit();
if (sharedWith().is_bound()) sharedWith().set_implicit_omit();
if (laneType().is_bound()) laneType().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void LaneAttributes::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.LaneAttributes.");
field_directionalUse.encode_text(text_buf);
field_sharedWith.encode_text(text_buf);
field_laneType.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void LaneAttributes::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_directionalUse.decode_text(text_buf);
field_sharedWith.decode_text(text_buf);
field_laneType.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void LaneAttributes::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LaneAttributes::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* LaneAttributes::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("directionalUse': ");
  new_tlv->add_TLV(field_directionalUse.BER_encode_TLV(LaneAttributes_directionalUse_descr_, p_coding));
  ec_1.set_msg("sharedWith': ");
  new_tlv->add_TLV(field_sharedWith.BER_encode_TLV(LaneAttributes_sharedWith_descr_, p_coding));
  ec_1.set_msg("laneType': ");
  new_tlv->add_TLV(field_laneType.BER_encode_TLV(LaneAttributes_laneType_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(LaneAttributes_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean LaneAttributes::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.LaneAttributes' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("directionalUse': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_directionalUse.BER_decode_TLV(LaneAttributes_directionalUse_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("sharedWith': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_sharedWith.BER_decode_TLV(LaneAttributes_sharedWith_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("laneType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_laneType.BER_decode_TLV(LaneAttributes_laneType_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(LaneAttributes_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int LaneAttributes::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.LaneAttributes.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "directionalUse");
    enc_len += field_directionalUse.JSON_encode(LaneAttributes_directionalUse_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sharedWith");
    enc_len += field_sharedWith.JSON_encode(LaneAttributes_sharedWith_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneType");
    enc_len += field_laneType.JSON_encode(LaneAttributes_laneType_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(LaneAttributes_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LaneAttributes::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (14 == name_len && 0 == strncmp(fld_name, "directionalUse", name_len)) {
         int ret_val = field_directionalUse.JSON_decode(LaneAttributes_directionalUse_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "directionalUse");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "sharedWith", name_len)) {
         int ret_val = field_sharedWith.JSON_decode(LaneAttributes_sharedWith_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sharedWith");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "laneType", name_len)) {
         int ret_val = field_laneType.JSON_decode(LaneAttributes_laneType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(LaneAttributes_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_directionalUse.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "directionalUse");
    return JSON_ERROR_FATAL;
  }
if (!field_sharedWith.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "sharedWith");
    return JSON_ERROR_FATAL;
  }
if (!field_laneType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "laneType");
    return JSON_ERROR_FATAL;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct LaneAttributes_template::single_value_struct {
BITSTRING_template field_directionalUse;
BITSTRING_template field_sharedWith;
LaneTypeAttributes_template field_laneType;
REGION::Reg__LaneAttributes_template field_regional;
};

void LaneAttributes_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_directionalUse = ANY_VALUE;
single_value->field_sharedWith = ANY_VALUE;
single_value->field_laneType = ANY_VALUE;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void LaneAttributes_template::copy_value(const LaneAttributes& other_value)
{
single_value = new single_value_struct;
if (other_value.directionalUse().is_bound()) {
  single_value->field_directionalUse = other_value.directionalUse();
} else {
  single_value->field_directionalUse.clean_up();
}
if (other_value.sharedWith().is_bound()) {
  single_value->field_sharedWith = other_value.sharedWith();
} else {
  single_value->field_sharedWith.clean_up();
}
if (other_value.laneType().is_bound()) {
  single_value->field_laneType = other_value.laneType();
} else {
  single_value->field_laneType.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void LaneAttributes_template::copy_template(const LaneAttributes_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.directionalUse().get_selection()) {
single_value->field_directionalUse = other_value.directionalUse();
} else {
single_value->field_directionalUse.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sharedWith().get_selection()) {
single_value->field_sharedWith = other_value.sharedWith();
} else {
single_value->field_sharedWith.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.laneType().get_selection()) {
single_value->field_laneType = other_value.laneType();
} else {
single_value->field_laneType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LaneAttributes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.LaneAttributes.");
break;
}
set_selection(other_value);
}

LaneAttributes_template::LaneAttributes_template()
{
}

LaneAttributes_template::LaneAttributes_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LaneAttributes_template::LaneAttributes_template(const LaneAttributes& other_value)
{
copy_value(other_value);
}

LaneAttributes_template::LaneAttributes_template(const OPTIONAL<LaneAttributes>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneAttributes&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.LaneAttributes from an unbound optional field.");
}
}

LaneAttributes_template::LaneAttributes_template(const LaneAttributes_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

LaneAttributes_template::~LaneAttributes_template()
{
clean_up();
}

LaneAttributes_template& LaneAttributes_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LaneAttributes_template& LaneAttributes_template::operator=(const LaneAttributes& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LaneAttributes_template& LaneAttributes_template::operator=(const OPTIONAL<LaneAttributes>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneAttributes&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.LaneAttributes.");
}
return *this;
}

LaneAttributes_template& LaneAttributes_template::operator=(const LaneAttributes_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LaneAttributes_template::match(const LaneAttributes& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.directionalUse().is_bound()) return FALSE;
if(!single_value->field_directionalUse.match(other_value.directionalUse(), legacy))return FALSE;
if(!other_value.sharedWith().is_bound()) return FALSE;
if(!single_value->field_sharedWith.match(other_value.sharedWith(), legacy))return FALSE;
if(!other_value.laneType().is_bound()) return FALSE;
if(!single_value->field_laneType.match(other_value.laneType(), legacy))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REGION::Reg__LaneAttributes&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.LaneAttributes.");
}
return FALSE;
}

boolean LaneAttributes_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_directionalUse.is_bound()) return TRUE;
if (single_value->field_sharedWith.is_bound()) return TRUE;
if (single_value->field_laneType.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean LaneAttributes_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_directionalUse.is_value()) return FALSE;
if (!single_value->field_sharedWith.is_value()) return FALSE;
if (!single_value->field_laneType.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void LaneAttributes_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LaneAttributes LaneAttributes_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.LaneAttributes.");
LaneAttributes ret_val;
if (single_value->field_directionalUse.is_bound()) {
ret_val.directionalUse() = single_value->field_directionalUse.valueof();
}
if (single_value->field_sharedWith.is_bound()) {
ret_val.sharedWith() = single_value->field_sharedWith.valueof();
}
if (single_value->field_laneType.is_bound()) {
ret_val.laneType() = single_value->field_laneType.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void LaneAttributes_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.LaneAttributes.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LaneAttributes_template[list_length];
}

LaneAttributes_template& LaneAttributes_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.LaneAttributes.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.LaneAttributes.");
return value_list.list_value[list_index];
}

BITSTRING_template& LaneAttributes_template::directionalUse()
{
set_specific();
return single_value->field_directionalUse;
}

const BITSTRING_template& LaneAttributes_template::directionalUse() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field directionalUse of a non-specific template of type @DSRC.LaneAttributes.");
return single_value->field_directionalUse;
}

BITSTRING_template& LaneAttributes_template::sharedWith()
{
set_specific();
return single_value->field_sharedWith;
}

const BITSTRING_template& LaneAttributes_template::sharedWith() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sharedWith of a non-specific template of type @DSRC.LaneAttributes.");
return single_value->field_sharedWith;
}

LaneTypeAttributes_template& LaneAttributes_template::laneType()
{
set_specific();
return single_value->field_laneType;
}

const LaneTypeAttributes_template& LaneAttributes_template::laneType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field laneType of a non-specific template of type @DSRC.LaneAttributes.");
return single_value->field_laneType;
}

REGION::Reg__LaneAttributes_template& LaneAttributes_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REGION::Reg__LaneAttributes_template& LaneAttributes_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.LaneAttributes.");
return single_value->field_regional;
}

int LaneAttributes_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.LaneAttributes which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 3;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.LaneAttributes containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.LaneAttributes containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.LaneAttributes containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.LaneAttributes containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.LaneAttributes containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.LaneAttributes.");
  }
  return 0;
}

void LaneAttributes_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ directionalUse := ");
single_value->field_directionalUse.log();
TTCN_Logger::log_event_str(", sharedWith := ");
single_value->field_sharedWith.log();
TTCN_Logger::log_event_str(", laneType := ");
single_value->field_laneType.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LaneAttributes_template::log_match(const LaneAttributes& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_directionalUse.match(match_value.directionalUse(), legacy)){
TTCN_Logger::log_logmatch_info(".directionalUse");
single_value->field_directionalUse.log_match(match_value.directionalUse(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sharedWith.match(match_value.sharedWith(), legacy)){
TTCN_Logger::log_logmatch_info(".sharedWith");
single_value->field_sharedWith.log_match(match_value.sharedWith(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_laneType.match(match_value.laneType(), legacy)){
TTCN_Logger::log_logmatch_info(".laneType");
single_value->field_laneType.log_match(match_value.laneType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ directionalUse := ");
single_value->field_directionalUse.log_match(match_value.directionalUse(), legacy);
TTCN_Logger::log_event_str(", sharedWith := ");
single_value->field_sharedWith.log_match(match_value.sharedWith(), legacy);
TTCN_Logger::log_event_str(", laneType := ");
single_value->field_laneType.log_match(match_value.laneType(), legacy);
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LaneAttributes_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_directionalUse.encode_text(text_buf);
single_value->field_sharedWith.encode_text(text_buf);
single_value->field_laneType.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.LaneAttributes.");
}
}

void LaneAttributes_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_directionalUse.decode_text(text_buf);
single_value->field_sharedWith.decode_text(text_buf);
single_value->field_laneType.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LaneAttributes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.LaneAttributes.");
}
}

void LaneAttributes_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.LaneAttributes'");
    }
    if (strcmp("directionalUse", param_field) == 0) {
      directionalUse().set_param(param);
      return;
    } else if (strcmp("sharedWith", param_field) == 0) {
      sharedWith().set_param(param);
      return;
    } else if (strcmp("laneType", param_field) == 0) {
      laneType().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.LaneAttributes'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LaneAttributes_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @DSRC.LaneAttributes has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) directionalUse().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sharedWith().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) laneType().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "directionalUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          directionalUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sharedWith")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sharedWith().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.LaneAttributes: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.LaneAttributes");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LaneAttributes_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.LaneAttributes'");
    }
    if (strcmp("directionalUse", param_field) == 0) {
      return directionalUse().get_param(param_name);
    } else if (strcmp("sharedWith", param_field) == 0) {
      return sharedWith().get_param(param_name);
    } else if (strcmp("laneType", param_field) == 0) {
      return laneType().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.LaneAttributes'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_directionalUse = single_value->field_directionalUse.get_param(param_name);
    mp_field_directionalUse->set_id(new Module_Param_FieldName(mcopystr("directionalUse")));
    mp->add_elem(mp_field_directionalUse);
    Module_Param* mp_field_sharedWith = single_value->field_sharedWith.get_param(param_name);
    mp_field_sharedWith->set_id(new Module_Param_FieldName(mcopystr("sharedWith")));
    mp->add_elem(mp_field_sharedWith);
    Module_Param* mp_field_laneType = single_value->field_laneType.get_param(param_name);
    mp_field_laneType->set_id(new Module_Param_FieldName(mcopystr("laneType")));
    mp->add_elem(mp_field_laneType);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LaneAttributes_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_directionalUse.check_restriction(t_res, t_name ? t_name : "@DSRC.LaneAttributes");
single_value->field_sharedWith.check_restriction(t_res, t_name ? t_name : "@DSRC.LaneAttributes");
single_value->field_laneType.check_restriction(t_res, t_name ? t_name : "@DSRC.LaneAttributes");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.LaneAttributes");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.LaneAttributes");
}

boolean LaneAttributes_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LaneAttributes_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void NodeList2::copy_value(const NodeList2& other_value)
{
switch (other_value.union_selection) {
case ALT_nodes:
field_nodes = new NodeSet(*other_value.field_nodes);
break;
case ALT_computed:
field_computed = new ComputedLane(*other_value.field_computed);
break;
default:
TTCN_error("Assignment of an unbound union value of type @DSRC.NodeList2.");
}
union_selection = other_value.union_selection;
}

NodeList2::NodeList2()
{
union_selection = UNBOUND_VALUE;
}

NodeList2::NodeList2(const NodeList2& other_value)
: Base_Type(){
copy_value(other_value);
}

NodeList2::~NodeList2()
{
clean_up();
}

NodeList2& NodeList2::operator=(const NodeList2& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean NodeList2::operator==(const NodeList2& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @DSRC.NodeList2.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @DSRC.NodeList2.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_nodes:
return *field_nodes == *other_value.field_nodes;
case ALT_computed:
return *field_computed == *other_value.field_computed;
default:
return FALSE;
}
}

NodeSet& NodeList2::nodes()
{
if (union_selection != ALT_nodes) {
clean_up();
field_nodes = new NodeSet;
union_selection = ALT_nodes;
}
return *field_nodes;
}

const NodeSet& NodeList2::nodes() const
{
if (union_selection != ALT_nodes) TTCN_error("Using non-selected field nodes in a value of union type @DSRC.NodeList2.");
return *field_nodes;
}

ComputedLane& NodeList2::computed()
{
if (union_selection != ALT_computed) {
clean_up();
field_computed = new ComputedLane;
union_selection = ALT_computed;
}
return *field_computed;
}

const ComputedLane& NodeList2::computed() const
{
if (union_selection != ALT_computed) TTCN_error("Using non-selected field computed in a value of union type @DSRC.NodeList2.");
return *field_computed;
}

boolean NodeList2::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.NodeList2.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @DSRC.NodeList2.");
return union_selection == checked_selection;
}

boolean NodeList2::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean NodeList2::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_nodes: return field_nodes->is_value();
case ALT_computed: return field_computed->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void NodeList2::clean_up()
{
switch (union_selection) {
case ALT_nodes:
  delete field_nodes;
  break;
case ALT_computed:
  delete field_computed;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void NodeList2::log() const
{
switch (union_selection) {
case ALT_nodes:
TTCN_Logger::log_event_str("{ nodes := ");
field_nodes->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_computed:
TTCN_Logger::log_event_str("{ computed := ");
field_computed->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void NodeList2::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@DSRC.NodeList2'");
    }
    if (strcmp("nodes", param_field) == 0) {
      nodes().set_param(param);
      return;
    } else if (strcmp("computed", param_field) == 0) {
      computed().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@DSRC.NodeList2'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "nodes")) {
    nodes().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "computed")) {
    computed().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @DSRC.NodeList2.", mp_last->get_id()->get_name());
}

Module_Param* NodeList2::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@DSRC.NodeList2'");
    }
    if (strcmp("nodes", param_field) == 0) {
      return nodes().get_param(param_name);
    } else if (strcmp("computed", param_field) == 0) {
      return computed().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `NodeList2'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_nodes:
    mp_field = field_nodes->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("nodes")));
    break;
  case ALT_computed:
    mp_field = field_computed->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("computed")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void NodeList2::set_implicit_omit()
{
switch (union_selection) {
case ALT_nodes:
field_nodes->set_implicit_omit(); break;
case ALT_computed:
field_computed->set_implicit_omit(); break;
default: break;
}
}

void NodeList2::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_nodes:
field_nodes->encode_text(text_buf);
break;
case ALT_computed:
field_computed->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @DSRC.NodeList2.");
}
}

void NodeList2::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_nodes:
nodes().decode_text(text_buf);
break;
case ALT_computed:
computed().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @DSRC.NodeList2.");
}
}

void NodeList2::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void NodeList2::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t *NodeList2::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv;
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  switch (union_selection) {
  case ALT_nodes:
    ec_1.set_msg("nodes': ");
    new_tlv = field_nodes->BER_encode_TLV(NodeList2_nodes_descr_, p_coding);
    break;
  case ALT_computed:
    ec_1.set_msg("computed': ");
    new_tlv = field_computed->BER_encode_TLV(NodeList2_computed_descr_, p_coding);
    break;
  case UNBOUND_VALUE:
    new_tlv = BER_encode_chk_bound(FALSE);
    break;
  default:
    TTCN_EncDec_ErrorContext::error_internal("Unknown selection.");
    new_tlv = NULL;
  }
  return ASN_BER_V2TLV(new_tlv, p_td, p_coding);
}

boolean NodeList2::BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv)
{
  clean_up();
  field_nodes = new NodeSet;
  union_selection = ALT_nodes;
  if (field_nodes->BER_decode_isMyMsg(NodeList2_nodes_descr_, p_tlv)) return TRUE;
  delete field_nodes;
  field_computed = new ComputedLane;
  union_selection = ALT_computed;
  if (field_computed->BER_decode_isMyMsg(NodeList2_computed_descr_, p_tlv)) return TRUE;
  delete field_computed;
  union_selection = UNBOUND_VALUE;
  return FALSE;
}

boolean NodeList2::BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv)
{
  if (p_td.ber->n_tags == 0) {
    NodeList2 tmp_type;
    return tmp_type.BER_decode_set_selection(p_tlv);
  } else return Base_Type::BER_decode_isMyMsg(p_td, p_tlv);
}

boolean NodeList2::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.NodeList2' type: ");
  ASN_BER_TLV_t tmp_tlv;
  if (!BER_decode_TLV_CHOICE(*p_td.ber, stripped_tlv, L_form, tmp_tlv) || !BER_decode_CHOICE_selection(BER_decode_set_selection(tmp_tlv), tmp_tlv)) return FALSE;
  TTCN_EncDec_ErrorContext ec_1("Alternative '");
  TTCN_EncDec_ErrorContext ec_2;
  switch (union_selection) {
  case ALT_nodes:
    ec_2.set_msg("nodes': ");
    field_nodes->BER_decode_TLV(NodeList2_nodes_descr_, tmp_tlv, L_form);
    break;
  case ALT_computed:
    ec_2.set_msg("computed': ");
    field_computed->BER_decode_TLV(NodeList2_computed_descr_, tmp_tlv, L_form);
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

int NodeList2::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_nodes:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nodes");
    enc_len += field_nodes->JSON_encode(NodeList2_nodes_descr_, p_tok);
    break;
  case ALT_computed:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "computed");
    enc_len += field_computed->JSON_encode(NodeList2_computed_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @DSRC.NodeList2.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int NodeList2::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "nodes", name_len)) {
      int ret_val = nodes().JSON_decode(NodeList2_nodes_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nodes");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "computed", name_len)) {
      int ret_val = computed().JSON_decode(NodeList2_computed_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "computed");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void NodeList2_template::copy_value(const NodeList2& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case NodeList2::ALT_nodes:
single_value.field_nodes = new NodeSet_template(other_value.nodes());
break;
case NodeList2::ALT_computed:
single_value.field_computed = new ComputedLane_template(other_value.computed());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @DSRC.NodeList2.");
}
set_selection(SPECIFIC_VALUE);
}

void NodeList2_template::copy_template(const NodeList2_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case NodeList2::ALT_nodes:
single_value.field_nodes = new NodeSet_template(*other_value.single_value.field_nodes);
break;
case NodeList2::ALT_computed:
single_value.field_computed = new ComputedLane_template(*other_value.single_value.field_computed);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @DSRC.NodeList2.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new NodeList2_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @DSRC.NodeList2.");
}
set_selection(other_value);
}

NodeList2_template::NodeList2_template()
{
}

NodeList2_template::NodeList2_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

NodeList2_template::NodeList2_template(const NodeList2& other_value)
{
copy_value(other_value);
}

NodeList2_template::NodeList2_template(const OPTIONAL<NodeList2>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const NodeList2&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @DSRC.NodeList2 from an unbound optional field.");
}
}

NodeList2_template::NodeList2_template(const NodeList2_template& other_value)
: Base_Template(){
copy_template(other_value);
}

NodeList2_template::~NodeList2_template()
{
clean_up();
}

void NodeList2_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case NodeList2::ALT_nodes:
delete single_value.field_nodes;
break;
case NodeList2::ALT_computed:
delete single_value.field_computed;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

NodeList2_template& NodeList2_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

NodeList2_template& NodeList2_template::operator=(const NodeList2& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

NodeList2_template& NodeList2_template::operator=(const OPTIONAL<NodeList2>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const NodeList2&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @DSRC.NodeList2.");
}
return *this;
}

NodeList2_template& NodeList2_template::operator=(const NodeList2_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean NodeList2_template::match(const NodeList2& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
NodeList2::union_selection_type value_selection = other_value.get_selection();
if (value_selection == NodeList2::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case NodeList2::ALT_nodes:
return single_value.field_nodes->match(other_value.nodes(), legacy);
case NodeList2::ALT_computed:
return single_value.field_computed->match(other_value.computed(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @DSRC.NodeList2.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @DSRC.NodeList2.");
}
return FALSE;
}

boolean NodeList2_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case NodeList2::ALT_nodes:
return single_value.field_nodes->is_value();
case NodeList2::ALT_computed:
return single_value.field_computed->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @DSRC.NodeList2.");
}
}

NodeList2 NodeList2_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @DSRC.NodeList2.");
NodeList2 ret_val;
switch (single_value.union_selection) {
case NodeList2::ALT_nodes:
ret_val.nodes() = single_value.field_nodes->valueof();
break;
case NodeList2::ALT_computed:
ret_val.computed() = single_value.field_computed->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @DSRC.NodeList2.");
}
return ret_val;
}

NodeList2_template& NodeList2_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @DSRC.NodeList2.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @DSRC.NodeList2.");
return value_list.list_value[list_index];
}
void NodeList2_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @DSRC.NodeList2.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new NodeList2_template[list_length];
}

NodeSet_template& NodeList2_template::nodes()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != NodeList2::ALT_nodes) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_nodes = new NodeSet_template(ANY_VALUE);
else single_value.field_nodes = new NodeSet_template;
single_value.union_selection = NodeList2::ALT_nodes;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_nodes;
}

const NodeSet_template& NodeList2_template::nodes() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field nodes in a non-specific template of union type @DSRC.NodeList2.");
if (single_value.union_selection != NodeList2::ALT_nodes) TTCN_error("Accessing non-selected field nodes in a template of union type @DSRC.NodeList2.");
return *single_value.field_nodes;
}

ComputedLane_template& NodeList2_template::computed()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != NodeList2::ALT_computed) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_computed = new ComputedLane_template(ANY_VALUE);
else single_value.field_computed = new ComputedLane_template;
single_value.union_selection = NodeList2::ALT_computed;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_computed;
}

const ComputedLane_template& NodeList2_template::computed() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field computed in a non-specific template of union type @DSRC.NodeList2.");
if (single_value.union_selection != NodeList2::ALT_computed) TTCN_error("Accessing non-selected field computed in a template of union type @DSRC.NodeList2.");
return *single_value.field_computed;
}

boolean NodeList2_template::ischosen(NodeList2::union_selection_type checked_selection) const
{
if (checked_selection == NodeList2::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.NodeList2.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == NodeList2::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @DSRC.NodeList2.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @DSRC.NodeList2 containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @DSRC.NodeList2, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @DSRC.NodeList2");
}
return FALSE;
}

void NodeList2_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case NodeList2::ALT_nodes:
TTCN_Logger::log_event_str("{ nodes := ");
single_value.field_nodes->log();
TTCN_Logger::log_event_str(" }");
break;
case NodeList2::ALT_computed:
TTCN_Logger::log_event_str("{ computed := ");
single_value.field_computed->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void NodeList2_template::log_match(const NodeList2& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case NodeList2::ALT_nodes:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".nodes");
single_value.field_nodes->log_match(match_value.nodes(), legacy);
} else {
TTCN_Logger::log_event_str("{ nodes := ");
single_value.field_nodes->log_match(match_value.nodes(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case NodeList2::ALT_computed:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".computed");
single_value.field_computed->log_match(match_value.computed(), legacy);
} else {
TTCN_Logger::log_event_str("{ computed := ");
single_value.field_computed->log_match(match_value.computed(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void NodeList2_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case NodeList2::ALT_nodes:
single_value.field_nodes->encode_text(text_buf);
break;
case NodeList2::ALT_computed:
single_value.field_computed->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @DSRC.NodeList2.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @DSRC.NodeList2.");
}
}

void NodeList2_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = NodeList2::UNBOUND_VALUE;
NodeList2::union_selection_type new_selection = (NodeList2::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case NodeList2::ALT_nodes:
single_value.field_nodes = new NodeSet_template;
single_value.field_nodes->decode_text(text_buf);
break;
case NodeList2::ALT_computed:
single_value.field_computed = new ComputedLane_template;
single_value.field_computed->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @DSRC.NodeList2.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new NodeList2_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @DSRC.NodeList2.");
}
}

boolean NodeList2_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean NodeList2_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void NodeList2_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@DSRC.NodeList2'");
    }
    if (strcmp("nodes", param_field) == 0) {
      nodes().set_param(param);
      return;
    } else if (strcmp("computed", param_field) == 0) {
      computed().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@DSRC.NodeList2'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    NodeList2_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@DSRC.NodeList2");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "nodes")) {
      nodes().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "computed")) {
      computed().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @DSRC.NodeList2.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@DSRC.NodeList2");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* NodeList2_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@DSRC.NodeList2'");
    }
    if (strcmp("nodes", param_field) == 0) {
      return nodes().get_param(param_name);
    } else if (strcmp("computed", param_field) == 0) {
      return computed().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `NodeList2'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case NodeList2::ALT_nodes:
      mp_field = single_value.field_nodes->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("nodes")));
      break;
    case NodeList2::ALT_computed:
      mp_field = single_value.field_computed->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("computed")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void NodeList2_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case NodeList2::ALT_nodes:
single_value.field_nodes->check_restriction(t_res, t_name ? t_name : "@DSRC.NodeList2");
return;
case NodeList2::ALT_computed:
single_value.field_computed->check_restriction(t_res, t_name ? t_name : "@DSRC.NodeList2");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @DSRC.NodeList2.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.NodeList2");
}


const Node NodeSet::UNBOUND_ELEM;
NodeSet::NodeSet()
{
val_ptr = NULL;
}

NodeSet::NodeSet(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

NodeSet::NodeSet(const NodeSet& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.NodeSet.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

NodeSet::~NodeSet()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void NodeSet::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

NodeSet& NodeSet::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

NodeSet& NodeSet::operator=(const NodeSet& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.NodeSet.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean NodeSet::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.NodeSet.");
return val_ptr->n_elements == 0 ;
}

boolean NodeSet::operator==(const NodeSet& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.NodeSet.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.NodeSet.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

Node& NodeSet::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.NodeSet using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (Node**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Node(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new Node;
}
return *val_ptr->value_elements[index_value];
}

Node& NodeSet::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.NodeSet.");
return (*this)[(int)index_value];
}

const Node& NodeSet::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.NodeSet.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.NodeSet using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.NodeSet: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const Node& NodeSet::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.NodeSet.");
return (*this)[(int)index_value];
}

NodeSet NodeSet::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

NodeSet NodeSet::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

NodeSet NodeSet::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

NodeSet NodeSet::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.NodeSet.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
NodeSet ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new Node(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

NodeSet NodeSet::operator+(const NodeSet& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.NodeSet concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
NodeSet ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Node(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new Node(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

NodeSet NodeSet::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.NodeSet.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.NodeSet","element");
NodeSet ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new Node(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

NodeSet NodeSet::replace(int index, int len, const NodeSet& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.NodeSet.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.NodeSet.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.NodeSet","element");
NodeSet ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Node(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new Node(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new Node(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

NodeSet NodeSet::replace(int index, int len, const NodeSet_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void NodeSet::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.NodeSet.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (Node**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Node(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (Node**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.NodeSet: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (Node**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean NodeSet::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int NodeSet::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.NodeSet.");
return val_ptr->n_elements;
}

int NodeSet::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.NodeSet.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void NodeSet::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void NodeSet::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.NodeSet'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.NodeSet");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.NodeSet");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* NodeSet::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.NodeSet'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void NodeSet::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void NodeSet::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.NodeSet.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void NodeSet::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.NodeSet.");
val_ptr->value_elements = (Node**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new Node;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void NodeSet::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void NodeSet::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* NodeSet::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean NodeSet::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (Node**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new Node;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int NodeSet::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.NodeSet.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int NodeSet::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    Node* val = new Node;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (Node**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void NodeSet_template::copy_value(const NodeSet& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.NodeSet with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (Node_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new Node_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new Node_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void NodeSet_template::copy_template(const NodeSet_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (Node_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new Node_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new Node_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new NodeSet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.NodeSet.");
break;
}
set_selection(other_value);
}

boolean NodeSet_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const NodeSet_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const NodeSet*)value_ptr)[value_index], legacy);
else return ((const NodeSet_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

NodeSet_template::NodeSet_template()
{
}

NodeSet_template::NodeSet_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

NodeSet_template::NodeSet_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

NodeSet_template::NodeSet_template(const NodeSet& other_value)
{
copy_value(other_value);
}

NodeSet_template::NodeSet_template(const OPTIONAL<NodeSet>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const NodeSet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.NodeSet from an unbound optional field.");
}
}

NodeSet_template::NodeSet_template(const NodeSet_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

NodeSet_template::~NodeSet_template()
{
clean_up();
}

void NodeSet_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

NodeSet_template& NodeSet_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

NodeSet_template& NodeSet_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

NodeSet_template& NodeSet_template::operator=(const NodeSet& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

NodeSet_template& NodeSet_template::operator=(const OPTIONAL<NodeSet>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const NodeSet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.NodeSet.");
}
return *this;
}

NodeSet_template& NodeSet_template::operator=(const NodeSet_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

Node_template& NodeSet_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.NodeSet using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.NodeSet.");
    break;
}
return *single_value.value_elements[index_value];
}

Node_template& NodeSet_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.NodeSet.");
return (*this)[(int)index_value];
}

const Node_template& NodeSet_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.NodeSet using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.NodeSet.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.NodeSet: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const Node_template& NodeSet_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.NodeSet.");
return (*this)[(int)index_value];
}

void NodeSet_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.NodeSet.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (Node_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Node_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Node_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (Node_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int NodeSet_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int NodeSet_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeSet which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeSet containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeSet containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeSet containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeSet containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeSet containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.NodeSet.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.NodeSet");
}

boolean NodeSet_template::match(const NodeSet& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.NodeSet.");
}
return FALSE;
}

boolean NodeSet_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

NodeSet NodeSet_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.NodeSet.");
NodeSet ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

NodeSet NodeSet_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

NodeSet NodeSet_template::replace(int index, int len, const NodeSet_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

NodeSet NodeSet_template::replace(int index, int len, const NodeSet& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void NodeSet_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new NodeSet_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.NodeSet.");
}
set_selection(template_type);
}

NodeSet_template& NodeSet_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.NodeSet.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.NodeSet.");
return value_list.list_value[list_index];
}

void NodeSet_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void NodeSet_template::log_match(const NodeSet& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void NodeSet_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.NodeSet.");
}
}

void NodeSet_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.NodeSet.");
single_value.value_elements = (Node_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new Node_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new NodeSet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.NodeSet.");
}
}

boolean NodeSet_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean NodeSet_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void NodeSet_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.NodeSet'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    NodeSet_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.NodeSet");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* NodeSet_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.NodeSet'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void NodeSet_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.NodeSet");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.NodeSet");
}

Node::Node()
{
  bound_flag = FALSE;
}

Node::Node(const DSRC2::NodeOffsetPoint& par_delta,
    const OPTIONAL<NodeAttributeSet>& par_attributes)
  :   field_delta(par_delta),
  field_attributes(par_attributes)
{
  bound_flag = TRUE;
}

Node::Node(const Node& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.Node.");
bound_flag = TRUE;
if (other_value.delta().is_bound()) field_delta = other_value.delta();
else field_delta.clean_up();
if (other_value.attributes().is_bound()) field_attributes = other_value.attributes();
else field_attributes.clean_up();
}

void Node::clean_up()
{
field_delta.clean_up();
field_attributes.clean_up();
bound_flag = FALSE;
}

Node& Node::operator=(const Node& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.Node.");
  bound_flag = TRUE;
  if (other_value.delta().is_bound()) field_delta = other_value.delta();
  else field_delta.clean_up();
  if (other_value.attributes().is_bound()) field_attributes = other_value.attributes();
  else field_attributes.clean_up();
}
return *this;
}

boolean Node::operator==(const Node& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_delta==other_value.field_delta
  && field_attributes==other_value.field_attributes;
}

boolean Node::is_bound() const
{
if (bound_flag) return TRUE;
if(field_delta.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_attributes.get_selection() || field_attributes.is_bound()) return TRUE;
return FALSE;
}
boolean Node::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_delta.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_attributes.get_selection() && !field_attributes.is_value()) return FALSE;
return TRUE;
}
int Node::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.Node");
  int ret_val = 1;
  if (field_attributes.ispresent()) ret_val++;
  return ret_val;
}

void Node::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ delta := ");
field_delta.log();
TTCN_Logger::log_event_str(", attributes := ");
field_attributes.log();
TTCN_Logger::log_event_str(" }");
}

void Node::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.Node'");
    }
    if (strcmp("delta", param_field) == 0) {
      delta().set_param(param);
      return;
    } else if (strcmp("attributes", param_field) == 0) {
      attributes().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.Node'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @DSRC.Node has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) delta().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) attributes().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "delta")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          delta().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "attributes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          attributes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.Node: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.Node");
  }
}

Module_Param* Node::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.Node'");
    }
    if (strcmp("delta", param_field) == 0) {
      return delta().get_param(param_name);
    } else if (strcmp("attributes", param_field) == 0) {
      return attributes().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.Node'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_delta = field_delta.get_param(param_name);
  mp_field_delta->set_id(new Module_Param_FieldName(mcopystr("delta")));
  mp->add_elem(mp_field_delta);
  Module_Param* mp_field_attributes = field_attributes.get_param(param_name);
  mp_field_attributes->set_id(new Module_Param_FieldName(mcopystr("attributes")));
  mp->add_elem(mp_field_attributes);
  return mp;
  }

void Node::set_implicit_omit()
{
if (delta().is_bound()) delta().set_implicit_omit();
if (!attributes().is_bound()) attributes() = OMIT_VALUE;
else attributes().set_implicit_omit();
}

void Node::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.Node.");
field_delta.encode_text(text_buf);
field_attributes.encode_text(text_buf);
}

void Node::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_delta.decode_text(text_buf);
field_attributes.decode_text(text_buf);
}

void Node::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Node::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* Node::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("delta': ");
  new_tlv->add_TLV(field_delta.BER_encode_TLV(Node_delta_descr_, p_coding));
  ec_1.set_msg("attributes': ");
  new_tlv->add_TLV(field_attributes.BER_encode_TLV(Node_attributes_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean Node::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.Node' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("delta': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_delta.BER_decode_TLV(Node_delta_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("attributes': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_attributes=OMIT_VALUE;
    else {
      field_attributes.BER_decode_TLV(Node_attributes_descr_, tmp_tlv, L_form);
      if(field_attributes.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int Node::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.Node.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "delta");
    enc_len += field_delta.JSON_encode(Node_delta_descr_, p_tok);
  }

  if (field_attributes.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "attributes");
    enc_len += field_attributes.JSON_encode(Node_attributes_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Node::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "delta", name_len)) {
         int ret_val = field_delta.JSON_decode(Node_delta_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "delta");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "attributes", name_len)) {
         int ret_val = field_attributes.JSON_decode(Node_attributes_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "attributes");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_delta.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "delta");
    return JSON_ERROR_FATAL;
  }
if (!field_attributes.is_bound()) {
    field_attributes = OMIT_VALUE;
  }

  return dec_len;
}

struct Node_template::single_value_struct {
DSRC2::NodeOffsetPoint_template field_delta;
NodeAttributeSet_template field_attributes;
};

void Node_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_delta = ANY_VALUE;
single_value->field_attributes = ANY_OR_OMIT;
}
}
}

void Node_template::copy_value(const Node& other_value)
{
single_value = new single_value_struct;
if (other_value.delta().is_bound()) {
  single_value->field_delta = other_value.delta();
} else {
  single_value->field_delta.clean_up();
}
if (other_value.attributes().is_bound()) {
  if (other_value.attributes().ispresent()) single_value->field_attributes = other_value.attributes()();
  else single_value->field_attributes = OMIT_VALUE;
} else {
  single_value->field_attributes.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Node_template::copy_template(const Node_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.delta().get_selection()) {
single_value->field_delta = other_value.delta();
} else {
single_value->field_delta.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.attributes().get_selection()) {
single_value->field_attributes = other_value.attributes();
} else {
single_value->field_attributes.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Node_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.Node.");
break;
}
set_selection(other_value);
}

Node_template::Node_template()
{
}

Node_template::Node_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Node_template::Node_template(const Node& other_value)
{
copy_value(other_value);
}

Node_template::Node_template(const OPTIONAL<Node>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Node&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.Node from an unbound optional field.");
}
}

Node_template::Node_template(const Node_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Node_template::~Node_template()
{
clean_up();
}

Node_template& Node_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Node_template& Node_template::operator=(const Node& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Node_template& Node_template::operator=(const OPTIONAL<Node>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Node&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.Node.");
}
return *this;
}

Node_template& Node_template::operator=(const Node_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Node_template::match(const Node& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.delta().is_bound()) return FALSE;
if(!single_value->field_delta.match(other_value.delta(), legacy))return FALSE;
if(!other_value.attributes().is_bound()) return FALSE;
if((other_value.attributes().ispresent() ? !single_value->field_attributes.match((const NodeAttributeSet&)other_value.attributes(), legacy) : !single_value->field_attributes.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.Node.");
}
return FALSE;
}

boolean Node_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_delta.is_bound()) return TRUE;
if (single_value->field_attributes.is_omit() || single_value->field_attributes.is_bound()) return TRUE;
return FALSE;
}

boolean Node_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_delta.is_value()) return FALSE;
if (!single_value->field_attributes.is_omit() && !single_value->field_attributes.is_value()) return FALSE;
return TRUE;
}

void Node_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Node Node_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.Node.");
Node ret_val;
if (single_value->field_delta.is_bound()) {
ret_val.delta() = single_value->field_delta.valueof();
}
if (single_value->field_attributes.is_omit()) ret_val.attributes() = OMIT_VALUE;
else if (single_value->field_attributes.is_bound()) {
ret_val.attributes() = single_value->field_attributes.valueof();
}
return ret_val;
}

void Node_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.Node.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Node_template[list_length];
}

Node_template& Node_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.Node.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.Node.");
return value_list.list_value[list_index];
}

DSRC2::NodeOffsetPoint_template& Node_template::delta()
{
set_specific();
return single_value->field_delta;
}

const DSRC2::NodeOffsetPoint_template& Node_template::delta() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field delta of a non-specific template of type @DSRC.Node.");
return single_value->field_delta;
}

NodeAttributeSet_template& Node_template::attributes()
{
set_specific();
return single_value->field_attributes;
}

const NodeAttributeSet_template& Node_template::attributes() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field attributes of a non-specific template of type @DSRC.Node.");
return single_value->field_attributes;
}

int Node_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.Node which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_attributes.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.Node containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.Node containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.Node containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.Node containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.Node containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.Node.");
  }
  return 0;
}

void Node_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ delta := ");
single_value->field_delta.log();
TTCN_Logger::log_event_str(", attributes := ");
single_value->field_attributes.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Node_template::log_match(const Node& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_delta.match(match_value.delta(), legacy)){
TTCN_Logger::log_logmatch_info(".delta");
single_value->field_delta.log_match(match_value.delta(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.attributes().ispresent()){
if(!single_value->field_attributes.match(match_value.attributes(), legacy)){
TTCN_Logger::log_logmatch_info(".attributes");
single_value->field_attributes.log_match(match_value.attributes(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_attributes.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".attributes := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_attributes.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ delta := ");
single_value->field_delta.log_match(match_value.delta(), legacy);
TTCN_Logger::log_event_str(", attributes := ");
if (match_value.attributes().ispresent()) single_value->field_attributes.log_match(match_value.attributes(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_attributes.log();
if (single_value->field_attributes.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Node_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_delta.encode_text(text_buf);
single_value->field_attributes.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.Node.");
}
}

void Node_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_delta.decode_text(text_buf);
single_value->field_attributes.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Node_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.Node.");
}
}

void Node_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.Node'");
    }
    if (strcmp("delta", param_field) == 0) {
      delta().set_param(param);
      return;
    } else if (strcmp("attributes", param_field) == 0) {
      attributes().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.Node'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Node_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @DSRC.Node has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) delta().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) attributes().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "delta")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          delta().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "attributes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          attributes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.Node: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.Node");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Node_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.Node'");
    }
    if (strcmp("delta", param_field) == 0) {
      return delta().get_param(param_name);
    } else if (strcmp("attributes", param_field) == 0) {
      return attributes().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.Node'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_delta = single_value->field_delta.get_param(param_name);
    mp_field_delta->set_id(new Module_Param_FieldName(mcopystr("delta")));
    mp->add_elem(mp_field_delta);
    Module_Param* mp_field_attributes = single_value->field_attributes.get_param(param_name);
    mp_field_attributes->set_id(new Module_Param_FieldName(mcopystr("attributes")));
    mp->add_elem(mp_field_attributes);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Node_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_delta.check_restriction(t_res, t_name ? t_name : "@DSRC.Node");
single_value->field_attributes.check_restriction(t_res, t_name ? t_name : "@DSRC.Node");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.Node");
}

boolean Node_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Node_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

NodeAttributeSet::NodeAttributeSet()
{
  bound_flag = FALSE;
}

NodeAttributeSet::NodeAttributeSet(const OPTIONAL<NodeAttributeList>& par_localNode,
    const OPTIONAL<SegmentAttributeList>& par_disabled,
    const OPTIONAL<SegmentAttributeList>& par_enabled,
    const OPTIONAL<LaneDataAttributeList>& par_data,
    const OPTIONAL<RegionalNodeAttributeList>& par_regional,
    const OPTIONAL<INTEGER>& par_dWidth,
    const OPTIONAL<INTEGER>& par_dElevation)
  :   field_localNode(par_localNode),
  field_disabled(par_disabled),
  field_enabled(par_enabled),
  field_data(par_data),
  field_regional(par_regional),
  field_dWidth(par_dWidth),
  field_dElevation(par_dElevation)
{
  bound_flag = TRUE;
}

NodeAttributeSet::NodeAttributeSet(const NodeAttributeSet& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.NodeAttributeSet.");
bound_flag = TRUE;
if (other_value.localNode().is_bound()) field_localNode = other_value.localNode();
else field_localNode.clean_up();
if (other_value.disabled().is_bound()) field_disabled = other_value.disabled();
else field_disabled.clean_up();
if (other_value.enabled().is_bound()) field_enabled = other_value.enabled();
else field_enabled.clean_up();
if (other_value.data().is_bound()) field_data = other_value.data();
else field_data.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
if (other_value.dWidth().is_bound()) field_dWidth = other_value.dWidth();
else field_dWidth.clean_up();
if (other_value.dElevation().is_bound()) field_dElevation = other_value.dElevation();
else field_dElevation.clean_up();
}

void NodeAttributeSet::clean_up()
{
field_localNode.clean_up();
field_disabled.clean_up();
field_enabled.clean_up();
field_data.clean_up();
field_regional.clean_up();
field_dWidth.clean_up();
field_dElevation.clean_up();
bound_flag = FALSE;
}

NodeAttributeSet& NodeAttributeSet::operator=(const NodeAttributeSet& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.NodeAttributeSet.");
  bound_flag = TRUE;
  if (other_value.localNode().is_bound()) field_localNode = other_value.localNode();
  else field_localNode.clean_up();
  if (other_value.disabled().is_bound()) field_disabled = other_value.disabled();
  else field_disabled.clean_up();
  if (other_value.enabled().is_bound()) field_enabled = other_value.enabled();
  else field_enabled.clean_up();
  if (other_value.data().is_bound()) field_data = other_value.data();
  else field_data.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
  if (other_value.dWidth().is_bound()) field_dWidth = other_value.dWidth();
  else field_dWidth.clean_up();
  if (other_value.dElevation().is_bound()) field_dElevation = other_value.dElevation();
  else field_dElevation.clean_up();
}
return *this;
}

boolean NodeAttributeSet::operator==(const NodeAttributeSet& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_localNode==other_value.field_localNode
  && field_disabled==other_value.field_disabled
  && field_enabled==other_value.field_enabled
  && field_data==other_value.field_data
  && field_regional==other_value.field_regional
  && field_dWidth==other_value.field_dWidth
  && field_dElevation==other_value.field_dElevation;
}

boolean NodeAttributeSet::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_localNode.get_selection() || field_localNode.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_disabled.get_selection() || field_disabled.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_enabled.get_selection() || field_enabled.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_data.get_selection() || field_data.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_dWidth.get_selection() || field_dWidth.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_dElevation.get_selection() || field_dElevation.is_bound()) return TRUE;
return FALSE;
}
boolean NodeAttributeSet::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_localNode.get_selection() && !field_localNode.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_disabled.get_selection() && !field_disabled.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_enabled.get_selection() && !field_enabled.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_data.get_selection() && !field_data.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_dWidth.get_selection() && !field_dWidth.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_dElevation.get_selection() && !field_dElevation.is_value()) return FALSE;
return TRUE;
}
int NodeAttributeSet::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.NodeAttributeSet");
  int ret_val = 0;
  if (field_localNode.ispresent()) ret_val++;
  if (field_disabled.ispresent()) ret_val++;
  if (field_enabled.ispresent()) ret_val++;
  if (field_data.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  if (field_dWidth.ispresent()) ret_val++;
  if (field_dElevation.ispresent()) ret_val++;
  return ret_val;
}

void NodeAttributeSet::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ localNode := ");
field_localNode.log();
TTCN_Logger::log_event_str(", disabled := ");
field_disabled.log();
TTCN_Logger::log_event_str(", enabled := ");
field_enabled.log();
TTCN_Logger::log_event_str(", data := ");
field_data.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(", dWidth := ");
field_dWidth.log();
TTCN_Logger::log_event_str(", dElevation := ");
field_dElevation.log();
TTCN_Logger::log_event_str(" }");
}

void NodeAttributeSet::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.NodeAttributeSet'");
    }
    if (strcmp("localNode", param_field) == 0) {
      localNode().set_param(param);
      return;
    } else if (strcmp("disabled", param_field) == 0) {
      disabled().set_param(param);
      return;
    } else if (strcmp("enabled", param_field) == 0) {
      enabled().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else if (strcmp("dWidth", param_field) == 0) {
      dWidth().set_param(param);
      return;
    } else if (strcmp("dElevation", param_field) == 0) {
      dElevation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.NodeAttributeSet'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record value of type @DSRC.NodeAttributeSet has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) localNode().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) disabled().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) enabled().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) dWidth().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) dElevation().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "localNode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          localNode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "disabled")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          disabled().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enabled")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enabled().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dWidth")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dWidth().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dElevation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dElevation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.NodeAttributeSet: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.NodeAttributeSet");
  }
}

Module_Param* NodeAttributeSet::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.NodeAttributeSet'");
    }
    if (strcmp("localNode", param_field) == 0) {
      return localNode().get_param(param_name);
    } else if (strcmp("disabled", param_field) == 0) {
      return disabled().get_param(param_name);
    } else if (strcmp("enabled", param_field) == 0) {
      return enabled().get_param(param_name);
    } else if (strcmp("data", param_field) == 0) {
      return data().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else if (strcmp("dWidth", param_field) == 0) {
      return dWidth().get_param(param_name);
    } else if (strcmp("dElevation", param_field) == 0) {
      return dElevation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.NodeAttributeSet'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_localNode = field_localNode.get_param(param_name);
  mp_field_localNode->set_id(new Module_Param_FieldName(mcopystr("localNode")));
  mp->add_elem(mp_field_localNode);
  Module_Param* mp_field_disabled = field_disabled.get_param(param_name);
  mp_field_disabled->set_id(new Module_Param_FieldName(mcopystr("disabled")));
  mp->add_elem(mp_field_disabled);
  Module_Param* mp_field_enabled = field_enabled.get_param(param_name);
  mp_field_enabled->set_id(new Module_Param_FieldName(mcopystr("enabled")));
  mp->add_elem(mp_field_enabled);
  Module_Param* mp_field_data = field_data.get_param(param_name);
  mp_field_data->set_id(new Module_Param_FieldName(mcopystr("data")));
  mp->add_elem(mp_field_data);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  Module_Param* mp_field_dWidth = field_dWidth.get_param(param_name);
  mp_field_dWidth->set_id(new Module_Param_FieldName(mcopystr("dWidth")));
  mp->add_elem(mp_field_dWidth);
  Module_Param* mp_field_dElevation = field_dElevation.get_param(param_name);
  mp_field_dElevation->set_id(new Module_Param_FieldName(mcopystr("dElevation")));
  mp->add_elem(mp_field_dElevation);
  return mp;
  }

void NodeAttributeSet::set_implicit_omit()
{
if (!localNode().is_bound()) localNode() = OMIT_VALUE;
else localNode().set_implicit_omit();
if (!disabled().is_bound()) disabled() = OMIT_VALUE;
else disabled().set_implicit_omit();
if (!enabled().is_bound()) enabled() = OMIT_VALUE;
else enabled().set_implicit_omit();
if (!data().is_bound()) data() = OMIT_VALUE;
else data().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
if (!dWidth().is_bound()) dWidth() = OMIT_VALUE;
else dWidth().set_implicit_omit();
if (!dElevation().is_bound()) dElevation() = OMIT_VALUE;
else dElevation().set_implicit_omit();
}

void NodeAttributeSet::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.NodeAttributeSet.");
field_localNode.encode_text(text_buf);
field_disabled.encode_text(text_buf);
field_enabled.encode_text(text_buf);
field_data.encode_text(text_buf);
field_regional.encode_text(text_buf);
field_dWidth.encode_text(text_buf);
field_dElevation.encode_text(text_buf);
}

void NodeAttributeSet::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_localNode.decode_text(text_buf);
field_disabled.decode_text(text_buf);
field_enabled.decode_text(text_buf);
field_data.decode_text(text_buf);
field_regional.decode_text(text_buf);
field_dWidth.decode_text(text_buf);
field_dElevation.decode_text(text_buf);
}

void NodeAttributeSet::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void NodeAttributeSet::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* NodeAttributeSet::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("localNode': ");
  new_tlv->add_TLV(field_localNode.BER_encode_TLV(NodeAttributeSet_localNode_descr_, p_coding));
  ec_1.set_msg("disabled': ");
  new_tlv->add_TLV(field_disabled.BER_encode_TLV(NodeAttributeSet_disabled_descr_, p_coding));
  ec_1.set_msg("enabled': ");
  new_tlv->add_TLV(field_enabled.BER_encode_TLV(NodeAttributeSet_enabled_descr_, p_coding));
  ec_1.set_msg("data': ");
  new_tlv->add_TLV(field_data.BER_encode_TLV(NodeAttributeSet_data_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(NodeAttributeSet_regional_descr_, p_coding));
  ec_1.set_msg("dWidth': ");
  new_tlv->add_TLV(field_dWidth.BER_encode_TLV(NodeAttributeSet_dWidth_descr_, p_coding));
  ec_1.set_msg("dElevation': ");
  new_tlv->add_TLV(field_dElevation.BER_encode_TLV(NodeAttributeSet_dElevation_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean NodeAttributeSet::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.NodeAttributeSet' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("localNode': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_localNode=OMIT_VALUE;
    else {
      field_localNode.BER_decode_TLV(NodeAttributeSet_localNode_descr_, tmp_tlv, L_form);
      if(field_localNode.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("disabled': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_disabled=OMIT_VALUE;
    else {
      field_disabled.BER_decode_TLV(NodeAttributeSet_disabled_descr_, tmp_tlv, L_form);
      if(field_disabled.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("enabled': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_enabled=OMIT_VALUE;
    else {
      field_enabled.BER_decode_TLV(NodeAttributeSet_enabled_descr_, tmp_tlv, L_form);
      if(field_enabled.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("data': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_data=OMIT_VALUE;
    else {
      field_data.BER_decode_TLV(NodeAttributeSet_data_descr_, tmp_tlv, L_form);
      if(field_data.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(NodeAttributeSet_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("dWidth': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_dWidth=OMIT_VALUE;
    else {
      field_dWidth.BER_decode_TLV(NodeAttributeSet_dWidth_descr_, tmp_tlv, L_form);
      if(field_dWidth.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("dElevation': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_dElevation=OMIT_VALUE;
    else {
      field_dElevation.BER_decode_TLV(NodeAttributeSet_dElevation_descr_, tmp_tlv, L_form);
      if(field_dElevation.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int NodeAttributeSet::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.NodeAttributeSet.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_localNode.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "localNode");
    enc_len += field_localNode.JSON_encode(NodeAttributeSet_localNode_descr_, p_tok);
  }

  if (field_disabled.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "disabled");
    enc_len += field_disabled.JSON_encode(NodeAttributeSet_disabled_descr_, p_tok);
  }

  if (field_enabled.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "enabled");
    enc_len += field_enabled.JSON_encode(NodeAttributeSet_enabled_descr_, p_tok);
  }

  if (field_data.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "data");
    enc_len += field_data.JSON_encode(NodeAttributeSet_data_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(NodeAttributeSet_regional_descr_, p_tok);
  }

  if (field_dWidth.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dWidth");
    enc_len += field_dWidth.JSON_encode(NodeAttributeSet_dWidth_descr_, p_tok);
  }

  if (field_dElevation.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dElevation");
    enc_len += field_dElevation.JSON_encode(NodeAttributeSet_dElevation_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int NodeAttributeSet::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "localNode", name_len)) {
         int ret_val = field_localNode.JSON_decode(NodeAttributeSet_localNode_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "localNode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "disabled", name_len)) {
         int ret_val = field_disabled.JSON_decode(NodeAttributeSet_disabled_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "disabled");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "enabled", name_len)) {
         int ret_val = field_enabled.JSON_decode(NodeAttributeSet_enabled_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "enabled");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "data", name_len)) {
         int ret_val = field_data.JSON_decode(NodeAttributeSet_data_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "data");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(NodeAttributeSet_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "dWidth", name_len)) {
         int ret_val = field_dWidth.JSON_decode(NodeAttributeSet_dWidth_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dWidth");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "dElevation", name_len)) {
         int ret_val = field_dElevation.JSON_decode(NodeAttributeSet_dElevation_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dElevation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_localNode.is_bound()) {
    field_localNode = OMIT_VALUE;
  }
if (!field_disabled.is_bound()) {
    field_disabled = OMIT_VALUE;
  }
if (!field_enabled.is_bound()) {
    field_enabled = OMIT_VALUE;
  }
if (!field_data.is_bound()) {
    field_data = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }
if (!field_dWidth.is_bound()) {
    field_dWidth = OMIT_VALUE;
  }
if (!field_dElevation.is_bound()) {
    field_dElevation = OMIT_VALUE;
  }

  return dec_len;
}

struct NodeAttributeSet_template::single_value_struct {
NodeAttributeList_template field_localNode;
SegmentAttributeList_template field_disabled;
SegmentAttributeList_template field_enabled;
LaneDataAttributeList_template field_data;
RegionalNodeAttributeList_template field_regional;
INTEGER_template field_dWidth;
INTEGER_template field_dElevation;
};

void NodeAttributeSet_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_localNode = ANY_OR_OMIT;
single_value->field_disabled = ANY_OR_OMIT;
single_value->field_enabled = ANY_OR_OMIT;
single_value->field_data = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
single_value->field_dWidth = ANY_OR_OMIT;
single_value->field_dElevation = ANY_OR_OMIT;
}
}
}

void NodeAttributeSet_template::copy_value(const NodeAttributeSet& other_value)
{
single_value = new single_value_struct;
if (other_value.localNode().is_bound()) {
  if (other_value.localNode().ispresent()) single_value->field_localNode = other_value.localNode()();
  else single_value->field_localNode = OMIT_VALUE;
} else {
  single_value->field_localNode.clean_up();
}
if (other_value.disabled().is_bound()) {
  if (other_value.disabled().ispresent()) single_value->field_disabled = other_value.disabled()();
  else single_value->field_disabled = OMIT_VALUE;
} else {
  single_value->field_disabled.clean_up();
}
if (other_value.enabled().is_bound()) {
  if (other_value.enabled().ispresent()) single_value->field_enabled = other_value.enabled()();
  else single_value->field_enabled = OMIT_VALUE;
} else {
  single_value->field_enabled.clean_up();
}
if (other_value.data().is_bound()) {
  if (other_value.data().ispresent()) single_value->field_data = other_value.data()();
  else single_value->field_data = OMIT_VALUE;
} else {
  single_value->field_data.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
if (other_value.dWidth().is_bound()) {
  if (other_value.dWidth().ispresent()) single_value->field_dWidth = other_value.dWidth()();
  else single_value->field_dWidth = OMIT_VALUE;
} else {
  single_value->field_dWidth.clean_up();
}
if (other_value.dElevation().is_bound()) {
  if (other_value.dElevation().ispresent()) single_value->field_dElevation = other_value.dElevation()();
  else single_value->field_dElevation = OMIT_VALUE;
} else {
  single_value->field_dElevation.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void NodeAttributeSet_template::copy_template(const NodeAttributeSet_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.localNode().get_selection()) {
single_value->field_localNode = other_value.localNode();
} else {
single_value->field_localNode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.disabled().get_selection()) {
single_value->field_disabled = other_value.disabled();
} else {
single_value->field_disabled.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.enabled().get_selection()) {
single_value->field_enabled = other_value.enabled();
} else {
single_value->field_enabled.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data().get_selection()) {
single_value->field_data = other_value.data();
} else {
single_value->field_data.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dWidth().get_selection()) {
single_value->field_dWidth = other_value.dWidth();
} else {
single_value->field_dWidth.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dElevation().get_selection()) {
single_value->field_dElevation = other_value.dElevation();
} else {
single_value->field_dElevation.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new NodeAttributeSet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.NodeAttributeSet.");
break;
}
set_selection(other_value);
}

NodeAttributeSet_template::NodeAttributeSet_template()
{
}

NodeAttributeSet_template::NodeAttributeSet_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

NodeAttributeSet_template::NodeAttributeSet_template(const NodeAttributeSet& other_value)
{
copy_value(other_value);
}

NodeAttributeSet_template::NodeAttributeSet_template(const OPTIONAL<NodeAttributeSet>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const NodeAttributeSet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.NodeAttributeSet from an unbound optional field.");
}
}

NodeAttributeSet_template::NodeAttributeSet_template(const NodeAttributeSet_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

NodeAttributeSet_template::~NodeAttributeSet_template()
{
clean_up();
}

NodeAttributeSet_template& NodeAttributeSet_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

NodeAttributeSet_template& NodeAttributeSet_template::operator=(const NodeAttributeSet& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

NodeAttributeSet_template& NodeAttributeSet_template::operator=(const OPTIONAL<NodeAttributeSet>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const NodeAttributeSet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.NodeAttributeSet.");
}
return *this;
}

NodeAttributeSet_template& NodeAttributeSet_template::operator=(const NodeAttributeSet_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean NodeAttributeSet_template::match(const NodeAttributeSet& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.localNode().is_bound()) return FALSE;
if((other_value.localNode().ispresent() ? !single_value->field_localNode.match((const NodeAttributeList&)other_value.localNode(), legacy) : !single_value->field_localNode.match_omit(legacy)))return FALSE;
if(!other_value.disabled().is_bound()) return FALSE;
if((other_value.disabled().ispresent() ? !single_value->field_disabled.match((const SegmentAttributeList&)other_value.disabled(), legacy) : !single_value->field_disabled.match_omit(legacy)))return FALSE;
if(!other_value.enabled().is_bound()) return FALSE;
if((other_value.enabled().ispresent() ? !single_value->field_enabled.match((const SegmentAttributeList&)other_value.enabled(), legacy) : !single_value->field_enabled.match_omit(legacy)))return FALSE;
if(!other_value.data().is_bound()) return FALSE;
if((other_value.data().ispresent() ? !single_value->field_data.match((const LaneDataAttributeList&)other_value.data(), legacy) : !single_value->field_data.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const RegionalNodeAttributeList&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
if(!other_value.dWidth().is_bound()) return FALSE;
if((other_value.dWidth().ispresent() ? !single_value->field_dWidth.match((const INTEGER&)other_value.dWidth(), legacy) : !single_value->field_dWidth.match_omit(legacy)))return FALSE;
if(!other_value.dElevation().is_bound()) return FALSE;
if((other_value.dElevation().ispresent() ? !single_value->field_dElevation.match((const INTEGER&)other_value.dElevation(), legacy) : !single_value->field_dElevation.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.NodeAttributeSet.");
}
return FALSE;
}

boolean NodeAttributeSet_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_localNode.is_omit() || single_value->field_localNode.is_bound()) return TRUE;
if (single_value->field_disabled.is_omit() || single_value->field_disabled.is_bound()) return TRUE;
if (single_value->field_enabled.is_omit() || single_value->field_enabled.is_bound()) return TRUE;
if (single_value->field_data.is_omit() || single_value->field_data.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
if (single_value->field_dWidth.is_omit() || single_value->field_dWidth.is_bound()) return TRUE;
if (single_value->field_dElevation.is_omit() || single_value->field_dElevation.is_bound()) return TRUE;
return FALSE;
}

boolean NodeAttributeSet_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_localNode.is_omit() && !single_value->field_localNode.is_value()) return FALSE;
if (!single_value->field_disabled.is_omit() && !single_value->field_disabled.is_value()) return FALSE;
if (!single_value->field_enabled.is_omit() && !single_value->field_enabled.is_value()) return FALSE;
if (!single_value->field_data.is_omit() && !single_value->field_data.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
if (!single_value->field_dWidth.is_omit() && !single_value->field_dWidth.is_value()) return FALSE;
if (!single_value->field_dElevation.is_omit() && !single_value->field_dElevation.is_value()) return FALSE;
return TRUE;
}

void NodeAttributeSet_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

NodeAttributeSet NodeAttributeSet_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.NodeAttributeSet.");
NodeAttributeSet ret_val;
if (single_value->field_localNode.is_omit()) ret_val.localNode() = OMIT_VALUE;
else if (single_value->field_localNode.is_bound()) {
ret_val.localNode() = single_value->field_localNode.valueof();
}
if (single_value->field_disabled.is_omit()) ret_val.disabled() = OMIT_VALUE;
else if (single_value->field_disabled.is_bound()) {
ret_val.disabled() = single_value->field_disabled.valueof();
}
if (single_value->field_enabled.is_omit()) ret_val.enabled() = OMIT_VALUE;
else if (single_value->field_enabled.is_bound()) {
ret_val.enabled() = single_value->field_enabled.valueof();
}
if (single_value->field_data.is_omit()) ret_val.data() = OMIT_VALUE;
else if (single_value->field_data.is_bound()) {
ret_val.data() = single_value->field_data.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
if (single_value->field_dWidth.is_omit()) ret_val.dWidth() = OMIT_VALUE;
else if (single_value->field_dWidth.is_bound()) {
ret_val.dWidth() = single_value->field_dWidth.valueof();
}
if (single_value->field_dElevation.is_omit()) ret_val.dElevation() = OMIT_VALUE;
else if (single_value->field_dElevation.is_bound()) {
ret_val.dElevation() = single_value->field_dElevation.valueof();
}
return ret_val;
}

void NodeAttributeSet_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.NodeAttributeSet.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new NodeAttributeSet_template[list_length];
}

NodeAttributeSet_template& NodeAttributeSet_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.NodeAttributeSet.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.NodeAttributeSet.");
return value_list.list_value[list_index];
}

NodeAttributeList_template& NodeAttributeSet_template::localNode()
{
set_specific();
return single_value->field_localNode;
}

const NodeAttributeList_template& NodeAttributeSet_template::localNode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field localNode of a non-specific template of type @DSRC.NodeAttributeSet.");
return single_value->field_localNode;
}

SegmentAttributeList_template& NodeAttributeSet_template::disabled()
{
set_specific();
return single_value->field_disabled;
}

const SegmentAttributeList_template& NodeAttributeSet_template::disabled() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field disabled of a non-specific template of type @DSRC.NodeAttributeSet.");
return single_value->field_disabled;
}

SegmentAttributeList_template& NodeAttributeSet_template::enabled()
{
set_specific();
return single_value->field_enabled;
}

const SegmentAttributeList_template& NodeAttributeSet_template::enabled() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field enabled of a non-specific template of type @DSRC.NodeAttributeSet.");
return single_value->field_enabled;
}

LaneDataAttributeList_template& NodeAttributeSet_template::data()
{
set_specific();
return single_value->field_data;
}

const LaneDataAttributeList_template& NodeAttributeSet_template::data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data of a non-specific template of type @DSRC.NodeAttributeSet.");
return single_value->field_data;
}

RegionalNodeAttributeList_template& NodeAttributeSet_template::regional()
{
set_specific();
return single_value->field_regional;
}

const RegionalNodeAttributeList_template& NodeAttributeSet_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.NodeAttributeSet.");
return single_value->field_regional;
}

INTEGER_template& NodeAttributeSet_template::dWidth()
{
set_specific();
return single_value->field_dWidth;
}

const INTEGER_template& NodeAttributeSet_template::dWidth() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dWidth of a non-specific template of type @DSRC.NodeAttributeSet.");
return single_value->field_dWidth;
}

INTEGER_template& NodeAttributeSet_template::dElevation()
{
set_specific();
return single_value->field_dElevation;
}

const INTEGER_template& NodeAttributeSet_template::dElevation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dElevation of a non-specific template of type @DSRC.NodeAttributeSet.");
return single_value->field_dElevation;
}

int NodeAttributeSet_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.NodeAttributeSet which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_localNode.is_present()) ret_val++;
      if (single_value->field_disabled.is_present()) ret_val++;
      if (single_value->field_enabled.is_present()) ret_val++;
      if (single_value->field_data.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      if (single_value->field_dWidth.is_present()) ret_val++;
      if (single_value->field_dElevation.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.NodeAttributeSet containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.NodeAttributeSet containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.NodeAttributeSet containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.NodeAttributeSet containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.NodeAttributeSet containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.NodeAttributeSet.");
  }
  return 0;
}

void NodeAttributeSet_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ localNode := ");
single_value->field_localNode.log();
TTCN_Logger::log_event_str(", disabled := ");
single_value->field_disabled.log();
TTCN_Logger::log_event_str(", enabled := ");
single_value->field_enabled.log();
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(", dWidth := ");
single_value->field_dWidth.log();
TTCN_Logger::log_event_str(", dElevation := ");
single_value->field_dElevation.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void NodeAttributeSet_template::log_match(const NodeAttributeSet& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.localNode().ispresent()){
if(!single_value->field_localNode.match(match_value.localNode(), legacy)){
TTCN_Logger::log_logmatch_info(".localNode");
single_value->field_localNode.log_match(match_value.localNode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_localNode.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".localNode := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_localNode.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.disabled().ispresent()){
if(!single_value->field_disabled.match(match_value.disabled(), legacy)){
TTCN_Logger::log_logmatch_info(".disabled");
single_value->field_disabled.log_match(match_value.disabled(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_disabled.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".disabled := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_disabled.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.enabled().ispresent()){
if(!single_value->field_enabled.match(match_value.enabled(), legacy)){
TTCN_Logger::log_logmatch_info(".enabled");
single_value->field_enabled.log_match(match_value.enabled(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_enabled.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".enabled := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_enabled.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.data().ispresent()){
if(!single_value->field_data.match(match_value.data(), legacy)){
TTCN_Logger::log_logmatch_info(".data");
single_value->field_data.log_match(match_value.data(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_data.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".data := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_data.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.dWidth().ispresent()){
if(!single_value->field_dWidth.match(match_value.dWidth(), legacy)){
TTCN_Logger::log_logmatch_info(".dWidth");
single_value->field_dWidth.log_match(match_value.dWidth(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_dWidth.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".dWidth := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_dWidth.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.dElevation().ispresent()){
if(!single_value->field_dElevation.match(match_value.dElevation(), legacy)){
TTCN_Logger::log_logmatch_info(".dElevation");
single_value->field_dElevation.log_match(match_value.dElevation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_dElevation.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".dElevation := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_dElevation.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ localNode := ");
if (match_value.localNode().ispresent()) single_value->field_localNode.log_match(match_value.localNode(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_localNode.log();
if (single_value->field_localNode.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", disabled := ");
if (match_value.disabled().ispresent()) single_value->field_disabled.log_match(match_value.disabled(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_disabled.log();
if (single_value->field_disabled.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", enabled := ");
if (match_value.enabled().ispresent()) single_value->field_enabled.log_match(match_value.enabled(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_enabled.log();
if (single_value->field_enabled.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", data := ");
if (match_value.data().ispresent()) single_value->field_data.log_match(match_value.data(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_data.log();
if (single_value->field_data.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", dWidth := ");
if (match_value.dWidth().ispresent()) single_value->field_dWidth.log_match(match_value.dWidth(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_dWidth.log();
if (single_value->field_dWidth.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", dElevation := ");
if (match_value.dElevation().ispresent()) single_value->field_dElevation.log_match(match_value.dElevation(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_dElevation.log();
if (single_value->field_dElevation.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void NodeAttributeSet_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_localNode.encode_text(text_buf);
single_value->field_disabled.encode_text(text_buf);
single_value->field_enabled.encode_text(text_buf);
single_value->field_data.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
single_value->field_dWidth.encode_text(text_buf);
single_value->field_dElevation.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.NodeAttributeSet.");
}
}

void NodeAttributeSet_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_localNode.decode_text(text_buf);
single_value->field_disabled.decode_text(text_buf);
single_value->field_enabled.decode_text(text_buf);
single_value->field_data.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
single_value->field_dWidth.decode_text(text_buf);
single_value->field_dElevation.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new NodeAttributeSet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.NodeAttributeSet.");
}
}

void NodeAttributeSet_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.NodeAttributeSet'");
    }
    if (strcmp("localNode", param_field) == 0) {
      localNode().set_param(param);
      return;
    } else if (strcmp("disabled", param_field) == 0) {
      disabled().set_param(param);
      return;
    } else if (strcmp("enabled", param_field) == 0) {
      enabled().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else if (strcmp("dWidth", param_field) == 0) {
      dWidth().set_param(param);
      return;
    } else if (strcmp("dElevation", param_field) == 0) {
      dElevation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.NodeAttributeSet'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    NodeAttributeSet_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record template of type @DSRC.NodeAttributeSet has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) localNode().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) disabled().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) enabled().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) dWidth().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) dElevation().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "localNode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          localNode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "disabled")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          disabled().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enabled")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enabled().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dWidth")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dWidth().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dElevation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dElevation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.NodeAttributeSet: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.NodeAttributeSet");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* NodeAttributeSet_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.NodeAttributeSet'");
    }
    if (strcmp("localNode", param_field) == 0) {
      return localNode().get_param(param_name);
    } else if (strcmp("disabled", param_field) == 0) {
      return disabled().get_param(param_name);
    } else if (strcmp("enabled", param_field) == 0) {
      return enabled().get_param(param_name);
    } else if (strcmp("data", param_field) == 0) {
      return data().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else if (strcmp("dWidth", param_field) == 0) {
      return dWidth().get_param(param_name);
    } else if (strcmp("dElevation", param_field) == 0) {
      return dElevation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.NodeAttributeSet'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_localNode = single_value->field_localNode.get_param(param_name);
    mp_field_localNode->set_id(new Module_Param_FieldName(mcopystr("localNode")));
    mp->add_elem(mp_field_localNode);
    Module_Param* mp_field_disabled = single_value->field_disabled.get_param(param_name);
    mp_field_disabled->set_id(new Module_Param_FieldName(mcopystr("disabled")));
    mp->add_elem(mp_field_disabled);
    Module_Param* mp_field_enabled = single_value->field_enabled.get_param(param_name);
    mp_field_enabled->set_id(new Module_Param_FieldName(mcopystr("enabled")));
    mp->add_elem(mp_field_enabled);
    Module_Param* mp_field_data = single_value->field_data.get_param(param_name);
    mp_field_data->set_id(new Module_Param_FieldName(mcopystr("data")));
    mp->add_elem(mp_field_data);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    Module_Param* mp_field_dWidth = single_value->field_dWidth.get_param(param_name);
    mp_field_dWidth->set_id(new Module_Param_FieldName(mcopystr("dWidth")));
    mp->add_elem(mp_field_dWidth);
    Module_Param* mp_field_dElevation = single_value->field_dElevation.get_param(param_name);
    mp_field_dElevation->set_id(new Module_Param_FieldName(mcopystr("dElevation")));
    mp->add_elem(mp_field_dElevation);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void NodeAttributeSet_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_localNode.check_restriction(t_res, t_name ? t_name : "@DSRC.NodeAttributeSet");
single_value->field_disabled.check_restriction(t_res, t_name ? t_name : "@DSRC.NodeAttributeSet");
single_value->field_enabled.check_restriction(t_res, t_name ? t_name : "@DSRC.NodeAttributeSet");
single_value->field_data.check_restriction(t_res, t_name ? t_name : "@DSRC.NodeAttributeSet");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.NodeAttributeSet");
single_value->field_dWidth.check_restriction(t_res, t_name ? t_name : "@DSRC.NodeAttributeSet");
single_value->field_dElevation.check_restriction(t_res, t_name ? t_name : "@DSRC.NodeAttributeSet");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.NodeAttributeSet");
}

boolean NodeAttributeSet_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean NodeAttributeSet_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const NodeAttribute NodeAttributeList::UNBOUND_ELEM;
NodeAttributeList::NodeAttributeList()
{
val_ptr = NULL;
}

NodeAttributeList::NodeAttributeList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

NodeAttributeList::NodeAttributeList(const NodeAttributeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.NodeAttributeList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

NodeAttributeList::~NodeAttributeList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void NodeAttributeList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

NodeAttributeList& NodeAttributeList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

NodeAttributeList& NodeAttributeList::operator=(const NodeAttributeList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.NodeAttributeList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean NodeAttributeList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.NodeAttributeList.");
return val_ptr->n_elements == 0 ;
}

boolean NodeAttributeList::operator==(const NodeAttributeList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.NodeAttributeList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.NodeAttributeList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

NodeAttribute& NodeAttributeList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.NodeAttributeList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (NodeAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new NodeAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new NodeAttribute;
}
return *val_ptr->value_elements[index_value];
}

NodeAttribute& NodeAttributeList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.NodeAttributeList.");
return (*this)[(int)index_value];
}

const NodeAttribute& NodeAttributeList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.NodeAttributeList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.NodeAttributeList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.NodeAttributeList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const NodeAttribute& NodeAttributeList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.NodeAttributeList.");
return (*this)[(int)index_value];
}

NodeAttributeList NodeAttributeList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

NodeAttributeList NodeAttributeList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

NodeAttributeList NodeAttributeList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

NodeAttributeList NodeAttributeList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.NodeAttributeList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
NodeAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new NodeAttribute(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

NodeAttributeList NodeAttributeList::operator+(const NodeAttributeList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.NodeAttributeList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
NodeAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new NodeAttribute(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new NodeAttribute(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

NodeAttributeList NodeAttributeList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.NodeAttributeList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.NodeAttributeList","element");
NodeAttributeList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new NodeAttribute(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

NodeAttributeList NodeAttributeList::replace(int index, int len, const NodeAttributeList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.NodeAttributeList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.NodeAttributeList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.NodeAttributeList","element");
NodeAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new NodeAttribute(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new NodeAttribute(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new NodeAttribute(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

NodeAttributeList NodeAttributeList::replace(int index, int len, const NodeAttributeList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void NodeAttributeList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.NodeAttributeList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (NodeAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new NodeAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (NodeAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.NodeAttributeList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (NodeAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean NodeAttributeList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int NodeAttributeList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.NodeAttributeList.");
return val_ptr->n_elements;
}

int NodeAttributeList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.NodeAttributeList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void NodeAttributeList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void NodeAttributeList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.NodeAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.NodeAttributeList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.NodeAttributeList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* NodeAttributeList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.NodeAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void NodeAttributeList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void NodeAttributeList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.NodeAttributeList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void NodeAttributeList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.NodeAttributeList.");
val_ptr->value_elements = (NodeAttribute**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new NodeAttribute;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void NodeAttributeList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void NodeAttributeList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* NodeAttributeList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean NodeAttributeList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (NodeAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new NodeAttribute;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int NodeAttributeList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.NodeAttributeList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int NodeAttributeList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    NodeAttribute* val = new NodeAttribute;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (NodeAttribute**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void NodeAttributeList_template::copy_value(const NodeAttributeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.NodeAttributeList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (NodeAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new NodeAttribute_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new NodeAttribute_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void NodeAttributeList_template::copy_template(const NodeAttributeList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (NodeAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new NodeAttribute_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new NodeAttribute_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new NodeAttributeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.NodeAttributeList.");
break;
}
set_selection(other_value);
}

boolean NodeAttributeList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const NodeAttributeList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const NodeAttributeList*)value_ptr)[value_index], legacy);
else return ((const NodeAttributeList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

NodeAttributeList_template::NodeAttributeList_template()
{
}

NodeAttributeList_template::NodeAttributeList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

NodeAttributeList_template::NodeAttributeList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

NodeAttributeList_template::NodeAttributeList_template(const NodeAttributeList& other_value)
{
copy_value(other_value);
}

NodeAttributeList_template::NodeAttributeList_template(const OPTIONAL<NodeAttributeList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const NodeAttributeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.NodeAttributeList from an unbound optional field.");
}
}

NodeAttributeList_template::NodeAttributeList_template(const NodeAttributeList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

NodeAttributeList_template::~NodeAttributeList_template()
{
clean_up();
}

void NodeAttributeList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

NodeAttributeList_template& NodeAttributeList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

NodeAttributeList_template& NodeAttributeList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

NodeAttributeList_template& NodeAttributeList_template::operator=(const NodeAttributeList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

NodeAttributeList_template& NodeAttributeList_template::operator=(const OPTIONAL<NodeAttributeList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const NodeAttributeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.NodeAttributeList.");
}
return *this;
}

NodeAttributeList_template& NodeAttributeList_template::operator=(const NodeAttributeList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

NodeAttribute_template& NodeAttributeList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.NodeAttributeList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.NodeAttributeList.");
    break;
}
return *single_value.value_elements[index_value];
}

NodeAttribute_template& NodeAttributeList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.NodeAttributeList.");
return (*this)[(int)index_value];
}

const NodeAttribute_template& NodeAttributeList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.NodeAttributeList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.NodeAttributeList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.NodeAttributeList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const NodeAttribute_template& NodeAttributeList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.NodeAttributeList.");
return (*this)[(int)index_value];
}

void NodeAttributeList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.NodeAttributeList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (NodeAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new NodeAttribute_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new NodeAttribute_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (NodeAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int NodeAttributeList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int NodeAttributeList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeAttributeList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeAttributeList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeAttributeList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeAttributeList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeAttributeList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.NodeAttributeList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.NodeAttributeList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.NodeAttributeList");
}

boolean NodeAttributeList_template::match(const NodeAttributeList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.NodeAttributeList.");
}
return FALSE;
}

boolean NodeAttributeList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

NodeAttributeList NodeAttributeList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.NodeAttributeList.");
NodeAttributeList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

NodeAttributeList NodeAttributeList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

NodeAttributeList NodeAttributeList_template::replace(int index, int len, const NodeAttributeList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

NodeAttributeList NodeAttributeList_template::replace(int index, int len, const NodeAttributeList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void NodeAttributeList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new NodeAttributeList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.NodeAttributeList.");
}
set_selection(template_type);
}

NodeAttributeList_template& NodeAttributeList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.NodeAttributeList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.NodeAttributeList.");
return value_list.list_value[list_index];
}

void NodeAttributeList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void NodeAttributeList_template::log_match(const NodeAttributeList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void NodeAttributeList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.NodeAttributeList.");
}
}

void NodeAttributeList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.NodeAttributeList.");
single_value.value_elements = (NodeAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new NodeAttribute_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new NodeAttributeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.NodeAttributeList.");
}
}

boolean NodeAttributeList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean NodeAttributeList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void NodeAttributeList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.NodeAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    NodeAttributeList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.NodeAttributeList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* NodeAttributeList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.NodeAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void NodeAttributeList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.NodeAttributeList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.NodeAttributeList");
}

NodeAttribute::NodeAttribute()
{
enum_value = UNBOUND_VALUE;
}

NodeAttribute::NodeAttribute(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @DSRC.NodeAttribute with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

NodeAttribute::NodeAttribute(enum_type other_value)
{
enum_value = other_value;
}

NodeAttribute::NodeAttribute(const NodeAttribute& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @DSRC.NodeAttribute.");
enum_value = other_value.enum_value;
}

NodeAttribute& NodeAttribute::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @DSRC.NodeAttribute.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

NodeAttribute& NodeAttribute::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

NodeAttribute& NodeAttribute::operator=(const NodeAttribute& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.NodeAttribute.");
enum_value = other_value.enum_value;
return *this;
}

boolean NodeAttribute::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.NodeAttribute.");
return enum_value == other_value;
}

boolean NodeAttribute::operator==(const NodeAttribute& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.NodeAttribute.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.NodeAttribute.");
return enum_value == other_value.enum_value;
}

boolean NodeAttribute::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.NodeAttribute.");
return enum_value < other_value;
}

boolean NodeAttribute::operator<(const NodeAttribute& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.NodeAttribute.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.NodeAttribute.");
return enum_value < other_value.enum_value;
}

boolean NodeAttribute::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.NodeAttribute.");
return enum_value > other_value;
}

boolean NodeAttribute::operator>(const NodeAttribute& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.NodeAttribute.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.NodeAttribute.");
return enum_value > other_value.enum_value;
}

const char *NodeAttribute::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case reserved: return "reserved";
case stopLine: return "stopLine";
case roundedCapStyleA: return "roundedCapStyleA";
case roundedCapStyleB: return "roundedCapStyleB";
case mergePoint: return "mergePoint";
case divergePoint: return "divergePoint";
case downstreamStopLine: return "downstreamStopLine";
case downstreamStartNode: return "downstreamStartNode";
case closedToTraffic: return "closedToTraffic";
case safeIsland: return "safeIsland";
case curbPresentAtStepOff: return "curbPresentAtStepOff";
case hydrantPresent: return "hydrantPresent";
default: return "<unknown>";
}
}

NodeAttribute::enum_type NodeAttribute::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "reserved")) return reserved;
else if (!strcmp(str_par, "stopLine")) return stopLine;
else if (!strcmp(str_par, "roundedCapStyleA")) return roundedCapStyleA;
else if (!strcmp(str_par, "roundedCapStyleB")) return roundedCapStyleB;
else if (!strcmp(str_par, "mergePoint")) return mergePoint;
else if (!strcmp(str_par, "divergePoint")) return divergePoint;
else if (!strcmp(str_par, "downstreamStopLine")) return downstreamStopLine;
else if (!strcmp(str_par, "downstreamStartNode")) return downstreamStartNode;
else if (!strcmp(str_par, "closedToTraffic")) return closedToTraffic;
else if (!strcmp(str_par, "safeIsland")) return safeIsland;
else if (!strcmp(str_par, "curbPresentAtStepOff")) return curbPresentAtStepOff;
else if (!strcmp(str_par, "hydrantPresent")) return hydrantPresent;
else return UNKNOWN_VALUE;
}

boolean NodeAttribute::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
return TRUE;
default:
return FALSE;
}
}

int NodeAttribute::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.NodeAttribute.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int NodeAttribute::enum2int(const NodeAttribute& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.NodeAttribute.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void NodeAttribute::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @DSRC.NodeAttribute.", int_val);
enum_value = (enum_type)int_val;
}

NodeAttribute::operator NodeAttribute::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @DSRC.NodeAttribute.");
return enum_value;
}

void NodeAttribute::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void NodeAttribute::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@DSRC.NodeAttribute");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @DSRC.NodeAttribute.");
  }
}

Module_Param* NodeAttribute::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void NodeAttribute::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @DSRC.NodeAttribute.");
text_buf.push_int(enum_value);
}

void NodeAttribute::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @DSRC.NodeAttribute.", enum_value);
}

void NodeAttribute::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void NodeAttribute::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* NodeAttribute::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean NodeAttribute::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @DSRC.NodeAttribute: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int NodeAttribute::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @DSRC.NodeAttribute.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int NodeAttribute::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void NodeAttribute_template::copy_template(const NodeAttribute_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new NodeAttribute_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @DSRC.NodeAttribute.");
}
}

NodeAttribute_template::NodeAttribute_template()
{
}

NodeAttribute_template::NodeAttribute_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

NodeAttribute_template::NodeAttribute_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!NodeAttribute::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @DSRC.NodeAttribute with unknown numeric value %d.", other_value);
single_value = (NodeAttribute::enum_type)other_value;
}

NodeAttribute_template::NodeAttribute_template(NodeAttribute::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

NodeAttribute_template::NodeAttribute_template(const NodeAttribute& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == NodeAttribute::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @DSRC.NodeAttribute.");
single_value = other_value.enum_value;
}

NodeAttribute_template::NodeAttribute_template(const OPTIONAL<NodeAttribute>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (NodeAttribute::enum_type)(const NodeAttribute&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @DSRC.NodeAttribute from an unbound optional field.");
}
}

NodeAttribute_template::NodeAttribute_template(const NodeAttribute_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

NodeAttribute_template::~NodeAttribute_template()
{
clean_up();
}

boolean NodeAttribute_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean NodeAttribute_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != NodeAttribute::UNBOUND_VALUE;
}

void NodeAttribute_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

NodeAttribute_template& NodeAttribute_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

NodeAttribute_template& NodeAttribute_template::operator=(int other_value)
{
if (!NodeAttribute::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @DSRC.NodeAttribute.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (NodeAttribute::enum_type)other_value;
return *this;
}

NodeAttribute_template& NodeAttribute_template::operator=(NodeAttribute::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

NodeAttribute_template& NodeAttribute_template::operator=(const NodeAttribute& other_value)
{
if (other_value.enum_value == NodeAttribute::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.NodeAttribute to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

NodeAttribute_template& NodeAttribute_template::operator=(const OPTIONAL<NodeAttribute>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (NodeAttribute::enum_type)(const NodeAttribute&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @DSRC.NodeAttribute.");
}
return *this;
}

NodeAttribute_template& NodeAttribute_template::operator=(const NodeAttribute_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean NodeAttribute_template::match(NodeAttribute::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @DSRC.NodeAttribute.");
}
return FALSE;
}

boolean NodeAttribute_template::match(const NodeAttribute& other_value, boolean) const
{
if (other_value.enum_value == NodeAttribute::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @DSRC.NodeAttribute with an unbound value.");
return match(other_value.enum_value);
}

NodeAttribute::enum_type NodeAttribute_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @DSRC.NodeAttribute.");
return single_value;
}

void NodeAttribute_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @DSRC.NodeAttribute.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new NodeAttribute_template[list_length];
}

NodeAttribute_template& NodeAttribute_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @DSRC.NodeAttribute.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @DSRC.NodeAttribute.");
return value_list.list_value[list_index];
}

void NodeAttribute_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(NodeAttribute::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void NodeAttribute_template::log_match(const NodeAttribute& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void NodeAttribute_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @DSRC.NodeAttribute.");
}
}

void NodeAttribute_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (NodeAttribute::enum_type)text_buf.pull_int().get_val();
if (!NodeAttribute::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @DSRC.NodeAttribute.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new NodeAttribute_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @DSRC.NodeAttribute.");
}
}

boolean NodeAttribute_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean NodeAttribute_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void NodeAttribute_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    NodeAttribute::enum_type enum_val = (enum_name != NULL) ? NodeAttribute::str_to_enum(enum_name) : NodeAttribute::UNKNOWN_VALUE;
    if (NodeAttribute::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    NodeAttribute_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    NodeAttribute::enum_type enum_val = NodeAttribute::str_to_enum(mp->get_enumerated());
    if (!NodeAttribute::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @DSRC.NodeAttribute.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@DSRC.NodeAttribute");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* NodeAttribute_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(NodeAttribute::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void NodeAttribute_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.NodeAttribute");
}


const SegmentAttribute SegmentAttributeList::UNBOUND_ELEM;
SegmentAttributeList::SegmentAttributeList()
{
val_ptr = NULL;
}

SegmentAttributeList::SegmentAttributeList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

SegmentAttributeList::SegmentAttributeList(const SegmentAttributeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.SegmentAttributeList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

SegmentAttributeList::~SegmentAttributeList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void SegmentAttributeList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

SegmentAttributeList& SegmentAttributeList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

SegmentAttributeList& SegmentAttributeList::operator=(const SegmentAttributeList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.SegmentAttributeList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean SegmentAttributeList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.SegmentAttributeList.");
return val_ptr->n_elements == 0 ;
}

boolean SegmentAttributeList::operator==(const SegmentAttributeList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.SegmentAttributeList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.SegmentAttributeList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

SegmentAttribute& SegmentAttributeList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.SegmentAttributeList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (SegmentAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new SegmentAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new SegmentAttribute;
}
return *val_ptr->value_elements[index_value];
}

SegmentAttribute& SegmentAttributeList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.SegmentAttributeList.");
return (*this)[(int)index_value];
}

const SegmentAttribute& SegmentAttributeList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.SegmentAttributeList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.SegmentAttributeList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.SegmentAttributeList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const SegmentAttribute& SegmentAttributeList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.SegmentAttributeList.");
return (*this)[(int)index_value];
}

SegmentAttributeList SegmentAttributeList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

SegmentAttributeList SegmentAttributeList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

SegmentAttributeList SegmentAttributeList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

SegmentAttributeList SegmentAttributeList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.SegmentAttributeList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
SegmentAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new SegmentAttribute(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

SegmentAttributeList SegmentAttributeList::operator+(const SegmentAttributeList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.SegmentAttributeList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
SegmentAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new SegmentAttribute(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new SegmentAttribute(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

SegmentAttributeList SegmentAttributeList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.SegmentAttributeList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.SegmentAttributeList","element");
SegmentAttributeList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new SegmentAttribute(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

SegmentAttributeList SegmentAttributeList::replace(int index, int len, const SegmentAttributeList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.SegmentAttributeList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.SegmentAttributeList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.SegmentAttributeList","element");
SegmentAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new SegmentAttribute(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new SegmentAttribute(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new SegmentAttribute(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

SegmentAttributeList SegmentAttributeList::replace(int index, int len, const SegmentAttributeList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void SegmentAttributeList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.SegmentAttributeList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (SegmentAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new SegmentAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (SegmentAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.SegmentAttributeList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (SegmentAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean SegmentAttributeList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int SegmentAttributeList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.SegmentAttributeList.");
return val_ptr->n_elements;
}

int SegmentAttributeList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.SegmentAttributeList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void SegmentAttributeList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void SegmentAttributeList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.SegmentAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.SegmentAttributeList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.SegmentAttributeList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* SegmentAttributeList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.SegmentAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void SegmentAttributeList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void SegmentAttributeList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.SegmentAttributeList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void SegmentAttributeList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.SegmentAttributeList.");
val_ptr->value_elements = (SegmentAttribute**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new SegmentAttribute;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void SegmentAttributeList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SegmentAttributeList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* SegmentAttributeList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean SegmentAttributeList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (SegmentAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new SegmentAttribute;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int SegmentAttributeList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.SegmentAttributeList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int SegmentAttributeList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    SegmentAttribute* val = new SegmentAttribute;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (SegmentAttribute**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void SegmentAttributeList_template::copy_value(const SegmentAttributeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.SegmentAttributeList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (SegmentAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new SegmentAttribute_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new SegmentAttribute_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void SegmentAttributeList_template::copy_template(const SegmentAttributeList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (SegmentAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new SegmentAttribute_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new SegmentAttribute_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SegmentAttributeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.SegmentAttributeList.");
break;
}
set_selection(other_value);
}

boolean SegmentAttributeList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const SegmentAttributeList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const SegmentAttributeList*)value_ptr)[value_index], legacy);
else return ((const SegmentAttributeList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

SegmentAttributeList_template::SegmentAttributeList_template()
{
}

SegmentAttributeList_template::SegmentAttributeList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

SegmentAttributeList_template::SegmentAttributeList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

SegmentAttributeList_template::SegmentAttributeList_template(const SegmentAttributeList& other_value)
{
copy_value(other_value);
}

SegmentAttributeList_template::SegmentAttributeList_template(const OPTIONAL<SegmentAttributeList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SegmentAttributeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.SegmentAttributeList from an unbound optional field.");
}
}

SegmentAttributeList_template::SegmentAttributeList_template(const SegmentAttributeList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

SegmentAttributeList_template::~SegmentAttributeList_template()
{
clean_up();
}

void SegmentAttributeList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SegmentAttributeList_template& SegmentAttributeList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SegmentAttributeList_template& SegmentAttributeList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

SegmentAttributeList_template& SegmentAttributeList_template::operator=(const SegmentAttributeList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SegmentAttributeList_template& SegmentAttributeList_template::operator=(const OPTIONAL<SegmentAttributeList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SegmentAttributeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.SegmentAttributeList.");
}
return *this;
}

SegmentAttributeList_template& SegmentAttributeList_template::operator=(const SegmentAttributeList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

SegmentAttribute_template& SegmentAttributeList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.SegmentAttributeList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.SegmentAttributeList.");
    break;
}
return *single_value.value_elements[index_value];
}

SegmentAttribute_template& SegmentAttributeList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.SegmentAttributeList.");
return (*this)[(int)index_value];
}

const SegmentAttribute_template& SegmentAttributeList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.SegmentAttributeList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.SegmentAttributeList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.SegmentAttributeList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const SegmentAttribute_template& SegmentAttributeList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.SegmentAttributeList.");
return (*this)[(int)index_value];
}

void SegmentAttributeList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.SegmentAttributeList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (SegmentAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new SegmentAttribute_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new SegmentAttribute_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (SegmentAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int SegmentAttributeList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int SegmentAttributeList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.SegmentAttributeList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.SegmentAttributeList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.SegmentAttributeList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.SegmentAttributeList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.SegmentAttributeList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.SegmentAttributeList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.SegmentAttributeList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.SegmentAttributeList");
}

boolean SegmentAttributeList_template::match(const SegmentAttributeList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.SegmentAttributeList.");
}
return FALSE;
}

boolean SegmentAttributeList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

SegmentAttributeList SegmentAttributeList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.SegmentAttributeList.");
SegmentAttributeList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

SegmentAttributeList SegmentAttributeList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

SegmentAttributeList SegmentAttributeList_template::replace(int index, int len, const SegmentAttributeList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

SegmentAttributeList SegmentAttributeList_template::replace(int index, int len, const SegmentAttributeList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void SegmentAttributeList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new SegmentAttributeList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.SegmentAttributeList.");
}
set_selection(template_type);
}

SegmentAttributeList_template& SegmentAttributeList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.SegmentAttributeList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.SegmentAttributeList.");
return value_list.list_value[list_index];
}

void SegmentAttributeList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void SegmentAttributeList_template::log_match(const SegmentAttributeList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SegmentAttributeList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.SegmentAttributeList.");
}
}

void SegmentAttributeList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.SegmentAttributeList.");
single_value.value_elements = (SegmentAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new SegmentAttribute_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SegmentAttributeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.SegmentAttributeList.");
}
}

boolean SegmentAttributeList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SegmentAttributeList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SegmentAttributeList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.SegmentAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SegmentAttributeList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.SegmentAttributeList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* SegmentAttributeList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.SegmentAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void SegmentAttributeList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.SegmentAttributeList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.SegmentAttributeList");
}

SegmentAttribute::SegmentAttribute()
{
enum_value = UNBOUND_VALUE;
}

SegmentAttribute::SegmentAttribute(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @DSRC.SegmentAttribute with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SegmentAttribute::SegmentAttribute(enum_type other_value)
{
enum_value = other_value;
}

SegmentAttribute::SegmentAttribute(const SegmentAttribute& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @DSRC.SegmentAttribute.");
enum_value = other_value.enum_value;
}

SegmentAttribute& SegmentAttribute::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @DSRC.SegmentAttribute.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SegmentAttribute& SegmentAttribute::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SegmentAttribute& SegmentAttribute::operator=(const SegmentAttribute& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.SegmentAttribute.");
enum_value = other_value.enum_value;
return *this;
}

boolean SegmentAttribute::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SegmentAttribute.");
return enum_value == other_value;
}

boolean SegmentAttribute::operator==(const SegmentAttribute& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SegmentAttribute.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.SegmentAttribute.");
return enum_value == other_value.enum_value;
}

boolean SegmentAttribute::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SegmentAttribute.");
return enum_value < other_value;
}

boolean SegmentAttribute::operator<(const SegmentAttribute& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SegmentAttribute.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.SegmentAttribute.");
return enum_value < other_value.enum_value;
}

boolean SegmentAttribute::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SegmentAttribute.");
return enum_value > other_value;
}

boolean SegmentAttribute::operator>(const SegmentAttribute& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SegmentAttribute.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.SegmentAttribute.");
return enum_value > other_value.enum_value;
}

const char *SegmentAttribute::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case reserved: return "reserved";
case doNotBlock: return "doNotBlock";
case whiteLine: return "whiteLine";
case mergingLaneLeft: return "mergingLaneLeft";
case mergingLaneRight: return "mergingLaneRight";
case curbOnLeft: return "curbOnLeft";
case curbOnRight: return "curbOnRight";
case loadingzoneOnLeft: return "loadingzoneOnLeft";
case loadingzoneOnRight: return "loadingzoneOnRight";
case turnOutPointOnLeft: return "turnOutPointOnLeft";
case turnOutPointOnRight: return "turnOutPointOnRight";
case adjacentParkingOnLeft: return "adjacentParkingOnLeft";
case adjacentParkingOnRight: return "adjacentParkingOnRight";
case adjacentBikeLaneOnLeft: return "adjacentBikeLaneOnLeft";
case adjacentBikeLaneOnRight: return "adjacentBikeLaneOnRight";
case sharedBikeLane: return "sharedBikeLane";
case bikeBoxInFront: return "bikeBoxInFront";
case transitStopOnLeft: return "transitStopOnLeft";
case transitStopOnRight: return "transitStopOnRight";
case transitStopInLane: return "transitStopInLane";
case sharedWithTrackedVehicle: return "sharedWithTrackedVehicle";
case safeIsland: return "safeIsland";
case lowCurbsPresent: return "lowCurbsPresent";
case rumbleStripPresent: return "rumbleStripPresent";
case audibleSignalingPresent: return "audibleSignalingPresent";
case adaptiveTimingPresent: return "adaptiveTimingPresent";
case rfSignalRequestPresent: return "rfSignalRequestPresent";
case partialCurbIntrusion: return "partialCurbIntrusion";
case taperToLeft: return "taperToLeft";
case taperToRight: return "taperToRight";
case taperToCenterLine: return "taperToCenterLine";
case parallelParking: return "parallelParking";
case headInParking: return "headInParking";
case freeParking: return "freeParking";
case timeRestrictionsOnParking: return "timeRestrictionsOnParking";
case costToPark: return "costToPark";
case midBlockCurbPresent: return "midBlockCurbPresent";
case unEvenPavementPresent: return "unEvenPavementPresent";
default: return "<unknown>";
}
}

SegmentAttribute::enum_type SegmentAttribute::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "reserved")) return reserved;
else if (!strcmp(str_par, "doNotBlock")) return doNotBlock;
else if (!strcmp(str_par, "whiteLine")) return whiteLine;
else if (!strcmp(str_par, "mergingLaneLeft")) return mergingLaneLeft;
else if (!strcmp(str_par, "mergingLaneRight")) return mergingLaneRight;
else if (!strcmp(str_par, "curbOnLeft")) return curbOnLeft;
else if (!strcmp(str_par, "curbOnRight")) return curbOnRight;
else if (!strcmp(str_par, "loadingzoneOnLeft")) return loadingzoneOnLeft;
else if (!strcmp(str_par, "loadingzoneOnRight")) return loadingzoneOnRight;
else if (!strcmp(str_par, "turnOutPointOnLeft")) return turnOutPointOnLeft;
else if (!strcmp(str_par, "turnOutPointOnRight")) return turnOutPointOnRight;
else if (!strcmp(str_par, "adjacentParkingOnLeft")) return adjacentParkingOnLeft;
else if (!strcmp(str_par, "adjacentParkingOnRight")) return adjacentParkingOnRight;
else if (!strcmp(str_par, "adjacentBikeLaneOnLeft")) return adjacentBikeLaneOnLeft;
else if (!strcmp(str_par, "adjacentBikeLaneOnRight")) return adjacentBikeLaneOnRight;
else if (!strcmp(str_par, "sharedBikeLane")) return sharedBikeLane;
else if (!strcmp(str_par, "bikeBoxInFront")) return bikeBoxInFront;
else if (!strcmp(str_par, "transitStopOnLeft")) return transitStopOnLeft;
else if (!strcmp(str_par, "transitStopOnRight")) return transitStopOnRight;
else if (!strcmp(str_par, "transitStopInLane")) return transitStopInLane;
else if (!strcmp(str_par, "sharedWithTrackedVehicle")) return sharedWithTrackedVehicle;
else if (!strcmp(str_par, "safeIsland")) return safeIsland;
else if (!strcmp(str_par, "lowCurbsPresent")) return lowCurbsPresent;
else if (!strcmp(str_par, "rumbleStripPresent")) return rumbleStripPresent;
else if (!strcmp(str_par, "audibleSignalingPresent")) return audibleSignalingPresent;
else if (!strcmp(str_par, "adaptiveTimingPresent")) return adaptiveTimingPresent;
else if (!strcmp(str_par, "rfSignalRequestPresent")) return rfSignalRequestPresent;
else if (!strcmp(str_par, "partialCurbIntrusion")) return partialCurbIntrusion;
else if (!strcmp(str_par, "taperToLeft")) return taperToLeft;
else if (!strcmp(str_par, "taperToRight")) return taperToRight;
else if (!strcmp(str_par, "taperToCenterLine")) return taperToCenterLine;
else if (!strcmp(str_par, "parallelParking")) return parallelParking;
else if (!strcmp(str_par, "headInParking")) return headInParking;
else if (!strcmp(str_par, "freeParking")) return freeParking;
else if (!strcmp(str_par, "timeRestrictionsOnParking")) return timeRestrictionsOnParking;
else if (!strcmp(str_par, "costToPark")) return costToPark;
else if (!strcmp(str_par, "midBlockCurbPresent")) return midBlockCurbPresent;
else if (!strcmp(str_par, "unEvenPavementPresent")) return unEvenPavementPresent;
else return UNKNOWN_VALUE;
}

boolean SegmentAttribute::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
case 23:
case 24:
case 25:
case 26:
case 27:
case 28:
case 29:
case 30:
case 31:
case 32:
case 33:
case 34:
case 35:
case 36:
case 37:
return TRUE;
default:
return FALSE;
}
}

int SegmentAttribute::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.SegmentAttribute.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SegmentAttribute::enum2int(const SegmentAttribute& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.SegmentAttribute.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SegmentAttribute::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @DSRC.SegmentAttribute.", int_val);
enum_value = (enum_type)int_val;
}

SegmentAttribute::operator SegmentAttribute::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @DSRC.SegmentAttribute.");
return enum_value;
}

void SegmentAttribute::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SegmentAttribute::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@DSRC.SegmentAttribute");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @DSRC.SegmentAttribute.");
  }
}

Module_Param* SegmentAttribute::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void SegmentAttribute::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @DSRC.SegmentAttribute.");
text_buf.push_int(enum_value);
}

void SegmentAttribute::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @DSRC.SegmentAttribute.", enum_value);
}

void SegmentAttribute::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SegmentAttribute::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* SegmentAttribute::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean SegmentAttribute::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @DSRC.SegmentAttribute: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int SegmentAttribute::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @DSRC.SegmentAttribute.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int SegmentAttribute::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void SegmentAttribute_template::copy_template(const SegmentAttribute_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SegmentAttribute_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @DSRC.SegmentAttribute.");
}
}

SegmentAttribute_template::SegmentAttribute_template()
{
}

SegmentAttribute_template::SegmentAttribute_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SegmentAttribute_template::SegmentAttribute_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SegmentAttribute::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @DSRC.SegmentAttribute with unknown numeric value %d.", other_value);
single_value = (SegmentAttribute::enum_type)other_value;
}

SegmentAttribute_template::SegmentAttribute_template(SegmentAttribute::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SegmentAttribute_template::SegmentAttribute_template(const SegmentAttribute& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SegmentAttribute::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @DSRC.SegmentAttribute.");
single_value = other_value.enum_value;
}

SegmentAttribute_template::SegmentAttribute_template(const OPTIONAL<SegmentAttribute>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SegmentAttribute::enum_type)(const SegmentAttribute&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @DSRC.SegmentAttribute from an unbound optional field.");
}
}

SegmentAttribute_template::SegmentAttribute_template(const SegmentAttribute_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SegmentAttribute_template::~SegmentAttribute_template()
{
clean_up();
}

boolean SegmentAttribute_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SegmentAttribute_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SegmentAttribute::UNBOUND_VALUE;
}

void SegmentAttribute_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SegmentAttribute_template& SegmentAttribute_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SegmentAttribute_template& SegmentAttribute_template::operator=(int other_value)
{
if (!SegmentAttribute::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @DSRC.SegmentAttribute.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SegmentAttribute::enum_type)other_value;
return *this;
}

SegmentAttribute_template& SegmentAttribute_template::operator=(SegmentAttribute::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SegmentAttribute_template& SegmentAttribute_template::operator=(const SegmentAttribute& other_value)
{
if (other_value.enum_value == SegmentAttribute::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.SegmentAttribute to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SegmentAttribute_template& SegmentAttribute_template::operator=(const OPTIONAL<SegmentAttribute>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SegmentAttribute::enum_type)(const SegmentAttribute&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @DSRC.SegmentAttribute.");
}
return *this;
}

SegmentAttribute_template& SegmentAttribute_template::operator=(const SegmentAttribute_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SegmentAttribute_template::match(SegmentAttribute::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @DSRC.SegmentAttribute.");
}
return FALSE;
}

boolean SegmentAttribute_template::match(const SegmentAttribute& other_value, boolean) const
{
if (other_value.enum_value == SegmentAttribute::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @DSRC.SegmentAttribute with an unbound value.");
return match(other_value.enum_value);
}

SegmentAttribute::enum_type SegmentAttribute_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @DSRC.SegmentAttribute.");
return single_value;
}

void SegmentAttribute_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @DSRC.SegmentAttribute.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SegmentAttribute_template[list_length];
}

SegmentAttribute_template& SegmentAttribute_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @DSRC.SegmentAttribute.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @DSRC.SegmentAttribute.");
return value_list.list_value[list_index];
}

void SegmentAttribute_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SegmentAttribute::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SegmentAttribute_template::log_match(const SegmentAttribute& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SegmentAttribute_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @DSRC.SegmentAttribute.");
}
}

void SegmentAttribute_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SegmentAttribute::enum_type)text_buf.pull_int().get_val();
if (!SegmentAttribute::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @DSRC.SegmentAttribute.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SegmentAttribute_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @DSRC.SegmentAttribute.");
}
}

boolean SegmentAttribute_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SegmentAttribute_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SegmentAttribute_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    SegmentAttribute::enum_type enum_val = (enum_name != NULL) ? SegmentAttribute::str_to_enum(enum_name) : SegmentAttribute::UNKNOWN_VALUE;
    if (SegmentAttribute::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SegmentAttribute_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SegmentAttribute::enum_type enum_val = SegmentAttribute::str_to_enum(mp->get_enumerated());
    if (!SegmentAttribute::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @DSRC.SegmentAttribute.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@DSRC.SegmentAttribute");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SegmentAttribute_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(SegmentAttribute::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SegmentAttribute_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.SegmentAttribute");
}


const LaneDataAttribute LaneDataAttributeList::UNBOUND_ELEM;
LaneDataAttributeList::LaneDataAttributeList()
{
val_ptr = NULL;
}

LaneDataAttributeList::LaneDataAttributeList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

LaneDataAttributeList::LaneDataAttributeList(const LaneDataAttributeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.LaneDataAttributeList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

LaneDataAttributeList::~LaneDataAttributeList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void LaneDataAttributeList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

LaneDataAttributeList& LaneDataAttributeList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

LaneDataAttributeList& LaneDataAttributeList::operator=(const LaneDataAttributeList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.LaneDataAttributeList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean LaneDataAttributeList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.LaneDataAttributeList.");
return val_ptr->n_elements == 0 ;
}

boolean LaneDataAttributeList::operator==(const LaneDataAttributeList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.LaneDataAttributeList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.LaneDataAttributeList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

LaneDataAttribute& LaneDataAttributeList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.LaneDataAttributeList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (LaneDataAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new LaneDataAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new LaneDataAttribute;
}
return *val_ptr->value_elements[index_value];
}

LaneDataAttribute& LaneDataAttributeList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.LaneDataAttributeList.");
return (*this)[(int)index_value];
}

const LaneDataAttribute& LaneDataAttributeList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.LaneDataAttributeList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.LaneDataAttributeList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.LaneDataAttributeList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const LaneDataAttribute& LaneDataAttributeList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.LaneDataAttributeList.");
return (*this)[(int)index_value];
}

LaneDataAttributeList LaneDataAttributeList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

LaneDataAttributeList LaneDataAttributeList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

LaneDataAttributeList LaneDataAttributeList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

LaneDataAttributeList LaneDataAttributeList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.LaneDataAttributeList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
LaneDataAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new LaneDataAttribute(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

LaneDataAttributeList LaneDataAttributeList::operator+(const LaneDataAttributeList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.LaneDataAttributeList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
LaneDataAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new LaneDataAttribute(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new LaneDataAttribute(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

LaneDataAttributeList LaneDataAttributeList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.LaneDataAttributeList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.LaneDataAttributeList","element");
LaneDataAttributeList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new LaneDataAttribute(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

LaneDataAttributeList LaneDataAttributeList::replace(int index, int len, const LaneDataAttributeList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.LaneDataAttributeList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.LaneDataAttributeList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.LaneDataAttributeList","element");
LaneDataAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new LaneDataAttribute(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new LaneDataAttribute(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new LaneDataAttribute(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

LaneDataAttributeList LaneDataAttributeList::replace(int index, int len, const LaneDataAttributeList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void LaneDataAttributeList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.LaneDataAttributeList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (LaneDataAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new LaneDataAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (LaneDataAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.LaneDataAttributeList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (LaneDataAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean LaneDataAttributeList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int LaneDataAttributeList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.LaneDataAttributeList.");
return val_ptr->n_elements;
}

int LaneDataAttributeList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.LaneDataAttributeList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void LaneDataAttributeList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void LaneDataAttributeList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.LaneDataAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.LaneDataAttributeList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.LaneDataAttributeList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* LaneDataAttributeList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.LaneDataAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void LaneDataAttributeList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void LaneDataAttributeList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.LaneDataAttributeList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void LaneDataAttributeList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.LaneDataAttributeList.");
val_ptr->value_elements = (LaneDataAttribute**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new LaneDataAttribute;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void LaneDataAttributeList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LaneDataAttributeList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* LaneDataAttributeList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean LaneDataAttributeList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (LaneDataAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new LaneDataAttribute;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int LaneDataAttributeList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.LaneDataAttributeList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int LaneDataAttributeList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    LaneDataAttribute* val = new LaneDataAttribute;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (LaneDataAttribute**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void LaneDataAttributeList_template::copy_value(const LaneDataAttributeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.LaneDataAttributeList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (LaneDataAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new LaneDataAttribute_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new LaneDataAttribute_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void LaneDataAttributeList_template::copy_template(const LaneDataAttributeList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (LaneDataAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new LaneDataAttribute_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new LaneDataAttribute_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LaneDataAttributeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.LaneDataAttributeList.");
break;
}
set_selection(other_value);
}

boolean LaneDataAttributeList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const LaneDataAttributeList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const LaneDataAttributeList*)value_ptr)[value_index], legacy);
else return ((const LaneDataAttributeList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

LaneDataAttributeList_template::LaneDataAttributeList_template()
{
}

LaneDataAttributeList_template::LaneDataAttributeList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

LaneDataAttributeList_template::LaneDataAttributeList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

LaneDataAttributeList_template::LaneDataAttributeList_template(const LaneDataAttributeList& other_value)
{
copy_value(other_value);
}

LaneDataAttributeList_template::LaneDataAttributeList_template(const OPTIONAL<LaneDataAttributeList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneDataAttributeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.LaneDataAttributeList from an unbound optional field.");
}
}

LaneDataAttributeList_template::LaneDataAttributeList_template(const LaneDataAttributeList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

LaneDataAttributeList_template::~LaneDataAttributeList_template()
{
clean_up();
}

void LaneDataAttributeList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LaneDataAttributeList_template& LaneDataAttributeList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LaneDataAttributeList_template& LaneDataAttributeList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

LaneDataAttributeList_template& LaneDataAttributeList_template::operator=(const LaneDataAttributeList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LaneDataAttributeList_template& LaneDataAttributeList_template::operator=(const OPTIONAL<LaneDataAttributeList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneDataAttributeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.LaneDataAttributeList.");
}
return *this;
}

LaneDataAttributeList_template& LaneDataAttributeList_template::operator=(const LaneDataAttributeList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

LaneDataAttribute_template& LaneDataAttributeList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.LaneDataAttributeList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.LaneDataAttributeList.");
    break;
}
return *single_value.value_elements[index_value];
}

LaneDataAttribute_template& LaneDataAttributeList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.LaneDataAttributeList.");
return (*this)[(int)index_value];
}

const LaneDataAttribute_template& LaneDataAttributeList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.LaneDataAttributeList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.LaneDataAttributeList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.LaneDataAttributeList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const LaneDataAttribute_template& LaneDataAttributeList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.LaneDataAttributeList.");
return (*this)[(int)index_value];
}

void LaneDataAttributeList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.LaneDataAttributeList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (LaneDataAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new LaneDataAttribute_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new LaneDataAttribute_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (LaneDataAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int LaneDataAttributeList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int LaneDataAttributeList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneDataAttributeList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneDataAttributeList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneDataAttributeList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneDataAttributeList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneDataAttributeList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.LaneDataAttributeList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.LaneDataAttributeList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.LaneDataAttributeList");
}

boolean LaneDataAttributeList_template::match(const LaneDataAttributeList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.LaneDataAttributeList.");
}
return FALSE;
}

boolean LaneDataAttributeList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

LaneDataAttributeList LaneDataAttributeList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.LaneDataAttributeList.");
LaneDataAttributeList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

LaneDataAttributeList LaneDataAttributeList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

LaneDataAttributeList LaneDataAttributeList_template::replace(int index, int len, const LaneDataAttributeList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

LaneDataAttributeList LaneDataAttributeList_template::replace(int index, int len, const LaneDataAttributeList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void LaneDataAttributeList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new LaneDataAttributeList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.LaneDataAttributeList.");
}
set_selection(template_type);
}

LaneDataAttributeList_template& LaneDataAttributeList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.LaneDataAttributeList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.LaneDataAttributeList.");
return value_list.list_value[list_index];
}

void LaneDataAttributeList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void LaneDataAttributeList_template::log_match(const LaneDataAttributeList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LaneDataAttributeList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.LaneDataAttributeList.");
}
}

void LaneDataAttributeList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.LaneDataAttributeList.");
single_value.value_elements = (LaneDataAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new LaneDataAttribute_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LaneDataAttributeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.LaneDataAttributeList.");
}
}

boolean LaneDataAttributeList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LaneDataAttributeList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void LaneDataAttributeList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.LaneDataAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LaneDataAttributeList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.LaneDataAttributeList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* LaneDataAttributeList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.LaneDataAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void LaneDataAttributeList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneDataAttributeList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.LaneDataAttributeList");
}

void LaneDataAttribute::copy_value(const LaneDataAttribute& other_value)
{
switch (other_value.union_selection) {
case ALT_pathEndPointAngle:
field_pathEndPointAngle = new INTEGER(*other_value.field_pathEndPointAngle);
break;
case ALT_laneCrownPointCenter:
field_laneCrownPointCenter = new INTEGER(*other_value.field_laneCrownPointCenter);
break;
case ALT_laneCrownPointLeft:
field_laneCrownPointLeft = new INTEGER(*other_value.field_laneCrownPointLeft);
break;
case ALT_laneCrownPointRight:
field_laneCrownPointRight = new INTEGER(*other_value.field_laneCrownPointRight);
break;
case ALT_laneAngle:
field_laneAngle = new INTEGER(*other_value.field_laneAngle);
break;
case ALT_speedLimits:
field_speedLimits = new SpeedLimitList(*other_value.field_speedLimits);
break;
case ALT_regional:
field_regional = new REGION::Reg__LaneDataAttribute(*other_value.field_regional);
break;
default:
TTCN_error("Assignment of an unbound union value of type @DSRC.LaneDataAttribute.");
}
union_selection = other_value.union_selection;
}

LaneDataAttribute::LaneDataAttribute()
{
union_selection = UNBOUND_VALUE;
}

LaneDataAttribute::LaneDataAttribute(const LaneDataAttribute& other_value)
: Base_Type(){
copy_value(other_value);
}

LaneDataAttribute::~LaneDataAttribute()
{
clean_up();
}

LaneDataAttribute& LaneDataAttribute::operator=(const LaneDataAttribute& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean LaneDataAttribute::operator==(const LaneDataAttribute& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @DSRC.LaneDataAttribute.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @DSRC.LaneDataAttribute.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_pathEndPointAngle:
return *field_pathEndPointAngle == *other_value.field_pathEndPointAngle;
case ALT_laneCrownPointCenter:
return *field_laneCrownPointCenter == *other_value.field_laneCrownPointCenter;
case ALT_laneCrownPointLeft:
return *field_laneCrownPointLeft == *other_value.field_laneCrownPointLeft;
case ALT_laneCrownPointRight:
return *field_laneCrownPointRight == *other_value.field_laneCrownPointRight;
case ALT_laneAngle:
return *field_laneAngle == *other_value.field_laneAngle;
case ALT_speedLimits:
return *field_speedLimits == *other_value.field_speedLimits;
case ALT_regional:
return *field_regional == *other_value.field_regional;
default:
return FALSE;
}
}

INTEGER& LaneDataAttribute::pathEndPointAngle()
{
if (union_selection != ALT_pathEndPointAngle) {
clean_up();
field_pathEndPointAngle = new INTEGER;
union_selection = ALT_pathEndPointAngle;
}
return *field_pathEndPointAngle;
}

const INTEGER& LaneDataAttribute::pathEndPointAngle() const
{
if (union_selection != ALT_pathEndPointAngle) TTCN_error("Using non-selected field pathEndPointAngle in a value of union type @DSRC.LaneDataAttribute.");
return *field_pathEndPointAngle;
}

INTEGER& LaneDataAttribute::laneCrownPointCenter()
{
if (union_selection != ALT_laneCrownPointCenter) {
clean_up();
field_laneCrownPointCenter = new INTEGER;
union_selection = ALT_laneCrownPointCenter;
}
return *field_laneCrownPointCenter;
}

const INTEGER& LaneDataAttribute::laneCrownPointCenter() const
{
if (union_selection != ALT_laneCrownPointCenter) TTCN_error("Using non-selected field laneCrownPointCenter in a value of union type @DSRC.LaneDataAttribute.");
return *field_laneCrownPointCenter;
}

INTEGER& LaneDataAttribute::laneCrownPointLeft()
{
if (union_selection != ALT_laneCrownPointLeft) {
clean_up();
field_laneCrownPointLeft = new INTEGER;
union_selection = ALT_laneCrownPointLeft;
}
return *field_laneCrownPointLeft;
}

const INTEGER& LaneDataAttribute::laneCrownPointLeft() const
{
if (union_selection != ALT_laneCrownPointLeft) TTCN_error("Using non-selected field laneCrownPointLeft in a value of union type @DSRC.LaneDataAttribute.");
return *field_laneCrownPointLeft;
}

INTEGER& LaneDataAttribute::laneCrownPointRight()
{
if (union_selection != ALT_laneCrownPointRight) {
clean_up();
field_laneCrownPointRight = new INTEGER;
union_selection = ALT_laneCrownPointRight;
}
return *field_laneCrownPointRight;
}

const INTEGER& LaneDataAttribute::laneCrownPointRight() const
{
if (union_selection != ALT_laneCrownPointRight) TTCN_error("Using non-selected field laneCrownPointRight in a value of union type @DSRC.LaneDataAttribute.");
return *field_laneCrownPointRight;
}

INTEGER& LaneDataAttribute::laneAngle()
{
if (union_selection != ALT_laneAngle) {
clean_up();
field_laneAngle = new INTEGER;
union_selection = ALT_laneAngle;
}
return *field_laneAngle;
}

const INTEGER& LaneDataAttribute::laneAngle() const
{
if (union_selection != ALT_laneAngle) TTCN_error("Using non-selected field laneAngle in a value of union type @DSRC.LaneDataAttribute.");
return *field_laneAngle;
}

SpeedLimitList& LaneDataAttribute::speedLimits()
{
if (union_selection != ALT_speedLimits) {
clean_up();
field_speedLimits = new SpeedLimitList;
union_selection = ALT_speedLimits;
}
return *field_speedLimits;
}

const SpeedLimitList& LaneDataAttribute::speedLimits() const
{
if (union_selection != ALT_speedLimits) TTCN_error("Using non-selected field speedLimits in a value of union type @DSRC.LaneDataAttribute.");
return *field_speedLimits;
}

REGION::Reg__LaneDataAttribute& LaneDataAttribute::regional()
{
if (union_selection != ALT_regional) {
clean_up();
field_regional = new REGION::Reg__LaneDataAttribute;
union_selection = ALT_regional;
}
return *field_regional;
}

const REGION::Reg__LaneDataAttribute& LaneDataAttribute::regional() const
{
if (union_selection != ALT_regional) TTCN_error("Using non-selected field regional in a value of union type @DSRC.LaneDataAttribute.");
return *field_regional;
}

boolean LaneDataAttribute::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.LaneDataAttribute.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @DSRC.LaneDataAttribute.");
return union_selection == checked_selection;
}

boolean LaneDataAttribute::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean LaneDataAttribute::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_pathEndPointAngle: return field_pathEndPointAngle->is_value();
case ALT_laneCrownPointCenter: return field_laneCrownPointCenter->is_value();
case ALT_laneCrownPointLeft: return field_laneCrownPointLeft->is_value();
case ALT_laneCrownPointRight: return field_laneCrownPointRight->is_value();
case ALT_laneAngle: return field_laneAngle->is_value();
case ALT_speedLimits: return field_speedLimits->is_value();
case ALT_regional: return field_regional->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void LaneDataAttribute::clean_up()
{
switch (union_selection) {
case ALT_pathEndPointAngle:
  delete field_pathEndPointAngle;
  break;
case ALT_laneCrownPointCenter:
  delete field_laneCrownPointCenter;
  break;
case ALT_laneCrownPointLeft:
  delete field_laneCrownPointLeft;
  break;
case ALT_laneCrownPointRight:
  delete field_laneCrownPointRight;
  break;
case ALT_laneAngle:
  delete field_laneAngle;
  break;
case ALT_speedLimits:
  delete field_speedLimits;
  break;
case ALT_regional:
  delete field_regional;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void LaneDataAttribute::log() const
{
switch (union_selection) {
case ALT_pathEndPointAngle:
TTCN_Logger::log_event_str("{ pathEndPointAngle := ");
field_pathEndPointAngle->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_laneCrownPointCenter:
TTCN_Logger::log_event_str("{ laneCrownPointCenter := ");
field_laneCrownPointCenter->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_laneCrownPointLeft:
TTCN_Logger::log_event_str("{ laneCrownPointLeft := ");
field_laneCrownPointLeft->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_laneCrownPointRight:
TTCN_Logger::log_event_str("{ laneCrownPointRight := ");
field_laneCrownPointRight->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_laneAngle:
TTCN_Logger::log_event_str("{ laneAngle := ");
field_laneAngle->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_speedLimits:
TTCN_Logger::log_event_str("{ speedLimits := ");
field_speedLimits->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_regional:
TTCN_Logger::log_event_str("{ regional := ");
field_regional->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void LaneDataAttribute::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@DSRC.LaneDataAttribute'");
    }
    if (strcmp("pathEndPointAngle", param_field) == 0) {
      pathEndPointAngle().set_param(param);
      return;
    } else if (strcmp("laneCrownPointCenter", param_field) == 0) {
      laneCrownPointCenter().set_param(param);
      return;
    } else if (strcmp("laneCrownPointLeft", param_field) == 0) {
      laneCrownPointLeft().set_param(param);
      return;
    } else if (strcmp("laneCrownPointRight", param_field) == 0) {
      laneCrownPointRight().set_param(param);
      return;
    } else if (strcmp("laneAngle", param_field) == 0) {
      laneAngle().set_param(param);
      return;
    } else if (strcmp("speedLimits", param_field) == 0) {
      speedLimits().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@DSRC.LaneDataAttribute'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "pathEndPointAngle")) {
    pathEndPointAngle().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "laneCrownPointCenter")) {
    laneCrownPointCenter().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "laneCrownPointLeft")) {
    laneCrownPointLeft().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "laneCrownPointRight")) {
    laneCrownPointRight().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "laneAngle")) {
    laneAngle().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "speedLimits")) {
    speedLimits().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "regional")) {
    regional().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @DSRC.LaneDataAttribute.", mp_last->get_id()->get_name());
}

Module_Param* LaneDataAttribute::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@DSRC.LaneDataAttribute'");
    }
    if (strcmp("pathEndPointAngle", param_field) == 0) {
      return pathEndPointAngle().get_param(param_name);
    } else if (strcmp("laneCrownPointCenter", param_field) == 0) {
      return laneCrownPointCenter().get_param(param_name);
    } else if (strcmp("laneCrownPointLeft", param_field) == 0) {
      return laneCrownPointLeft().get_param(param_name);
    } else if (strcmp("laneCrownPointRight", param_field) == 0) {
      return laneCrownPointRight().get_param(param_name);
    } else if (strcmp("laneAngle", param_field) == 0) {
      return laneAngle().get_param(param_name);
    } else if (strcmp("speedLimits", param_field) == 0) {
      return speedLimits().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `LaneDataAttribute'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_pathEndPointAngle:
    mp_field = field_pathEndPointAngle->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("pathEndPointAngle")));
    break;
  case ALT_laneCrownPointCenter:
    mp_field = field_laneCrownPointCenter->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("laneCrownPointCenter")));
    break;
  case ALT_laneCrownPointLeft:
    mp_field = field_laneCrownPointLeft->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("laneCrownPointLeft")));
    break;
  case ALT_laneCrownPointRight:
    mp_field = field_laneCrownPointRight->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("laneCrownPointRight")));
    break;
  case ALT_laneAngle:
    mp_field = field_laneAngle->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("laneAngle")));
    break;
  case ALT_speedLimits:
    mp_field = field_speedLimits->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("speedLimits")));
    break;
  case ALT_regional:
    mp_field = field_regional->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("regional")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void LaneDataAttribute::set_implicit_omit()
{
switch (union_selection) {
case ALT_pathEndPointAngle:
field_pathEndPointAngle->set_implicit_omit(); break;
case ALT_laneCrownPointCenter:
field_laneCrownPointCenter->set_implicit_omit(); break;
case ALT_laneCrownPointLeft:
field_laneCrownPointLeft->set_implicit_omit(); break;
case ALT_laneCrownPointRight:
field_laneCrownPointRight->set_implicit_omit(); break;
case ALT_laneAngle:
field_laneAngle->set_implicit_omit(); break;
case ALT_speedLimits:
field_speedLimits->set_implicit_omit(); break;
case ALT_regional:
field_regional->set_implicit_omit(); break;
default: break;
}
}

void LaneDataAttribute::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_pathEndPointAngle:
field_pathEndPointAngle->encode_text(text_buf);
break;
case ALT_laneCrownPointCenter:
field_laneCrownPointCenter->encode_text(text_buf);
break;
case ALT_laneCrownPointLeft:
field_laneCrownPointLeft->encode_text(text_buf);
break;
case ALT_laneCrownPointRight:
field_laneCrownPointRight->encode_text(text_buf);
break;
case ALT_laneAngle:
field_laneAngle->encode_text(text_buf);
break;
case ALT_speedLimits:
field_speedLimits->encode_text(text_buf);
break;
case ALT_regional:
field_regional->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @DSRC.LaneDataAttribute.");
}
}

void LaneDataAttribute::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_pathEndPointAngle:
pathEndPointAngle().decode_text(text_buf);
break;
case ALT_laneCrownPointCenter:
laneCrownPointCenter().decode_text(text_buf);
break;
case ALT_laneCrownPointLeft:
laneCrownPointLeft().decode_text(text_buf);
break;
case ALT_laneCrownPointRight:
laneCrownPointRight().decode_text(text_buf);
break;
case ALT_laneAngle:
laneAngle().decode_text(text_buf);
break;
case ALT_speedLimits:
speedLimits().decode_text(text_buf);
break;
case ALT_regional:
regional().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @DSRC.LaneDataAttribute.");
}
}

void LaneDataAttribute::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LaneDataAttribute::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t *LaneDataAttribute::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv;
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  switch (union_selection) {
  case ALT_pathEndPointAngle:
    ec_1.set_msg("pathEndPointAngle': ");
    new_tlv = field_pathEndPointAngle->BER_encode_TLV(LaneDataAttribute_pathEndPointAngle_descr_, p_coding);
    break;
  case ALT_laneCrownPointCenter:
    ec_1.set_msg("laneCrownPointCenter': ");
    new_tlv = field_laneCrownPointCenter->BER_encode_TLV(LaneDataAttribute_laneCrownPointCenter_descr_, p_coding);
    break;
  case ALT_laneCrownPointLeft:
    ec_1.set_msg("laneCrownPointLeft': ");
    new_tlv = field_laneCrownPointLeft->BER_encode_TLV(LaneDataAttribute_laneCrownPointLeft_descr_, p_coding);
    break;
  case ALT_laneCrownPointRight:
    ec_1.set_msg("laneCrownPointRight': ");
    new_tlv = field_laneCrownPointRight->BER_encode_TLV(LaneDataAttribute_laneCrownPointRight_descr_, p_coding);
    break;
  case ALT_laneAngle:
    ec_1.set_msg("laneAngle': ");
    new_tlv = field_laneAngle->BER_encode_TLV(LaneDataAttribute_laneAngle_descr_, p_coding);
    break;
  case ALT_speedLimits:
    ec_1.set_msg("speedLimits': ");
    new_tlv = field_speedLimits->BER_encode_TLV(LaneDataAttribute_speedLimits_descr_, p_coding);
    break;
  case ALT_regional:
    ec_1.set_msg("regional': ");
    new_tlv = field_regional->BER_encode_TLV(LaneDataAttribute_regional_descr_, p_coding);
    break;
  case UNBOUND_VALUE:
    new_tlv = BER_encode_chk_bound(FALSE);
    break;
  default:
    TTCN_EncDec_ErrorContext::error_internal("Unknown selection.");
    new_tlv = NULL;
  }
  return ASN_BER_V2TLV(new_tlv, p_td, p_coding);
}

boolean LaneDataAttribute::BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv)
{
  clean_up();
  field_pathEndPointAngle = new INTEGER;
  union_selection = ALT_pathEndPointAngle;
  if (field_pathEndPointAngle->BER_decode_isMyMsg(LaneDataAttribute_pathEndPointAngle_descr_, p_tlv)) return TRUE;
  delete field_pathEndPointAngle;
  field_laneCrownPointCenter = new INTEGER;
  union_selection = ALT_laneCrownPointCenter;
  if (field_laneCrownPointCenter->BER_decode_isMyMsg(LaneDataAttribute_laneCrownPointCenter_descr_, p_tlv)) return TRUE;
  delete field_laneCrownPointCenter;
  field_laneCrownPointLeft = new INTEGER;
  union_selection = ALT_laneCrownPointLeft;
  if (field_laneCrownPointLeft->BER_decode_isMyMsg(LaneDataAttribute_laneCrownPointLeft_descr_, p_tlv)) return TRUE;
  delete field_laneCrownPointLeft;
  field_laneCrownPointRight = new INTEGER;
  union_selection = ALT_laneCrownPointRight;
  if (field_laneCrownPointRight->BER_decode_isMyMsg(LaneDataAttribute_laneCrownPointRight_descr_, p_tlv)) return TRUE;
  delete field_laneCrownPointRight;
  field_laneAngle = new INTEGER;
  union_selection = ALT_laneAngle;
  if (field_laneAngle->BER_decode_isMyMsg(LaneDataAttribute_laneAngle_descr_, p_tlv)) return TRUE;
  delete field_laneAngle;
  field_speedLimits = new SpeedLimitList;
  union_selection = ALT_speedLimits;
  if (field_speedLimits->BER_decode_isMyMsg(LaneDataAttribute_speedLimits_descr_, p_tlv)) return TRUE;
  delete field_speedLimits;
  field_regional = new REGION::Reg__LaneDataAttribute;
  union_selection = ALT_regional;
  if (field_regional->BER_decode_isMyMsg(LaneDataAttribute_regional_descr_, p_tlv)) return TRUE;
  delete field_regional;
  union_selection = UNBOUND_VALUE;
  return FALSE;
}

boolean LaneDataAttribute::BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv)
{
  if (p_td.ber->n_tags == 0) {
    LaneDataAttribute tmp_type;
    return tmp_type.BER_decode_set_selection(p_tlv);
  } else return Base_Type::BER_decode_isMyMsg(p_td, p_tlv);
}

boolean LaneDataAttribute::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.LaneDataAttribute' type: ");
  ASN_BER_TLV_t tmp_tlv;
  if (!BER_decode_TLV_CHOICE(*p_td.ber, stripped_tlv, L_form, tmp_tlv) || !BER_decode_CHOICE_selection(BER_decode_set_selection(tmp_tlv), tmp_tlv)) return FALSE;
  TTCN_EncDec_ErrorContext ec_1("Alternative '");
  TTCN_EncDec_ErrorContext ec_2;
  switch (union_selection) {
  case ALT_pathEndPointAngle:
    ec_2.set_msg("pathEndPointAngle': ");
    field_pathEndPointAngle->BER_decode_TLV(LaneDataAttribute_pathEndPointAngle_descr_, tmp_tlv, L_form);
    break;
  case ALT_laneCrownPointCenter:
    ec_2.set_msg("laneCrownPointCenter': ");
    field_laneCrownPointCenter->BER_decode_TLV(LaneDataAttribute_laneCrownPointCenter_descr_, tmp_tlv, L_form);
    break;
  case ALT_laneCrownPointLeft:
    ec_2.set_msg("laneCrownPointLeft': ");
    field_laneCrownPointLeft->BER_decode_TLV(LaneDataAttribute_laneCrownPointLeft_descr_, tmp_tlv, L_form);
    break;
  case ALT_laneCrownPointRight:
    ec_2.set_msg("laneCrownPointRight': ");
    field_laneCrownPointRight->BER_decode_TLV(LaneDataAttribute_laneCrownPointRight_descr_, tmp_tlv, L_form);
    break;
  case ALT_laneAngle:
    ec_2.set_msg("laneAngle': ");
    field_laneAngle->BER_decode_TLV(LaneDataAttribute_laneAngle_descr_, tmp_tlv, L_form);
    break;
  case ALT_speedLimits:
    ec_2.set_msg("speedLimits': ");
    field_speedLimits->BER_decode_TLV(LaneDataAttribute_speedLimits_descr_, tmp_tlv, L_form);
    break;
  case ALT_regional:
    ec_2.set_msg("regional': ");
    field_regional->BER_decode_TLV(LaneDataAttribute_regional_descr_, tmp_tlv, L_form);
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

int LaneDataAttribute::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_pathEndPointAngle:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "pathEndPointAngle");
    enc_len += field_pathEndPointAngle->JSON_encode(LaneDataAttribute_pathEndPointAngle_descr_, p_tok);
    break;
  case ALT_laneCrownPointCenter:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneCrownPointCenter");
    enc_len += field_laneCrownPointCenter->JSON_encode(LaneDataAttribute_laneCrownPointCenter_descr_, p_tok);
    break;
  case ALT_laneCrownPointLeft:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneCrownPointLeft");
    enc_len += field_laneCrownPointLeft->JSON_encode(LaneDataAttribute_laneCrownPointLeft_descr_, p_tok);
    break;
  case ALT_laneCrownPointRight:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneCrownPointRight");
    enc_len += field_laneCrownPointRight->JSON_encode(LaneDataAttribute_laneCrownPointRight_descr_, p_tok);
    break;
  case ALT_laneAngle:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneAngle");
    enc_len += field_laneAngle->JSON_encode(LaneDataAttribute_laneAngle_descr_, p_tok);
    break;
  case ALT_speedLimits:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speedLimits");
    enc_len += field_speedLimits->JSON_encode(LaneDataAttribute_speedLimits_descr_, p_tok);
    break;
  case ALT_regional:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional->JSON_encode(LaneDataAttribute_regional_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @DSRC.LaneDataAttribute.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LaneDataAttribute::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "pathEndPointAngle", name_len)) {
      int ret_val = pathEndPointAngle().JSON_decode(LaneDataAttribute_pathEndPointAngle_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "pathEndPointAngle");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "laneCrownPointCenter", name_len)) {
      int ret_val = laneCrownPointCenter().JSON_decode(LaneDataAttribute_laneCrownPointCenter_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneCrownPointCenter");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "laneCrownPointLeft", name_len)) {
      int ret_val = laneCrownPointLeft().JSON_decode(LaneDataAttribute_laneCrownPointLeft_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneCrownPointLeft");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "laneCrownPointRight", name_len)) {
      int ret_val = laneCrownPointRight().JSON_decode(LaneDataAttribute_laneCrownPointRight_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneCrownPointRight");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "laneAngle", name_len)) {
      int ret_val = laneAngle().JSON_decode(LaneDataAttribute_laneAngle_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneAngle");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "speedLimits", name_len)) {
      int ret_val = speedLimits().JSON_decode(LaneDataAttribute_speedLimits_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speedLimits");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "regional", name_len)) {
      int ret_val = regional().JSON_decode(LaneDataAttribute_regional_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void LaneDataAttribute_template::copy_value(const LaneDataAttribute& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
single_value.field_pathEndPointAngle = new INTEGER_template(other_value.pathEndPointAngle());
break;
case LaneDataAttribute::ALT_laneCrownPointCenter:
single_value.field_laneCrownPointCenter = new INTEGER_template(other_value.laneCrownPointCenter());
break;
case LaneDataAttribute::ALT_laneCrownPointLeft:
single_value.field_laneCrownPointLeft = new INTEGER_template(other_value.laneCrownPointLeft());
break;
case LaneDataAttribute::ALT_laneCrownPointRight:
single_value.field_laneCrownPointRight = new INTEGER_template(other_value.laneCrownPointRight());
break;
case LaneDataAttribute::ALT_laneAngle:
single_value.field_laneAngle = new INTEGER_template(other_value.laneAngle());
break;
case LaneDataAttribute::ALT_speedLimits:
single_value.field_speedLimits = new SpeedLimitList_template(other_value.speedLimits());
break;
case LaneDataAttribute::ALT_regional:
single_value.field_regional = new REGION::Reg__LaneDataAttribute_template(other_value.regional());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @DSRC.LaneDataAttribute.");
}
set_selection(SPECIFIC_VALUE);
}

void LaneDataAttribute_template::copy_template(const LaneDataAttribute_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
single_value.field_pathEndPointAngle = new INTEGER_template(*other_value.single_value.field_pathEndPointAngle);
break;
case LaneDataAttribute::ALT_laneCrownPointCenter:
single_value.field_laneCrownPointCenter = new INTEGER_template(*other_value.single_value.field_laneCrownPointCenter);
break;
case LaneDataAttribute::ALT_laneCrownPointLeft:
single_value.field_laneCrownPointLeft = new INTEGER_template(*other_value.single_value.field_laneCrownPointLeft);
break;
case LaneDataAttribute::ALT_laneCrownPointRight:
single_value.field_laneCrownPointRight = new INTEGER_template(*other_value.single_value.field_laneCrownPointRight);
break;
case LaneDataAttribute::ALT_laneAngle:
single_value.field_laneAngle = new INTEGER_template(*other_value.single_value.field_laneAngle);
break;
case LaneDataAttribute::ALT_speedLimits:
single_value.field_speedLimits = new SpeedLimitList_template(*other_value.single_value.field_speedLimits);
break;
case LaneDataAttribute::ALT_regional:
single_value.field_regional = new REGION::Reg__LaneDataAttribute_template(*other_value.single_value.field_regional);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @DSRC.LaneDataAttribute.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LaneDataAttribute_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @DSRC.LaneDataAttribute.");
}
set_selection(other_value);
}

LaneDataAttribute_template::LaneDataAttribute_template()
{
}

LaneDataAttribute_template::LaneDataAttribute_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LaneDataAttribute_template::LaneDataAttribute_template(const LaneDataAttribute& other_value)
{
copy_value(other_value);
}

LaneDataAttribute_template::LaneDataAttribute_template(const OPTIONAL<LaneDataAttribute>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneDataAttribute&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @DSRC.LaneDataAttribute from an unbound optional field.");
}
}

LaneDataAttribute_template::LaneDataAttribute_template(const LaneDataAttribute_template& other_value)
: Base_Template(){
copy_template(other_value);
}

LaneDataAttribute_template::~LaneDataAttribute_template()
{
clean_up();
}

void LaneDataAttribute_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
delete single_value.field_pathEndPointAngle;
break;
case LaneDataAttribute::ALT_laneCrownPointCenter:
delete single_value.field_laneCrownPointCenter;
break;
case LaneDataAttribute::ALT_laneCrownPointLeft:
delete single_value.field_laneCrownPointLeft;
break;
case LaneDataAttribute::ALT_laneCrownPointRight:
delete single_value.field_laneCrownPointRight;
break;
case LaneDataAttribute::ALT_laneAngle:
delete single_value.field_laneAngle;
break;
case LaneDataAttribute::ALT_speedLimits:
delete single_value.field_speedLimits;
break;
case LaneDataAttribute::ALT_regional:
delete single_value.field_regional;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LaneDataAttribute_template& LaneDataAttribute_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LaneDataAttribute_template& LaneDataAttribute_template::operator=(const LaneDataAttribute& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LaneDataAttribute_template& LaneDataAttribute_template::operator=(const OPTIONAL<LaneDataAttribute>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LaneDataAttribute&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @DSRC.LaneDataAttribute.");
}
return *this;
}

LaneDataAttribute_template& LaneDataAttribute_template::operator=(const LaneDataAttribute_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LaneDataAttribute_template::match(const LaneDataAttribute& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
LaneDataAttribute::union_selection_type value_selection = other_value.get_selection();
if (value_selection == LaneDataAttribute::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
return single_value.field_pathEndPointAngle->match(other_value.pathEndPointAngle(), legacy);
case LaneDataAttribute::ALT_laneCrownPointCenter:
return single_value.field_laneCrownPointCenter->match(other_value.laneCrownPointCenter(), legacy);
case LaneDataAttribute::ALT_laneCrownPointLeft:
return single_value.field_laneCrownPointLeft->match(other_value.laneCrownPointLeft(), legacy);
case LaneDataAttribute::ALT_laneCrownPointRight:
return single_value.field_laneCrownPointRight->match(other_value.laneCrownPointRight(), legacy);
case LaneDataAttribute::ALT_laneAngle:
return single_value.field_laneAngle->match(other_value.laneAngle(), legacy);
case LaneDataAttribute::ALT_speedLimits:
return single_value.field_speedLimits->match(other_value.speedLimits(), legacy);
case LaneDataAttribute::ALT_regional:
return single_value.field_regional->match(other_value.regional(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @DSRC.LaneDataAttribute.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @DSRC.LaneDataAttribute.");
}
return FALSE;
}

boolean LaneDataAttribute_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
return single_value.field_pathEndPointAngle->is_value();
case LaneDataAttribute::ALT_laneCrownPointCenter:
return single_value.field_laneCrownPointCenter->is_value();
case LaneDataAttribute::ALT_laneCrownPointLeft:
return single_value.field_laneCrownPointLeft->is_value();
case LaneDataAttribute::ALT_laneCrownPointRight:
return single_value.field_laneCrownPointRight->is_value();
case LaneDataAttribute::ALT_laneAngle:
return single_value.field_laneAngle->is_value();
case LaneDataAttribute::ALT_speedLimits:
return single_value.field_speedLimits->is_value();
case LaneDataAttribute::ALT_regional:
return single_value.field_regional->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @DSRC.LaneDataAttribute.");
}
}

LaneDataAttribute LaneDataAttribute_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @DSRC.LaneDataAttribute.");
LaneDataAttribute ret_val;
switch (single_value.union_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
ret_val.pathEndPointAngle() = single_value.field_pathEndPointAngle->valueof();
break;
case LaneDataAttribute::ALT_laneCrownPointCenter:
ret_val.laneCrownPointCenter() = single_value.field_laneCrownPointCenter->valueof();
break;
case LaneDataAttribute::ALT_laneCrownPointLeft:
ret_val.laneCrownPointLeft() = single_value.field_laneCrownPointLeft->valueof();
break;
case LaneDataAttribute::ALT_laneCrownPointRight:
ret_val.laneCrownPointRight() = single_value.field_laneCrownPointRight->valueof();
break;
case LaneDataAttribute::ALT_laneAngle:
ret_val.laneAngle() = single_value.field_laneAngle->valueof();
break;
case LaneDataAttribute::ALT_speedLimits:
ret_val.speedLimits() = single_value.field_speedLimits->valueof();
break;
case LaneDataAttribute::ALT_regional:
ret_val.regional() = single_value.field_regional->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @DSRC.LaneDataAttribute.");
}
return ret_val;
}

LaneDataAttribute_template& LaneDataAttribute_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @DSRC.LaneDataAttribute.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @DSRC.LaneDataAttribute.");
return value_list.list_value[list_index];
}
void LaneDataAttribute_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @DSRC.LaneDataAttribute.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LaneDataAttribute_template[list_length];
}

INTEGER_template& LaneDataAttribute_template::pathEndPointAngle()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneDataAttribute::ALT_pathEndPointAngle) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pathEndPointAngle = new INTEGER_template(ANY_VALUE);
else single_value.field_pathEndPointAngle = new INTEGER_template;
single_value.union_selection = LaneDataAttribute::ALT_pathEndPointAngle;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pathEndPointAngle;
}

const INTEGER_template& LaneDataAttribute_template::pathEndPointAngle() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pathEndPointAngle in a non-specific template of union type @DSRC.LaneDataAttribute.");
if (single_value.union_selection != LaneDataAttribute::ALT_pathEndPointAngle) TTCN_error("Accessing non-selected field pathEndPointAngle in a template of union type @DSRC.LaneDataAttribute.");
return *single_value.field_pathEndPointAngle;
}

INTEGER_template& LaneDataAttribute_template::laneCrownPointCenter()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneDataAttribute::ALT_laneCrownPointCenter) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_laneCrownPointCenter = new INTEGER_template(ANY_VALUE);
else single_value.field_laneCrownPointCenter = new INTEGER_template;
single_value.union_selection = LaneDataAttribute::ALT_laneCrownPointCenter;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_laneCrownPointCenter;
}

const INTEGER_template& LaneDataAttribute_template::laneCrownPointCenter() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field laneCrownPointCenter in a non-specific template of union type @DSRC.LaneDataAttribute.");
if (single_value.union_selection != LaneDataAttribute::ALT_laneCrownPointCenter) TTCN_error("Accessing non-selected field laneCrownPointCenter in a template of union type @DSRC.LaneDataAttribute.");
return *single_value.field_laneCrownPointCenter;
}

INTEGER_template& LaneDataAttribute_template::laneCrownPointLeft()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneDataAttribute::ALT_laneCrownPointLeft) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_laneCrownPointLeft = new INTEGER_template(ANY_VALUE);
else single_value.field_laneCrownPointLeft = new INTEGER_template;
single_value.union_selection = LaneDataAttribute::ALT_laneCrownPointLeft;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_laneCrownPointLeft;
}

const INTEGER_template& LaneDataAttribute_template::laneCrownPointLeft() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field laneCrownPointLeft in a non-specific template of union type @DSRC.LaneDataAttribute.");
if (single_value.union_selection != LaneDataAttribute::ALT_laneCrownPointLeft) TTCN_error("Accessing non-selected field laneCrownPointLeft in a template of union type @DSRC.LaneDataAttribute.");
return *single_value.field_laneCrownPointLeft;
}

INTEGER_template& LaneDataAttribute_template::laneCrownPointRight()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneDataAttribute::ALT_laneCrownPointRight) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_laneCrownPointRight = new INTEGER_template(ANY_VALUE);
else single_value.field_laneCrownPointRight = new INTEGER_template;
single_value.union_selection = LaneDataAttribute::ALT_laneCrownPointRight;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_laneCrownPointRight;
}

const INTEGER_template& LaneDataAttribute_template::laneCrownPointRight() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field laneCrownPointRight in a non-specific template of union type @DSRC.LaneDataAttribute.");
if (single_value.union_selection != LaneDataAttribute::ALT_laneCrownPointRight) TTCN_error("Accessing non-selected field laneCrownPointRight in a template of union type @DSRC.LaneDataAttribute.");
return *single_value.field_laneCrownPointRight;
}

INTEGER_template& LaneDataAttribute_template::laneAngle()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneDataAttribute::ALT_laneAngle) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_laneAngle = new INTEGER_template(ANY_VALUE);
else single_value.field_laneAngle = new INTEGER_template;
single_value.union_selection = LaneDataAttribute::ALT_laneAngle;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_laneAngle;
}

const INTEGER_template& LaneDataAttribute_template::laneAngle() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field laneAngle in a non-specific template of union type @DSRC.LaneDataAttribute.");
if (single_value.union_selection != LaneDataAttribute::ALT_laneAngle) TTCN_error("Accessing non-selected field laneAngle in a template of union type @DSRC.LaneDataAttribute.");
return *single_value.field_laneAngle;
}

SpeedLimitList_template& LaneDataAttribute_template::speedLimits()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneDataAttribute::ALT_speedLimits) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_speedLimits = new SpeedLimitList_template(ANY_VALUE);
else single_value.field_speedLimits = new SpeedLimitList_template;
single_value.union_selection = LaneDataAttribute::ALT_speedLimits;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_speedLimits;
}

const SpeedLimitList_template& LaneDataAttribute_template::speedLimits() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field speedLimits in a non-specific template of union type @DSRC.LaneDataAttribute.");
if (single_value.union_selection != LaneDataAttribute::ALT_speedLimits) TTCN_error("Accessing non-selected field speedLimits in a template of union type @DSRC.LaneDataAttribute.");
return *single_value.field_speedLimits;
}

REGION::Reg__LaneDataAttribute_template& LaneDataAttribute_template::regional()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != LaneDataAttribute::ALT_regional) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_regional = new REGION::Reg__LaneDataAttribute_template(ANY_VALUE);
else single_value.field_regional = new REGION::Reg__LaneDataAttribute_template;
single_value.union_selection = LaneDataAttribute::ALT_regional;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_regional;
}

const REGION::Reg__LaneDataAttribute_template& LaneDataAttribute_template::regional() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field regional in a non-specific template of union type @DSRC.LaneDataAttribute.");
if (single_value.union_selection != LaneDataAttribute::ALT_regional) TTCN_error("Accessing non-selected field regional in a template of union type @DSRC.LaneDataAttribute.");
return *single_value.field_regional;
}

boolean LaneDataAttribute_template::ischosen(LaneDataAttribute::union_selection_type checked_selection) const
{
if (checked_selection == LaneDataAttribute::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.LaneDataAttribute.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == LaneDataAttribute::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @DSRC.LaneDataAttribute.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @DSRC.LaneDataAttribute containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @DSRC.LaneDataAttribute, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @DSRC.LaneDataAttribute");
}
return FALSE;
}

void LaneDataAttribute_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
TTCN_Logger::log_event_str("{ pathEndPointAngle := ");
single_value.field_pathEndPointAngle->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneDataAttribute::ALT_laneCrownPointCenter:
TTCN_Logger::log_event_str("{ laneCrownPointCenter := ");
single_value.field_laneCrownPointCenter->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneDataAttribute::ALT_laneCrownPointLeft:
TTCN_Logger::log_event_str("{ laneCrownPointLeft := ");
single_value.field_laneCrownPointLeft->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneDataAttribute::ALT_laneCrownPointRight:
TTCN_Logger::log_event_str("{ laneCrownPointRight := ");
single_value.field_laneCrownPointRight->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneDataAttribute::ALT_laneAngle:
TTCN_Logger::log_event_str("{ laneAngle := ");
single_value.field_laneAngle->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneDataAttribute::ALT_speedLimits:
TTCN_Logger::log_event_str("{ speedLimits := ");
single_value.field_speedLimits->log();
TTCN_Logger::log_event_str(" }");
break;
case LaneDataAttribute::ALT_regional:
TTCN_Logger::log_event_str("{ regional := ");
single_value.field_regional->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LaneDataAttribute_template::log_match(const LaneDataAttribute& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pathEndPointAngle");
single_value.field_pathEndPointAngle->log_match(match_value.pathEndPointAngle(), legacy);
} else {
TTCN_Logger::log_event_str("{ pathEndPointAngle := ");
single_value.field_pathEndPointAngle->log_match(match_value.pathEndPointAngle(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneDataAttribute::ALT_laneCrownPointCenter:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".laneCrownPointCenter");
single_value.field_laneCrownPointCenter->log_match(match_value.laneCrownPointCenter(), legacy);
} else {
TTCN_Logger::log_event_str("{ laneCrownPointCenter := ");
single_value.field_laneCrownPointCenter->log_match(match_value.laneCrownPointCenter(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneDataAttribute::ALT_laneCrownPointLeft:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".laneCrownPointLeft");
single_value.field_laneCrownPointLeft->log_match(match_value.laneCrownPointLeft(), legacy);
} else {
TTCN_Logger::log_event_str("{ laneCrownPointLeft := ");
single_value.field_laneCrownPointLeft->log_match(match_value.laneCrownPointLeft(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneDataAttribute::ALT_laneCrownPointRight:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".laneCrownPointRight");
single_value.field_laneCrownPointRight->log_match(match_value.laneCrownPointRight(), legacy);
} else {
TTCN_Logger::log_event_str("{ laneCrownPointRight := ");
single_value.field_laneCrownPointRight->log_match(match_value.laneCrownPointRight(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneDataAttribute::ALT_laneAngle:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".laneAngle");
single_value.field_laneAngle->log_match(match_value.laneAngle(), legacy);
} else {
TTCN_Logger::log_event_str("{ laneAngle := ");
single_value.field_laneAngle->log_match(match_value.laneAngle(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneDataAttribute::ALT_speedLimits:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".speedLimits");
single_value.field_speedLimits->log_match(match_value.speedLimits(), legacy);
} else {
TTCN_Logger::log_event_str("{ speedLimits := ");
single_value.field_speedLimits->log_match(match_value.speedLimits(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case LaneDataAttribute::ALT_regional:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".regional");
single_value.field_regional->log_match(match_value.regional(), legacy);
} else {
TTCN_Logger::log_event_str("{ regional := ");
single_value.field_regional->log_match(match_value.regional(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LaneDataAttribute_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
single_value.field_pathEndPointAngle->encode_text(text_buf);
break;
case LaneDataAttribute::ALT_laneCrownPointCenter:
single_value.field_laneCrownPointCenter->encode_text(text_buf);
break;
case LaneDataAttribute::ALT_laneCrownPointLeft:
single_value.field_laneCrownPointLeft->encode_text(text_buf);
break;
case LaneDataAttribute::ALT_laneCrownPointRight:
single_value.field_laneCrownPointRight->encode_text(text_buf);
break;
case LaneDataAttribute::ALT_laneAngle:
single_value.field_laneAngle->encode_text(text_buf);
break;
case LaneDataAttribute::ALT_speedLimits:
single_value.field_speedLimits->encode_text(text_buf);
break;
case LaneDataAttribute::ALT_regional:
single_value.field_regional->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @DSRC.LaneDataAttribute.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @DSRC.LaneDataAttribute.");
}
}

void LaneDataAttribute_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = LaneDataAttribute::UNBOUND_VALUE;
LaneDataAttribute::union_selection_type new_selection = (LaneDataAttribute::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
single_value.field_pathEndPointAngle = new INTEGER_template;
single_value.field_pathEndPointAngle->decode_text(text_buf);
break;
case LaneDataAttribute::ALT_laneCrownPointCenter:
single_value.field_laneCrownPointCenter = new INTEGER_template;
single_value.field_laneCrownPointCenter->decode_text(text_buf);
break;
case LaneDataAttribute::ALT_laneCrownPointLeft:
single_value.field_laneCrownPointLeft = new INTEGER_template;
single_value.field_laneCrownPointLeft->decode_text(text_buf);
break;
case LaneDataAttribute::ALT_laneCrownPointRight:
single_value.field_laneCrownPointRight = new INTEGER_template;
single_value.field_laneCrownPointRight->decode_text(text_buf);
break;
case LaneDataAttribute::ALT_laneAngle:
single_value.field_laneAngle = new INTEGER_template;
single_value.field_laneAngle->decode_text(text_buf);
break;
case LaneDataAttribute::ALT_speedLimits:
single_value.field_speedLimits = new SpeedLimitList_template;
single_value.field_speedLimits->decode_text(text_buf);
break;
case LaneDataAttribute::ALT_regional:
single_value.field_regional = new REGION::Reg__LaneDataAttribute_template;
single_value.field_regional->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @DSRC.LaneDataAttribute.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LaneDataAttribute_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @DSRC.LaneDataAttribute.");
}
}

boolean LaneDataAttribute_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LaneDataAttribute_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void LaneDataAttribute_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@DSRC.LaneDataAttribute'");
    }
    if (strcmp("pathEndPointAngle", param_field) == 0) {
      pathEndPointAngle().set_param(param);
      return;
    } else if (strcmp("laneCrownPointCenter", param_field) == 0) {
      laneCrownPointCenter().set_param(param);
      return;
    } else if (strcmp("laneCrownPointLeft", param_field) == 0) {
      laneCrownPointLeft().set_param(param);
      return;
    } else if (strcmp("laneCrownPointRight", param_field) == 0) {
      laneCrownPointRight().set_param(param);
      return;
    } else if (strcmp("laneAngle", param_field) == 0) {
      laneAngle().set_param(param);
      return;
    } else if (strcmp("speedLimits", param_field) == 0) {
      speedLimits().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@DSRC.LaneDataAttribute'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LaneDataAttribute_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@DSRC.LaneDataAttribute");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "pathEndPointAngle")) {
      pathEndPointAngle().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "laneCrownPointCenter")) {
      laneCrownPointCenter().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "laneCrownPointLeft")) {
      laneCrownPointLeft().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "laneCrownPointRight")) {
      laneCrownPointRight().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "laneAngle")) {
      laneAngle().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "speedLimits")) {
      speedLimits().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "regional")) {
      regional().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @DSRC.LaneDataAttribute.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@DSRC.LaneDataAttribute");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LaneDataAttribute_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@DSRC.LaneDataAttribute'");
    }
    if (strcmp("pathEndPointAngle", param_field) == 0) {
      return pathEndPointAngle().get_param(param_name);
    } else if (strcmp("laneCrownPointCenter", param_field) == 0) {
      return laneCrownPointCenter().get_param(param_name);
    } else if (strcmp("laneCrownPointLeft", param_field) == 0) {
      return laneCrownPointLeft().get_param(param_name);
    } else if (strcmp("laneCrownPointRight", param_field) == 0) {
      return laneCrownPointRight().get_param(param_name);
    } else if (strcmp("laneAngle", param_field) == 0) {
      return laneAngle().get_param(param_name);
    } else if (strcmp("speedLimits", param_field) == 0) {
      return speedLimits().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `LaneDataAttribute'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case LaneDataAttribute::ALT_pathEndPointAngle:
      mp_field = single_value.field_pathEndPointAngle->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("pathEndPointAngle")));
      break;
    case LaneDataAttribute::ALT_laneCrownPointCenter:
      mp_field = single_value.field_laneCrownPointCenter->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("laneCrownPointCenter")));
      break;
    case LaneDataAttribute::ALT_laneCrownPointLeft:
      mp_field = single_value.field_laneCrownPointLeft->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("laneCrownPointLeft")));
      break;
    case LaneDataAttribute::ALT_laneCrownPointRight:
      mp_field = single_value.field_laneCrownPointRight->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("laneCrownPointRight")));
      break;
    case LaneDataAttribute::ALT_laneAngle:
      mp_field = single_value.field_laneAngle->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("laneAngle")));
      break;
    case LaneDataAttribute::ALT_speedLimits:
      mp_field = single_value.field_speedLimits->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("speedLimits")));
      break;
    case LaneDataAttribute::ALT_regional:
      mp_field = single_value.field_regional->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("regional")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LaneDataAttribute_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case LaneDataAttribute::ALT_pathEndPointAngle:
single_value.field_pathEndPointAngle->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneDataAttribute");
return;
case LaneDataAttribute::ALT_laneCrownPointCenter:
single_value.field_laneCrownPointCenter->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneDataAttribute");
return;
case LaneDataAttribute::ALT_laneCrownPointLeft:
single_value.field_laneCrownPointLeft->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneDataAttribute");
return;
case LaneDataAttribute::ALT_laneCrownPointRight:
single_value.field_laneCrownPointRight->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneDataAttribute");
return;
case LaneDataAttribute::ALT_laneAngle:
single_value.field_laneAngle->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneDataAttribute");
return;
case LaneDataAttribute::ALT_speedLimits:
single_value.field_speedLimits->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneDataAttribute");
return;
case LaneDataAttribute::ALT_regional:
single_value.field_regional->check_restriction(t_res, t_name ? t_name : "@DSRC.LaneDataAttribute");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @DSRC.LaneDataAttribute.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.LaneDataAttribute");
}


const RegulatorySpeedLimit SpeedLimitList::UNBOUND_ELEM;
SpeedLimitList::SpeedLimitList()
{
val_ptr = NULL;
}

SpeedLimitList::SpeedLimitList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

SpeedLimitList::SpeedLimitList(const SpeedLimitList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.SpeedLimitList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

SpeedLimitList::~SpeedLimitList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void SpeedLimitList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

SpeedLimitList& SpeedLimitList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

SpeedLimitList& SpeedLimitList::operator=(const SpeedLimitList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.SpeedLimitList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean SpeedLimitList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.SpeedLimitList.");
return val_ptr->n_elements == 0 ;
}

boolean SpeedLimitList::operator==(const SpeedLimitList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.SpeedLimitList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.SpeedLimitList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

RegulatorySpeedLimit& SpeedLimitList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.SpeedLimitList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (RegulatorySpeedLimit**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RegulatorySpeedLimit(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new RegulatorySpeedLimit;
}
return *val_ptr->value_elements[index_value];
}

RegulatorySpeedLimit& SpeedLimitList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.SpeedLimitList.");
return (*this)[(int)index_value];
}

const RegulatorySpeedLimit& SpeedLimitList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.SpeedLimitList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.SpeedLimitList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.SpeedLimitList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const RegulatorySpeedLimit& SpeedLimitList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.SpeedLimitList.");
return (*this)[(int)index_value];
}

SpeedLimitList SpeedLimitList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

SpeedLimitList SpeedLimitList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

SpeedLimitList SpeedLimitList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

SpeedLimitList SpeedLimitList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.SpeedLimitList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
SpeedLimitList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new RegulatorySpeedLimit(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

SpeedLimitList SpeedLimitList::operator+(const SpeedLimitList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.SpeedLimitList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
SpeedLimitList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RegulatorySpeedLimit(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new RegulatorySpeedLimit(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

SpeedLimitList SpeedLimitList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.SpeedLimitList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.SpeedLimitList","element");
SpeedLimitList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new RegulatorySpeedLimit(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

SpeedLimitList SpeedLimitList::replace(int index, int len, const SpeedLimitList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.SpeedLimitList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.SpeedLimitList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.SpeedLimitList","element");
SpeedLimitList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RegulatorySpeedLimit(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new RegulatorySpeedLimit(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new RegulatorySpeedLimit(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

SpeedLimitList SpeedLimitList::replace(int index, int len, const SpeedLimitList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void SpeedLimitList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.SpeedLimitList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (RegulatorySpeedLimit**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RegulatorySpeedLimit(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (RegulatorySpeedLimit**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.SpeedLimitList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (RegulatorySpeedLimit**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean SpeedLimitList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int SpeedLimitList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.SpeedLimitList.");
return val_ptr->n_elements;
}

int SpeedLimitList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.SpeedLimitList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void SpeedLimitList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void SpeedLimitList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.SpeedLimitList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.SpeedLimitList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.SpeedLimitList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* SpeedLimitList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.SpeedLimitList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void SpeedLimitList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void SpeedLimitList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.SpeedLimitList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void SpeedLimitList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.SpeedLimitList.");
val_ptr->value_elements = (RegulatorySpeedLimit**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new RegulatorySpeedLimit;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void SpeedLimitList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SpeedLimitList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* SpeedLimitList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean SpeedLimitList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (RegulatorySpeedLimit**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new RegulatorySpeedLimit;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int SpeedLimitList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.SpeedLimitList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int SpeedLimitList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    RegulatorySpeedLimit* val = new RegulatorySpeedLimit;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (RegulatorySpeedLimit**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void SpeedLimitList_template::copy_value(const SpeedLimitList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.SpeedLimitList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (RegulatorySpeedLimit_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new RegulatorySpeedLimit_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new RegulatorySpeedLimit_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void SpeedLimitList_template::copy_template(const SpeedLimitList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (RegulatorySpeedLimit_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new RegulatorySpeedLimit_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new RegulatorySpeedLimit_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SpeedLimitList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.SpeedLimitList.");
break;
}
set_selection(other_value);
}

boolean SpeedLimitList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const SpeedLimitList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const SpeedLimitList*)value_ptr)[value_index], legacy);
else return ((const SpeedLimitList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

SpeedLimitList_template::SpeedLimitList_template()
{
}

SpeedLimitList_template::SpeedLimitList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

SpeedLimitList_template::SpeedLimitList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

SpeedLimitList_template::SpeedLimitList_template(const SpeedLimitList& other_value)
{
copy_value(other_value);
}

SpeedLimitList_template::SpeedLimitList_template(const OPTIONAL<SpeedLimitList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpeedLimitList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.SpeedLimitList from an unbound optional field.");
}
}

SpeedLimitList_template::SpeedLimitList_template(const SpeedLimitList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

SpeedLimitList_template::~SpeedLimitList_template()
{
clean_up();
}

void SpeedLimitList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SpeedLimitList_template& SpeedLimitList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SpeedLimitList_template& SpeedLimitList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

SpeedLimitList_template& SpeedLimitList_template::operator=(const SpeedLimitList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SpeedLimitList_template& SpeedLimitList_template::operator=(const OPTIONAL<SpeedLimitList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpeedLimitList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.SpeedLimitList.");
}
return *this;
}

SpeedLimitList_template& SpeedLimitList_template::operator=(const SpeedLimitList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

RegulatorySpeedLimit_template& SpeedLimitList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.SpeedLimitList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.SpeedLimitList.");
    break;
}
return *single_value.value_elements[index_value];
}

RegulatorySpeedLimit_template& SpeedLimitList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.SpeedLimitList.");
return (*this)[(int)index_value];
}

const RegulatorySpeedLimit_template& SpeedLimitList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.SpeedLimitList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.SpeedLimitList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.SpeedLimitList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const RegulatorySpeedLimit_template& SpeedLimitList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.SpeedLimitList.");
return (*this)[(int)index_value];
}

void SpeedLimitList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.SpeedLimitList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (RegulatorySpeedLimit_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RegulatorySpeedLimit_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RegulatorySpeedLimit_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (RegulatorySpeedLimit_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int SpeedLimitList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int SpeedLimitList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.SpeedLimitList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.SpeedLimitList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.SpeedLimitList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.SpeedLimitList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.SpeedLimitList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.SpeedLimitList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.SpeedLimitList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.SpeedLimitList");
}

boolean SpeedLimitList_template::match(const SpeedLimitList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.SpeedLimitList.");
}
return FALSE;
}

boolean SpeedLimitList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

SpeedLimitList SpeedLimitList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.SpeedLimitList.");
SpeedLimitList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

SpeedLimitList SpeedLimitList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

SpeedLimitList SpeedLimitList_template::replace(int index, int len, const SpeedLimitList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

SpeedLimitList SpeedLimitList_template::replace(int index, int len, const SpeedLimitList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void SpeedLimitList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new SpeedLimitList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.SpeedLimitList.");
}
set_selection(template_type);
}

SpeedLimitList_template& SpeedLimitList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.SpeedLimitList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.SpeedLimitList.");
return value_list.list_value[list_index];
}

void SpeedLimitList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void SpeedLimitList_template::log_match(const SpeedLimitList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SpeedLimitList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.SpeedLimitList.");
}
}

void SpeedLimitList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.SpeedLimitList.");
single_value.value_elements = (RegulatorySpeedLimit_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new RegulatorySpeedLimit_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SpeedLimitList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.SpeedLimitList.");
}
}

boolean SpeedLimitList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SpeedLimitList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SpeedLimitList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.SpeedLimitList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SpeedLimitList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.SpeedLimitList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* SpeedLimitList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.SpeedLimitList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void SpeedLimitList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.SpeedLimitList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.SpeedLimitList");
}

SpeedLimitType::SpeedLimitType()
{
enum_value = UNBOUND_VALUE;
}

SpeedLimitType::SpeedLimitType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @DSRC.SpeedLimitType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SpeedLimitType::SpeedLimitType(enum_type other_value)
{
enum_value = other_value;
}

SpeedLimitType::SpeedLimitType(const SpeedLimitType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @DSRC.SpeedLimitType.");
enum_value = other_value.enum_value;
}

SpeedLimitType& SpeedLimitType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @DSRC.SpeedLimitType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SpeedLimitType& SpeedLimitType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SpeedLimitType& SpeedLimitType::operator=(const SpeedLimitType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.SpeedLimitType.");
enum_value = other_value.enum_value;
return *this;
}

boolean SpeedLimitType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SpeedLimitType.");
return enum_value == other_value;
}

boolean SpeedLimitType::operator==(const SpeedLimitType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SpeedLimitType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.SpeedLimitType.");
return enum_value == other_value.enum_value;
}

boolean SpeedLimitType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SpeedLimitType.");
return enum_value < other_value;
}

boolean SpeedLimitType::operator<(const SpeedLimitType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SpeedLimitType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.SpeedLimitType.");
return enum_value < other_value.enum_value;
}

boolean SpeedLimitType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SpeedLimitType.");
return enum_value > other_value;
}

boolean SpeedLimitType::operator>(const SpeedLimitType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.SpeedLimitType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.SpeedLimitType.");
return enum_value > other_value.enum_value;
}

const char *SpeedLimitType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case unknown: return "unknown";
case maxSpeedInSchoolZone: return "maxSpeedInSchoolZone";
case maxSpeedInSchoolZoneWhenChildrenArePresent: return "maxSpeedInSchoolZoneWhenChildrenArePresent";
case maxSpeedInConstructionZone: return "maxSpeedInConstructionZone";
case vehicleMinSpeed: return "vehicleMinSpeed";
case vehicleMaxSpeed: return "vehicleMaxSpeed";
case vehicleNightMaxSpeed: return "vehicleNightMaxSpeed";
case truckMinSpeed: return "truckMinSpeed";
case truckMaxSpeed: return "truckMaxSpeed";
case truckNightMaxSpeed: return "truckNightMaxSpeed";
case vehiclesWithTrailersMinSpeed: return "vehiclesWithTrailersMinSpeed";
case vehiclesWithTrailersMaxSpeed: return "vehiclesWithTrailersMaxSpeed";
case vehiclesWithTrailersNightMaxSpeed: return "vehiclesWithTrailersNightMaxSpeed";
default: return "<unknown>";
}
}

SpeedLimitType::enum_type SpeedLimitType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "unknown")) return unknown;
else if (!strcmp(str_par, "maxSpeedInSchoolZone")) return maxSpeedInSchoolZone;
else if (!strcmp(str_par, "maxSpeedInSchoolZoneWhenChildrenArePresent")) return maxSpeedInSchoolZoneWhenChildrenArePresent;
else if (!strcmp(str_par, "maxSpeedInConstructionZone")) return maxSpeedInConstructionZone;
else if (!strcmp(str_par, "vehicleMinSpeed")) return vehicleMinSpeed;
else if (!strcmp(str_par, "vehicleMaxSpeed")) return vehicleMaxSpeed;
else if (!strcmp(str_par, "vehicleNightMaxSpeed")) return vehicleNightMaxSpeed;
else if (!strcmp(str_par, "truckMinSpeed")) return truckMinSpeed;
else if (!strcmp(str_par, "truckMaxSpeed")) return truckMaxSpeed;
else if (!strcmp(str_par, "truckNightMaxSpeed")) return truckNightMaxSpeed;
else if (!strcmp(str_par, "vehiclesWithTrailersMinSpeed")) return vehiclesWithTrailersMinSpeed;
else if (!strcmp(str_par, "vehiclesWithTrailersMaxSpeed")) return vehiclesWithTrailersMaxSpeed;
else if (!strcmp(str_par, "vehiclesWithTrailersNightMaxSpeed")) return vehiclesWithTrailersNightMaxSpeed;
else return UNKNOWN_VALUE;
}

boolean SpeedLimitType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
return TRUE;
default:
return FALSE;
}
}

int SpeedLimitType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.SpeedLimitType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SpeedLimitType::enum2int(const SpeedLimitType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.SpeedLimitType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SpeedLimitType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @DSRC.SpeedLimitType.", int_val);
enum_value = (enum_type)int_val;
}

SpeedLimitType::operator SpeedLimitType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @DSRC.SpeedLimitType.");
return enum_value;
}

void SpeedLimitType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SpeedLimitType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@DSRC.SpeedLimitType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @DSRC.SpeedLimitType.");
  }
}

Module_Param* SpeedLimitType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void SpeedLimitType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @DSRC.SpeedLimitType.");
text_buf.push_int(enum_value);
}

void SpeedLimitType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @DSRC.SpeedLimitType.", enum_value);
}

void SpeedLimitType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SpeedLimitType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* SpeedLimitType::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean SpeedLimitType::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @DSRC.SpeedLimitType: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int SpeedLimitType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @DSRC.SpeedLimitType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int SpeedLimitType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void SpeedLimitType_template::copy_template(const SpeedLimitType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SpeedLimitType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @DSRC.SpeedLimitType.");
}
}

SpeedLimitType_template::SpeedLimitType_template()
{
}

SpeedLimitType_template::SpeedLimitType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SpeedLimitType_template::SpeedLimitType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SpeedLimitType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @DSRC.SpeedLimitType with unknown numeric value %d.", other_value);
single_value = (SpeedLimitType::enum_type)other_value;
}

SpeedLimitType_template::SpeedLimitType_template(SpeedLimitType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SpeedLimitType_template::SpeedLimitType_template(const SpeedLimitType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SpeedLimitType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @DSRC.SpeedLimitType.");
single_value = other_value.enum_value;
}

SpeedLimitType_template::SpeedLimitType_template(const OPTIONAL<SpeedLimitType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SpeedLimitType::enum_type)(const SpeedLimitType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @DSRC.SpeedLimitType from an unbound optional field.");
}
}

SpeedLimitType_template::SpeedLimitType_template(const SpeedLimitType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SpeedLimitType_template::~SpeedLimitType_template()
{
clean_up();
}

boolean SpeedLimitType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SpeedLimitType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SpeedLimitType::UNBOUND_VALUE;
}

void SpeedLimitType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SpeedLimitType_template& SpeedLimitType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SpeedLimitType_template& SpeedLimitType_template::operator=(int other_value)
{
if (!SpeedLimitType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @DSRC.SpeedLimitType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SpeedLimitType::enum_type)other_value;
return *this;
}

SpeedLimitType_template& SpeedLimitType_template::operator=(SpeedLimitType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SpeedLimitType_template& SpeedLimitType_template::operator=(const SpeedLimitType& other_value)
{
if (other_value.enum_value == SpeedLimitType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.SpeedLimitType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SpeedLimitType_template& SpeedLimitType_template::operator=(const OPTIONAL<SpeedLimitType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SpeedLimitType::enum_type)(const SpeedLimitType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @DSRC.SpeedLimitType.");
}
return *this;
}

SpeedLimitType_template& SpeedLimitType_template::operator=(const SpeedLimitType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SpeedLimitType_template::match(SpeedLimitType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @DSRC.SpeedLimitType.");
}
return FALSE;
}

boolean SpeedLimitType_template::match(const SpeedLimitType& other_value, boolean) const
{
if (other_value.enum_value == SpeedLimitType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @DSRC.SpeedLimitType with an unbound value.");
return match(other_value.enum_value);
}

SpeedLimitType::enum_type SpeedLimitType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @DSRC.SpeedLimitType.");
return single_value;
}

void SpeedLimitType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @DSRC.SpeedLimitType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SpeedLimitType_template[list_length];
}

SpeedLimitType_template& SpeedLimitType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @DSRC.SpeedLimitType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @DSRC.SpeedLimitType.");
return value_list.list_value[list_index];
}

void SpeedLimitType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SpeedLimitType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SpeedLimitType_template::log_match(const SpeedLimitType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SpeedLimitType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @DSRC.SpeedLimitType.");
}
}

void SpeedLimitType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SpeedLimitType::enum_type)text_buf.pull_int().get_val();
if (!SpeedLimitType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @DSRC.SpeedLimitType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SpeedLimitType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @DSRC.SpeedLimitType.");
}
}

boolean SpeedLimitType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SpeedLimitType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SpeedLimitType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    SpeedLimitType::enum_type enum_val = (enum_name != NULL) ? SpeedLimitType::str_to_enum(enum_name) : SpeedLimitType::UNKNOWN_VALUE;
    if (SpeedLimitType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SpeedLimitType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SpeedLimitType::enum_type enum_val = SpeedLimitType::str_to_enum(mp->get_enumerated());
    if (!SpeedLimitType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @DSRC.SpeedLimitType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@DSRC.SpeedLimitType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SpeedLimitType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(SpeedLimitType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SpeedLimitType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.SpeedLimitType");
}

RegulatorySpeedLimit::RegulatorySpeedLimit()
{
  bound_flag = FALSE;
}

RegulatorySpeedLimit::RegulatorySpeedLimit(const SpeedLimitType& par_type__,
    const INTEGER& par_speed)
  :   field_type__(par_type__),
  field_speed(par_speed)
{
  bound_flag = TRUE;
}

RegulatorySpeedLimit::RegulatorySpeedLimit(const RegulatorySpeedLimit& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.RegulatorySpeedLimit.");
bound_flag = TRUE;
if (other_value.type__().is_bound()) field_type__ = other_value.type__();
else field_type__.clean_up();
if (other_value.speed().is_bound()) field_speed = other_value.speed();
else field_speed.clean_up();
}

void RegulatorySpeedLimit::clean_up()
{
field_type__.clean_up();
field_speed.clean_up();
bound_flag = FALSE;
}

RegulatorySpeedLimit& RegulatorySpeedLimit::operator=(const RegulatorySpeedLimit& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.RegulatorySpeedLimit.");
  bound_flag = TRUE;
  if (other_value.type__().is_bound()) field_type__ = other_value.type__();
  else field_type__.clean_up();
  if (other_value.speed().is_bound()) field_speed = other_value.speed();
  else field_speed.clean_up();
}
return *this;
}

boolean RegulatorySpeedLimit::operator==(const RegulatorySpeedLimit& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_type__==other_value.field_type__
  && field_speed==other_value.field_speed;
}

boolean RegulatorySpeedLimit::is_bound() const
{
if (bound_flag) return TRUE;
if(field_type__.is_bound()) return TRUE;
if(field_speed.is_bound()) return TRUE;
return FALSE;
}
boolean RegulatorySpeedLimit::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_type__.is_value()) return FALSE;
if(!field_speed.is_value()) return FALSE;
return TRUE;
}
int RegulatorySpeedLimit::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.RegulatorySpeedLimit");
  return 2;
}

void RegulatorySpeedLimit::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ type_ := ");
field_type__.log();
TTCN_Logger::log_event_str(", speed := ");
field_speed.log();
TTCN_Logger::log_event_str(" }");
}

void RegulatorySpeedLimit::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.RegulatorySpeedLimit'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("speed", param_field) == 0) {
      speed().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.RegulatorySpeedLimit'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @DSRC.RegulatorySpeedLimit has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) speed().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.RegulatorySpeedLimit: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.RegulatorySpeedLimit");
  }
}

Module_Param* RegulatorySpeedLimit::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.RegulatorySpeedLimit'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("speed", param_field) == 0) {
      return speed().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.RegulatorySpeedLimit'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_type__ = field_type__.get_param(param_name);
  mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
  mp->add_elem(mp_field_type__);
  Module_Param* mp_field_speed = field_speed.get_param(param_name);
  mp_field_speed->set_id(new Module_Param_FieldName(mcopystr("speed")));
  mp->add_elem(mp_field_speed);
  return mp;
  }

void RegulatorySpeedLimit::set_implicit_omit()
{
if (type__().is_bound()) type__().set_implicit_omit();
if (speed().is_bound()) speed().set_implicit_omit();
}

void RegulatorySpeedLimit::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.RegulatorySpeedLimit.");
field_type__.encode_text(text_buf);
field_speed.encode_text(text_buf);
}

void RegulatorySpeedLimit::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_type__.decode_text(text_buf);
field_speed.decode_text(text_buf);
}

void RegulatorySpeedLimit::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RegulatorySpeedLimit::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RegulatorySpeedLimit::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("type_': ");
  new_tlv->add_TLV(field_type__.BER_encode_TLV(RegulatorySpeedLimit_type___descr_, p_coding));
  ec_1.set_msg("speed': ");
  new_tlv->add_TLV(field_speed.BER_encode_TLV(RegulatorySpeedLimit_speed_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RegulatorySpeedLimit::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.RegulatorySpeedLimit' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("type_': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_type__.BER_decode_TLV(RegulatorySpeedLimit_type___descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("speed': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_speed.BER_decode_TLV(RegulatorySpeedLimit_speed_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int RegulatorySpeedLimit::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.RegulatorySpeedLimit.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "type_");
    enc_len += field_type__.JSON_encode(RegulatorySpeedLimit_type___descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speed");
    enc_len += field_speed.JSON_encode(RegulatorySpeedLimit_speed_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RegulatorySpeedLimit::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "type_", name_len)) {
         int ret_val = field_type__.JSON_decode(RegulatorySpeedLimit_type___descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "type_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "speed", name_len)) {
         int ret_val = field_speed.JSON_decode(RegulatorySpeedLimit_speed_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speed");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_type__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "type_");
    return JSON_ERROR_FATAL;
  }
if (!field_speed.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "speed");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct RegulatorySpeedLimit_template::single_value_struct {
SpeedLimitType_template field_type__;
INTEGER_template field_speed;
};

void RegulatorySpeedLimit_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_type__ = ANY_VALUE;
single_value->field_speed = ANY_VALUE;
}
}
}

void RegulatorySpeedLimit_template::copy_value(const RegulatorySpeedLimit& other_value)
{
single_value = new single_value_struct;
if (other_value.type__().is_bound()) {
  single_value->field_type__ = other_value.type__();
} else {
  single_value->field_type__.clean_up();
}
if (other_value.speed().is_bound()) {
  single_value->field_speed = other_value.speed();
} else {
  single_value->field_speed.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RegulatorySpeedLimit_template::copy_template(const RegulatorySpeedLimit_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.type__().get_selection()) {
single_value->field_type__ = other_value.type__();
} else {
single_value->field_type__.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speed().get_selection()) {
single_value->field_speed = other_value.speed();
} else {
single_value->field_speed.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RegulatorySpeedLimit_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.RegulatorySpeedLimit.");
break;
}
set_selection(other_value);
}

RegulatorySpeedLimit_template::RegulatorySpeedLimit_template()
{
}

RegulatorySpeedLimit_template::RegulatorySpeedLimit_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RegulatorySpeedLimit_template::RegulatorySpeedLimit_template(const RegulatorySpeedLimit& other_value)
{
copy_value(other_value);
}

RegulatorySpeedLimit_template::RegulatorySpeedLimit_template(const OPTIONAL<RegulatorySpeedLimit>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RegulatorySpeedLimit&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.RegulatorySpeedLimit from an unbound optional field.");
}
}

RegulatorySpeedLimit_template::RegulatorySpeedLimit_template(const RegulatorySpeedLimit_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RegulatorySpeedLimit_template::~RegulatorySpeedLimit_template()
{
clean_up();
}

RegulatorySpeedLimit_template& RegulatorySpeedLimit_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RegulatorySpeedLimit_template& RegulatorySpeedLimit_template::operator=(const RegulatorySpeedLimit& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RegulatorySpeedLimit_template& RegulatorySpeedLimit_template::operator=(const OPTIONAL<RegulatorySpeedLimit>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RegulatorySpeedLimit&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.RegulatorySpeedLimit.");
}
return *this;
}

RegulatorySpeedLimit_template& RegulatorySpeedLimit_template::operator=(const RegulatorySpeedLimit_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RegulatorySpeedLimit_template::match(const RegulatorySpeedLimit& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.type__().is_bound()) return FALSE;
if(!single_value->field_type__.match(other_value.type__(), legacy))return FALSE;
if(!other_value.speed().is_bound()) return FALSE;
if(!single_value->field_speed.match(other_value.speed(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.RegulatorySpeedLimit.");
}
return FALSE;
}

boolean RegulatorySpeedLimit_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_type__.is_bound()) return TRUE;
if (single_value->field_speed.is_bound()) return TRUE;
return FALSE;
}

boolean RegulatorySpeedLimit_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_type__.is_value()) return FALSE;
if (!single_value->field_speed.is_value()) return FALSE;
return TRUE;
}

void RegulatorySpeedLimit_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RegulatorySpeedLimit RegulatorySpeedLimit_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.RegulatorySpeedLimit.");
RegulatorySpeedLimit ret_val;
if (single_value->field_type__.is_bound()) {
ret_val.type__() = single_value->field_type__.valueof();
}
if (single_value->field_speed.is_bound()) {
ret_val.speed() = single_value->field_speed.valueof();
}
return ret_val;
}

void RegulatorySpeedLimit_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.RegulatorySpeedLimit.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RegulatorySpeedLimit_template[list_length];
}

RegulatorySpeedLimit_template& RegulatorySpeedLimit_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.RegulatorySpeedLimit.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.RegulatorySpeedLimit.");
return value_list.list_value[list_index];
}

SpeedLimitType_template& RegulatorySpeedLimit_template::type__()
{
set_specific();
return single_value->field_type__;
}

const SpeedLimitType_template& RegulatorySpeedLimit_template::type__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field type_ of a non-specific template of type @DSRC.RegulatorySpeedLimit.");
return single_value->field_type__;
}

INTEGER_template& RegulatorySpeedLimit_template::speed()
{
set_specific();
return single_value->field_speed;
}

const INTEGER_template& RegulatorySpeedLimit_template::speed() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speed of a non-specific template of type @DSRC.RegulatorySpeedLimit.");
return single_value->field_speed;
}

int RegulatorySpeedLimit_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.RegulatorySpeedLimit which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.RegulatorySpeedLimit containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.RegulatorySpeedLimit containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RegulatorySpeedLimit containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RegulatorySpeedLimit containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RegulatorySpeedLimit containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.RegulatorySpeedLimit.");
  }
  return 0;
}

void RegulatorySpeedLimit_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log();
TTCN_Logger::log_event_str(", speed := ");
single_value->field_speed.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RegulatorySpeedLimit_template::log_match(const RegulatorySpeedLimit& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_type__.match(match_value.type__(), legacy)){
TTCN_Logger::log_logmatch_info(".type_");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_speed.match(match_value.speed(), legacy)){
TTCN_Logger::log_logmatch_info(".speed");
single_value->field_speed.log_match(match_value.speed(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::log_event_str(", speed := ");
single_value->field_speed.log_match(match_value.speed(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RegulatorySpeedLimit_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_type__.encode_text(text_buf);
single_value->field_speed.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.RegulatorySpeedLimit.");
}
}

void RegulatorySpeedLimit_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_type__.decode_text(text_buf);
single_value->field_speed.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RegulatorySpeedLimit_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.RegulatorySpeedLimit.");
}
}

void RegulatorySpeedLimit_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.RegulatorySpeedLimit'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("speed", param_field) == 0) {
      speed().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.RegulatorySpeedLimit'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RegulatorySpeedLimit_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @DSRC.RegulatorySpeedLimit has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) speed().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.RegulatorySpeedLimit: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.RegulatorySpeedLimit");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RegulatorySpeedLimit_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.RegulatorySpeedLimit'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("speed", param_field) == 0) {
      return speed().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.RegulatorySpeedLimit'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_type__ = single_value->field_type__.get_param(param_name);
    mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
    mp->add_elem(mp_field_type__);
    Module_Param* mp_field_speed = single_value->field_speed.get_param(param_name);
    mp_field_speed->set_id(new Module_Param_FieldName(mcopystr("speed")));
    mp->add_elem(mp_field_speed);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RegulatorySpeedLimit_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_type__.check_restriction(t_res, t_name ? t_name : "@DSRC.RegulatorySpeedLimit");
single_value->field_speed.check_restriction(t_res, t_name ? t_name : "@DSRC.RegulatorySpeedLimit");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RegulatorySpeedLimit");
}

boolean RegulatorySpeedLimit_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RegulatorySpeedLimit_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const REGION::Reg__NodeAttribute RegionalNodeAttributeList::UNBOUND_ELEM;
RegionalNodeAttributeList::RegionalNodeAttributeList()
{
val_ptr = NULL;
}

RegionalNodeAttributeList::RegionalNodeAttributeList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

RegionalNodeAttributeList::RegionalNodeAttributeList(const RegionalNodeAttributeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.RegionalNodeAttributeList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

RegionalNodeAttributeList::~RegionalNodeAttributeList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void RegionalNodeAttributeList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

RegionalNodeAttributeList& RegionalNodeAttributeList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

RegionalNodeAttributeList& RegionalNodeAttributeList::operator=(const RegionalNodeAttributeList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.RegionalNodeAttributeList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean RegionalNodeAttributeList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RegionalNodeAttributeList.");
return val_ptr->n_elements == 0 ;
}

boolean RegionalNodeAttributeList::operator==(const RegionalNodeAttributeList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RegionalNodeAttributeList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RegionalNodeAttributeList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

REGION::Reg__NodeAttribute& RegionalNodeAttributeList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RegionalNodeAttributeList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (REGION::Reg__NodeAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new REGION::Reg__NodeAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new REGION::Reg__NodeAttribute;
}
return *val_ptr->value_elements[index_value];
}

REGION::Reg__NodeAttribute& RegionalNodeAttributeList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RegionalNodeAttributeList.");
return (*this)[(int)index_value];
}

const REGION::Reg__NodeAttribute& RegionalNodeAttributeList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.RegionalNodeAttributeList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RegionalNodeAttributeList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.RegionalNodeAttributeList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const REGION::Reg__NodeAttribute& RegionalNodeAttributeList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RegionalNodeAttributeList.");
return (*this)[(int)index_value];
}

RegionalNodeAttributeList RegionalNodeAttributeList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

RegionalNodeAttributeList RegionalNodeAttributeList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

RegionalNodeAttributeList RegionalNodeAttributeList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

RegionalNodeAttributeList RegionalNodeAttributeList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.RegionalNodeAttributeList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
RegionalNodeAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new REGION::Reg__NodeAttribute(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

RegionalNodeAttributeList RegionalNodeAttributeList::operator+(const RegionalNodeAttributeList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.RegionalNodeAttributeList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
RegionalNodeAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new REGION::Reg__NodeAttribute(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new REGION::Reg__NodeAttribute(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

RegionalNodeAttributeList RegionalNodeAttributeList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.RegionalNodeAttributeList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.RegionalNodeAttributeList","element");
RegionalNodeAttributeList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new REGION::Reg__NodeAttribute(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

RegionalNodeAttributeList RegionalNodeAttributeList::replace(int index, int len, const RegionalNodeAttributeList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.RegionalNodeAttributeList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.RegionalNodeAttributeList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.RegionalNodeAttributeList","element");
RegionalNodeAttributeList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new REGION::Reg__NodeAttribute(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new REGION::Reg__NodeAttribute(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new REGION::Reg__NodeAttribute(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

RegionalNodeAttributeList RegionalNodeAttributeList::replace(int index, int len, const RegionalNodeAttributeList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void RegionalNodeAttributeList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.RegionalNodeAttributeList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (REGION::Reg__NodeAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new REGION::Reg__NodeAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (REGION::Reg__NodeAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.RegionalNodeAttributeList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (REGION::Reg__NodeAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean RegionalNodeAttributeList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int RegionalNodeAttributeList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.RegionalNodeAttributeList.");
return val_ptr->n_elements;
}

int RegionalNodeAttributeList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.RegionalNodeAttributeList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void RegionalNodeAttributeList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void RegionalNodeAttributeList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.RegionalNodeAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.RegionalNodeAttributeList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.RegionalNodeAttributeList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* RegionalNodeAttributeList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.RegionalNodeAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void RegionalNodeAttributeList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void RegionalNodeAttributeList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.RegionalNodeAttributeList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void RegionalNodeAttributeList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.RegionalNodeAttributeList.");
val_ptr->value_elements = (REGION::Reg__NodeAttribute**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new REGION::Reg__NodeAttribute;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void RegionalNodeAttributeList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RegionalNodeAttributeList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RegionalNodeAttributeList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RegionalNodeAttributeList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (REGION::Reg__NodeAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new REGION::Reg__NodeAttribute;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int RegionalNodeAttributeList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.RegionalNodeAttributeList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int RegionalNodeAttributeList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    REGION::Reg__NodeAttribute* val = new REGION::Reg__NodeAttribute;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (REGION::Reg__NodeAttribute**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void RegionalNodeAttributeList_template::copy_value(const RegionalNodeAttributeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.RegionalNodeAttributeList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (REGION::Reg__NodeAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new REGION::Reg__NodeAttribute_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new REGION::Reg__NodeAttribute_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void RegionalNodeAttributeList_template::copy_template(const RegionalNodeAttributeList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (REGION::Reg__NodeAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new REGION::Reg__NodeAttribute_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new REGION::Reg__NodeAttribute_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RegionalNodeAttributeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.RegionalNodeAttributeList.");
break;
}
set_selection(other_value);
}

boolean RegionalNodeAttributeList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const RegionalNodeAttributeList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const RegionalNodeAttributeList*)value_ptr)[value_index], legacy);
else return ((const RegionalNodeAttributeList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

RegionalNodeAttributeList_template::RegionalNodeAttributeList_template()
{
}

RegionalNodeAttributeList_template::RegionalNodeAttributeList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

RegionalNodeAttributeList_template::RegionalNodeAttributeList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

RegionalNodeAttributeList_template::RegionalNodeAttributeList_template(const RegionalNodeAttributeList& other_value)
{
copy_value(other_value);
}

RegionalNodeAttributeList_template::RegionalNodeAttributeList_template(const OPTIONAL<RegionalNodeAttributeList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RegionalNodeAttributeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.RegionalNodeAttributeList from an unbound optional field.");
}
}

RegionalNodeAttributeList_template::RegionalNodeAttributeList_template(const RegionalNodeAttributeList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

RegionalNodeAttributeList_template::~RegionalNodeAttributeList_template()
{
clean_up();
}

void RegionalNodeAttributeList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RegionalNodeAttributeList_template& RegionalNodeAttributeList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RegionalNodeAttributeList_template& RegionalNodeAttributeList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

RegionalNodeAttributeList_template& RegionalNodeAttributeList_template::operator=(const RegionalNodeAttributeList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RegionalNodeAttributeList_template& RegionalNodeAttributeList_template::operator=(const OPTIONAL<RegionalNodeAttributeList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RegionalNodeAttributeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.RegionalNodeAttributeList.");
}
return *this;
}

RegionalNodeAttributeList_template& RegionalNodeAttributeList_template::operator=(const RegionalNodeAttributeList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

REGION::Reg__NodeAttribute_template& RegionalNodeAttributeList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RegionalNodeAttributeList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.RegionalNodeAttributeList.");
    break;
}
return *single_value.value_elements[index_value];
}

REGION::Reg__NodeAttribute_template& RegionalNodeAttributeList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RegionalNodeAttributeList.");
return (*this)[(int)index_value];
}

const REGION::Reg__NodeAttribute_template& RegionalNodeAttributeList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RegionalNodeAttributeList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.RegionalNodeAttributeList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.RegionalNodeAttributeList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const REGION::Reg__NodeAttribute_template& RegionalNodeAttributeList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RegionalNodeAttributeList.");
return (*this)[(int)index_value];
}

void RegionalNodeAttributeList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.RegionalNodeAttributeList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (REGION::Reg__NodeAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new REGION::Reg__NodeAttribute_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new REGION::Reg__NodeAttribute_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (REGION::Reg__NodeAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int RegionalNodeAttributeList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int RegionalNodeAttributeList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.RegionalNodeAttributeList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RegionalNodeAttributeList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RegionalNodeAttributeList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.RegionalNodeAttributeList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RegionalNodeAttributeList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RegionalNodeAttributeList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.RegionalNodeAttributeList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.RegionalNodeAttributeList");
}

boolean RegionalNodeAttributeList_template::match(const RegionalNodeAttributeList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.RegionalNodeAttributeList.");
}
return FALSE;
}

boolean RegionalNodeAttributeList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

RegionalNodeAttributeList RegionalNodeAttributeList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.RegionalNodeAttributeList.");
RegionalNodeAttributeList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

RegionalNodeAttributeList RegionalNodeAttributeList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

RegionalNodeAttributeList RegionalNodeAttributeList_template::replace(int index, int len, const RegionalNodeAttributeList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

RegionalNodeAttributeList RegionalNodeAttributeList_template::replace(int index, int len, const RegionalNodeAttributeList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void RegionalNodeAttributeList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new RegionalNodeAttributeList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.RegionalNodeAttributeList.");
}
set_selection(template_type);
}

RegionalNodeAttributeList_template& RegionalNodeAttributeList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.RegionalNodeAttributeList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.RegionalNodeAttributeList.");
return value_list.list_value[list_index];
}

void RegionalNodeAttributeList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void RegionalNodeAttributeList_template::log_match(const RegionalNodeAttributeList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RegionalNodeAttributeList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.RegionalNodeAttributeList.");
}
}

void RegionalNodeAttributeList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.RegionalNodeAttributeList.");
single_value.value_elements = (REGION::Reg__NodeAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new REGION::Reg__NodeAttribute_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RegionalNodeAttributeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.RegionalNodeAttributeList.");
}
}

boolean RegionalNodeAttributeList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RegionalNodeAttributeList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RegionalNodeAttributeList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.RegionalNodeAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RegionalNodeAttributeList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.RegionalNodeAttributeList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* RegionalNodeAttributeList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.RegionalNodeAttributeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void RegionalNodeAttributeList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.RegionalNodeAttributeList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RegionalNodeAttributeList");
}

void ComputedLane_offsetXaxis::copy_value(const ComputedLane_offsetXaxis& other_value)
{
switch (other_value.union_selection) {
case ALT_small:
field_small = new INTEGER(*other_value.field_small);
break;
case ALT_large:
field_large = new INTEGER(*other_value.field_large);
break;
default:
TTCN_error("Assignment of an unbound union value of type @DSRC.ComputedLane.offsetXaxis.");
}
union_selection = other_value.union_selection;
}

ComputedLane_offsetXaxis::ComputedLane_offsetXaxis()
{
union_selection = UNBOUND_VALUE;
}

ComputedLane_offsetXaxis::ComputedLane_offsetXaxis(const ComputedLane_offsetXaxis& other_value)
: Base_Type(){
copy_value(other_value);
}

ComputedLane_offsetXaxis::~ComputedLane_offsetXaxis()
{
clean_up();
}

ComputedLane_offsetXaxis& ComputedLane_offsetXaxis::operator=(const ComputedLane_offsetXaxis& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean ComputedLane_offsetXaxis::operator==(const ComputedLane_offsetXaxis& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @DSRC.ComputedLane.offsetXaxis.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @DSRC.ComputedLane.offsetXaxis.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_small:
return *field_small == *other_value.field_small;
case ALT_large:
return *field_large == *other_value.field_large;
default:
return FALSE;
}
}

INTEGER& ComputedLane_offsetXaxis::small()
{
if (union_selection != ALT_small) {
clean_up();
field_small = new INTEGER;
union_selection = ALT_small;
}
return *field_small;
}

const INTEGER& ComputedLane_offsetXaxis::small() const
{
if (union_selection != ALT_small) TTCN_error("Using non-selected field small in a value of union type @DSRC.ComputedLane.offsetXaxis.");
return *field_small;
}

INTEGER& ComputedLane_offsetXaxis::large()
{
if (union_selection != ALT_large) {
clean_up();
field_large = new INTEGER;
union_selection = ALT_large;
}
return *field_large;
}

const INTEGER& ComputedLane_offsetXaxis::large() const
{
if (union_selection != ALT_large) TTCN_error("Using non-selected field large in a value of union type @DSRC.ComputedLane.offsetXaxis.");
return *field_large;
}

boolean ComputedLane_offsetXaxis::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.ComputedLane.offsetXaxis.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @DSRC.ComputedLane.offsetXaxis.");
return union_selection == checked_selection;
}

boolean ComputedLane_offsetXaxis::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean ComputedLane_offsetXaxis::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_small: return field_small->is_value();
case ALT_large: return field_large->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void ComputedLane_offsetXaxis::clean_up()
{
switch (union_selection) {
case ALT_small:
  delete field_small;
  break;
case ALT_large:
  delete field_large;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void ComputedLane_offsetXaxis::log() const
{
switch (union_selection) {
case ALT_small:
TTCN_Logger::log_event_str("{ small := ");
field_small->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_large:
TTCN_Logger::log_event_str("{ large := ");
field_large->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void ComputedLane_offsetXaxis::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@DSRC.ComputedLane.offsetXaxis'");
    }
    if (strcmp("small", param_field) == 0) {
      small().set_param(param);
      return;
    } else if (strcmp("large", param_field) == 0) {
      large().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@DSRC.ComputedLane.offsetXaxis'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "small")) {
    small().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "large")) {
    large().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @DSRC.ComputedLane.offsetXaxis.", mp_last->get_id()->get_name());
}

Module_Param* ComputedLane_offsetXaxis::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@DSRC.ComputedLane.offsetXaxis'");
    }
    if (strcmp("small", param_field) == 0) {
      return small().get_param(param_name);
    } else if (strcmp("large", param_field) == 0) {
      return large().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ComputedLane_offsetXaxis'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_small:
    mp_field = field_small->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("small")));
    break;
  case ALT_large:
    mp_field = field_large->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("large")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void ComputedLane_offsetXaxis::set_implicit_omit()
{
switch (union_selection) {
case ALT_small:
field_small->set_implicit_omit(); break;
case ALT_large:
field_large->set_implicit_omit(); break;
default: break;
}
}

void ComputedLane_offsetXaxis::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_small:
field_small->encode_text(text_buf);
break;
case ALT_large:
field_large->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @DSRC.ComputedLane.offsetXaxis.");
}
}

void ComputedLane_offsetXaxis::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_small:
small().decode_text(text_buf);
break;
case ALT_large:
large().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @DSRC.ComputedLane.offsetXaxis.");
}
}

void ComputedLane_offsetXaxis::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ComputedLane_offsetXaxis::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t *ComputedLane_offsetXaxis::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv;
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  switch (union_selection) {
  case ALT_small:
    ec_1.set_msg("small': ");
    new_tlv = field_small->BER_encode_TLV(ComputedLane_offsetXaxis_small_descr_, p_coding);
    break;
  case ALT_large:
    ec_1.set_msg("large': ");
    new_tlv = field_large->BER_encode_TLV(ComputedLane_offsetXaxis_large_descr_, p_coding);
    break;
  case UNBOUND_VALUE:
    new_tlv = BER_encode_chk_bound(FALSE);
    break;
  default:
    TTCN_EncDec_ErrorContext::error_internal("Unknown selection.");
    new_tlv = NULL;
  }
  return ASN_BER_V2TLV(new_tlv, p_td, p_coding);
}

boolean ComputedLane_offsetXaxis::BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv)
{
  clean_up();
  field_small = new INTEGER;
  union_selection = ALT_small;
  if (field_small->BER_decode_isMyMsg(ComputedLane_offsetXaxis_small_descr_, p_tlv)) return TRUE;
  delete field_small;
  field_large = new INTEGER;
  union_selection = ALT_large;
  if (field_large->BER_decode_isMyMsg(ComputedLane_offsetXaxis_large_descr_, p_tlv)) return TRUE;
  delete field_large;
  union_selection = UNBOUND_VALUE;
  return FALSE;
}

boolean ComputedLane_offsetXaxis::BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv)
{
  if (p_td.ber->n_tags == 0) {
    ComputedLane_offsetXaxis tmp_type;
    return tmp_type.BER_decode_set_selection(p_tlv);
  } else return Base_Type::BER_decode_isMyMsg(p_td, p_tlv);
}

boolean ComputedLane_offsetXaxis::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.ComputedLane.offsetXaxis' type: ");
  ASN_BER_TLV_t tmp_tlv;
  if (!BER_decode_TLV_CHOICE(*p_td.ber, stripped_tlv, L_form, tmp_tlv) || !BER_decode_CHOICE_selection(BER_decode_set_selection(tmp_tlv), tmp_tlv)) return FALSE;
  TTCN_EncDec_ErrorContext ec_1("Alternative '");
  TTCN_EncDec_ErrorContext ec_2;
  switch (union_selection) {
  case ALT_small:
    ec_2.set_msg("small': ");
    field_small->BER_decode_TLV(ComputedLane_offsetXaxis_small_descr_, tmp_tlv, L_form);
    break;
  case ALT_large:
    ec_2.set_msg("large': ");
    field_large->BER_decode_TLV(ComputedLane_offsetXaxis_large_descr_, tmp_tlv, L_form);
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

int ComputedLane_offsetXaxis::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_small:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "small");
    enc_len += field_small->JSON_encode(ComputedLane_offsetXaxis_small_descr_, p_tok);
    break;
  case ALT_large:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "large");
    enc_len += field_large->JSON_encode(ComputedLane_offsetXaxis_large_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @DSRC.ComputedLane.offsetXaxis.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ComputedLane_offsetXaxis::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "small", name_len)) {
      int ret_val = small().JSON_decode(ComputedLane_offsetXaxis_small_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "small");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "large", name_len)) {
      int ret_val = large().JSON_decode(ComputedLane_offsetXaxis_large_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "large");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ComputedLane_offsetXaxis_template::copy_value(const ComputedLane_offsetXaxis& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case ComputedLane_offsetXaxis::ALT_small:
single_value.field_small = new INTEGER_template(other_value.small());
break;
case ComputedLane_offsetXaxis::ALT_large:
single_value.field_large = new INTEGER_template(other_value.large());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @DSRC.ComputedLane.offsetXaxis.");
}
set_selection(SPECIFIC_VALUE);
}

void ComputedLane_offsetXaxis_template::copy_template(const ComputedLane_offsetXaxis_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case ComputedLane_offsetXaxis::ALT_small:
single_value.field_small = new INTEGER_template(*other_value.single_value.field_small);
break;
case ComputedLane_offsetXaxis::ALT_large:
single_value.field_large = new INTEGER_template(*other_value.single_value.field_large);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @DSRC.ComputedLane.offsetXaxis.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ComputedLane_offsetXaxis_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @DSRC.ComputedLane.offsetXaxis.");
}
set_selection(other_value);
}

ComputedLane_offsetXaxis_template::ComputedLane_offsetXaxis_template()
{
}

ComputedLane_offsetXaxis_template::ComputedLane_offsetXaxis_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ComputedLane_offsetXaxis_template::ComputedLane_offsetXaxis_template(const ComputedLane_offsetXaxis& other_value)
{
copy_value(other_value);
}

ComputedLane_offsetXaxis_template::ComputedLane_offsetXaxis_template(const OPTIONAL<ComputedLane_offsetXaxis>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ComputedLane_offsetXaxis&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @DSRC.ComputedLane.offsetXaxis from an unbound optional field.");
}
}

ComputedLane_offsetXaxis_template::ComputedLane_offsetXaxis_template(const ComputedLane_offsetXaxis_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ComputedLane_offsetXaxis_template::~ComputedLane_offsetXaxis_template()
{
clean_up();
}

void ComputedLane_offsetXaxis_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ComputedLane_offsetXaxis::ALT_small:
delete single_value.field_small;
break;
case ComputedLane_offsetXaxis::ALT_large:
delete single_value.field_large;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ComputedLane_offsetXaxis_template& ComputedLane_offsetXaxis_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ComputedLane_offsetXaxis_template& ComputedLane_offsetXaxis_template::operator=(const ComputedLane_offsetXaxis& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ComputedLane_offsetXaxis_template& ComputedLane_offsetXaxis_template::operator=(const OPTIONAL<ComputedLane_offsetXaxis>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ComputedLane_offsetXaxis&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @DSRC.ComputedLane.offsetXaxis.");
}
return *this;
}

ComputedLane_offsetXaxis_template& ComputedLane_offsetXaxis_template::operator=(const ComputedLane_offsetXaxis_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ComputedLane_offsetXaxis_template::match(const ComputedLane_offsetXaxis& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
ComputedLane_offsetXaxis::union_selection_type value_selection = other_value.get_selection();
if (value_selection == ComputedLane_offsetXaxis::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case ComputedLane_offsetXaxis::ALT_small:
return single_value.field_small->match(other_value.small(), legacy);
case ComputedLane_offsetXaxis::ALT_large:
return single_value.field_large->match(other_value.large(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @DSRC.ComputedLane.offsetXaxis.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @DSRC.ComputedLane.offsetXaxis.");
}
return FALSE;
}

boolean ComputedLane_offsetXaxis_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case ComputedLane_offsetXaxis::ALT_small:
return single_value.field_small->is_value();
case ComputedLane_offsetXaxis::ALT_large:
return single_value.field_large->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @DSRC.ComputedLane.offsetXaxis.");
}
}

ComputedLane_offsetXaxis ComputedLane_offsetXaxis_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @DSRC.ComputedLane.offsetXaxis.");
ComputedLane_offsetXaxis ret_val;
switch (single_value.union_selection) {
case ComputedLane_offsetXaxis::ALT_small:
ret_val.small() = single_value.field_small->valueof();
break;
case ComputedLane_offsetXaxis::ALT_large:
ret_val.large() = single_value.field_large->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @DSRC.ComputedLane.offsetXaxis.");
}
return ret_val;
}

ComputedLane_offsetXaxis_template& ComputedLane_offsetXaxis_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @DSRC.ComputedLane.offsetXaxis.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @DSRC.ComputedLane.offsetXaxis.");
return value_list.list_value[list_index];
}
void ComputedLane_offsetXaxis_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @DSRC.ComputedLane.offsetXaxis.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ComputedLane_offsetXaxis_template[list_length];
}

INTEGER_template& ComputedLane_offsetXaxis_template::small()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ComputedLane_offsetXaxis::ALT_small) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_small = new INTEGER_template(ANY_VALUE);
else single_value.field_small = new INTEGER_template;
single_value.union_selection = ComputedLane_offsetXaxis::ALT_small;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_small;
}

const INTEGER_template& ComputedLane_offsetXaxis_template::small() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field small in a non-specific template of union type @DSRC.ComputedLane.offsetXaxis.");
if (single_value.union_selection != ComputedLane_offsetXaxis::ALT_small) TTCN_error("Accessing non-selected field small in a template of union type @DSRC.ComputedLane.offsetXaxis.");
return *single_value.field_small;
}

INTEGER_template& ComputedLane_offsetXaxis_template::large()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ComputedLane_offsetXaxis::ALT_large) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_large = new INTEGER_template(ANY_VALUE);
else single_value.field_large = new INTEGER_template;
single_value.union_selection = ComputedLane_offsetXaxis::ALT_large;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_large;
}

const INTEGER_template& ComputedLane_offsetXaxis_template::large() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field large in a non-specific template of union type @DSRC.ComputedLane.offsetXaxis.");
if (single_value.union_selection != ComputedLane_offsetXaxis::ALT_large) TTCN_error("Accessing non-selected field large in a template of union type @DSRC.ComputedLane.offsetXaxis.");
return *single_value.field_large;
}

boolean ComputedLane_offsetXaxis_template::ischosen(ComputedLane_offsetXaxis::union_selection_type checked_selection) const
{
if (checked_selection == ComputedLane_offsetXaxis::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.ComputedLane.offsetXaxis.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == ComputedLane_offsetXaxis::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @DSRC.ComputedLane.offsetXaxis.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @DSRC.ComputedLane.offsetXaxis containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @DSRC.ComputedLane.offsetXaxis, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @DSRC.ComputedLane.offsetXaxis");
}
return FALSE;
}

void ComputedLane_offsetXaxis_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ComputedLane_offsetXaxis::ALT_small:
TTCN_Logger::log_event_str("{ small := ");
single_value.field_small->log();
TTCN_Logger::log_event_str(" }");
break;
case ComputedLane_offsetXaxis::ALT_large:
TTCN_Logger::log_event_str("{ large := ");
single_value.field_large->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ComputedLane_offsetXaxis_template::log_match(const ComputedLane_offsetXaxis& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case ComputedLane_offsetXaxis::ALT_small:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".small");
single_value.field_small->log_match(match_value.small(), legacy);
} else {
TTCN_Logger::log_event_str("{ small := ");
single_value.field_small->log_match(match_value.small(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ComputedLane_offsetXaxis::ALT_large:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".large");
single_value.field_large->log_match(match_value.large(), legacy);
} else {
TTCN_Logger::log_event_str("{ large := ");
single_value.field_large->log_match(match_value.large(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ComputedLane_offsetXaxis_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case ComputedLane_offsetXaxis::ALT_small:
single_value.field_small->encode_text(text_buf);
break;
case ComputedLane_offsetXaxis::ALT_large:
single_value.field_large->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @DSRC.ComputedLane.offsetXaxis.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @DSRC.ComputedLane.offsetXaxis.");
}
}

void ComputedLane_offsetXaxis_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = ComputedLane_offsetXaxis::UNBOUND_VALUE;
ComputedLane_offsetXaxis::union_selection_type new_selection = (ComputedLane_offsetXaxis::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case ComputedLane_offsetXaxis::ALT_small:
single_value.field_small = new INTEGER_template;
single_value.field_small->decode_text(text_buf);
break;
case ComputedLane_offsetXaxis::ALT_large:
single_value.field_large = new INTEGER_template;
single_value.field_large->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @DSRC.ComputedLane.offsetXaxis.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ComputedLane_offsetXaxis_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @DSRC.ComputedLane.offsetXaxis.");
}
}

boolean ComputedLane_offsetXaxis_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ComputedLane_offsetXaxis_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ComputedLane_offsetXaxis_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@DSRC.ComputedLane.offsetXaxis'");
    }
    if (strcmp("small", param_field) == 0) {
      small().set_param(param);
      return;
    } else if (strcmp("large", param_field) == 0) {
      large().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@DSRC.ComputedLane.offsetXaxis'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ComputedLane_offsetXaxis_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@DSRC.ComputedLane.offsetXaxis");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "small")) {
      small().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "large")) {
      large().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @DSRC.ComputedLane.offsetXaxis.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@DSRC.ComputedLane.offsetXaxis");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ComputedLane_offsetXaxis_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@DSRC.ComputedLane.offsetXaxis'");
    }
    if (strcmp("small", param_field) == 0) {
      return small().get_param(param_name);
    } else if (strcmp("large", param_field) == 0) {
      return large().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ComputedLane_offsetXaxis'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case ComputedLane_offsetXaxis::ALT_small:
      mp_field = single_value.field_small->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("small")));
      break;
    case ComputedLane_offsetXaxis::ALT_large:
      mp_field = single_value.field_large->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("large")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ComputedLane_offsetXaxis_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case ComputedLane_offsetXaxis::ALT_small:
single_value.field_small->check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane.offsetXaxis");
return;
case ComputedLane_offsetXaxis::ALT_large:
single_value.field_large->check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane.offsetXaxis");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @DSRC.ComputedLane.offsetXaxis.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.ComputedLane.offsetXaxis");
}

void ComputedLane_offsetYaxis::copy_value(const ComputedLane_offsetYaxis& other_value)
{
switch (other_value.union_selection) {
case ALT_small:
field_small = new INTEGER(*other_value.field_small);
break;
case ALT_large:
field_large = new INTEGER(*other_value.field_large);
break;
default:
TTCN_error("Assignment of an unbound union value of type @DSRC.ComputedLane.offsetYaxis.");
}
union_selection = other_value.union_selection;
}

ComputedLane_offsetYaxis::ComputedLane_offsetYaxis()
{
union_selection = UNBOUND_VALUE;
}

ComputedLane_offsetYaxis::ComputedLane_offsetYaxis(const ComputedLane_offsetYaxis& other_value)
: Base_Type(){
copy_value(other_value);
}

ComputedLane_offsetYaxis::~ComputedLane_offsetYaxis()
{
clean_up();
}

ComputedLane_offsetYaxis& ComputedLane_offsetYaxis::operator=(const ComputedLane_offsetYaxis& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean ComputedLane_offsetYaxis::operator==(const ComputedLane_offsetYaxis& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @DSRC.ComputedLane.offsetYaxis.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @DSRC.ComputedLane.offsetYaxis.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_small:
return *field_small == *other_value.field_small;
case ALT_large:
return *field_large == *other_value.field_large;
default:
return FALSE;
}
}

INTEGER& ComputedLane_offsetYaxis::small()
{
if (union_selection != ALT_small) {
clean_up();
field_small = new INTEGER;
union_selection = ALT_small;
}
return *field_small;
}

const INTEGER& ComputedLane_offsetYaxis::small() const
{
if (union_selection != ALT_small) TTCN_error("Using non-selected field small in a value of union type @DSRC.ComputedLane.offsetYaxis.");
return *field_small;
}

INTEGER& ComputedLane_offsetYaxis::large()
{
if (union_selection != ALT_large) {
clean_up();
field_large = new INTEGER;
union_selection = ALT_large;
}
return *field_large;
}

const INTEGER& ComputedLane_offsetYaxis::large() const
{
if (union_selection != ALT_large) TTCN_error("Using non-selected field large in a value of union type @DSRC.ComputedLane.offsetYaxis.");
return *field_large;
}

boolean ComputedLane_offsetYaxis::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.ComputedLane.offsetYaxis.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @DSRC.ComputedLane.offsetYaxis.");
return union_selection == checked_selection;
}

boolean ComputedLane_offsetYaxis::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean ComputedLane_offsetYaxis::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_small: return field_small->is_value();
case ALT_large: return field_large->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void ComputedLane_offsetYaxis::clean_up()
{
switch (union_selection) {
case ALT_small:
  delete field_small;
  break;
case ALT_large:
  delete field_large;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void ComputedLane_offsetYaxis::log() const
{
switch (union_selection) {
case ALT_small:
TTCN_Logger::log_event_str("{ small := ");
field_small->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_large:
TTCN_Logger::log_event_str("{ large := ");
field_large->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void ComputedLane_offsetYaxis::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@DSRC.ComputedLane.offsetYaxis'");
    }
    if (strcmp("small", param_field) == 0) {
      small().set_param(param);
      return;
    } else if (strcmp("large", param_field) == 0) {
      large().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@DSRC.ComputedLane.offsetYaxis'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "small")) {
    small().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "large")) {
    large().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @DSRC.ComputedLane.offsetYaxis.", mp_last->get_id()->get_name());
}

Module_Param* ComputedLane_offsetYaxis::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@DSRC.ComputedLane.offsetYaxis'");
    }
    if (strcmp("small", param_field) == 0) {
      return small().get_param(param_name);
    } else if (strcmp("large", param_field) == 0) {
      return large().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ComputedLane_offsetYaxis'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_small:
    mp_field = field_small->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("small")));
    break;
  case ALT_large:
    mp_field = field_large->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("large")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void ComputedLane_offsetYaxis::set_implicit_omit()
{
switch (union_selection) {
case ALT_small:
field_small->set_implicit_omit(); break;
case ALT_large:
field_large->set_implicit_omit(); break;
default: break;
}
}

void ComputedLane_offsetYaxis::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_small:
field_small->encode_text(text_buf);
break;
case ALT_large:
field_large->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @DSRC.ComputedLane.offsetYaxis.");
}
}

void ComputedLane_offsetYaxis::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_small:
small().decode_text(text_buf);
break;
case ALT_large:
large().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @DSRC.ComputedLane.offsetYaxis.");
}
}

void ComputedLane_offsetYaxis::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ComputedLane_offsetYaxis::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t *ComputedLane_offsetYaxis::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv;
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  switch (union_selection) {
  case ALT_small:
    ec_1.set_msg("small': ");
    new_tlv = field_small->BER_encode_TLV(ComputedLane_offsetYaxis_small_descr_, p_coding);
    break;
  case ALT_large:
    ec_1.set_msg("large': ");
    new_tlv = field_large->BER_encode_TLV(ComputedLane_offsetYaxis_large_descr_, p_coding);
    break;
  case UNBOUND_VALUE:
    new_tlv = BER_encode_chk_bound(FALSE);
    break;
  default:
    TTCN_EncDec_ErrorContext::error_internal("Unknown selection.");
    new_tlv = NULL;
  }
  return ASN_BER_V2TLV(new_tlv, p_td, p_coding);
}

boolean ComputedLane_offsetYaxis::BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv)
{
  clean_up();
  field_small = new INTEGER;
  union_selection = ALT_small;
  if (field_small->BER_decode_isMyMsg(ComputedLane_offsetYaxis_small_descr_, p_tlv)) return TRUE;
  delete field_small;
  field_large = new INTEGER;
  union_selection = ALT_large;
  if (field_large->BER_decode_isMyMsg(ComputedLane_offsetYaxis_large_descr_, p_tlv)) return TRUE;
  delete field_large;
  union_selection = UNBOUND_VALUE;
  return FALSE;
}

boolean ComputedLane_offsetYaxis::BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv)
{
  if (p_td.ber->n_tags == 0) {
    ComputedLane_offsetYaxis tmp_type;
    return tmp_type.BER_decode_set_selection(p_tlv);
  } else return Base_Type::BER_decode_isMyMsg(p_td, p_tlv);
}

boolean ComputedLane_offsetYaxis::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.ComputedLane.offsetYaxis' type: ");
  ASN_BER_TLV_t tmp_tlv;
  if (!BER_decode_TLV_CHOICE(*p_td.ber, stripped_tlv, L_form, tmp_tlv) || !BER_decode_CHOICE_selection(BER_decode_set_selection(tmp_tlv), tmp_tlv)) return FALSE;
  TTCN_EncDec_ErrorContext ec_1("Alternative '");
  TTCN_EncDec_ErrorContext ec_2;
  switch (union_selection) {
  case ALT_small:
    ec_2.set_msg("small': ");
    field_small->BER_decode_TLV(ComputedLane_offsetYaxis_small_descr_, tmp_tlv, L_form);
    break;
  case ALT_large:
    ec_2.set_msg("large': ");
    field_large->BER_decode_TLV(ComputedLane_offsetYaxis_large_descr_, tmp_tlv, L_form);
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

int ComputedLane_offsetYaxis::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_small:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "small");
    enc_len += field_small->JSON_encode(ComputedLane_offsetYaxis_small_descr_, p_tok);
    break;
  case ALT_large:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "large");
    enc_len += field_large->JSON_encode(ComputedLane_offsetYaxis_large_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @DSRC.ComputedLane.offsetYaxis.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ComputedLane_offsetYaxis::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "small", name_len)) {
      int ret_val = small().JSON_decode(ComputedLane_offsetYaxis_small_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "small");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "large", name_len)) {
      int ret_val = large().JSON_decode(ComputedLane_offsetYaxis_large_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "large");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ComputedLane_offsetYaxis_template::copy_value(const ComputedLane_offsetYaxis& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case ComputedLane_offsetYaxis::ALT_small:
single_value.field_small = new INTEGER_template(other_value.small());
break;
case ComputedLane_offsetYaxis::ALT_large:
single_value.field_large = new INTEGER_template(other_value.large());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @DSRC.ComputedLane.offsetYaxis.");
}
set_selection(SPECIFIC_VALUE);
}

void ComputedLane_offsetYaxis_template::copy_template(const ComputedLane_offsetYaxis_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case ComputedLane_offsetYaxis::ALT_small:
single_value.field_small = new INTEGER_template(*other_value.single_value.field_small);
break;
case ComputedLane_offsetYaxis::ALT_large:
single_value.field_large = new INTEGER_template(*other_value.single_value.field_large);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @DSRC.ComputedLane.offsetYaxis.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ComputedLane_offsetYaxis_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @DSRC.ComputedLane.offsetYaxis.");
}
set_selection(other_value);
}

ComputedLane_offsetYaxis_template::ComputedLane_offsetYaxis_template()
{
}

ComputedLane_offsetYaxis_template::ComputedLane_offsetYaxis_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ComputedLane_offsetYaxis_template::ComputedLane_offsetYaxis_template(const ComputedLane_offsetYaxis& other_value)
{
copy_value(other_value);
}

ComputedLane_offsetYaxis_template::ComputedLane_offsetYaxis_template(const OPTIONAL<ComputedLane_offsetYaxis>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ComputedLane_offsetYaxis&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @DSRC.ComputedLane.offsetYaxis from an unbound optional field.");
}
}

ComputedLane_offsetYaxis_template::ComputedLane_offsetYaxis_template(const ComputedLane_offsetYaxis_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ComputedLane_offsetYaxis_template::~ComputedLane_offsetYaxis_template()
{
clean_up();
}

void ComputedLane_offsetYaxis_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ComputedLane_offsetYaxis::ALT_small:
delete single_value.field_small;
break;
case ComputedLane_offsetYaxis::ALT_large:
delete single_value.field_large;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ComputedLane_offsetYaxis_template& ComputedLane_offsetYaxis_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ComputedLane_offsetYaxis_template& ComputedLane_offsetYaxis_template::operator=(const ComputedLane_offsetYaxis& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ComputedLane_offsetYaxis_template& ComputedLane_offsetYaxis_template::operator=(const OPTIONAL<ComputedLane_offsetYaxis>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ComputedLane_offsetYaxis&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @DSRC.ComputedLane.offsetYaxis.");
}
return *this;
}

ComputedLane_offsetYaxis_template& ComputedLane_offsetYaxis_template::operator=(const ComputedLane_offsetYaxis_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ComputedLane_offsetYaxis_template::match(const ComputedLane_offsetYaxis& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
ComputedLane_offsetYaxis::union_selection_type value_selection = other_value.get_selection();
if (value_selection == ComputedLane_offsetYaxis::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case ComputedLane_offsetYaxis::ALT_small:
return single_value.field_small->match(other_value.small(), legacy);
case ComputedLane_offsetYaxis::ALT_large:
return single_value.field_large->match(other_value.large(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @DSRC.ComputedLane.offsetYaxis.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @DSRC.ComputedLane.offsetYaxis.");
}
return FALSE;
}

boolean ComputedLane_offsetYaxis_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case ComputedLane_offsetYaxis::ALT_small:
return single_value.field_small->is_value();
case ComputedLane_offsetYaxis::ALT_large:
return single_value.field_large->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @DSRC.ComputedLane.offsetYaxis.");
}
}

ComputedLane_offsetYaxis ComputedLane_offsetYaxis_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @DSRC.ComputedLane.offsetYaxis.");
ComputedLane_offsetYaxis ret_val;
switch (single_value.union_selection) {
case ComputedLane_offsetYaxis::ALT_small:
ret_val.small() = single_value.field_small->valueof();
break;
case ComputedLane_offsetYaxis::ALT_large:
ret_val.large() = single_value.field_large->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @DSRC.ComputedLane.offsetYaxis.");
}
return ret_val;
}

ComputedLane_offsetYaxis_template& ComputedLane_offsetYaxis_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @DSRC.ComputedLane.offsetYaxis.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @DSRC.ComputedLane.offsetYaxis.");
return value_list.list_value[list_index];
}
void ComputedLane_offsetYaxis_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @DSRC.ComputedLane.offsetYaxis.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ComputedLane_offsetYaxis_template[list_length];
}

INTEGER_template& ComputedLane_offsetYaxis_template::small()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ComputedLane_offsetYaxis::ALT_small) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_small = new INTEGER_template(ANY_VALUE);
else single_value.field_small = new INTEGER_template;
single_value.union_selection = ComputedLane_offsetYaxis::ALT_small;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_small;
}

const INTEGER_template& ComputedLane_offsetYaxis_template::small() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field small in a non-specific template of union type @DSRC.ComputedLane.offsetYaxis.");
if (single_value.union_selection != ComputedLane_offsetYaxis::ALT_small) TTCN_error("Accessing non-selected field small in a template of union type @DSRC.ComputedLane.offsetYaxis.");
return *single_value.field_small;
}

INTEGER_template& ComputedLane_offsetYaxis_template::large()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ComputedLane_offsetYaxis::ALT_large) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_large = new INTEGER_template(ANY_VALUE);
else single_value.field_large = new INTEGER_template;
single_value.union_selection = ComputedLane_offsetYaxis::ALT_large;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_large;
}

const INTEGER_template& ComputedLane_offsetYaxis_template::large() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field large in a non-specific template of union type @DSRC.ComputedLane.offsetYaxis.");
if (single_value.union_selection != ComputedLane_offsetYaxis::ALT_large) TTCN_error("Accessing non-selected field large in a template of union type @DSRC.ComputedLane.offsetYaxis.");
return *single_value.field_large;
}

boolean ComputedLane_offsetYaxis_template::ischosen(ComputedLane_offsetYaxis::union_selection_type checked_selection) const
{
if (checked_selection == ComputedLane_offsetYaxis::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.ComputedLane.offsetYaxis.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == ComputedLane_offsetYaxis::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @DSRC.ComputedLane.offsetYaxis.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @DSRC.ComputedLane.offsetYaxis containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @DSRC.ComputedLane.offsetYaxis, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @DSRC.ComputedLane.offsetYaxis");
}
return FALSE;
}

void ComputedLane_offsetYaxis_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ComputedLane_offsetYaxis::ALT_small:
TTCN_Logger::log_event_str("{ small := ");
single_value.field_small->log();
TTCN_Logger::log_event_str(" }");
break;
case ComputedLane_offsetYaxis::ALT_large:
TTCN_Logger::log_event_str("{ large := ");
single_value.field_large->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ComputedLane_offsetYaxis_template::log_match(const ComputedLane_offsetYaxis& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case ComputedLane_offsetYaxis::ALT_small:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".small");
single_value.field_small->log_match(match_value.small(), legacy);
} else {
TTCN_Logger::log_event_str("{ small := ");
single_value.field_small->log_match(match_value.small(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ComputedLane_offsetYaxis::ALT_large:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".large");
single_value.field_large->log_match(match_value.large(), legacy);
} else {
TTCN_Logger::log_event_str("{ large := ");
single_value.field_large->log_match(match_value.large(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ComputedLane_offsetYaxis_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case ComputedLane_offsetYaxis::ALT_small:
single_value.field_small->encode_text(text_buf);
break;
case ComputedLane_offsetYaxis::ALT_large:
single_value.field_large->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @DSRC.ComputedLane.offsetYaxis.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @DSRC.ComputedLane.offsetYaxis.");
}
}

void ComputedLane_offsetYaxis_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = ComputedLane_offsetYaxis::UNBOUND_VALUE;
ComputedLane_offsetYaxis::union_selection_type new_selection = (ComputedLane_offsetYaxis::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case ComputedLane_offsetYaxis::ALT_small:
single_value.field_small = new INTEGER_template;
single_value.field_small->decode_text(text_buf);
break;
case ComputedLane_offsetYaxis::ALT_large:
single_value.field_large = new INTEGER_template;
single_value.field_large->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @DSRC.ComputedLane.offsetYaxis.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ComputedLane_offsetYaxis_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @DSRC.ComputedLane.offsetYaxis.");
}
}

boolean ComputedLane_offsetYaxis_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ComputedLane_offsetYaxis_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ComputedLane_offsetYaxis_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@DSRC.ComputedLane.offsetYaxis'");
    }
    if (strcmp("small", param_field) == 0) {
      small().set_param(param);
      return;
    } else if (strcmp("large", param_field) == 0) {
      large().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@DSRC.ComputedLane.offsetYaxis'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ComputedLane_offsetYaxis_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@DSRC.ComputedLane.offsetYaxis");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "small")) {
      small().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "large")) {
      large().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @DSRC.ComputedLane.offsetYaxis.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@DSRC.ComputedLane.offsetYaxis");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ComputedLane_offsetYaxis_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@DSRC.ComputedLane.offsetYaxis'");
    }
    if (strcmp("small", param_field) == 0) {
      return small().get_param(param_name);
    } else if (strcmp("large", param_field) == 0) {
      return large().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ComputedLane_offsetYaxis'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case ComputedLane_offsetYaxis::ALT_small:
      mp_field = single_value.field_small->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("small")));
      break;
    case ComputedLane_offsetYaxis::ALT_large:
      mp_field = single_value.field_large->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("large")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ComputedLane_offsetYaxis_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case ComputedLane_offsetYaxis::ALT_small:
single_value.field_small->check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane.offsetYaxis");
return;
case ComputedLane_offsetYaxis::ALT_large:
single_value.field_large->check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane.offsetYaxis");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @DSRC.ComputedLane.offsetYaxis.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.ComputedLane.offsetYaxis");
}

ComputedLane::ComputedLane()
{
  bound_flag = FALSE;
}

ComputedLane::ComputedLane(const INTEGER& par_referenceLaneId,
    const ComputedLane_offsetXaxis& par_offsetXaxis,
    const ComputedLane_offsetYaxis& par_offsetYaxis,
    const OPTIONAL<INTEGER>& par_rotateXY,
    const OPTIONAL<INTEGER>& par_scaleXaxis,
    const OPTIONAL<INTEGER>& par_scaleYaxis,
    const OPTIONAL<REGION::Reg__ComputedLane>& par_regional)
  :   field_referenceLaneId(par_referenceLaneId),
  field_offsetXaxis(par_offsetXaxis),
  field_offsetYaxis(par_offsetYaxis),
  field_rotateXY(par_rotateXY),
  field_scaleXaxis(par_scaleXaxis),
  field_scaleYaxis(par_scaleYaxis),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

ComputedLane::ComputedLane(const ComputedLane& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.ComputedLane.");
bound_flag = TRUE;
if (other_value.referenceLaneId().is_bound()) field_referenceLaneId = other_value.referenceLaneId();
else field_referenceLaneId.clean_up();
if (other_value.offsetXaxis().is_bound()) field_offsetXaxis = other_value.offsetXaxis();
else field_offsetXaxis.clean_up();
if (other_value.offsetYaxis().is_bound()) field_offsetYaxis = other_value.offsetYaxis();
else field_offsetYaxis.clean_up();
if (other_value.rotateXY().is_bound()) field_rotateXY = other_value.rotateXY();
else field_rotateXY.clean_up();
if (other_value.scaleXaxis().is_bound()) field_scaleXaxis = other_value.scaleXaxis();
else field_scaleXaxis.clean_up();
if (other_value.scaleYaxis().is_bound()) field_scaleYaxis = other_value.scaleYaxis();
else field_scaleYaxis.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void ComputedLane::clean_up()
{
field_referenceLaneId.clean_up();
field_offsetXaxis.clean_up();
field_offsetYaxis.clean_up();
field_rotateXY.clean_up();
field_scaleXaxis.clean_up();
field_scaleYaxis.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

ComputedLane& ComputedLane::operator=(const ComputedLane& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.ComputedLane.");
  bound_flag = TRUE;
  if (other_value.referenceLaneId().is_bound()) field_referenceLaneId = other_value.referenceLaneId();
  else field_referenceLaneId.clean_up();
  if (other_value.offsetXaxis().is_bound()) field_offsetXaxis = other_value.offsetXaxis();
  else field_offsetXaxis.clean_up();
  if (other_value.offsetYaxis().is_bound()) field_offsetYaxis = other_value.offsetYaxis();
  else field_offsetYaxis.clean_up();
  if (other_value.rotateXY().is_bound()) field_rotateXY = other_value.rotateXY();
  else field_rotateXY.clean_up();
  if (other_value.scaleXaxis().is_bound()) field_scaleXaxis = other_value.scaleXaxis();
  else field_scaleXaxis.clean_up();
  if (other_value.scaleYaxis().is_bound()) field_scaleYaxis = other_value.scaleYaxis();
  else field_scaleYaxis.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean ComputedLane::operator==(const ComputedLane& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_referenceLaneId==other_value.field_referenceLaneId
  && field_offsetXaxis==other_value.field_offsetXaxis
  && field_offsetYaxis==other_value.field_offsetYaxis
  && field_rotateXY==other_value.field_rotateXY
  && field_scaleXaxis==other_value.field_scaleXaxis
  && field_scaleYaxis==other_value.field_scaleYaxis
  && field_regional==other_value.field_regional;
}

boolean ComputedLane::is_bound() const
{
if (bound_flag) return TRUE;
if(field_referenceLaneId.is_bound()) return TRUE;
if(field_offsetXaxis.is_bound()) return TRUE;
if(field_offsetYaxis.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_rotateXY.get_selection() || field_rotateXY.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_scaleXaxis.get_selection() || field_scaleXaxis.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_scaleYaxis.get_selection() || field_scaleYaxis.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean ComputedLane::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_referenceLaneId.is_value()) return FALSE;
if(!field_offsetXaxis.is_value()) return FALSE;
if(!field_offsetYaxis.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_rotateXY.get_selection() && !field_rotateXY.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_scaleXaxis.get_selection() && !field_scaleXaxis.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_scaleYaxis.get_selection() && !field_scaleYaxis.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int ComputedLane::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.ComputedLane");
  int ret_val = 3;
  if (field_rotateXY.ispresent()) ret_val++;
  if (field_scaleXaxis.ispresent()) ret_val++;
  if (field_scaleYaxis.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void ComputedLane::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ referenceLaneId := ");
field_referenceLaneId.log();
TTCN_Logger::log_event_str(", offsetXaxis := ");
field_offsetXaxis.log();
TTCN_Logger::log_event_str(", offsetYaxis := ");
field_offsetYaxis.log();
TTCN_Logger::log_event_str(", rotateXY := ");
field_rotateXY.log();
TTCN_Logger::log_event_str(", scaleXaxis := ");
field_scaleXaxis.log();
TTCN_Logger::log_event_str(", scaleYaxis := ");
field_scaleYaxis.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void ComputedLane::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.ComputedLane'");
    }
    if (strcmp("referenceLaneId", param_field) == 0) {
      referenceLaneId().set_param(param);
      return;
    } else if (strcmp("offsetXaxis", param_field) == 0) {
      offsetXaxis().set_param(param);
      return;
    } else if (strcmp("offsetYaxis", param_field) == 0) {
      offsetYaxis().set_param(param);
      return;
    } else if (strcmp("rotateXY", param_field) == 0) {
      rotateXY().set_param(param);
      return;
    } else if (strcmp("scaleXaxis", param_field) == 0) {
      scaleXaxis().set_param(param);
      return;
    } else if (strcmp("scaleYaxis", param_field) == 0) {
      scaleYaxis().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.ComputedLane'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record value of type @DSRC.ComputedLane has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) referenceLaneId().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) offsetXaxis().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) offsetYaxis().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) rotateXY().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) scaleXaxis().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) scaleYaxis().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "referenceLaneId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          referenceLaneId().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "offsetXaxis")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          offsetXaxis().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "offsetYaxis")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          offsetYaxis().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rotateXY")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rotateXY().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "scaleXaxis")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          scaleXaxis().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "scaleYaxis")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          scaleYaxis().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.ComputedLane: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.ComputedLane");
  }
}

Module_Param* ComputedLane::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.ComputedLane'");
    }
    if (strcmp("referenceLaneId", param_field) == 0) {
      return referenceLaneId().get_param(param_name);
    } else if (strcmp("offsetXaxis", param_field) == 0) {
      return offsetXaxis().get_param(param_name);
    } else if (strcmp("offsetYaxis", param_field) == 0) {
      return offsetYaxis().get_param(param_name);
    } else if (strcmp("rotateXY", param_field) == 0) {
      return rotateXY().get_param(param_name);
    } else if (strcmp("scaleXaxis", param_field) == 0) {
      return scaleXaxis().get_param(param_name);
    } else if (strcmp("scaleYaxis", param_field) == 0) {
      return scaleYaxis().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.ComputedLane'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_referenceLaneId = field_referenceLaneId.get_param(param_name);
  mp_field_referenceLaneId->set_id(new Module_Param_FieldName(mcopystr("referenceLaneId")));
  mp->add_elem(mp_field_referenceLaneId);
  Module_Param* mp_field_offsetXaxis = field_offsetXaxis.get_param(param_name);
  mp_field_offsetXaxis->set_id(new Module_Param_FieldName(mcopystr("offsetXaxis")));
  mp->add_elem(mp_field_offsetXaxis);
  Module_Param* mp_field_offsetYaxis = field_offsetYaxis.get_param(param_name);
  mp_field_offsetYaxis->set_id(new Module_Param_FieldName(mcopystr("offsetYaxis")));
  mp->add_elem(mp_field_offsetYaxis);
  Module_Param* mp_field_rotateXY = field_rotateXY.get_param(param_name);
  mp_field_rotateXY->set_id(new Module_Param_FieldName(mcopystr("rotateXY")));
  mp->add_elem(mp_field_rotateXY);
  Module_Param* mp_field_scaleXaxis = field_scaleXaxis.get_param(param_name);
  mp_field_scaleXaxis->set_id(new Module_Param_FieldName(mcopystr("scaleXaxis")));
  mp->add_elem(mp_field_scaleXaxis);
  Module_Param* mp_field_scaleYaxis = field_scaleYaxis.get_param(param_name);
  mp_field_scaleYaxis->set_id(new Module_Param_FieldName(mcopystr("scaleYaxis")));
  mp->add_elem(mp_field_scaleYaxis);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void ComputedLane::set_implicit_omit()
{
if (referenceLaneId().is_bound()) referenceLaneId().set_implicit_omit();
if (offsetXaxis().is_bound()) offsetXaxis().set_implicit_omit();
if (offsetYaxis().is_bound()) offsetYaxis().set_implicit_omit();
if (!rotateXY().is_bound()) rotateXY() = OMIT_VALUE;
else rotateXY().set_implicit_omit();
if (!scaleXaxis().is_bound()) scaleXaxis() = OMIT_VALUE;
else scaleXaxis().set_implicit_omit();
if (!scaleYaxis().is_bound()) scaleYaxis() = OMIT_VALUE;
else scaleYaxis().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void ComputedLane::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.ComputedLane.");
field_referenceLaneId.encode_text(text_buf);
field_offsetXaxis.encode_text(text_buf);
field_offsetYaxis.encode_text(text_buf);
field_rotateXY.encode_text(text_buf);
field_scaleXaxis.encode_text(text_buf);
field_scaleYaxis.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void ComputedLane::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_referenceLaneId.decode_text(text_buf);
field_offsetXaxis.decode_text(text_buf);
field_offsetYaxis.decode_text(text_buf);
field_rotateXY.decode_text(text_buf);
field_scaleXaxis.decode_text(text_buf);
field_scaleYaxis.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void ComputedLane::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ComputedLane::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ComputedLane::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("referenceLaneId': ");
  new_tlv->add_TLV(field_referenceLaneId.BER_encode_TLV(ComputedLane_referenceLaneId_descr_, p_coding));
  ec_1.set_msg("offsetXaxis': ");
  new_tlv->add_TLV(field_offsetXaxis.BER_encode_TLV(ComputedLane_offsetXaxis_descr_, p_coding));
  ec_1.set_msg("offsetYaxis': ");
  new_tlv->add_TLV(field_offsetYaxis.BER_encode_TLV(ComputedLane_offsetYaxis_descr_, p_coding));
  ec_1.set_msg("rotateXY': ");
  new_tlv->add_TLV(field_rotateXY.BER_encode_TLV(ComputedLane_rotateXY_descr_, p_coding));
  ec_1.set_msg("scaleXaxis': ");
  new_tlv->add_TLV(field_scaleXaxis.BER_encode_TLV(ComputedLane_scaleXaxis_descr_, p_coding));
  ec_1.set_msg("scaleYaxis': ");
  new_tlv->add_TLV(field_scaleYaxis.BER_encode_TLV(ComputedLane_scaleYaxis_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(ComputedLane_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ComputedLane::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.ComputedLane' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("referenceLaneId': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_referenceLaneId.BER_decode_TLV(ComputedLane_referenceLaneId_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("offsetXaxis': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_offsetXaxis.BER_decode_TLV(ComputedLane_offsetXaxis_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("offsetYaxis': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_offsetYaxis.BER_decode_TLV(ComputedLane_offsetYaxis_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("rotateXY': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_rotateXY=OMIT_VALUE;
    else {
      field_rotateXY.BER_decode_TLV(ComputedLane_rotateXY_descr_, tmp_tlv, L_form);
      if(field_rotateXY.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("scaleXaxis': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_scaleXaxis=OMIT_VALUE;
    else {
      field_scaleXaxis.BER_decode_TLV(ComputedLane_scaleXaxis_descr_, tmp_tlv, L_form);
      if(field_scaleXaxis.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("scaleYaxis': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_scaleYaxis=OMIT_VALUE;
    else {
      field_scaleYaxis.BER_decode_TLV(ComputedLane_scaleYaxis_descr_, tmp_tlv, L_form);
      if(field_scaleYaxis.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(ComputedLane_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ComputedLane::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.ComputedLane.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "referenceLaneId");
    enc_len += field_referenceLaneId.JSON_encode(ComputedLane_referenceLaneId_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "offsetXaxis");
    enc_len += field_offsetXaxis.JSON_encode(ComputedLane_offsetXaxis_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "offsetYaxis");
    enc_len += field_offsetYaxis.JSON_encode(ComputedLane_offsetYaxis_descr_, p_tok);
  }

  if (field_rotateXY.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rotateXY");
    enc_len += field_rotateXY.JSON_encode(ComputedLane_rotateXY_descr_, p_tok);
  }

  if (field_scaleXaxis.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "scaleXaxis");
    enc_len += field_scaleXaxis.JSON_encode(ComputedLane_scaleXaxis_descr_, p_tok);
  }

  if (field_scaleYaxis.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "scaleYaxis");
    enc_len += field_scaleYaxis.JSON_encode(ComputedLane_scaleYaxis_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(ComputedLane_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ComputedLane::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (15 == name_len && 0 == strncmp(fld_name, "referenceLaneId", name_len)) {
         int ret_val = field_referenceLaneId.JSON_decode(ComputedLane_referenceLaneId_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "referenceLaneId");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "offsetXaxis", name_len)) {
         int ret_val = field_offsetXaxis.JSON_decode(ComputedLane_offsetXaxis_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "offsetXaxis");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "offsetYaxis", name_len)) {
         int ret_val = field_offsetYaxis.JSON_decode(ComputedLane_offsetYaxis_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "offsetYaxis");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "rotateXY", name_len)) {
         int ret_val = field_rotateXY.JSON_decode(ComputedLane_rotateXY_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rotateXY");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "scaleXaxis", name_len)) {
         int ret_val = field_scaleXaxis.JSON_decode(ComputedLane_scaleXaxis_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "scaleXaxis");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "scaleYaxis", name_len)) {
         int ret_val = field_scaleYaxis.JSON_decode(ComputedLane_scaleYaxis_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "scaleYaxis");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(ComputedLane_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_referenceLaneId.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "referenceLaneId");
    return JSON_ERROR_FATAL;
  }
if (!field_offsetXaxis.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "offsetXaxis");
    return JSON_ERROR_FATAL;
  }
if (!field_offsetYaxis.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "offsetYaxis");
    return JSON_ERROR_FATAL;
  }
if (!field_rotateXY.is_bound()) {
    field_rotateXY = OMIT_VALUE;
  }
if (!field_scaleXaxis.is_bound()) {
    field_scaleXaxis = OMIT_VALUE;
  }
if (!field_scaleYaxis.is_bound()) {
    field_scaleYaxis = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct ComputedLane_template::single_value_struct {
INTEGER_template field_referenceLaneId;
ComputedLane_offsetXaxis_template field_offsetXaxis;
ComputedLane_offsetYaxis_template field_offsetYaxis;
INTEGER_template field_rotateXY;
INTEGER_template field_scaleXaxis;
INTEGER_template field_scaleYaxis;
REGION::Reg__ComputedLane_template field_regional;
};

void ComputedLane_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_referenceLaneId = ANY_VALUE;
single_value->field_offsetXaxis = ANY_VALUE;
single_value->field_offsetYaxis = ANY_VALUE;
single_value->field_rotateXY = ANY_OR_OMIT;
single_value->field_scaleXaxis = ANY_OR_OMIT;
single_value->field_scaleYaxis = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void ComputedLane_template::copy_value(const ComputedLane& other_value)
{
single_value = new single_value_struct;
if (other_value.referenceLaneId().is_bound()) {
  single_value->field_referenceLaneId = other_value.referenceLaneId();
} else {
  single_value->field_referenceLaneId.clean_up();
}
if (other_value.offsetXaxis().is_bound()) {
  single_value->field_offsetXaxis = other_value.offsetXaxis();
} else {
  single_value->field_offsetXaxis.clean_up();
}
if (other_value.offsetYaxis().is_bound()) {
  single_value->field_offsetYaxis = other_value.offsetYaxis();
} else {
  single_value->field_offsetYaxis.clean_up();
}
if (other_value.rotateXY().is_bound()) {
  if (other_value.rotateXY().ispresent()) single_value->field_rotateXY = other_value.rotateXY()();
  else single_value->field_rotateXY = OMIT_VALUE;
} else {
  single_value->field_rotateXY.clean_up();
}
if (other_value.scaleXaxis().is_bound()) {
  if (other_value.scaleXaxis().ispresent()) single_value->field_scaleXaxis = other_value.scaleXaxis()();
  else single_value->field_scaleXaxis = OMIT_VALUE;
} else {
  single_value->field_scaleXaxis.clean_up();
}
if (other_value.scaleYaxis().is_bound()) {
  if (other_value.scaleYaxis().ispresent()) single_value->field_scaleYaxis = other_value.scaleYaxis()();
  else single_value->field_scaleYaxis = OMIT_VALUE;
} else {
  single_value->field_scaleYaxis.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ComputedLane_template::copy_template(const ComputedLane_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.referenceLaneId().get_selection()) {
single_value->field_referenceLaneId = other_value.referenceLaneId();
} else {
single_value->field_referenceLaneId.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.offsetXaxis().get_selection()) {
single_value->field_offsetXaxis = other_value.offsetXaxis();
} else {
single_value->field_offsetXaxis.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.offsetYaxis().get_selection()) {
single_value->field_offsetYaxis = other_value.offsetYaxis();
} else {
single_value->field_offsetYaxis.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rotateXY().get_selection()) {
single_value->field_rotateXY = other_value.rotateXY();
} else {
single_value->field_rotateXY.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.scaleXaxis().get_selection()) {
single_value->field_scaleXaxis = other_value.scaleXaxis();
} else {
single_value->field_scaleXaxis.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.scaleYaxis().get_selection()) {
single_value->field_scaleYaxis = other_value.scaleYaxis();
} else {
single_value->field_scaleYaxis.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ComputedLane_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.ComputedLane.");
break;
}
set_selection(other_value);
}

ComputedLane_template::ComputedLane_template()
{
}

ComputedLane_template::ComputedLane_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ComputedLane_template::ComputedLane_template(const ComputedLane& other_value)
{
copy_value(other_value);
}

ComputedLane_template::ComputedLane_template(const OPTIONAL<ComputedLane>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ComputedLane&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.ComputedLane from an unbound optional field.");
}
}

ComputedLane_template::ComputedLane_template(const ComputedLane_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ComputedLane_template::~ComputedLane_template()
{
clean_up();
}

ComputedLane_template& ComputedLane_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ComputedLane_template& ComputedLane_template::operator=(const ComputedLane& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ComputedLane_template& ComputedLane_template::operator=(const OPTIONAL<ComputedLane>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ComputedLane&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.ComputedLane.");
}
return *this;
}

ComputedLane_template& ComputedLane_template::operator=(const ComputedLane_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ComputedLane_template::match(const ComputedLane& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.referenceLaneId().is_bound()) return FALSE;
if(!single_value->field_referenceLaneId.match(other_value.referenceLaneId(), legacy))return FALSE;
if(!other_value.offsetXaxis().is_bound()) return FALSE;
if(!single_value->field_offsetXaxis.match(other_value.offsetXaxis(), legacy))return FALSE;
if(!other_value.offsetYaxis().is_bound()) return FALSE;
if(!single_value->field_offsetYaxis.match(other_value.offsetYaxis(), legacy))return FALSE;
if(!other_value.rotateXY().is_bound()) return FALSE;
if((other_value.rotateXY().ispresent() ? !single_value->field_rotateXY.match((const INTEGER&)other_value.rotateXY(), legacy) : !single_value->field_rotateXY.match_omit(legacy)))return FALSE;
if(!other_value.scaleXaxis().is_bound()) return FALSE;
if((other_value.scaleXaxis().ispresent() ? !single_value->field_scaleXaxis.match((const INTEGER&)other_value.scaleXaxis(), legacy) : !single_value->field_scaleXaxis.match_omit(legacy)))return FALSE;
if(!other_value.scaleYaxis().is_bound()) return FALSE;
if((other_value.scaleYaxis().ispresent() ? !single_value->field_scaleYaxis.match((const INTEGER&)other_value.scaleYaxis(), legacy) : !single_value->field_scaleYaxis.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REGION::Reg__ComputedLane&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.ComputedLane.");
}
return FALSE;
}

boolean ComputedLane_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_referenceLaneId.is_bound()) return TRUE;
if (single_value->field_offsetXaxis.is_bound()) return TRUE;
if (single_value->field_offsetYaxis.is_bound()) return TRUE;
if (single_value->field_rotateXY.is_omit() || single_value->field_rotateXY.is_bound()) return TRUE;
if (single_value->field_scaleXaxis.is_omit() || single_value->field_scaleXaxis.is_bound()) return TRUE;
if (single_value->field_scaleYaxis.is_omit() || single_value->field_scaleYaxis.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean ComputedLane_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_referenceLaneId.is_value()) return FALSE;
if (!single_value->field_offsetXaxis.is_value()) return FALSE;
if (!single_value->field_offsetYaxis.is_value()) return FALSE;
if (!single_value->field_rotateXY.is_omit() && !single_value->field_rotateXY.is_value()) return FALSE;
if (!single_value->field_scaleXaxis.is_omit() && !single_value->field_scaleXaxis.is_value()) return FALSE;
if (!single_value->field_scaleYaxis.is_omit() && !single_value->field_scaleYaxis.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void ComputedLane_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ComputedLane ComputedLane_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.ComputedLane.");
ComputedLane ret_val;
if (single_value->field_referenceLaneId.is_bound()) {
ret_val.referenceLaneId() = single_value->field_referenceLaneId.valueof();
}
if (single_value->field_offsetXaxis.is_bound()) {
ret_val.offsetXaxis() = single_value->field_offsetXaxis.valueof();
}
if (single_value->field_offsetYaxis.is_bound()) {
ret_val.offsetYaxis() = single_value->field_offsetYaxis.valueof();
}
if (single_value->field_rotateXY.is_omit()) ret_val.rotateXY() = OMIT_VALUE;
else if (single_value->field_rotateXY.is_bound()) {
ret_val.rotateXY() = single_value->field_rotateXY.valueof();
}
if (single_value->field_scaleXaxis.is_omit()) ret_val.scaleXaxis() = OMIT_VALUE;
else if (single_value->field_scaleXaxis.is_bound()) {
ret_val.scaleXaxis() = single_value->field_scaleXaxis.valueof();
}
if (single_value->field_scaleYaxis.is_omit()) ret_val.scaleYaxis() = OMIT_VALUE;
else if (single_value->field_scaleYaxis.is_bound()) {
ret_val.scaleYaxis() = single_value->field_scaleYaxis.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void ComputedLane_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.ComputedLane.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ComputedLane_template[list_length];
}

ComputedLane_template& ComputedLane_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.ComputedLane.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.ComputedLane.");
return value_list.list_value[list_index];
}

INTEGER_template& ComputedLane_template::referenceLaneId()
{
set_specific();
return single_value->field_referenceLaneId;
}

const INTEGER_template& ComputedLane_template::referenceLaneId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field referenceLaneId of a non-specific template of type @DSRC.ComputedLane.");
return single_value->field_referenceLaneId;
}

ComputedLane_offsetXaxis_template& ComputedLane_template::offsetXaxis()
{
set_specific();
return single_value->field_offsetXaxis;
}

const ComputedLane_offsetXaxis_template& ComputedLane_template::offsetXaxis() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field offsetXaxis of a non-specific template of type @DSRC.ComputedLane.");
return single_value->field_offsetXaxis;
}

ComputedLane_offsetYaxis_template& ComputedLane_template::offsetYaxis()
{
set_specific();
return single_value->field_offsetYaxis;
}

const ComputedLane_offsetYaxis_template& ComputedLane_template::offsetYaxis() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field offsetYaxis of a non-specific template of type @DSRC.ComputedLane.");
return single_value->field_offsetYaxis;
}

INTEGER_template& ComputedLane_template::rotateXY()
{
set_specific();
return single_value->field_rotateXY;
}

const INTEGER_template& ComputedLane_template::rotateXY() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rotateXY of a non-specific template of type @DSRC.ComputedLane.");
return single_value->field_rotateXY;
}

INTEGER_template& ComputedLane_template::scaleXaxis()
{
set_specific();
return single_value->field_scaleXaxis;
}

const INTEGER_template& ComputedLane_template::scaleXaxis() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field scaleXaxis of a non-specific template of type @DSRC.ComputedLane.");
return single_value->field_scaleXaxis;
}

INTEGER_template& ComputedLane_template::scaleYaxis()
{
set_specific();
return single_value->field_scaleYaxis;
}

const INTEGER_template& ComputedLane_template::scaleYaxis() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field scaleYaxis of a non-specific template of type @DSRC.ComputedLane.");
return single_value->field_scaleYaxis;
}

REGION::Reg__ComputedLane_template& ComputedLane_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REGION::Reg__ComputedLane_template& ComputedLane_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.ComputedLane.");
return single_value->field_regional;
}

int ComputedLane_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.ComputedLane which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 3;
      if (single_value->field_rotateXY.is_present()) ret_val++;
      if (single_value->field_scaleXaxis.is_present()) ret_val++;
      if (single_value->field_scaleYaxis.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.ComputedLane containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.ComputedLane containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.ComputedLane containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.ComputedLane containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.ComputedLane containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.ComputedLane.");
  }
  return 0;
}

void ComputedLane_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ referenceLaneId := ");
single_value->field_referenceLaneId.log();
TTCN_Logger::log_event_str(", offsetXaxis := ");
single_value->field_offsetXaxis.log();
TTCN_Logger::log_event_str(", offsetYaxis := ");
single_value->field_offsetYaxis.log();
TTCN_Logger::log_event_str(", rotateXY := ");
single_value->field_rotateXY.log();
TTCN_Logger::log_event_str(", scaleXaxis := ");
single_value->field_scaleXaxis.log();
TTCN_Logger::log_event_str(", scaleYaxis := ");
single_value->field_scaleYaxis.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ComputedLane_template::log_match(const ComputedLane& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_referenceLaneId.match(match_value.referenceLaneId(), legacy)){
TTCN_Logger::log_logmatch_info(".referenceLaneId");
single_value->field_referenceLaneId.log_match(match_value.referenceLaneId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_offsetXaxis.match(match_value.offsetXaxis(), legacy)){
TTCN_Logger::log_logmatch_info(".offsetXaxis");
single_value->field_offsetXaxis.log_match(match_value.offsetXaxis(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_offsetYaxis.match(match_value.offsetYaxis(), legacy)){
TTCN_Logger::log_logmatch_info(".offsetYaxis");
single_value->field_offsetYaxis.log_match(match_value.offsetYaxis(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.rotateXY().ispresent()){
if(!single_value->field_rotateXY.match(match_value.rotateXY(), legacy)){
TTCN_Logger::log_logmatch_info(".rotateXY");
single_value->field_rotateXY.log_match(match_value.rotateXY(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_rotateXY.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".rotateXY := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_rotateXY.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.scaleXaxis().ispresent()){
if(!single_value->field_scaleXaxis.match(match_value.scaleXaxis(), legacy)){
TTCN_Logger::log_logmatch_info(".scaleXaxis");
single_value->field_scaleXaxis.log_match(match_value.scaleXaxis(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_scaleXaxis.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".scaleXaxis := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_scaleXaxis.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.scaleYaxis().ispresent()){
if(!single_value->field_scaleYaxis.match(match_value.scaleYaxis(), legacy)){
TTCN_Logger::log_logmatch_info(".scaleYaxis");
single_value->field_scaleYaxis.log_match(match_value.scaleYaxis(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_scaleYaxis.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".scaleYaxis := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_scaleYaxis.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ referenceLaneId := ");
single_value->field_referenceLaneId.log_match(match_value.referenceLaneId(), legacy);
TTCN_Logger::log_event_str(", offsetXaxis := ");
single_value->field_offsetXaxis.log_match(match_value.offsetXaxis(), legacy);
TTCN_Logger::log_event_str(", offsetYaxis := ");
single_value->field_offsetYaxis.log_match(match_value.offsetYaxis(), legacy);
TTCN_Logger::log_event_str(", rotateXY := ");
if (match_value.rotateXY().ispresent()) single_value->field_rotateXY.log_match(match_value.rotateXY(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_rotateXY.log();
if (single_value->field_rotateXY.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", scaleXaxis := ");
if (match_value.scaleXaxis().ispresent()) single_value->field_scaleXaxis.log_match(match_value.scaleXaxis(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_scaleXaxis.log();
if (single_value->field_scaleXaxis.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", scaleYaxis := ");
if (match_value.scaleYaxis().ispresent()) single_value->field_scaleYaxis.log_match(match_value.scaleYaxis(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_scaleYaxis.log();
if (single_value->field_scaleYaxis.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ComputedLane_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_referenceLaneId.encode_text(text_buf);
single_value->field_offsetXaxis.encode_text(text_buf);
single_value->field_offsetYaxis.encode_text(text_buf);
single_value->field_rotateXY.encode_text(text_buf);
single_value->field_scaleXaxis.encode_text(text_buf);
single_value->field_scaleYaxis.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.ComputedLane.");
}
}

void ComputedLane_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_referenceLaneId.decode_text(text_buf);
single_value->field_offsetXaxis.decode_text(text_buf);
single_value->field_offsetYaxis.decode_text(text_buf);
single_value->field_rotateXY.decode_text(text_buf);
single_value->field_scaleXaxis.decode_text(text_buf);
single_value->field_scaleYaxis.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ComputedLane_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.ComputedLane.");
}
}

void ComputedLane_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.ComputedLane'");
    }
    if (strcmp("referenceLaneId", param_field) == 0) {
      referenceLaneId().set_param(param);
      return;
    } else if (strcmp("offsetXaxis", param_field) == 0) {
      offsetXaxis().set_param(param);
      return;
    } else if (strcmp("offsetYaxis", param_field) == 0) {
      offsetYaxis().set_param(param);
      return;
    } else if (strcmp("rotateXY", param_field) == 0) {
      rotateXY().set_param(param);
      return;
    } else if (strcmp("scaleXaxis", param_field) == 0) {
      scaleXaxis().set_param(param);
      return;
    } else if (strcmp("scaleYaxis", param_field) == 0) {
      scaleYaxis().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.ComputedLane'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ComputedLane_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record template of type @DSRC.ComputedLane has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) referenceLaneId().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) offsetXaxis().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) offsetYaxis().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) rotateXY().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) scaleXaxis().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) scaleYaxis().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "referenceLaneId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          referenceLaneId().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "offsetXaxis")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          offsetXaxis().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "offsetYaxis")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          offsetYaxis().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rotateXY")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rotateXY().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "scaleXaxis")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          scaleXaxis().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "scaleYaxis")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          scaleYaxis().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.ComputedLane: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.ComputedLane");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ComputedLane_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.ComputedLane'");
    }
    if (strcmp("referenceLaneId", param_field) == 0) {
      return referenceLaneId().get_param(param_name);
    } else if (strcmp("offsetXaxis", param_field) == 0) {
      return offsetXaxis().get_param(param_name);
    } else if (strcmp("offsetYaxis", param_field) == 0) {
      return offsetYaxis().get_param(param_name);
    } else if (strcmp("rotateXY", param_field) == 0) {
      return rotateXY().get_param(param_name);
    } else if (strcmp("scaleXaxis", param_field) == 0) {
      return scaleXaxis().get_param(param_name);
    } else if (strcmp("scaleYaxis", param_field) == 0) {
      return scaleYaxis().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.ComputedLane'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_referenceLaneId = single_value->field_referenceLaneId.get_param(param_name);
    mp_field_referenceLaneId->set_id(new Module_Param_FieldName(mcopystr("referenceLaneId")));
    mp->add_elem(mp_field_referenceLaneId);
    Module_Param* mp_field_offsetXaxis = single_value->field_offsetXaxis.get_param(param_name);
    mp_field_offsetXaxis->set_id(new Module_Param_FieldName(mcopystr("offsetXaxis")));
    mp->add_elem(mp_field_offsetXaxis);
    Module_Param* mp_field_offsetYaxis = single_value->field_offsetYaxis.get_param(param_name);
    mp_field_offsetYaxis->set_id(new Module_Param_FieldName(mcopystr("offsetYaxis")));
    mp->add_elem(mp_field_offsetYaxis);
    Module_Param* mp_field_rotateXY = single_value->field_rotateXY.get_param(param_name);
    mp_field_rotateXY->set_id(new Module_Param_FieldName(mcopystr("rotateXY")));
    mp->add_elem(mp_field_rotateXY);
    Module_Param* mp_field_scaleXaxis = single_value->field_scaleXaxis.get_param(param_name);
    mp_field_scaleXaxis->set_id(new Module_Param_FieldName(mcopystr("scaleXaxis")));
    mp->add_elem(mp_field_scaleXaxis);
    Module_Param* mp_field_scaleYaxis = single_value->field_scaleYaxis.get_param(param_name);
    mp_field_scaleYaxis->set_id(new Module_Param_FieldName(mcopystr("scaleYaxis")));
    mp->add_elem(mp_field_scaleYaxis);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ComputedLane_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_referenceLaneId.check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane");
single_value->field_offsetXaxis.check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane");
single_value->field_offsetYaxis.check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane");
single_value->field_rotateXY.check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane");
single_value->field_scaleXaxis.check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane");
single_value->field_scaleYaxis.check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.ComputedLane");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.ComputedLane");
}

boolean ComputedLane_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ComputedLane_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GenericLane::GenericLane()
{
  bound_flag = FALSE;
}

GenericLane::GenericLane(const INTEGER& par_laneID,
    const OPTIONAL<CHARSTRING>& par_name,
    const OPTIONAL<INTEGER>& par_ingressApproach,
    const OPTIONAL<INTEGER>& par_egressApproach,
    const LaneAttributes& par_laneAttributes,
    const OPTIONAL<BITSTRING>& par_maneuvers,
    const NodeList2& par_nodeList,
    const OPTIONAL<ConnectsToList>& par_connectsTo,
    const OPTIONAL<OverlayLaneList>& par_overlays,
    const OPTIONAL<REGION::Reg__GenericLane>& par_regional)
  :   field_laneID(par_laneID),
  field_name(par_name),
  field_ingressApproach(par_ingressApproach),
  field_egressApproach(par_egressApproach),
  field_laneAttributes(par_laneAttributes),
  field_maneuvers(par_maneuvers),
  field_nodeList(par_nodeList),
  field_connectsTo(par_connectsTo),
  field_overlays(par_overlays),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

GenericLane::GenericLane(const GenericLane& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.GenericLane.");
bound_flag = TRUE;
if (other_value.laneID().is_bound()) field_laneID = other_value.laneID();
else field_laneID.clean_up();
if (other_value.name().is_bound()) field_name = other_value.name();
else field_name.clean_up();
if (other_value.ingressApproach().is_bound()) field_ingressApproach = other_value.ingressApproach();
else field_ingressApproach.clean_up();
if (other_value.egressApproach().is_bound()) field_egressApproach = other_value.egressApproach();
else field_egressApproach.clean_up();
if (other_value.laneAttributes().is_bound()) field_laneAttributes = other_value.laneAttributes();
else field_laneAttributes.clean_up();
if (other_value.maneuvers().is_bound()) field_maneuvers = other_value.maneuvers();
else field_maneuvers.clean_up();
if (other_value.nodeList().is_bound()) field_nodeList = other_value.nodeList();
else field_nodeList.clean_up();
if (other_value.connectsTo().is_bound()) field_connectsTo = other_value.connectsTo();
else field_connectsTo.clean_up();
if (other_value.overlays().is_bound()) field_overlays = other_value.overlays();
else field_overlays.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void GenericLane::clean_up()
{
field_laneID.clean_up();
field_name.clean_up();
field_ingressApproach.clean_up();
field_egressApproach.clean_up();
field_laneAttributes.clean_up();
field_maneuvers.clean_up();
field_nodeList.clean_up();
field_connectsTo.clean_up();
field_overlays.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

GenericLane& GenericLane::operator=(const GenericLane& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.GenericLane.");
  bound_flag = TRUE;
  if (other_value.laneID().is_bound()) field_laneID = other_value.laneID();
  else field_laneID.clean_up();
  if (other_value.name().is_bound()) field_name = other_value.name();
  else field_name.clean_up();
  if (other_value.ingressApproach().is_bound()) field_ingressApproach = other_value.ingressApproach();
  else field_ingressApproach.clean_up();
  if (other_value.egressApproach().is_bound()) field_egressApproach = other_value.egressApproach();
  else field_egressApproach.clean_up();
  if (other_value.laneAttributes().is_bound()) field_laneAttributes = other_value.laneAttributes();
  else field_laneAttributes.clean_up();
  if (other_value.maneuvers().is_bound()) field_maneuvers = other_value.maneuvers();
  else field_maneuvers.clean_up();
  if (other_value.nodeList().is_bound()) field_nodeList = other_value.nodeList();
  else field_nodeList.clean_up();
  if (other_value.connectsTo().is_bound()) field_connectsTo = other_value.connectsTo();
  else field_connectsTo.clean_up();
  if (other_value.overlays().is_bound()) field_overlays = other_value.overlays();
  else field_overlays.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean GenericLane::operator==(const GenericLane& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_laneID==other_value.field_laneID
  && field_name==other_value.field_name
  && field_ingressApproach==other_value.field_ingressApproach
  && field_egressApproach==other_value.field_egressApproach
  && field_laneAttributes==other_value.field_laneAttributes
  && field_maneuvers==other_value.field_maneuvers
  && field_nodeList==other_value.field_nodeList
  && field_connectsTo==other_value.field_connectsTo
  && field_overlays==other_value.field_overlays
  && field_regional==other_value.field_regional;
}

boolean GenericLane::is_bound() const
{
if (bound_flag) return TRUE;
if(field_laneID.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_name.get_selection() || field_name.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ingressApproach.get_selection() || field_ingressApproach.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_egressApproach.get_selection() || field_egressApproach.is_bound()) return TRUE;
if(field_laneAttributes.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_maneuvers.get_selection() || field_maneuvers.is_bound()) return TRUE;
if(field_nodeList.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_connectsTo.get_selection() || field_connectsTo.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_overlays.get_selection() || field_overlays.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean GenericLane::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_laneID.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_name.get_selection() && !field_name.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ingressApproach.get_selection() && !field_ingressApproach.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_egressApproach.get_selection() && !field_egressApproach.is_value()) return FALSE;
if(!field_laneAttributes.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_maneuvers.get_selection() && !field_maneuvers.is_value()) return FALSE;
if(!field_nodeList.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_connectsTo.get_selection() && !field_connectsTo.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_overlays.get_selection() && !field_overlays.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int GenericLane::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.GenericLane");
  int ret_val = 3;
  if (field_name.ispresent()) ret_val++;
  if (field_ingressApproach.ispresent()) ret_val++;
  if (field_egressApproach.ispresent()) ret_val++;
  if (field_maneuvers.ispresent()) ret_val++;
  if (field_connectsTo.ispresent()) ret_val++;
  if (field_overlays.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void GenericLane::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ laneID := ");
field_laneID.log();
TTCN_Logger::log_event_str(", name := ");
field_name.log();
TTCN_Logger::log_event_str(", ingressApproach := ");
field_ingressApproach.log();
TTCN_Logger::log_event_str(", egressApproach := ");
field_egressApproach.log();
TTCN_Logger::log_event_str(", laneAttributes := ");
field_laneAttributes.log();
TTCN_Logger::log_event_str(", maneuvers := ");
field_maneuvers.log();
TTCN_Logger::log_event_str(", nodeList := ");
field_nodeList.log();
TTCN_Logger::log_event_str(", connectsTo := ");
field_connectsTo.log();
TTCN_Logger::log_event_str(", overlays := ");
field_overlays.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void GenericLane::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.GenericLane'");
    }
    if (strcmp("laneID", param_field) == 0) {
      laneID().set_param(param);
      return;
    } else if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("ingressApproach", param_field) == 0) {
      ingressApproach().set_param(param);
      return;
    } else if (strcmp("egressApproach", param_field) == 0) {
      egressApproach().set_param(param);
      return;
    } else if (strcmp("laneAttributes", param_field) == 0) {
      laneAttributes().set_param(param);
      return;
    } else if (strcmp("maneuvers", param_field) == 0) {
      maneuvers().set_param(param);
      return;
    } else if (strcmp("nodeList", param_field) == 0) {
      nodeList().set_param(param);
      return;
    } else if (strcmp("connectsTo", param_field) == 0) {
      connectsTo().set_param(param);
      return;
    } else if (strcmp("overlays", param_field) == 0) {
      overlays().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.GenericLane'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (10<mp->get_size()) {
      param.error("record value of type @DSRC.GenericLane has 10 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) laneID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ingressApproach().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) egressApproach().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) laneAttributes().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) maneuvers().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) nodeList().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) connectsTo().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) overlays().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(9));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ingressApproach")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ingressApproach().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "egressApproach")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          egressApproach().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneAttributes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneAttributes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maneuvers")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maneuvers().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nodeList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nodeList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connectsTo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connectsTo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "overlays")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          overlays().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.GenericLane: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.GenericLane");
  }
}

Module_Param* GenericLane::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.GenericLane'");
    }
    if (strcmp("laneID", param_field) == 0) {
      return laneID().get_param(param_name);
    } else if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("ingressApproach", param_field) == 0) {
      return ingressApproach().get_param(param_name);
    } else if (strcmp("egressApproach", param_field) == 0) {
      return egressApproach().get_param(param_name);
    } else if (strcmp("laneAttributes", param_field) == 0) {
      return laneAttributes().get_param(param_name);
    } else if (strcmp("maneuvers", param_field) == 0) {
      return maneuvers().get_param(param_name);
    } else if (strcmp("nodeList", param_field) == 0) {
      return nodeList().get_param(param_name);
    } else if (strcmp("connectsTo", param_field) == 0) {
      return connectsTo().get_param(param_name);
    } else if (strcmp("overlays", param_field) == 0) {
      return overlays().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.GenericLane'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_laneID = field_laneID.get_param(param_name);
  mp_field_laneID->set_id(new Module_Param_FieldName(mcopystr("laneID")));
  mp->add_elem(mp_field_laneID);
  Module_Param* mp_field_name = field_name.get_param(param_name);
  mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
  mp->add_elem(mp_field_name);
  Module_Param* mp_field_ingressApproach = field_ingressApproach.get_param(param_name);
  mp_field_ingressApproach->set_id(new Module_Param_FieldName(mcopystr("ingressApproach")));
  mp->add_elem(mp_field_ingressApproach);
  Module_Param* mp_field_egressApproach = field_egressApproach.get_param(param_name);
  mp_field_egressApproach->set_id(new Module_Param_FieldName(mcopystr("egressApproach")));
  mp->add_elem(mp_field_egressApproach);
  Module_Param* mp_field_laneAttributes = field_laneAttributes.get_param(param_name);
  mp_field_laneAttributes->set_id(new Module_Param_FieldName(mcopystr("laneAttributes")));
  mp->add_elem(mp_field_laneAttributes);
  Module_Param* mp_field_maneuvers = field_maneuvers.get_param(param_name);
  mp_field_maneuvers->set_id(new Module_Param_FieldName(mcopystr("maneuvers")));
  mp->add_elem(mp_field_maneuvers);
  Module_Param* mp_field_nodeList = field_nodeList.get_param(param_name);
  mp_field_nodeList->set_id(new Module_Param_FieldName(mcopystr("nodeList")));
  mp->add_elem(mp_field_nodeList);
  Module_Param* mp_field_connectsTo = field_connectsTo.get_param(param_name);
  mp_field_connectsTo->set_id(new Module_Param_FieldName(mcopystr("connectsTo")));
  mp->add_elem(mp_field_connectsTo);
  Module_Param* mp_field_overlays = field_overlays.get_param(param_name);
  mp_field_overlays->set_id(new Module_Param_FieldName(mcopystr("overlays")));
  mp->add_elem(mp_field_overlays);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void GenericLane::set_implicit_omit()
{
if (laneID().is_bound()) laneID().set_implicit_omit();
if (!name().is_bound()) name() = OMIT_VALUE;
else name().set_implicit_omit();
if (!ingressApproach().is_bound()) ingressApproach() = OMIT_VALUE;
else ingressApproach().set_implicit_omit();
if (!egressApproach().is_bound()) egressApproach() = OMIT_VALUE;
else egressApproach().set_implicit_omit();
if (laneAttributes().is_bound()) laneAttributes().set_implicit_omit();
if (!maneuvers().is_bound()) maneuvers() = OMIT_VALUE;
else maneuvers().set_implicit_omit();
if (nodeList().is_bound()) nodeList().set_implicit_omit();
if (!connectsTo().is_bound()) connectsTo() = OMIT_VALUE;
else connectsTo().set_implicit_omit();
if (!overlays().is_bound()) overlays() = OMIT_VALUE;
else overlays().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void GenericLane::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.GenericLane.");
field_laneID.encode_text(text_buf);
field_name.encode_text(text_buf);
field_ingressApproach.encode_text(text_buf);
field_egressApproach.encode_text(text_buf);
field_laneAttributes.encode_text(text_buf);
field_maneuvers.encode_text(text_buf);
field_nodeList.encode_text(text_buf);
field_connectsTo.encode_text(text_buf);
field_overlays.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void GenericLane::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_laneID.decode_text(text_buf);
field_name.decode_text(text_buf);
field_ingressApproach.decode_text(text_buf);
field_egressApproach.decode_text(text_buf);
field_laneAttributes.decode_text(text_buf);
field_maneuvers.decode_text(text_buf);
field_nodeList.decode_text(text_buf);
field_connectsTo.decode_text(text_buf);
field_overlays.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void GenericLane::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GenericLane::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* GenericLane::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("laneID': ");
  new_tlv->add_TLV(field_laneID.BER_encode_TLV(GenericLane_laneID_descr_, p_coding));
  ec_1.set_msg("name': ");
  new_tlv->add_TLV(field_name.BER_encode_TLV(GenericLane_name_descr_, p_coding));
  ec_1.set_msg("ingressApproach': ");
  new_tlv->add_TLV(field_ingressApproach.BER_encode_TLV(GenericLane_ingressApproach_descr_, p_coding));
  ec_1.set_msg("egressApproach': ");
  new_tlv->add_TLV(field_egressApproach.BER_encode_TLV(GenericLane_egressApproach_descr_, p_coding));
  ec_1.set_msg("laneAttributes': ");
  new_tlv->add_TLV(field_laneAttributes.BER_encode_TLV(GenericLane_laneAttributes_descr_, p_coding));
  ec_1.set_msg("maneuvers': ");
  new_tlv->add_TLV(field_maneuvers.BER_encode_TLV(GenericLane_maneuvers_descr_, p_coding));
  ec_1.set_msg("nodeList': ");
  new_tlv->add_TLV(field_nodeList.BER_encode_TLV(GenericLane_nodeList_descr_, p_coding));
  ec_1.set_msg("connectsTo': ");
  new_tlv->add_TLV(field_connectsTo.BER_encode_TLV(GenericLane_connectsTo_descr_, p_coding));
  ec_1.set_msg("overlays': ");
  new_tlv->add_TLV(field_overlays.BER_encode_TLV(GenericLane_overlays_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(GenericLane_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean GenericLane::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.GenericLane' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("laneID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_laneID.BER_decode_TLV(GenericLane_laneID_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("name': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_name=OMIT_VALUE;
    else {
      field_name.BER_decode_TLV(GenericLane_name_descr_, tmp_tlv, L_form);
      if(field_name.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("ingressApproach': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_ingressApproach=OMIT_VALUE;
    else {
      field_ingressApproach.BER_decode_TLV(GenericLane_ingressApproach_descr_, tmp_tlv, L_form);
      if(field_ingressApproach.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("egressApproach': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_egressApproach=OMIT_VALUE;
    else {
      field_egressApproach.BER_decode_TLV(GenericLane_egressApproach_descr_, tmp_tlv, L_form);
      if(field_egressApproach.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("laneAttributes': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_laneAttributes.BER_decode_TLV(GenericLane_laneAttributes_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("maneuvers': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_maneuvers=OMIT_VALUE;
    else {
      field_maneuvers.BER_decode_TLV(GenericLane_maneuvers_descr_, tmp_tlv, L_form);
      if(field_maneuvers.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("nodeList': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_nodeList.BER_decode_TLV(GenericLane_nodeList_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("connectsTo': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_connectsTo=OMIT_VALUE;
    else {
      field_connectsTo.BER_decode_TLV(GenericLane_connectsTo_descr_, tmp_tlv, L_form);
      if(field_connectsTo.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("overlays': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_overlays=OMIT_VALUE;
    else {
      field_overlays.BER_decode_TLV(GenericLane_overlays_descr_, tmp_tlv, L_form);
      if(field_overlays.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(GenericLane_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int GenericLane::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.GenericLane.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneID");
    enc_len += field_laneID.JSON_encode(GenericLane_laneID_descr_, p_tok);
  }

  if (field_name.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "name");
    enc_len += field_name.JSON_encode(GenericLane_name_descr_, p_tok);
  }

  if (field_ingressApproach.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ingressApproach");
    enc_len += field_ingressApproach.JSON_encode(GenericLane_ingressApproach_descr_, p_tok);
  }

  if (field_egressApproach.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "egressApproach");
    enc_len += field_egressApproach.JSON_encode(GenericLane_egressApproach_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneAttributes");
    enc_len += field_laneAttributes.JSON_encode(GenericLane_laneAttributes_descr_, p_tok);
  }

  if (field_maneuvers.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "maneuvers");
    enc_len += field_maneuvers.JSON_encode(GenericLane_maneuvers_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nodeList");
    enc_len += field_nodeList.JSON_encode(GenericLane_nodeList_descr_, p_tok);
  }

  if (field_connectsTo.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "connectsTo");
    enc_len += field_connectsTo.JSON_encode(GenericLane_connectsTo_descr_, p_tok);
  }

  if (field_overlays.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "overlays");
    enc_len += field_overlays.JSON_encode(GenericLane_overlays_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(GenericLane_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GenericLane::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "laneID", name_len)) {
         int ret_val = field_laneID.JSON_decode(GenericLane_laneID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "name", name_len)) {
         int ret_val = field_name.JSON_decode(GenericLane_name_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "name");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "ingressApproach", name_len)) {
         int ret_val = field_ingressApproach.JSON_decode(GenericLane_ingressApproach_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ingressApproach");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "egressApproach", name_len)) {
         int ret_val = field_egressApproach.JSON_decode(GenericLane_egressApproach_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "egressApproach");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "laneAttributes", name_len)) {
         int ret_val = field_laneAttributes.JSON_decode(GenericLane_laneAttributes_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneAttributes");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "maneuvers", name_len)) {
         int ret_val = field_maneuvers.JSON_decode(GenericLane_maneuvers_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "maneuvers");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "nodeList", name_len)) {
         int ret_val = field_nodeList.JSON_decode(GenericLane_nodeList_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nodeList");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "connectsTo", name_len)) {
         int ret_val = field_connectsTo.JSON_decode(GenericLane_connectsTo_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "connectsTo");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "overlays", name_len)) {
         int ret_val = field_overlays.JSON_decode(GenericLane_overlays_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "overlays");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(GenericLane_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_laneID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "laneID");
    return JSON_ERROR_FATAL;
  }
if (!field_name.is_bound()) {
    field_name = OMIT_VALUE;
  }
if (!field_ingressApproach.is_bound()) {
    field_ingressApproach = OMIT_VALUE;
  }
if (!field_egressApproach.is_bound()) {
    field_egressApproach = OMIT_VALUE;
  }
if (!field_laneAttributes.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "laneAttributes");
    return JSON_ERROR_FATAL;
  }
if (!field_maneuvers.is_bound()) {
    field_maneuvers = OMIT_VALUE;
  }
if (!field_nodeList.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nodeList");
    return JSON_ERROR_FATAL;
  }
if (!field_connectsTo.is_bound()) {
    field_connectsTo = OMIT_VALUE;
  }
if (!field_overlays.is_bound()) {
    field_overlays = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct GenericLane_template::single_value_struct {
INTEGER_template field_laneID;
CHARSTRING_template field_name;
INTEGER_template field_ingressApproach;
INTEGER_template field_egressApproach;
LaneAttributes_template field_laneAttributes;
BITSTRING_template field_maneuvers;
NodeList2_template field_nodeList;
ConnectsToList_template field_connectsTo;
OverlayLaneList_template field_overlays;
REGION::Reg__GenericLane_template field_regional;
};

void GenericLane_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_laneID = ANY_VALUE;
single_value->field_name = ANY_OR_OMIT;
single_value->field_ingressApproach = ANY_OR_OMIT;
single_value->field_egressApproach = ANY_OR_OMIT;
single_value->field_laneAttributes = ANY_VALUE;
single_value->field_maneuvers = ANY_OR_OMIT;
single_value->field_nodeList = ANY_VALUE;
single_value->field_connectsTo = ANY_OR_OMIT;
single_value->field_overlays = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void GenericLane_template::copy_value(const GenericLane& other_value)
{
single_value = new single_value_struct;
if (other_value.laneID().is_bound()) {
  single_value->field_laneID = other_value.laneID();
} else {
  single_value->field_laneID.clean_up();
}
if (other_value.name().is_bound()) {
  if (other_value.name().ispresent()) single_value->field_name = other_value.name()();
  else single_value->field_name = OMIT_VALUE;
} else {
  single_value->field_name.clean_up();
}
if (other_value.ingressApproach().is_bound()) {
  if (other_value.ingressApproach().ispresent()) single_value->field_ingressApproach = other_value.ingressApproach()();
  else single_value->field_ingressApproach = OMIT_VALUE;
} else {
  single_value->field_ingressApproach.clean_up();
}
if (other_value.egressApproach().is_bound()) {
  if (other_value.egressApproach().ispresent()) single_value->field_egressApproach = other_value.egressApproach()();
  else single_value->field_egressApproach = OMIT_VALUE;
} else {
  single_value->field_egressApproach.clean_up();
}
if (other_value.laneAttributes().is_bound()) {
  single_value->field_laneAttributes = other_value.laneAttributes();
} else {
  single_value->field_laneAttributes.clean_up();
}
if (other_value.maneuvers().is_bound()) {
  if (other_value.maneuvers().ispresent()) single_value->field_maneuvers = other_value.maneuvers()();
  else single_value->field_maneuvers = OMIT_VALUE;
} else {
  single_value->field_maneuvers.clean_up();
}
if (other_value.nodeList().is_bound()) {
  single_value->field_nodeList = other_value.nodeList();
} else {
  single_value->field_nodeList.clean_up();
}
if (other_value.connectsTo().is_bound()) {
  if (other_value.connectsTo().ispresent()) single_value->field_connectsTo = other_value.connectsTo()();
  else single_value->field_connectsTo = OMIT_VALUE;
} else {
  single_value->field_connectsTo.clean_up();
}
if (other_value.overlays().is_bound()) {
  if (other_value.overlays().ispresent()) single_value->field_overlays = other_value.overlays()();
  else single_value->field_overlays = OMIT_VALUE;
} else {
  single_value->field_overlays.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GenericLane_template::copy_template(const GenericLane_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.laneID().get_selection()) {
single_value->field_laneID = other_value.laneID();
} else {
single_value->field_laneID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.name().get_selection()) {
single_value->field_name = other_value.name();
} else {
single_value->field_name.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ingressApproach().get_selection()) {
single_value->field_ingressApproach = other_value.ingressApproach();
} else {
single_value->field_ingressApproach.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.egressApproach().get_selection()) {
single_value->field_egressApproach = other_value.egressApproach();
} else {
single_value->field_egressApproach.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.laneAttributes().get_selection()) {
single_value->field_laneAttributes = other_value.laneAttributes();
} else {
single_value->field_laneAttributes.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.maneuvers().get_selection()) {
single_value->field_maneuvers = other_value.maneuvers();
} else {
single_value->field_maneuvers.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nodeList().get_selection()) {
single_value->field_nodeList = other_value.nodeList();
} else {
single_value->field_nodeList.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.connectsTo().get_selection()) {
single_value->field_connectsTo = other_value.connectsTo();
} else {
single_value->field_connectsTo.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.overlays().get_selection()) {
single_value->field_overlays = other_value.overlays();
} else {
single_value->field_overlays.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GenericLane_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.GenericLane.");
break;
}
set_selection(other_value);
}

GenericLane_template::GenericLane_template()
{
}

GenericLane_template::GenericLane_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GenericLane_template::GenericLane_template(const GenericLane& other_value)
{
copy_value(other_value);
}

GenericLane_template::GenericLane_template(const OPTIONAL<GenericLane>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenericLane&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.GenericLane from an unbound optional field.");
}
}

GenericLane_template::GenericLane_template(const GenericLane_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GenericLane_template::~GenericLane_template()
{
clean_up();
}

GenericLane_template& GenericLane_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GenericLane_template& GenericLane_template::operator=(const GenericLane& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GenericLane_template& GenericLane_template::operator=(const OPTIONAL<GenericLane>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenericLane&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.GenericLane.");
}
return *this;
}

GenericLane_template& GenericLane_template::operator=(const GenericLane_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GenericLane_template::match(const GenericLane& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.laneID().is_bound()) return FALSE;
if(!single_value->field_laneID.match(other_value.laneID(), legacy))return FALSE;
if(!other_value.name().is_bound()) return FALSE;
if((other_value.name().ispresent() ? !single_value->field_name.match((const CHARSTRING&)other_value.name(), legacy) : !single_value->field_name.match_omit(legacy)))return FALSE;
if(!other_value.ingressApproach().is_bound()) return FALSE;
if((other_value.ingressApproach().ispresent() ? !single_value->field_ingressApproach.match((const INTEGER&)other_value.ingressApproach(), legacy) : !single_value->field_ingressApproach.match_omit(legacy)))return FALSE;
if(!other_value.egressApproach().is_bound()) return FALSE;
if((other_value.egressApproach().ispresent() ? !single_value->field_egressApproach.match((const INTEGER&)other_value.egressApproach(), legacy) : !single_value->field_egressApproach.match_omit(legacy)))return FALSE;
if(!other_value.laneAttributes().is_bound()) return FALSE;
if(!single_value->field_laneAttributes.match(other_value.laneAttributes(), legacy))return FALSE;
if(!other_value.maneuvers().is_bound()) return FALSE;
if((other_value.maneuvers().ispresent() ? !single_value->field_maneuvers.match((const BITSTRING&)other_value.maneuvers(), legacy) : !single_value->field_maneuvers.match_omit(legacy)))return FALSE;
if(!other_value.nodeList().is_bound()) return FALSE;
if(!single_value->field_nodeList.match(other_value.nodeList(), legacy))return FALSE;
if(!other_value.connectsTo().is_bound()) return FALSE;
if((other_value.connectsTo().ispresent() ? !single_value->field_connectsTo.match((const ConnectsToList&)other_value.connectsTo(), legacy) : !single_value->field_connectsTo.match_omit(legacy)))return FALSE;
if(!other_value.overlays().is_bound()) return FALSE;
if((other_value.overlays().ispresent() ? !single_value->field_overlays.match((const OverlayLaneList&)other_value.overlays(), legacy) : !single_value->field_overlays.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REGION::Reg__GenericLane&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.GenericLane.");
}
return FALSE;
}

boolean GenericLane_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_laneID.is_bound()) return TRUE;
if (single_value->field_name.is_omit() || single_value->field_name.is_bound()) return TRUE;
if (single_value->field_ingressApproach.is_omit() || single_value->field_ingressApproach.is_bound()) return TRUE;
if (single_value->field_egressApproach.is_omit() || single_value->field_egressApproach.is_bound()) return TRUE;
if (single_value->field_laneAttributes.is_bound()) return TRUE;
if (single_value->field_maneuvers.is_omit() || single_value->field_maneuvers.is_bound()) return TRUE;
if (single_value->field_nodeList.is_bound()) return TRUE;
if (single_value->field_connectsTo.is_omit() || single_value->field_connectsTo.is_bound()) return TRUE;
if (single_value->field_overlays.is_omit() || single_value->field_overlays.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean GenericLane_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_laneID.is_value()) return FALSE;
if (!single_value->field_name.is_omit() && !single_value->field_name.is_value()) return FALSE;
if (!single_value->field_ingressApproach.is_omit() && !single_value->field_ingressApproach.is_value()) return FALSE;
if (!single_value->field_egressApproach.is_omit() && !single_value->field_egressApproach.is_value()) return FALSE;
if (!single_value->field_laneAttributes.is_value()) return FALSE;
if (!single_value->field_maneuvers.is_omit() && !single_value->field_maneuvers.is_value()) return FALSE;
if (!single_value->field_nodeList.is_value()) return FALSE;
if (!single_value->field_connectsTo.is_omit() && !single_value->field_connectsTo.is_value()) return FALSE;
if (!single_value->field_overlays.is_omit() && !single_value->field_overlays.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void GenericLane_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GenericLane GenericLane_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.GenericLane.");
GenericLane ret_val;
if (single_value->field_laneID.is_bound()) {
ret_val.laneID() = single_value->field_laneID.valueof();
}
if (single_value->field_name.is_omit()) ret_val.name() = OMIT_VALUE;
else if (single_value->field_name.is_bound()) {
ret_val.name() = single_value->field_name.valueof();
}
if (single_value->field_ingressApproach.is_omit()) ret_val.ingressApproach() = OMIT_VALUE;
else if (single_value->field_ingressApproach.is_bound()) {
ret_val.ingressApproach() = single_value->field_ingressApproach.valueof();
}
if (single_value->field_egressApproach.is_omit()) ret_val.egressApproach() = OMIT_VALUE;
else if (single_value->field_egressApproach.is_bound()) {
ret_val.egressApproach() = single_value->field_egressApproach.valueof();
}
if (single_value->field_laneAttributes.is_bound()) {
ret_val.laneAttributes() = single_value->field_laneAttributes.valueof();
}
if (single_value->field_maneuvers.is_omit()) ret_val.maneuvers() = OMIT_VALUE;
else if (single_value->field_maneuvers.is_bound()) {
ret_val.maneuvers() = single_value->field_maneuvers.valueof();
}
if (single_value->field_nodeList.is_bound()) {
ret_val.nodeList() = single_value->field_nodeList.valueof();
}
if (single_value->field_connectsTo.is_omit()) ret_val.connectsTo() = OMIT_VALUE;
else if (single_value->field_connectsTo.is_bound()) {
ret_val.connectsTo() = single_value->field_connectsTo.valueof();
}
if (single_value->field_overlays.is_omit()) ret_val.overlays() = OMIT_VALUE;
else if (single_value->field_overlays.is_bound()) {
ret_val.overlays() = single_value->field_overlays.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void GenericLane_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.GenericLane.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GenericLane_template[list_length];
}

GenericLane_template& GenericLane_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.GenericLane.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.GenericLane.");
return value_list.list_value[list_index];
}

INTEGER_template& GenericLane_template::laneID()
{
set_specific();
return single_value->field_laneID;
}

const INTEGER_template& GenericLane_template::laneID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field laneID of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_laneID;
}

CHARSTRING_template& GenericLane_template::name()
{
set_specific();
return single_value->field_name;
}

const CHARSTRING_template& GenericLane_template::name() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field name of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_name;
}

INTEGER_template& GenericLane_template::ingressApproach()
{
set_specific();
return single_value->field_ingressApproach;
}

const INTEGER_template& GenericLane_template::ingressApproach() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ingressApproach of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_ingressApproach;
}

INTEGER_template& GenericLane_template::egressApproach()
{
set_specific();
return single_value->field_egressApproach;
}

const INTEGER_template& GenericLane_template::egressApproach() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field egressApproach of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_egressApproach;
}

LaneAttributes_template& GenericLane_template::laneAttributes()
{
set_specific();
return single_value->field_laneAttributes;
}

const LaneAttributes_template& GenericLane_template::laneAttributes() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field laneAttributes of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_laneAttributes;
}

BITSTRING_template& GenericLane_template::maneuvers()
{
set_specific();
return single_value->field_maneuvers;
}

const BITSTRING_template& GenericLane_template::maneuvers() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field maneuvers of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_maneuvers;
}

NodeList2_template& GenericLane_template::nodeList()
{
set_specific();
return single_value->field_nodeList;
}

const NodeList2_template& GenericLane_template::nodeList() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nodeList of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_nodeList;
}

ConnectsToList_template& GenericLane_template::connectsTo()
{
set_specific();
return single_value->field_connectsTo;
}

const ConnectsToList_template& GenericLane_template::connectsTo() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connectsTo of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_connectsTo;
}

OverlayLaneList_template& GenericLane_template::overlays()
{
set_specific();
return single_value->field_overlays;
}

const OverlayLaneList_template& GenericLane_template::overlays() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field overlays of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_overlays;
}

REGION::Reg__GenericLane_template& GenericLane_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REGION::Reg__GenericLane_template& GenericLane_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.GenericLane.");
return single_value->field_regional;
}

int GenericLane_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.GenericLane which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 3;
      if (single_value->field_name.is_present()) ret_val++;
      if (single_value->field_ingressApproach.is_present()) ret_val++;
      if (single_value->field_egressApproach.is_present()) ret_val++;
      if (single_value->field_maneuvers.is_present()) ret_val++;
      if (single_value->field_connectsTo.is_present()) ret_val++;
      if (single_value->field_overlays.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.GenericLane containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.GenericLane containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.GenericLane containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.GenericLane containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.GenericLane containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.GenericLane.");
  }
  return 0;
}

void GenericLane_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ laneID := ");
single_value->field_laneID.log();
TTCN_Logger::log_event_str(", name := ");
single_value->field_name.log();
TTCN_Logger::log_event_str(", ingressApproach := ");
single_value->field_ingressApproach.log();
TTCN_Logger::log_event_str(", egressApproach := ");
single_value->field_egressApproach.log();
TTCN_Logger::log_event_str(", laneAttributes := ");
single_value->field_laneAttributes.log();
TTCN_Logger::log_event_str(", maneuvers := ");
single_value->field_maneuvers.log();
TTCN_Logger::log_event_str(", nodeList := ");
single_value->field_nodeList.log();
TTCN_Logger::log_event_str(", connectsTo := ");
single_value->field_connectsTo.log();
TTCN_Logger::log_event_str(", overlays := ");
single_value->field_overlays.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GenericLane_template::log_match(const GenericLane& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_laneID.match(match_value.laneID(), legacy)){
TTCN_Logger::log_logmatch_info(".laneID");
single_value->field_laneID.log_match(match_value.laneID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.name().ispresent()){
if(!single_value->field_name.match(match_value.name(), legacy)){
TTCN_Logger::log_logmatch_info(".name");
single_value->field_name.log_match(match_value.name(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_name.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".name := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_name.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.ingressApproach().ispresent()){
if(!single_value->field_ingressApproach.match(match_value.ingressApproach(), legacy)){
TTCN_Logger::log_logmatch_info(".ingressApproach");
single_value->field_ingressApproach.log_match(match_value.ingressApproach(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ingressApproach.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ingressApproach := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ingressApproach.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.egressApproach().ispresent()){
if(!single_value->field_egressApproach.match(match_value.egressApproach(), legacy)){
TTCN_Logger::log_logmatch_info(".egressApproach");
single_value->field_egressApproach.log_match(match_value.egressApproach(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_egressApproach.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".egressApproach := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_egressApproach.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_laneAttributes.match(match_value.laneAttributes(), legacy)){
TTCN_Logger::log_logmatch_info(".laneAttributes");
single_value->field_laneAttributes.log_match(match_value.laneAttributes(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.maneuvers().ispresent()){
if(!single_value->field_maneuvers.match(match_value.maneuvers(), legacy)){
TTCN_Logger::log_logmatch_info(".maneuvers");
single_value->field_maneuvers.log_match(match_value.maneuvers(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_maneuvers.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".maneuvers := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_maneuvers.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_nodeList.match(match_value.nodeList(), legacy)){
TTCN_Logger::log_logmatch_info(".nodeList");
single_value->field_nodeList.log_match(match_value.nodeList(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.connectsTo().ispresent()){
if(!single_value->field_connectsTo.match(match_value.connectsTo(), legacy)){
TTCN_Logger::log_logmatch_info(".connectsTo");
single_value->field_connectsTo.log_match(match_value.connectsTo(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_connectsTo.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".connectsTo := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_connectsTo.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.overlays().ispresent()){
if(!single_value->field_overlays.match(match_value.overlays(), legacy)){
TTCN_Logger::log_logmatch_info(".overlays");
single_value->field_overlays.log_match(match_value.overlays(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_overlays.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".overlays := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_overlays.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ laneID := ");
single_value->field_laneID.log_match(match_value.laneID(), legacy);
TTCN_Logger::log_event_str(", name := ");
if (match_value.name().ispresent()) single_value->field_name.log_match(match_value.name(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_name.log();
if (single_value->field_name.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", ingressApproach := ");
if (match_value.ingressApproach().ispresent()) single_value->field_ingressApproach.log_match(match_value.ingressApproach(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ingressApproach.log();
if (single_value->field_ingressApproach.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", egressApproach := ");
if (match_value.egressApproach().ispresent()) single_value->field_egressApproach.log_match(match_value.egressApproach(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_egressApproach.log();
if (single_value->field_egressApproach.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", laneAttributes := ");
single_value->field_laneAttributes.log_match(match_value.laneAttributes(), legacy);
TTCN_Logger::log_event_str(", maneuvers := ");
if (match_value.maneuvers().ispresent()) single_value->field_maneuvers.log_match(match_value.maneuvers(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_maneuvers.log();
if (single_value->field_maneuvers.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", nodeList := ");
single_value->field_nodeList.log_match(match_value.nodeList(), legacy);
TTCN_Logger::log_event_str(", connectsTo := ");
if (match_value.connectsTo().ispresent()) single_value->field_connectsTo.log_match(match_value.connectsTo(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_connectsTo.log();
if (single_value->field_connectsTo.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", overlays := ");
if (match_value.overlays().ispresent()) single_value->field_overlays.log_match(match_value.overlays(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_overlays.log();
if (single_value->field_overlays.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GenericLane_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_laneID.encode_text(text_buf);
single_value->field_name.encode_text(text_buf);
single_value->field_ingressApproach.encode_text(text_buf);
single_value->field_egressApproach.encode_text(text_buf);
single_value->field_laneAttributes.encode_text(text_buf);
single_value->field_maneuvers.encode_text(text_buf);
single_value->field_nodeList.encode_text(text_buf);
single_value->field_connectsTo.encode_text(text_buf);
single_value->field_overlays.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.GenericLane.");
}
}

void GenericLane_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_laneID.decode_text(text_buf);
single_value->field_name.decode_text(text_buf);
single_value->field_ingressApproach.decode_text(text_buf);
single_value->field_egressApproach.decode_text(text_buf);
single_value->field_laneAttributes.decode_text(text_buf);
single_value->field_maneuvers.decode_text(text_buf);
single_value->field_nodeList.decode_text(text_buf);
single_value->field_connectsTo.decode_text(text_buf);
single_value->field_overlays.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GenericLane_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.GenericLane.");
}
}

void GenericLane_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.GenericLane'");
    }
    if (strcmp("laneID", param_field) == 0) {
      laneID().set_param(param);
      return;
    } else if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("ingressApproach", param_field) == 0) {
      ingressApproach().set_param(param);
      return;
    } else if (strcmp("egressApproach", param_field) == 0) {
      egressApproach().set_param(param);
      return;
    } else if (strcmp("laneAttributes", param_field) == 0) {
      laneAttributes().set_param(param);
      return;
    } else if (strcmp("maneuvers", param_field) == 0) {
      maneuvers().set_param(param);
      return;
    } else if (strcmp("nodeList", param_field) == 0) {
      nodeList().set_param(param);
      return;
    } else if (strcmp("connectsTo", param_field) == 0) {
      connectsTo().set_param(param);
      return;
    } else if (strcmp("overlays", param_field) == 0) {
      overlays().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.GenericLane'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GenericLane_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (10<mp->get_size()) {
      param.error("record template of type @DSRC.GenericLane has 10 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) laneID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ingressApproach().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) egressApproach().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) laneAttributes().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) maneuvers().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) nodeList().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) connectsTo().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) overlays().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(9));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ingressApproach")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ingressApproach().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "egressApproach")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          egressApproach().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneAttributes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneAttributes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maneuvers")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maneuvers().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nodeList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nodeList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connectsTo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connectsTo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "overlays")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          overlays().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.GenericLane: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.GenericLane");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GenericLane_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.GenericLane'");
    }
    if (strcmp("laneID", param_field) == 0) {
      return laneID().get_param(param_name);
    } else if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("ingressApproach", param_field) == 0) {
      return ingressApproach().get_param(param_name);
    } else if (strcmp("egressApproach", param_field) == 0) {
      return egressApproach().get_param(param_name);
    } else if (strcmp("laneAttributes", param_field) == 0) {
      return laneAttributes().get_param(param_name);
    } else if (strcmp("maneuvers", param_field) == 0) {
      return maneuvers().get_param(param_name);
    } else if (strcmp("nodeList", param_field) == 0) {
      return nodeList().get_param(param_name);
    } else if (strcmp("connectsTo", param_field) == 0) {
      return connectsTo().get_param(param_name);
    } else if (strcmp("overlays", param_field) == 0) {
      return overlays().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.GenericLane'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_laneID = single_value->field_laneID.get_param(param_name);
    mp_field_laneID->set_id(new Module_Param_FieldName(mcopystr("laneID")));
    mp->add_elem(mp_field_laneID);
    Module_Param* mp_field_name = single_value->field_name.get_param(param_name);
    mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
    mp->add_elem(mp_field_name);
    Module_Param* mp_field_ingressApproach = single_value->field_ingressApproach.get_param(param_name);
    mp_field_ingressApproach->set_id(new Module_Param_FieldName(mcopystr("ingressApproach")));
    mp->add_elem(mp_field_ingressApproach);
    Module_Param* mp_field_egressApproach = single_value->field_egressApproach.get_param(param_name);
    mp_field_egressApproach->set_id(new Module_Param_FieldName(mcopystr("egressApproach")));
    mp->add_elem(mp_field_egressApproach);
    Module_Param* mp_field_laneAttributes = single_value->field_laneAttributes.get_param(param_name);
    mp_field_laneAttributes->set_id(new Module_Param_FieldName(mcopystr("laneAttributes")));
    mp->add_elem(mp_field_laneAttributes);
    Module_Param* mp_field_maneuvers = single_value->field_maneuvers.get_param(param_name);
    mp_field_maneuvers->set_id(new Module_Param_FieldName(mcopystr("maneuvers")));
    mp->add_elem(mp_field_maneuvers);
    Module_Param* mp_field_nodeList = single_value->field_nodeList.get_param(param_name);
    mp_field_nodeList->set_id(new Module_Param_FieldName(mcopystr("nodeList")));
    mp->add_elem(mp_field_nodeList);
    Module_Param* mp_field_connectsTo = single_value->field_connectsTo.get_param(param_name);
    mp_field_connectsTo->set_id(new Module_Param_FieldName(mcopystr("connectsTo")));
    mp->add_elem(mp_field_connectsTo);
    Module_Param* mp_field_overlays = single_value->field_overlays.get_param(param_name);
    mp_field_overlays->set_id(new Module_Param_FieldName(mcopystr("overlays")));
    mp->add_elem(mp_field_overlays);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GenericLane_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_laneID.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
single_value->field_name.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
single_value->field_ingressApproach.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
single_value->field_egressApproach.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
single_value->field_laneAttributes.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
single_value->field_maneuvers.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
single_value->field_nodeList.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
single_value->field_connectsTo.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
single_value->field_overlays.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.GenericLane");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.GenericLane");
}

boolean GenericLane_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GenericLane_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const Connection ConnectsToList::UNBOUND_ELEM;
ConnectsToList::ConnectsToList()
{
val_ptr = NULL;
}

ConnectsToList::ConnectsToList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

ConnectsToList::ConnectsToList(const ConnectsToList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.ConnectsToList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

ConnectsToList::~ConnectsToList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void ConnectsToList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

ConnectsToList& ConnectsToList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

ConnectsToList& ConnectsToList::operator=(const ConnectsToList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.ConnectsToList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean ConnectsToList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.ConnectsToList.");
return val_ptr->n_elements == 0 ;
}

boolean ConnectsToList::operator==(const ConnectsToList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.ConnectsToList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.ConnectsToList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

Connection& ConnectsToList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.ConnectsToList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (Connection**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Connection(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new Connection;
}
return *val_ptr->value_elements[index_value];
}

Connection& ConnectsToList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.ConnectsToList.");
return (*this)[(int)index_value];
}

const Connection& ConnectsToList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.ConnectsToList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.ConnectsToList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.ConnectsToList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const Connection& ConnectsToList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.ConnectsToList.");
return (*this)[(int)index_value];
}

ConnectsToList ConnectsToList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

ConnectsToList ConnectsToList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

ConnectsToList ConnectsToList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

ConnectsToList ConnectsToList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.ConnectsToList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
ConnectsToList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new Connection(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

ConnectsToList ConnectsToList::operator+(const ConnectsToList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.ConnectsToList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
ConnectsToList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Connection(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new Connection(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

ConnectsToList ConnectsToList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.ConnectsToList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.ConnectsToList","element");
ConnectsToList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new Connection(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

ConnectsToList ConnectsToList::replace(int index, int len, const ConnectsToList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.ConnectsToList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.ConnectsToList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.ConnectsToList","element");
ConnectsToList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Connection(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new Connection(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new Connection(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

ConnectsToList ConnectsToList::replace(int index, int len, const ConnectsToList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void ConnectsToList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.ConnectsToList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (Connection**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Connection(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (Connection**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.ConnectsToList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (Connection**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean ConnectsToList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int ConnectsToList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.ConnectsToList.");
return val_ptr->n_elements;
}

int ConnectsToList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.ConnectsToList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void ConnectsToList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void ConnectsToList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.ConnectsToList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.ConnectsToList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.ConnectsToList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* ConnectsToList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.ConnectsToList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void ConnectsToList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void ConnectsToList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.ConnectsToList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void ConnectsToList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.ConnectsToList.");
val_ptr->value_elements = (Connection**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new Connection;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void ConnectsToList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ConnectsToList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ConnectsToList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ConnectsToList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (Connection**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new Connection;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int ConnectsToList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.ConnectsToList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int ConnectsToList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    Connection* val = new Connection;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (Connection**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ConnectsToList_template::copy_value(const ConnectsToList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.ConnectsToList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (Connection_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new Connection_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new Connection_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void ConnectsToList_template::copy_template(const ConnectsToList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (Connection_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new Connection_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new Connection_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ConnectsToList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.ConnectsToList.");
break;
}
set_selection(other_value);
}

boolean ConnectsToList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ConnectsToList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const ConnectsToList*)value_ptr)[value_index], legacy);
else return ((const ConnectsToList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

ConnectsToList_template::ConnectsToList_template()
{
}

ConnectsToList_template::ConnectsToList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

ConnectsToList_template::ConnectsToList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

ConnectsToList_template::ConnectsToList_template(const ConnectsToList& other_value)
{
copy_value(other_value);
}

ConnectsToList_template::ConnectsToList_template(const OPTIONAL<ConnectsToList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ConnectsToList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.ConnectsToList from an unbound optional field.");
}
}

ConnectsToList_template::ConnectsToList_template(const ConnectsToList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

ConnectsToList_template::~ConnectsToList_template()
{
clean_up();
}

void ConnectsToList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ConnectsToList_template& ConnectsToList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ConnectsToList_template& ConnectsToList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

ConnectsToList_template& ConnectsToList_template::operator=(const ConnectsToList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ConnectsToList_template& ConnectsToList_template::operator=(const OPTIONAL<ConnectsToList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ConnectsToList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.ConnectsToList.");
}
return *this;
}

ConnectsToList_template& ConnectsToList_template::operator=(const ConnectsToList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

Connection_template& ConnectsToList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.ConnectsToList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.ConnectsToList.");
    break;
}
return *single_value.value_elements[index_value];
}

Connection_template& ConnectsToList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.ConnectsToList.");
return (*this)[(int)index_value];
}

const Connection_template& ConnectsToList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.ConnectsToList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.ConnectsToList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.ConnectsToList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const Connection_template& ConnectsToList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.ConnectsToList.");
return (*this)[(int)index_value];
}

void ConnectsToList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.ConnectsToList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (Connection_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Connection_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Connection_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (Connection_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int ConnectsToList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int ConnectsToList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.ConnectsToList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.ConnectsToList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.ConnectsToList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.ConnectsToList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.ConnectsToList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.ConnectsToList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.ConnectsToList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.ConnectsToList");
}

boolean ConnectsToList_template::match(const ConnectsToList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.ConnectsToList.");
}
return FALSE;
}

boolean ConnectsToList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

ConnectsToList ConnectsToList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.ConnectsToList.");
ConnectsToList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

ConnectsToList ConnectsToList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

ConnectsToList ConnectsToList_template::replace(int index, int len, const ConnectsToList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

ConnectsToList ConnectsToList_template::replace(int index, int len, const ConnectsToList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void ConnectsToList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new ConnectsToList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.ConnectsToList.");
}
set_selection(template_type);
}

ConnectsToList_template& ConnectsToList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.ConnectsToList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.ConnectsToList.");
return value_list.list_value[list_index];
}

void ConnectsToList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void ConnectsToList_template::log_match(const ConnectsToList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ConnectsToList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.ConnectsToList.");
}
}

void ConnectsToList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.ConnectsToList.");
single_value.value_elements = (Connection_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new Connection_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ConnectsToList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.ConnectsToList.");
}
}

boolean ConnectsToList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ConnectsToList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ConnectsToList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.ConnectsToList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ConnectsToList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.ConnectsToList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* ConnectsToList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.ConnectsToList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void ConnectsToList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.ConnectsToList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.ConnectsToList");
}

ConnectingLane::ConnectingLane()
{
  bound_flag = FALSE;
}

ConnectingLane::ConnectingLane(const INTEGER& par_lane,
    const OPTIONAL<BITSTRING>& par_maneuver)
  :   field_lane(par_lane),
  field_maneuver(par_maneuver)
{
  bound_flag = TRUE;
}

ConnectingLane::ConnectingLane(const ConnectingLane& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.ConnectingLane.");
bound_flag = TRUE;
if (other_value.lane().is_bound()) field_lane = other_value.lane();
else field_lane.clean_up();
if (other_value.maneuver().is_bound()) field_maneuver = other_value.maneuver();
else field_maneuver.clean_up();
}

void ConnectingLane::clean_up()
{
field_lane.clean_up();
field_maneuver.clean_up();
bound_flag = FALSE;
}

ConnectingLane& ConnectingLane::operator=(const ConnectingLane& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.ConnectingLane.");
  bound_flag = TRUE;
  if (other_value.lane().is_bound()) field_lane = other_value.lane();
  else field_lane.clean_up();
  if (other_value.maneuver().is_bound()) field_maneuver = other_value.maneuver();
  else field_maneuver.clean_up();
}
return *this;
}

boolean ConnectingLane::operator==(const ConnectingLane& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lane==other_value.field_lane
  && field_maneuver==other_value.field_maneuver;
}

boolean ConnectingLane::is_bound() const
{
if (bound_flag) return TRUE;
if(field_lane.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_maneuver.get_selection() || field_maneuver.is_bound()) return TRUE;
return FALSE;
}
boolean ConnectingLane::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_lane.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_maneuver.get_selection() && !field_maneuver.is_value()) return FALSE;
return TRUE;
}
int ConnectingLane::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.ConnectingLane");
  int ret_val = 1;
  if (field_maneuver.ispresent()) ret_val++;
  return ret_val;
}

void ConnectingLane::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lane := ");
field_lane.log();
TTCN_Logger::log_event_str(", maneuver := ");
field_maneuver.log();
TTCN_Logger::log_event_str(" }");
}

void ConnectingLane::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.ConnectingLane'");
    }
    if (strcmp("lane", param_field) == 0) {
      lane().set_param(param);
      return;
    } else if (strcmp("maneuver", param_field) == 0) {
      maneuver().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.ConnectingLane'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @DSRC.ConnectingLane has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lane().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) maneuver().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lane")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lane().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maneuver")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maneuver().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.ConnectingLane: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.ConnectingLane");
  }
}

Module_Param* ConnectingLane::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.ConnectingLane'");
    }
    if (strcmp("lane", param_field) == 0) {
      return lane().get_param(param_name);
    } else if (strcmp("maneuver", param_field) == 0) {
      return maneuver().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.ConnectingLane'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_lane = field_lane.get_param(param_name);
  mp_field_lane->set_id(new Module_Param_FieldName(mcopystr("lane")));
  mp->add_elem(mp_field_lane);
  Module_Param* mp_field_maneuver = field_maneuver.get_param(param_name);
  mp_field_maneuver->set_id(new Module_Param_FieldName(mcopystr("maneuver")));
  mp->add_elem(mp_field_maneuver);
  return mp;
  }

void ConnectingLane::set_implicit_omit()
{
if (lane().is_bound()) lane().set_implicit_omit();
if (!maneuver().is_bound()) maneuver() = OMIT_VALUE;
else maneuver().set_implicit_omit();
}

void ConnectingLane::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.ConnectingLane.");
field_lane.encode_text(text_buf);
field_maneuver.encode_text(text_buf);
}

void ConnectingLane::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lane.decode_text(text_buf);
field_maneuver.decode_text(text_buf);
}

void ConnectingLane::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ConnectingLane::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ConnectingLane::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("lane': ");
  new_tlv->add_TLV(field_lane.BER_encode_TLV(ConnectingLane_lane_descr_, p_coding));
  ec_1.set_msg("maneuver': ");
  new_tlv->add_TLV(field_maneuver.BER_encode_TLV(ConnectingLane_maneuver_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ConnectingLane::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.ConnectingLane' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("lane': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_lane.BER_decode_TLV(ConnectingLane_lane_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("maneuver': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_maneuver=OMIT_VALUE;
    else {
      field_maneuver.BER_decode_TLV(ConnectingLane_maneuver_descr_, tmp_tlv, L_form);
      if(field_maneuver.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ConnectingLane::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.ConnectingLane.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lane");
    enc_len += field_lane.JSON_encode(ConnectingLane_lane_descr_, p_tok);
  }

  if (field_maneuver.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "maneuver");
    enc_len += field_maneuver.JSON_encode(ConnectingLane_maneuver_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ConnectingLane::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (4 == name_len && 0 == strncmp(fld_name, "lane", name_len)) {
         int ret_val = field_lane.JSON_decode(ConnectingLane_lane_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lane");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "maneuver", name_len)) {
         int ret_val = field_maneuver.JSON_decode(ConnectingLane_maneuver_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "maneuver");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lane.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lane");
    return JSON_ERROR_FATAL;
  }
if (!field_maneuver.is_bound()) {
    field_maneuver = OMIT_VALUE;
  }

  return dec_len;
}

struct ConnectingLane_template::single_value_struct {
INTEGER_template field_lane;
BITSTRING_template field_maneuver;
};

void ConnectingLane_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lane = ANY_VALUE;
single_value->field_maneuver = ANY_OR_OMIT;
}
}
}

void ConnectingLane_template::copy_value(const ConnectingLane& other_value)
{
single_value = new single_value_struct;
if (other_value.lane().is_bound()) {
  single_value->field_lane = other_value.lane();
} else {
  single_value->field_lane.clean_up();
}
if (other_value.maneuver().is_bound()) {
  if (other_value.maneuver().ispresent()) single_value->field_maneuver = other_value.maneuver()();
  else single_value->field_maneuver = OMIT_VALUE;
} else {
  single_value->field_maneuver.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ConnectingLane_template::copy_template(const ConnectingLane_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lane().get_selection()) {
single_value->field_lane = other_value.lane();
} else {
single_value->field_lane.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.maneuver().get_selection()) {
single_value->field_maneuver = other_value.maneuver();
} else {
single_value->field_maneuver.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ConnectingLane_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.ConnectingLane.");
break;
}
set_selection(other_value);
}

ConnectingLane_template::ConnectingLane_template()
{
}

ConnectingLane_template::ConnectingLane_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ConnectingLane_template::ConnectingLane_template(const ConnectingLane& other_value)
{
copy_value(other_value);
}

ConnectingLane_template::ConnectingLane_template(const OPTIONAL<ConnectingLane>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ConnectingLane&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.ConnectingLane from an unbound optional field.");
}
}

ConnectingLane_template::ConnectingLane_template(const ConnectingLane_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ConnectingLane_template::~ConnectingLane_template()
{
clean_up();
}

ConnectingLane_template& ConnectingLane_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ConnectingLane_template& ConnectingLane_template::operator=(const ConnectingLane& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ConnectingLane_template& ConnectingLane_template::operator=(const OPTIONAL<ConnectingLane>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ConnectingLane&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.ConnectingLane.");
}
return *this;
}

ConnectingLane_template& ConnectingLane_template::operator=(const ConnectingLane_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ConnectingLane_template::match(const ConnectingLane& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lane().is_bound()) return FALSE;
if(!single_value->field_lane.match(other_value.lane(), legacy))return FALSE;
if(!other_value.maneuver().is_bound()) return FALSE;
if((other_value.maneuver().ispresent() ? !single_value->field_maneuver.match((const BITSTRING&)other_value.maneuver(), legacy) : !single_value->field_maneuver.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.ConnectingLane.");
}
return FALSE;
}

boolean ConnectingLane_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lane.is_bound()) return TRUE;
if (single_value->field_maneuver.is_omit() || single_value->field_maneuver.is_bound()) return TRUE;
return FALSE;
}

boolean ConnectingLane_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lane.is_value()) return FALSE;
if (!single_value->field_maneuver.is_omit() && !single_value->field_maneuver.is_value()) return FALSE;
return TRUE;
}

void ConnectingLane_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ConnectingLane ConnectingLane_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.ConnectingLane.");
ConnectingLane ret_val;
if (single_value->field_lane.is_bound()) {
ret_val.lane() = single_value->field_lane.valueof();
}
if (single_value->field_maneuver.is_omit()) ret_val.maneuver() = OMIT_VALUE;
else if (single_value->field_maneuver.is_bound()) {
ret_val.maneuver() = single_value->field_maneuver.valueof();
}
return ret_val;
}

void ConnectingLane_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.ConnectingLane.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ConnectingLane_template[list_length];
}

ConnectingLane_template& ConnectingLane_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.ConnectingLane.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.ConnectingLane.");
return value_list.list_value[list_index];
}

INTEGER_template& ConnectingLane_template::lane()
{
set_specific();
return single_value->field_lane;
}

const INTEGER_template& ConnectingLane_template::lane() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lane of a non-specific template of type @DSRC.ConnectingLane.");
return single_value->field_lane;
}

BITSTRING_template& ConnectingLane_template::maneuver()
{
set_specific();
return single_value->field_maneuver;
}

const BITSTRING_template& ConnectingLane_template::maneuver() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field maneuver of a non-specific template of type @DSRC.ConnectingLane.");
return single_value->field_maneuver;
}

int ConnectingLane_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectingLane which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_maneuver.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.ConnectingLane containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectingLane containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectingLane containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectingLane containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectingLane containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.ConnectingLane.");
  }
  return 0;
}

void ConnectingLane_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lane := ");
single_value->field_lane.log();
TTCN_Logger::log_event_str(", maneuver := ");
single_value->field_maneuver.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ConnectingLane_template::log_match(const ConnectingLane& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_lane.match(match_value.lane(), legacy)){
TTCN_Logger::log_logmatch_info(".lane");
single_value->field_lane.log_match(match_value.lane(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.maneuver().ispresent()){
if(!single_value->field_maneuver.match(match_value.maneuver(), legacy)){
TTCN_Logger::log_logmatch_info(".maneuver");
single_value->field_maneuver.log_match(match_value.maneuver(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_maneuver.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".maneuver := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_maneuver.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lane := ");
single_value->field_lane.log_match(match_value.lane(), legacy);
TTCN_Logger::log_event_str(", maneuver := ");
if (match_value.maneuver().ispresent()) single_value->field_maneuver.log_match(match_value.maneuver(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_maneuver.log();
if (single_value->field_maneuver.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ConnectingLane_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lane.encode_text(text_buf);
single_value->field_maneuver.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.ConnectingLane.");
}
}

void ConnectingLane_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lane.decode_text(text_buf);
single_value->field_maneuver.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ConnectingLane_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.ConnectingLane.");
}
}

void ConnectingLane_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.ConnectingLane'");
    }
    if (strcmp("lane", param_field) == 0) {
      lane().set_param(param);
      return;
    } else if (strcmp("maneuver", param_field) == 0) {
      maneuver().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.ConnectingLane'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ConnectingLane_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @DSRC.ConnectingLane has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lane().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) maneuver().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lane")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lane().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maneuver")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maneuver().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.ConnectingLane: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.ConnectingLane");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ConnectingLane_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.ConnectingLane'");
    }
    if (strcmp("lane", param_field) == 0) {
      return lane().get_param(param_name);
    } else if (strcmp("maneuver", param_field) == 0) {
      return maneuver().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.ConnectingLane'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_lane = single_value->field_lane.get_param(param_name);
    mp_field_lane->set_id(new Module_Param_FieldName(mcopystr("lane")));
    mp->add_elem(mp_field_lane);
    Module_Param* mp_field_maneuver = single_value->field_maneuver.get_param(param_name);
    mp_field_maneuver->set_id(new Module_Param_FieldName(mcopystr("maneuver")));
    mp->add_elem(mp_field_maneuver);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ConnectingLane_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lane.check_restriction(t_res, t_name ? t_name : "@DSRC.ConnectingLane");
single_value->field_maneuver.check_restriction(t_res, t_name ? t_name : "@DSRC.ConnectingLane");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.ConnectingLane");
}

boolean ConnectingLane_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ConnectingLane_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Connection::Connection()
{
  bound_flag = FALSE;
}

Connection::Connection(const ConnectingLane& par_connectingLane,
    const OPTIONAL<IntersectionReferenceID>& par_remoteIntersection,
    const OPTIONAL<INTEGER>& par_signalGroup,
    const OPTIONAL<INTEGER>& par_userClass,
    const OPTIONAL<INTEGER>& par_connectionID)
  :   field_connectingLane(par_connectingLane),
  field_remoteIntersection(par_remoteIntersection),
  field_signalGroup(par_signalGroup),
  field_userClass(par_userClass),
  field_connectionID(par_connectionID)
{
  bound_flag = TRUE;
}

Connection::Connection(const Connection& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.Connection.");
bound_flag = TRUE;
if (other_value.connectingLane().is_bound()) field_connectingLane = other_value.connectingLane();
else field_connectingLane.clean_up();
if (other_value.remoteIntersection().is_bound()) field_remoteIntersection = other_value.remoteIntersection();
else field_remoteIntersection.clean_up();
if (other_value.signalGroup().is_bound()) field_signalGroup = other_value.signalGroup();
else field_signalGroup.clean_up();
if (other_value.userClass().is_bound()) field_userClass = other_value.userClass();
else field_userClass.clean_up();
if (other_value.connectionID().is_bound()) field_connectionID = other_value.connectionID();
else field_connectionID.clean_up();
}

void Connection::clean_up()
{
field_connectingLane.clean_up();
field_remoteIntersection.clean_up();
field_signalGroup.clean_up();
field_userClass.clean_up();
field_connectionID.clean_up();
bound_flag = FALSE;
}

Connection& Connection::operator=(const Connection& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.Connection.");
  bound_flag = TRUE;
  if (other_value.connectingLane().is_bound()) field_connectingLane = other_value.connectingLane();
  else field_connectingLane.clean_up();
  if (other_value.remoteIntersection().is_bound()) field_remoteIntersection = other_value.remoteIntersection();
  else field_remoteIntersection.clean_up();
  if (other_value.signalGroup().is_bound()) field_signalGroup = other_value.signalGroup();
  else field_signalGroup.clean_up();
  if (other_value.userClass().is_bound()) field_userClass = other_value.userClass();
  else field_userClass.clean_up();
  if (other_value.connectionID().is_bound()) field_connectionID = other_value.connectionID();
  else field_connectionID.clean_up();
}
return *this;
}

boolean Connection::operator==(const Connection& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_connectingLane==other_value.field_connectingLane
  && field_remoteIntersection==other_value.field_remoteIntersection
  && field_signalGroup==other_value.field_signalGroup
  && field_userClass==other_value.field_userClass
  && field_connectionID==other_value.field_connectionID;
}

boolean Connection::is_bound() const
{
if (bound_flag) return TRUE;
if(field_connectingLane.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_remoteIntersection.get_selection() || field_remoteIntersection.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_signalGroup.get_selection() || field_signalGroup.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_userClass.get_selection() || field_userClass.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_connectionID.get_selection() || field_connectionID.is_bound()) return TRUE;
return FALSE;
}
boolean Connection::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_connectingLane.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_remoteIntersection.get_selection() && !field_remoteIntersection.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_signalGroup.get_selection() && !field_signalGroup.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_userClass.get_selection() && !field_userClass.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_connectionID.get_selection() && !field_connectionID.is_value()) return FALSE;
return TRUE;
}
int Connection::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.Connection");
  int ret_val = 1;
  if (field_remoteIntersection.ispresent()) ret_val++;
  if (field_signalGroup.ispresent()) ret_val++;
  if (field_userClass.ispresent()) ret_val++;
  if (field_connectionID.ispresent()) ret_val++;
  return ret_val;
}

void Connection::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ connectingLane := ");
field_connectingLane.log();
TTCN_Logger::log_event_str(", remoteIntersection := ");
field_remoteIntersection.log();
TTCN_Logger::log_event_str(", signalGroup := ");
field_signalGroup.log();
TTCN_Logger::log_event_str(", userClass := ");
field_userClass.log();
TTCN_Logger::log_event_str(", connectionID := ");
field_connectionID.log();
TTCN_Logger::log_event_str(" }");
}

void Connection::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.Connection'");
    }
    if (strcmp("connectingLane", param_field) == 0) {
      connectingLane().set_param(param);
      return;
    } else if (strcmp("remoteIntersection", param_field) == 0) {
      remoteIntersection().set_param(param);
      return;
    } else if (strcmp("signalGroup", param_field) == 0) {
      signalGroup().set_param(param);
      return;
    } else if (strcmp("userClass", param_field) == 0) {
      userClass().set_param(param);
      return;
    } else if (strcmp("connectionID", param_field) == 0) {
      connectionID().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.Connection'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record value of type @DSRC.Connection has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connectingLane().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remoteIntersection().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) signalGroup().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) userClass().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) connectionID().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connectingLane")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connectingLane().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remoteIntersection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remoteIntersection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signalGroup")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signalGroup().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "userClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          userClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connectionID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connectionID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.Connection: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.Connection");
  }
}

Module_Param* Connection::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.Connection'");
    }
    if (strcmp("connectingLane", param_field) == 0) {
      return connectingLane().get_param(param_name);
    } else if (strcmp("remoteIntersection", param_field) == 0) {
      return remoteIntersection().get_param(param_name);
    } else if (strcmp("signalGroup", param_field) == 0) {
      return signalGroup().get_param(param_name);
    } else if (strcmp("userClass", param_field) == 0) {
      return userClass().get_param(param_name);
    } else if (strcmp("connectionID", param_field) == 0) {
      return connectionID().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.Connection'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_connectingLane = field_connectingLane.get_param(param_name);
  mp_field_connectingLane->set_id(new Module_Param_FieldName(mcopystr("connectingLane")));
  mp->add_elem(mp_field_connectingLane);
  Module_Param* mp_field_remoteIntersection = field_remoteIntersection.get_param(param_name);
  mp_field_remoteIntersection->set_id(new Module_Param_FieldName(mcopystr("remoteIntersection")));
  mp->add_elem(mp_field_remoteIntersection);
  Module_Param* mp_field_signalGroup = field_signalGroup.get_param(param_name);
  mp_field_signalGroup->set_id(new Module_Param_FieldName(mcopystr("signalGroup")));
  mp->add_elem(mp_field_signalGroup);
  Module_Param* mp_field_userClass = field_userClass.get_param(param_name);
  mp_field_userClass->set_id(new Module_Param_FieldName(mcopystr("userClass")));
  mp->add_elem(mp_field_userClass);
  Module_Param* mp_field_connectionID = field_connectionID.get_param(param_name);
  mp_field_connectionID->set_id(new Module_Param_FieldName(mcopystr("connectionID")));
  mp->add_elem(mp_field_connectionID);
  return mp;
  }

void Connection::set_implicit_omit()
{
if (connectingLane().is_bound()) connectingLane().set_implicit_omit();
if (!remoteIntersection().is_bound()) remoteIntersection() = OMIT_VALUE;
else remoteIntersection().set_implicit_omit();
if (!signalGroup().is_bound()) signalGroup() = OMIT_VALUE;
else signalGroup().set_implicit_omit();
if (!userClass().is_bound()) userClass() = OMIT_VALUE;
else userClass().set_implicit_omit();
if (!connectionID().is_bound()) connectionID() = OMIT_VALUE;
else connectionID().set_implicit_omit();
}

void Connection::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.Connection.");
field_connectingLane.encode_text(text_buf);
field_remoteIntersection.encode_text(text_buf);
field_signalGroup.encode_text(text_buf);
field_userClass.encode_text(text_buf);
field_connectionID.encode_text(text_buf);
}

void Connection::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_connectingLane.decode_text(text_buf);
field_remoteIntersection.decode_text(text_buf);
field_signalGroup.decode_text(text_buf);
field_userClass.decode_text(text_buf);
field_connectionID.decode_text(text_buf);
}

void Connection::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Connection::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* Connection::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("connectingLane': ");
  new_tlv->add_TLV(field_connectingLane.BER_encode_TLV(Connection_connectingLane_descr_, p_coding));
  ec_1.set_msg("remoteIntersection': ");
  new_tlv->add_TLV(field_remoteIntersection.BER_encode_TLV(Connection_remoteIntersection_descr_, p_coding));
  ec_1.set_msg("signalGroup': ");
  new_tlv->add_TLV(field_signalGroup.BER_encode_TLV(Connection_signalGroup_descr_, p_coding));
  ec_1.set_msg("userClass': ");
  new_tlv->add_TLV(field_userClass.BER_encode_TLV(Connection_userClass_descr_, p_coding));
  ec_1.set_msg("connectionID': ");
  new_tlv->add_TLV(field_connectionID.BER_encode_TLV(Connection_connectionID_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean Connection::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.Connection' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("connectingLane': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_connectingLane.BER_decode_TLV(Connection_connectingLane_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("remoteIntersection': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_remoteIntersection=OMIT_VALUE;
    else {
      field_remoteIntersection.BER_decode_TLV(Connection_remoteIntersection_descr_, tmp_tlv, L_form);
      if(field_remoteIntersection.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("signalGroup': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_signalGroup=OMIT_VALUE;
    else {
      field_signalGroup.BER_decode_TLV(Connection_signalGroup_descr_, tmp_tlv, L_form);
      if(field_signalGroup.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("userClass': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_userClass=OMIT_VALUE;
    else {
      field_userClass.BER_decode_TLV(Connection_userClass_descr_, tmp_tlv, L_form);
      if(field_userClass.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("connectionID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_connectionID=OMIT_VALUE;
    else {
      field_connectionID.BER_decode_TLV(Connection_connectionID_descr_, tmp_tlv, L_form);
      if(field_connectionID.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int Connection::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.Connection.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "connectingLane");
    enc_len += field_connectingLane.JSON_encode(Connection_connectingLane_descr_, p_tok);
  }

  if (field_remoteIntersection.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "remoteIntersection");
    enc_len += field_remoteIntersection.JSON_encode(Connection_remoteIntersection_descr_, p_tok);
  }

  if (field_signalGroup.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signalGroup");
    enc_len += field_signalGroup.JSON_encode(Connection_signalGroup_descr_, p_tok);
  }

  if (field_userClass.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "userClass");
    enc_len += field_userClass.JSON_encode(Connection_userClass_descr_, p_tok);
  }

  if (field_connectionID.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "connectionID");
    enc_len += field_connectionID.JSON_encode(Connection_connectionID_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Connection::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (14 == name_len && 0 == strncmp(fld_name, "connectingLane", name_len)) {
         int ret_val = field_connectingLane.JSON_decode(Connection_connectingLane_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "connectingLane");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "remoteIntersection", name_len)) {
         int ret_val = field_remoteIntersection.JSON_decode(Connection_remoteIntersection_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "remoteIntersection");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "signalGroup", name_len)) {
         int ret_val = field_signalGroup.JSON_decode(Connection_signalGroup_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signalGroup");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "userClass", name_len)) {
         int ret_val = field_userClass.JSON_decode(Connection_userClass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "userClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "connectionID", name_len)) {
         int ret_val = field_connectionID.JSON_decode(Connection_connectionID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "connectionID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_connectingLane.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "connectingLane");
    return JSON_ERROR_FATAL;
  }
if (!field_remoteIntersection.is_bound()) {
    field_remoteIntersection = OMIT_VALUE;
  }
if (!field_signalGroup.is_bound()) {
    field_signalGroup = OMIT_VALUE;
  }
if (!field_userClass.is_bound()) {
    field_userClass = OMIT_VALUE;
  }
if (!field_connectionID.is_bound()) {
    field_connectionID = OMIT_VALUE;
  }

  return dec_len;
}

struct Connection_template::single_value_struct {
ConnectingLane_template field_connectingLane;
IntersectionReferenceID_template field_remoteIntersection;
INTEGER_template field_signalGroup;
INTEGER_template field_userClass;
INTEGER_template field_connectionID;
};

void Connection_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_connectingLane = ANY_VALUE;
single_value->field_remoteIntersection = ANY_OR_OMIT;
single_value->field_signalGroup = ANY_OR_OMIT;
single_value->field_userClass = ANY_OR_OMIT;
single_value->field_connectionID = ANY_OR_OMIT;
}
}
}

void Connection_template::copy_value(const Connection& other_value)
{
single_value = new single_value_struct;
if (other_value.connectingLane().is_bound()) {
  single_value->field_connectingLane = other_value.connectingLane();
} else {
  single_value->field_connectingLane.clean_up();
}
if (other_value.remoteIntersection().is_bound()) {
  if (other_value.remoteIntersection().ispresent()) single_value->field_remoteIntersection = other_value.remoteIntersection()();
  else single_value->field_remoteIntersection = OMIT_VALUE;
} else {
  single_value->field_remoteIntersection.clean_up();
}
if (other_value.signalGroup().is_bound()) {
  if (other_value.signalGroup().ispresent()) single_value->field_signalGroup = other_value.signalGroup()();
  else single_value->field_signalGroup = OMIT_VALUE;
} else {
  single_value->field_signalGroup.clean_up();
}
if (other_value.userClass().is_bound()) {
  if (other_value.userClass().ispresent()) single_value->field_userClass = other_value.userClass()();
  else single_value->field_userClass = OMIT_VALUE;
} else {
  single_value->field_userClass.clean_up();
}
if (other_value.connectionID().is_bound()) {
  if (other_value.connectionID().ispresent()) single_value->field_connectionID = other_value.connectionID()();
  else single_value->field_connectionID = OMIT_VALUE;
} else {
  single_value->field_connectionID.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Connection_template::copy_template(const Connection_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.connectingLane().get_selection()) {
single_value->field_connectingLane = other_value.connectingLane();
} else {
single_value->field_connectingLane.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remoteIntersection().get_selection()) {
single_value->field_remoteIntersection = other_value.remoteIntersection();
} else {
single_value->field_remoteIntersection.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signalGroup().get_selection()) {
single_value->field_signalGroup = other_value.signalGroup();
} else {
single_value->field_signalGroup.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.userClass().get_selection()) {
single_value->field_userClass = other_value.userClass();
} else {
single_value->field_userClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.connectionID().get_selection()) {
single_value->field_connectionID = other_value.connectionID();
} else {
single_value->field_connectionID.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Connection_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.Connection.");
break;
}
set_selection(other_value);
}

Connection_template::Connection_template()
{
}

Connection_template::Connection_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Connection_template::Connection_template(const Connection& other_value)
{
copy_value(other_value);
}

Connection_template::Connection_template(const OPTIONAL<Connection>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Connection&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.Connection from an unbound optional field.");
}
}

Connection_template::Connection_template(const Connection_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Connection_template::~Connection_template()
{
clean_up();
}

Connection_template& Connection_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Connection_template& Connection_template::operator=(const Connection& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Connection_template& Connection_template::operator=(const OPTIONAL<Connection>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Connection&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.Connection.");
}
return *this;
}

Connection_template& Connection_template::operator=(const Connection_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Connection_template::match(const Connection& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.connectingLane().is_bound()) return FALSE;
if(!single_value->field_connectingLane.match(other_value.connectingLane(), legacy))return FALSE;
if(!other_value.remoteIntersection().is_bound()) return FALSE;
if((other_value.remoteIntersection().ispresent() ? !single_value->field_remoteIntersection.match((const IntersectionReferenceID&)other_value.remoteIntersection(), legacy) : !single_value->field_remoteIntersection.match_omit(legacy)))return FALSE;
if(!other_value.signalGroup().is_bound()) return FALSE;
if((other_value.signalGroup().ispresent() ? !single_value->field_signalGroup.match((const INTEGER&)other_value.signalGroup(), legacy) : !single_value->field_signalGroup.match_omit(legacy)))return FALSE;
if(!other_value.userClass().is_bound()) return FALSE;
if((other_value.userClass().ispresent() ? !single_value->field_userClass.match((const INTEGER&)other_value.userClass(), legacy) : !single_value->field_userClass.match_omit(legacy)))return FALSE;
if(!other_value.connectionID().is_bound()) return FALSE;
if((other_value.connectionID().ispresent() ? !single_value->field_connectionID.match((const INTEGER&)other_value.connectionID(), legacy) : !single_value->field_connectionID.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.Connection.");
}
return FALSE;
}

boolean Connection_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_connectingLane.is_bound()) return TRUE;
if (single_value->field_remoteIntersection.is_omit() || single_value->field_remoteIntersection.is_bound()) return TRUE;
if (single_value->field_signalGroup.is_omit() || single_value->field_signalGroup.is_bound()) return TRUE;
if (single_value->field_userClass.is_omit() || single_value->field_userClass.is_bound()) return TRUE;
if (single_value->field_connectionID.is_omit() || single_value->field_connectionID.is_bound()) return TRUE;
return FALSE;
}

boolean Connection_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_connectingLane.is_value()) return FALSE;
if (!single_value->field_remoteIntersection.is_omit() && !single_value->field_remoteIntersection.is_value()) return FALSE;
if (!single_value->field_signalGroup.is_omit() && !single_value->field_signalGroup.is_value()) return FALSE;
if (!single_value->field_userClass.is_omit() && !single_value->field_userClass.is_value()) return FALSE;
if (!single_value->field_connectionID.is_omit() && !single_value->field_connectionID.is_value()) return FALSE;
return TRUE;
}

void Connection_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Connection Connection_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.Connection.");
Connection ret_val;
if (single_value->field_connectingLane.is_bound()) {
ret_val.connectingLane() = single_value->field_connectingLane.valueof();
}
if (single_value->field_remoteIntersection.is_omit()) ret_val.remoteIntersection() = OMIT_VALUE;
else if (single_value->field_remoteIntersection.is_bound()) {
ret_val.remoteIntersection() = single_value->field_remoteIntersection.valueof();
}
if (single_value->field_signalGroup.is_omit()) ret_val.signalGroup() = OMIT_VALUE;
else if (single_value->field_signalGroup.is_bound()) {
ret_val.signalGroup() = single_value->field_signalGroup.valueof();
}
if (single_value->field_userClass.is_omit()) ret_val.userClass() = OMIT_VALUE;
else if (single_value->field_userClass.is_bound()) {
ret_val.userClass() = single_value->field_userClass.valueof();
}
if (single_value->field_connectionID.is_omit()) ret_val.connectionID() = OMIT_VALUE;
else if (single_value->field_connectionID.is_bound()) {
ret_val.connectionID() = single_value->field_connectionID.valueof();
}
return ret_val;
}

void Connection_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.Connection.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Connection_template[list_length];
}

Connection_template& Connection_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.Connection.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.Connection.");
return value_list.list_value[list_index];
}

ConnectingLane_template& Connection_template::connectingLane()
{
set_specific();
return single_value->field_connectingLane;
}

const ConnectingLane_template& Connection_template::connectingLane() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connectingLane of a non-specific template of type @DSRC.Connection.");
return single_value->field_connectingLane;
}

IntersectionReferenceID_template& Connection_template::remoteIntersection()
{
set_specific();
return single_value->field_remoteIntersection;
}

const IntersectionReferenceID_template& Connection_template::remoteIntersection() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remoteIntersection of a non-specific template of type @DSRC.Connection.");
return single_value->field_remoteIntersection;
}

INTEGER_template& Connection_template::signalGroup()
{
set_specific();
return single_value->field_signalGroup;
}

const INTEGER_template& Connection_template::signalGroup() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signalGroup of a non-specific template of type @DSRC.Connection.");
return single_value->field_signalGroup;
}

INTEGER_template& Connection_template::userClass()
{
set_specific();
return single_value->field_userClass;
}

const INTEGER_template& Connection_template::userClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field userClass of a non-specific template of type @DSRC.Connection.");
return single_value->field_userClass;
}

INTEGER_template& Connection_template::connectionID()
{
set_specific();
return single_value->field_connectionID;
}

const INTEGER_template& Connection_template::connectionID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connectionID of a non-specific template of type @DSRC.Connection.");
return single_value->field_connectionID;
}

int Connection_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.Connection which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_remoteIntersection.is_present()) ret_val++;
      if (single_value->field_signalGroup.is_present()) ret_val++;
      if (single_value->field_userClass.is_present()) ret_val++;
      if (single_value->field_connectionID.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.Connection containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.Connection containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.Connection containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.Connection containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.Connection containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.Connection.");
  }
  return 0;
}

void Connection_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ connectingLane := ");
single_value->field_connectingLane.log();
TTCN_Logger::log_event_str(", remoteIntersection := ");
single_value->field_remoteIntersection.log();
TTCN_Logger::log_event_str(", signalGroup := ");
single_value->field_signalGroup.log();
TTCN_Logger::log_event_str(", userClass := ");
single_value->field_userClass.log();
TTCN_Logger::log_event_str(", connectionID := ");
single_value->field_connectionID.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Connection_template::log_match(const Connection& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_connectingLane.match(match_value.connectingLane(), legacy)){
TTCN_Logger::log_logmatch_info(".connectingLane");
single_value->field_connectingLane.log_match(match_value.connectingLane(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.remoteIntersection().ispresent()){
if(!single_value->field_remoteIntersection.match(match_value.remoteIntersection(), legacy)){
TTCN_Logger::log_logmatch_info(".remoteIntersection");
single_value->field_remoteIntersection.log_match(match_value.remoteIntersection(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_remoteIntersection.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".remoteIntersection := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_remoteIntersection.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.signalGroup().ispresent()){
if(!single_value->field_signalGroup.match(match_value.signalGroup(), legacy)){
TTCN_Logger::log_logmatch_info(".signalGroup");
single_value->field_signalGroup.log_match(match_value.signalGroup(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_signalGroup.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".signalGroup := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_signalGroup.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.userClass().ispresent()){
if(!single_value->field_userClass.match(match_value.userClass(), legacy)){
TTCN_Logger::log_logmatch_info(".userClass");
single_value->field_userClass.log_match(match_value.userClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_userClass.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".userClass := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_userClass.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.connectionID().ispresent()){
if(!single_value->field_connectionID.match(match_value.connectionID(), legacy)){
TTCN_Logger::log_logmatch_info(".connectionID");
single_value->field_connectionID.log_match(match_value.connectionID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_connectionID.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".connectionID := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_connectionID.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ connectingLane := ");
single_value->field_connectingLane.log_match(match_value.connectingLane(), legacy);
TTCN_Logger::log_event_str(", remoteIntersection := ");
if (match_value.remoteIntersection().ispresent()) single_value->field_remoteIntersection.log_match(match_value.remoteIntersection(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_remoteIntersection.log();
if (single_value->field_remoteIntersection.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", signalGroup := ");
if (match_value.signalGroup().ispresent()) single_value->field_signalGroup.log_match(match_value.signalGroup(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_signalGroup.log();
if (single_value->field_signalGroup.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", userClass := ");
if (match_value.userClass().ispresent()) single_value->field_userClass.log_match(match_value.userClass(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_userClass.log();
if (single_value->field_userClass.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", connectionID := ");
if (match_value.connectionID().ispresent()) single_value->field_connectionID.log_match(match_value.connectionID(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_connectionID.log();
if (single_value->field_connectionID.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Connection_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_connectingLane.encode_text(text_buf);
single_value->field_remoteIntersection.encode_text(text_buf);
single_value->field_signalGroup.encode_text(text_buf);
single_value->field_userClass.encode_text(text_buf);
single_value->field_connectionID.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.Connection.");
}
}

void Connection_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_connectingLane.decode_text(text_buf);
single_value->field_remoteIntersection.decode_text(text_buf);
single_value->field_signalGroup.decode_text(text_buf);
single_value->field_userClass.decode_text(text_buf);
single_value->field_connectionID.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Connection_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.Connection.");
}
}

void Connection_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.Connection'");
    }
    if (strcmp("connectingLane", param_field) == 0) {
      connectingLane().set_param(param);
      return;
    } else if (strcmp("remoteIntersection", param_field) == 0) {
      remoteIntersection().set_param(param);
      return;
    } else if (strcmp("signalGroup", param_field) == 0) {
      signalGroup().set_param(param);
      return;
    } else if (strcmp("userClass", param_field) == 0) {
      userClass().set_param(param);
      return;
    } else if (strcmp("connectionID", param_field) == 0) {
      connectionID().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.Connection'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Connection_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record template of type @DSRC.Connection has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connectingLane().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remoteIntersection().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) signalGroup().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) userClass().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) connectionID().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connectingLane")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connectingLane().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remoteIntersection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remoteIntersection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signalGroup")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signalGroup().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "userClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          userClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connectionID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connectionID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.Connection: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.Connection");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Connection_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.Connection'");
    }
    if (strcmp("connectingLane", param_field) == 0) {
      return connectingLane().get_param(param_name);
    } else if (strcmp("remoteIntersection", param_field) == 0) {
      return remoteIntersection().get_param(param_name);
    } else if (strcmp("signalGroup", param_field) == 0) {
      return signalGroup().get_param(param_name);
    } else if (strcmp("userClass", param_field) == 0) {
      return userClass().get_param(param_name);
    } else if (strcmp("connectionID", param_field) == 0) {
      return connectionID().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.Connection'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_connectingLane = single_value->field_connectingLane.get_param(param_name);
    mp_field_connectingLane->set_id(new Module_Param_FieldName(mcopystr("connectingLane")));
    mp->add_elem(mp_field_connectingLane);
    Module_Param* mp_field_remoteIntersection = single_value->field_remoteIntersection.get_param(param_name);
    mp_field_remoteIntersection->set_id(new Module_Param_FieldName(mcopystr("remoteIntersection")));
    mp->add_elem(mp_field_remoteIntersection);
    Module_Param* mp_field_signalGroup = single_value->field_signalGroup.get_param(param_name);
    mp_field_signalGroup->set_id(new Module_Param_FieldName(mcopystr("signalGroup")));
    mp->add_elem(mp_field_signalGroup);
    Module_Param* mp_field_userClass = single_value->field_userClass.get_param(param_name);
    mp_field_userClass->set_id(new Module_Param_FieldName(mcopystr("userClass")));
    mp->add_elem(mp_field_userClass);
    Module_Param* mp_field_connectionID = single_value->field_connectionID.get_param(param_name);
    mp_field_connectionID->set_id(new Module_Param_FieldName(mcopystr("connectionID")));
    mp->add_elem(mp_field_connectionID);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Connection_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_connectingLane.check_restriction(t_res, t_name ? t_name : "@DSRC.Connection");
single_value->field_remoteIntersection.check_restriction(t_res, t_name ? t_name : "@DSRC.Connection");
single_value->field_signalGroup.check_restriction(t_res, t_name ? t_name : "@DSRC.Connection");
single_value->field_userClass.check_restriction(t_res, t_name ? t_name : "@DSRC.Connection");
single_value->field_connectionID.check_restriction(t_res, t_name ? t_name : "@DSRC.Connection");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.Connection");
}

boolean Connection_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Connection_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

IntersectionGeometry::IntersectionGeometry()
{
  bound_flag = FALSE;
}

IntersectionGeometry::IntersectionGeometry(const OPTIONAL<CHARSTRING>& par_name,
    const IntersectionReferenceID& par_id,
    const INTEGER& par_revision,
    const Position3D__2& par_refPoint,
    const OPTIONAL<INTEGER>& par_laneWidth,
    const OPTIONAL<SpeedLimitList>& par_speedLimits,
    const LaneList& par_laneSet,
    const OPTIONAL<PreemptPriorityList>& par_preemptPriorityData,
    const OPTIONAL<REGION::Reg__Intersection>& par_regional)
  :   field_name(par_name),
  field_id(par_id),
  field_revision(par_revision),
  field_refPoint(par_refPoint),
  field_laneWidth(par_laneWidth),
  field_speedLimits(par_speedLimits),
  field_laneSet(par_laneSet),
  field_preemptPriorityData(par_preemptPriorityData),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

IntersectionGeometry::IntersectionGeometry(const IntersectionGeometry& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.IntersectionGeometry.");
bound_flag = TRUE;
if (other_value.name().is_bound()) field_name = other_value.name();
else field_name.clean_up();
if (other_value.id().is_bound()) field_id = other_value.id();
else field_id.clean_up();
if (other_value.revision().is_bound()) field_revision = other_value.revision();
else field_revision.clean_up();
if (other_value.refPoint().is_bound()) field_refPoint = other_value.refPoint();
else field_refPoint.clean_up();
if (other_value.laneWidth().is_bound()) field_laneWidth = other_value.laneWidth();
else field_laneWidth.clean_up();
if (other_value.speedLimits().is_bound()) field_speedLimits = other_value.speedLimits();
else field_speedLimits.clean_up();
if (other_value.laneSet().is_bound()) field_laneSet = other_value.laneSet();
else field_laneSet.clean_up();
if (other_value.preemptPriorityData().is_bound()) field_preemptPriorityData = other_value.preemptPriorityData();
else field_preemptPriorityData.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void IntersectionGeometry::clean_up()
{
field_name.clean_up();
field_id.clean_up();
field_revision.clean_up();
field_refPoint.clean_up();
field_laneWidth.clean_up();
field_speedLimits.clean_up();
field_laneSet.clean_up();
field_preemptPriorityData.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

IntersectionGeometry& IntersectionGeometry::operator=(const IntersectionGeometry& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.IntersectionGeometry.");
  bound_flag = TRUE;
  if (other_value.name().is_bound()) field_name = other_value.name();
  else field_name.clean_up();
  if (other_value.id().is_bound()) field_id = other_value.id();
  else field_id.clean_up();
  if (other_value.revision().is_bound()) field_revision = other_value.revision();
  else field_revision.clean_up();
  if (other_value.refPoint().is_bound()) field_refPoint = other_value.refPoint();
  else field_refPoint.clean_up();
  if (other_value.laneWidth().is_bound()) field_laneWidth = other_value.laneWidth();
  else field_laneWidth.clean_up();
  if (other_value.speedLimits().is_bound()) field_speedLimits = other_value.speedLimits();
  else field_speedLimits.clean_up();
  if (other_value.laneSet().is_bound()) field_laneSet = other_value.laneSet();
  else field_laneSet.clean_up();
  if (other_value.preemptPriorityData().is_bound()) field_preemptPriorityData = other_value.preemptPriorityData();
  else field_preemptPriorityData.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean IntersectionGeometry::operator==(const IntersectionGeometry& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_name==other_value.field_name
  && field_id==other_value.field_id
  && field_revision==other_value.field_revision
  && field_refPoint==other_value.field_refPoint
  && field_laneWidth==other_value.field_laneWidth
  && field_speedLimits==other_value.field_speedLimits
  && field_laneSet==other_value.field_laneSet
  && field_preemptPriorityData==other_value.field_preemptPriorityData
  && field_regional==other_value.field_regional;
}

boolean IntersectionGeometry::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_name.get_selection() || field_name.is_bound()) return TRUE;
if(field_id.is_bound()) return TRUE;
if(field_revision.is_bound()) return TRUE;
if(field_refPoint.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_laneWidth.get_selection() || field_laneWidth.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_speedLimits.get_selection() || field_speedLimits.is_bound()) return TRUE;
if(field_laneSet.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_preemptPriorityData.get_selection() || field_preemptPriorityData.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean IntersectionGeometry::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_name.get_selection() && !field_name.is_value()) return FALSE;
if(!field_id.is_value()) return FALSE;
if(!field_revision.is_value()) return FALSE;
if(!field_refPoint.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_laneWidth.get_selection() && !field_laneWidth.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_speedLimits.get_selection() && !field_speedLimits.is_value()) return FALSE;
if(!field_laneSet.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_preemptPriorityData.get_selection() && !field_preemptPriorityData.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int IntersectionGeometry::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.IntersectionGeometry");
  int ret_val = 4;
  if (field_name.ispresent()) ret_val++;
  if (field_laneWidth.ispresent()) ret_val++;
  if (field_speedLimits.ispresent()) ret_val++;
  if (field_preemptPriorityData.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void IntersectionGeometry::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ name := ");
field_name.log();
TTCN_Logger::log_event_str(", id := ");
field_id.log();
TTCN_Logger::log_event_str(", revision := ");
field_revision.log();
TTCN_Logger::log_event_str(", refPoint := ");
field_refPoint.log();
TTCN_Logger::log_event_str(", laneWidth := ");
field_laneWidth.log();
TTCN_Logger::log_event_str(", speedLimits := ");
field_speedLimits.log();
TTCN_Logger::log_event_str(", laneSet := ");
field_laneSet.log();
TTCN_Logger::log_event_str(", preemptPriorityData := ");
field_preemptPriorityData.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void IntersectionGeometry::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.IntersectionGeometry'");
    }
    if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("revision", param_field) == 0) {
      revision().set_param(param);
      return;
    } else if (strcmp("refPoint", param_field) == 0) {
      refPoint().set_param(param);
      return;
    } else if (strcmp("laneWidth", param_field) == 0) {
      laneWidth().set_param(param);
      return;
    } else if (strcmp("speedLimits", param_field) == 0) {
      speedLimits().set_param(param);
      return;
    } else if (strcmp("laneSet", param_field) == 0) {
      laneSet().set_param(param);
      return;
    } else if (strcmp("preemptPriorityData", param_field) == 0) {
      preemptPriorityData().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.IntersectionGeometry'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (9<mp->get_size()) {
      param.error("record value of type @DSRC.IntersectionGeometry has 9 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) revision().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) refPoint().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) laneWidth().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) speedLimits().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) laneSet().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) preemptPriorityData().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(8));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "revision")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          revision().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "refPoint")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          refPoint().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneWidth")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneWidth().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimits().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneSet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneSet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "preemptPriorityData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          preemptPriorityData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.IntersectionGeometry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.IntersectionGeometry");
  }
}

Module_Param* IntersectionGeometry::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.IntersectionGeometry'");
    }
    if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else if (strcmp("revision", param_field) == 0) {
      return revision().get_param(param_name);
    } else if (strcmp("refPoint", param_field) == 0) {
      return refPoint().get_param(param_name);
    } else if (strcmp("laneWidth", param_field) == 0) {
      return laneWidth().get_param(param_name);
    } else if (strcmp("speedLimits", param_field) == 0) {
      return speedLimits().get_param(param_name);
    } else if (strcmp("laneSet", param_field) == 0) {
      return laneSet().get_param(param_name);
    } else if (strcmp("preemptPriorityData", param_field) == 0) {
      return preemptPriorityData().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.IntersectionGeometry'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_name = field_name.get_param(param_name);
  mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
  mp->add_elem(mp_field_name);
  Module_Param* mp_field_id = field_id.get_param(param_name);
  mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
  mp->add_elem(mp_field_id);
  Module_Param* mp_field_revision = field_revision.get_param(param_name);
  mp_field_revision->set_id(new Module_Param_FieldName(mcopystr("revision")));
  mp->add_elem(mp_field_revision);
  Module_Param* mp_field_refPoint = field_refPoint.get_param(param_name);
  mp_field_refPoint->set_id(new Module_Param_FieldName(mcopystr("refPoint")));
  mp->add_elem(mp_field_refPoint);
  Module_Param* mp_field_laneWidth = field_laneWidth.get_param(param_name);
  mp_field_laneWidth->set_id(new Module_Param_FieldName(mcopystr("laneWidth")));
  mp->add_elem(mp_field_laneWidth);
  Module_Param* mp_field_speedLimits = field_speedLimits.get_param(param_name);
  mp_field_speedLimits->set_id(new Module_Param_FieldName(mcopystr("speedLimits")));
  mp->add_elem(mp_field_speedLimits);
  Module_Param* mp_field_laneSet = field_laneSet.get_param(param_name);
  mp_field_laneSet->set_id(new Module_Param_FieldName(mcopystr("laneSet")));
  mp->add_elem(mp_field_laneSet);
  Module_Param* mp_field_preemptPriorityData = field_preemptPriorityData.get_param(param_name);
  mp_field_preemptPriorityData->set_id(new Module_Param_FieldName(mcopystr("preemptPriorityData")));
  mp->add_elem(mp_field_preemptPriorityData);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void IntersectionGeometry::set_implicit_omit()
{
if (!name().is_bound()) name() = OMIT_VALUE;
else name().set_implicit_omit();
if (id().is_bound()) id().set_implicit_omit();
if (revision().is_bound()) revision().set_implicit_omit();
if (refPoint().is_bound()) refPoint().set_implicit_omit();
if (!laneWidth().is_bound()) laneWidth() = OMIT_VALUE;
else laneWidth().set_implicit_omit();
if (!speedLimits().is_bound()) speedLimits() = OMIT_VALUE;
else speedLimits().set_implicit_omit();
if (laneSet().is_bound()) laneSet().set_implicit_omit();
if (!preemptPriorityData().is_bound()) preemptPriorityData() = OMIT_VALUE;
else preemptPriorityData().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void IntersectionGeometry::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.IntersectionGeometry.");
field_name.encode_text(text_buf);
field_id.encode_text(text_buf);
field_revision.encode_text(text_buf);
field_refPoint.encode_text(text_buf);
field_laneWidth.encode_text(text_buf);
field_speedLimits.encode_text(text_buf);
field_laneSet.encode_text(text_buf);
field_preemptPriorityData.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void IntersectionGeometry::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_name.decode_text(text_buf);
field_id.decode_text(text_buf);
field_revision.decode_text(text_buf);
field_refPoint.decode_text(text_buf);
field_laneWidth.decode_text(text_buf);
field_speedLimits.decode_text(text_buf);
field_laneSet.decode_text(text_buf);
field_preemptPriorityData.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void IntersectionGeometry::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IntersectionGeometry::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* IntersectionGeometry::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("name': ");
  new_tlv->add_TLV(field_name.BER_encode_TLV(IntersectionGeometry_name_descr_, p_coding));
  ec_1.set_msg("id': ");
  new_tlv->add_TLV(field_id.BER_encode_TLV(IntersectionGeometry_id_descr_, p_coding));
  ec_1.set_msg("revision': ");
  new_tlv->add_TLV(field_revision.BER_encode_TLV(IntersectionGeometry_revision_descr_, p_coding));
  ec_1.set_msg("refPoint': ");
  new_tlv->add_TLV(field_refPoint.BER_encode_TLV(IntersectionGeometry_refPoint_descr_, p_coding));
  ec_1.set_msg("laneWidth': ");
  new_tlv->add_TLV(field_laneWidth.BER_encode_TLV(IntersectionGeometry_laneWidth_descr_, p_coding));
  ec_1.set_msg("speedLimits': ");
  new_tlv->add_TLV(field_speedLimits.BER_encode_TLV(IntersectionGeometry_speedLimits_descr_, p_coding));
  ec_1.set_msg("laneSet': ");
  new_tlv->add_TLV(field_laneSet.BER_encode_TLV(IntersectionGeometry_laneSet_descr_, p_coding));
  ec_1.set_msg("preemptPriorityData': ");
  new_tlv->add_TLV(field_preemptPriorityData.BER_encode_TLV(IntersectionGeometry_preemptPriorityData_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(IntersectionGeometry_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean IntersectionGeometry::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.IntersectionGeometry' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("name': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_name=OMIT_VALUE;
    else {
      field_name.BER_decode_TLV(IntersectionGeometry_name_descr_, tmp_tlv, L_form);
      if(field_name.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("id': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_id.BER_decode_TLV(IntersectionGeometry_id_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("revision': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_revision.BER_decode_TLV(IntersectionGeometry_revision_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("refPoint': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_refPoint.BER_decode_TLV(IntersectionGeometry_refPoint_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("laneWidth': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_laneWidth=OMIT_VALUE;
    else {
      field_laneWidth.BER_decode_TLV(IntersectionGeometry_laneWidth_descr_, tmp_tlv, L_form);
      if(field_laneWidth.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("speedLimits': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_speedLimits=OMIT_VALUE;
    else {
      field_speedLimits.BER_decode_TLV(IntersectionGeometry_speedLimits_descr_, tmp_tlv, L_form);
      if(field_speedLimits.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("laneSet': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_laneSet.BER_decode_TLV(IntersectionGeometry_laneSet_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("preemptPriorityData': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_preemptPriorityData=OMIT_VALUE;
    else {
      field_preemptPriorityData.BER_decode_TLV(IntersectionGeometry_preemptPriorityData_descr_, tmp_tlv, L_form);
      if(field_preemptPriorityData.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(IntersectionGeometry_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int IntersectionGeometry::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.IntersectionGeometry.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_name.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "name");
    enc_len += field_name.JSON_encode(IntersectionGeometry_name_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "id");
    enc_len += field_id.JSON_encode(IntersectionGeometry_id_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "revision");
    enc_len += field_revision.JSON_encode(IntersectionGeometry_revision_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "refPoint");
    enc_len += field_refPoint.JSON_encode(IntersectionGeometry_refPoint_descr_, p_tok);
  }

  if (field_laneWidth.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneWidth");
    enc_len += field_laneWidth.JSON_encode(IntersectionGeometry_laneWidth_descr_, p_tok);
  }

  if (field_speedLimits.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speedLimits");
    enc_len += field_speedLimits.JSON_encode(IntersectionGeometry_speedLimits_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneSet");
    enc_len += field_laneSet.JSON_encode(IntersectionGeometry_laneSet_descr_, p_tok);
  }

  if (field_preemptPriorityData.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "preemptPriorityData");
    enc_len += field_preemptPriorityData.JSON_encode(IntersectionGeometry_preemptPriorityData_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(IntersectionGeometry_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IntersectionGeometry::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (4 == name_len && 0 == strncmp(fld_name, "name", name_len)) {
         int ret_val = field_name.JSON_decode(IntersectionGeometry_name_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "name");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (2 == name_len && 0 == strncmp(fld_name, "id", name_len)) {
         int ret_val = field_id.JSON_decode(IntersectionGeometry_id_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "id");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "revision", name_len)) {
         int ret_val = field_revision.JSON_decode(IntersectionGeometry_revision_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "revision");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "refPoint", name_len)) {
         int ret_val = field_refPoint.JSON_decode(IntersectionGeometry_refPoint_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "refPoint");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "laneWidth", name_len)) {
         int ret_val = field_laneWidth.JSON_decode(IntersectionGeometry_laneWidth_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneWidth");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "speedLimits", name_len)) {
         int ret_val = field_speedLimits.JSON_decode(IntersectionGeometry_speedLimits_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speedLimits");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "laneSet", name_len)) {
         int ret_val = field_laneSet.JSON_decode(IntersectionGeometry_laneSet_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneSet");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "preemptPriorityData", name_len)) {
         int ret_val = field_preemptPriorityData.JSON_decode(IntersectionGeometry_preemptPriorityData_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "preemptPriorityData");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(IntersectionGeometry_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_name.is_bound()) {
    field_name = OMIT_VALUE;
  }
if (!field_id.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "id");
    return JSON_ERROR_FATAL;
  }
if (!field_revision.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "revision");
    return JSON_ERROR_FATAL;
  }
if (!field_refPoint.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "refPoint");
    return JSON_ERROR_FATAL;
  }
if (!field_laneWidth.is_bound()) {
    field_laneWidth = OMIT_VALUE;
  }
if (!field_speedLimits.is_bound()) {
    field_speedLimits = OMIT_VALUE;
  }
if (!field_laneSet.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "laneSet");
    return JSON_ERROR_FATAL;
  }
if (!field_preemptPriorityData.is_bound()) {
    field_preemptPriorityData = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct IntersectionGeometry_template::single_value_struct {
CHARSTRING_template field_name;
IntersectionReferenceID_template field_id;
INTEGER_template field_revision;
Position3D__2_template field_refPoint;
INTEGER_template field_laneWidth;
SpeedLimitList_template field_speedLimits;
LaneList_template field_laneSet;
PreemptPriorityList_template field_preemptPriorityData;
REGION::Reg__Intersection_template field_regional;
};

void IntersectionGeometry_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_name = ANY_OR_OMIT;
single_value->field_id = ANY_VALUE;
single_value->field_revision = ANY_VALUE;
single_value->field_refPoint = ANY_VALUE;
single_value->field_laneWidth = ANY_OR_OMIT;
single_value->field_speedLimits = ANY_OR_OMIT;
single_value->field_laneSet = ANY_VALUE;
single_value->field_preemptPriorityData = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void IntersectionGeometry_template::copy_value(const IntersectionGeometry& other_value)
{
single_value = new single_value_struct;
if (other_value.name().is_bound()) {
  if (other_value.name().ispresent()) single_value->field_name = other_value.name()();
  else single_value->field_name = OMIT_VALUE;
} else {
  single_value->field_name.clean_up();
}
if (other_value.id().is_bound()) {
  single_value->field_id = other_value.id();
} else {
  single_value->field_id.clean_up();
}
if (other_value.revision().is_bound()) {
  single_value->field_revision = other_value.revision();
} else {
  single_value->field_revision.clean_up();
}
if (other_value.refPoint().is_bound()) {
  single_value->field_refPoint = other_value.refPoint();
} else {
  single_value->field_refPoint.clean_up();
}
if (other_value.laneWidth().is_bound()) {
  if (other_value.laneWidth().ispresent()) single_value->field_laneWidth = other_value.laneWidth()();
  else single_value->field_laneWidth = OMIT_VALUE;
} else {
  single_value->field_laneWidth.clean_up();
}
if (other_value.speedLimits().is_bound()) {
  if (other_value.speedLimits().ispresent()) single_value->field_speedLimits = other_value.speedLimits()();
  else single_value->field_speedLimits = OMIT_VALUE;
} else {
  single_value->field_speedLimits.clean_up();
}
if (other_value.laneSet().is_bound()) {
  single_value->field_laneSet = other_value.laneSet();
} else {
  single_value->field_laneSet.clean_up();
}
if (other_value.preemptPriorityData().is_bound()) {
  if (other_value.preemptPriorityData().ispresent()) single_value->field_preemptPriorityData = other_value.preemptPriorityData()();
  else single_value->field_preemptPriorityData = OMIT_VALUE;
} else {
  single_value->field_preemptPriorityData.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IntersectionGeometry_template::copy_template(const IntersectionGeometry_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.name().get_selection()) {
single_value->field_name = other_value.name();
} else {
single_value->field_name.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.id().get_selection()) {
single_value->field_id = other_value.id();
} else {
single_value->field_id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.revision().get_selection()) {
single_value->field_revision = other_value.revision();
} else {
single_value->field_revision.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.refPoint().get_selection()) {
single_value->field_refPoint = other_value.refPoint();
} else {
single_value->field_refPoint.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.laneWidth().get_selection()) {
single_value->field_laneWidth = other_value.laneWidth();
} else {
single_value->field_laneWidth.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speedLimits().get_selection()) {
single_value->field_speedLimits = other_value.speedLimits();
} else {
single_value->field_speedLimits.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.laneSet().get_selection()) {
single_value->field_laneSet = other_value.laneSet();
} else {
single_value->field_laneSet.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.preemptPriorityData().get_selection()) {
single_value->field_preemptPriorityData = other_value.preemptPriorityData();
} else {
single_value->field_preemptPriorityData.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IntersectionGeometry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.IntersectionGeometry.");
break;
}
set_selection(other_value);
}

IntersectionGeometry_template::IntersectionGeometry_template()
{
}

IntersectionGeometry_template::IntersectionGeometry_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IntersectionGeometry_template::IntersectionGeometry_template(const IntersectionGeometry& other_value)
{
copy_value(other_value);
}

IntersectionGeometry_template::IntersectionGeometry_template(const OPTIONAL<IntersectionGeometry>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionGeometry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.IntersectionGeometry from an unbound optional field.");
}
}

IntersectionGeometry_template::IntersectionGeometry_template(const IntersectionGeometry_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IntersectionGeometry_template::~IntersectionGeometry_template()
{
clean_up();
}

IntersectionGeometry_template& IntersectionGeometry_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IntersectionGeometry_template& IntersectionGeometry_template::operator=(const IntersectionGeometry& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IntersectionGeometry_template& IntersectionGeometry_template::operator=(const OPTIONAL<IntersectionGeometry>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionGeometry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.IntersectionGeometry.");
}
return *this;
}

IntersectionGeometry_template& IntersectionGeometry_template::operator=(const IntersectionGeometry_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IntersectionGeometry_template::match(const IntersectionGeometry& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.name().is_bound()) return FALSE;
if((other_value.name().ispresent() ? !single_value->field_name.match((const CHARSTRING&)other_value.name(), legacy) : !single_value->field_name.match_omit(legacy)))return FALSE;
if(!other_value.id().is_bound()) return FALSE;
if(!single_value->field_id.match(other_value.id(), legacy))return FALSE;
if(!other_value.revision().is_bound()) return FALSE;
if(!single_value->field_revision.match(other_value.revision(), legacy))return FALSE;
if(!other_value.refPoint().is_bound()) return FALSE;
if(!single_value->field_refPoint.match(other_value.refPoint(), legacy))return FALSE;
if(!other_value.laneWidth().is_bound()) return FALSE;
if((other_value.laneWidth().ispresent() ? !single_value->field_laneWidth.match((const INTEGER&)other_value.laneWidth(), legacy) : !single_value->field_laneWidth.match_omit(legacy)))return FALSE;
if(!other_value.speedLimits().is_bound()) return FALSE;
if((other_value.speedLimits().ispresent() ? !single_value->field_speedLimits.match((const SpeedLimitList&)other_value.speedLimits(), legacy) : !single_value->field_speedLimits.match_omit(legacy)))return FALSE;
if(!other_value.laneSet().is_bound()) return FALSE;
if(!single_value->field_laneSet.match(other_value.laneSet(), legacy))return FALSE;
if(!other_value.preemptPriorityData().is_bound()) return FALSE;
if((other_value.preemptPriorityData().ispresent() ? !single_value->field_preemptPriorityData.match((const PreemptPriorityList&)other_value.preemptPriorityData(), legacy) : !single_value->field_preemptPriorityData.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REGION::Reg__Intersection&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.IntersectionGeometry.");
}
return FALSE;
}

boolean IntersectionGeometry_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_name.is_omit() || single_value->field_name.is_bound()) return TRUE;
if (single_value->field_id.is_bound()) return TRUE;
if (single_value->field_revision.is_bound()) return TRUE;
if (single_value->field_refPoint.is_bound()) return TRUE;
if (single_value->field_laneWidth.is_omit() || single_value->field_laneWidth.is_bound()) return TRUE;
if (single_value->field_speedLimits.is_omit() || single_value->field_speedLimits.is_bound()) return TRUE;
if (single_value->field_laneSet.is_bound()) return TRUE;
if (single_value->field_preemptPriorityData.is_omit() || single_value->field_preemptPriorityData.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean IntersectionGeometry_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_name.is_omit() && !single_value->field_name.is_value()) return FALSE;
if (!single_value->field_id.is_value()) return FALSE;
if (!single_value->field_revision.is_value()) return FALSE;
if (!single_value->field_refPoint.is_value()) return FALSE;
if (!single_value->field_laneWidth.is_omit() && !single_value->field_laneWidth.is_value()) return FALSE;
if (!single_value->field_speedLimits.is_omit() && !single_value->field_speedLimits.is_value()) return FALSE;
if (!single_value->field_laneSet.is_value()) return FALSE;
if (!single_value->field_preemptPriorityData.is_omit() && !single_value->field_preemptPriorityData.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void IntersectionGeometry_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IntersectionGeometry IntersectionGeometry_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.IntersectionGeometry.");
IntersectionGeometry ret_val;
if (single_value->field_name.is_omit()) ret_val.name() = OMIT_VALUE;
else if (single_value->field_name.is_bound()) {
ret_val.name() = single_value->field_name.valueof();
}
if (single_value->field_id.is_bound()) {
ret_val.id() = single_value->field_id.valueof();
}
if (single_value->field_revision.is_bound()) {
ret_val.revision() = single_value->field_revision.valueof();
}
if (single_value->field_refPoint.is_bound()) {
ret_val.refPoint() = single_value->field_refPoint.valueof();
}
if (single_value->field_laneWidth.is_omit()) ret_val.laneWidth() = OMIT_VALUE;
else if (single_value->field_laneWidth.is_bound()) {
ret_val.laneWidth() = single_value->field_laneWidth.valueof();
}
if (single_value->field_speedLimits.is_omit()) ret_val.speedLimits() = OMIT_VALUE;
else if (single_value->field_speedLimits.is_bound()) {
ret_val.speedLimits() = single_value->field_speedLimits.valueof();
}
if (single_value->field_laneSet.is_bound()) {
ret_val.laneSet() = single_value->field_laneSet.valueof();
}
if (single_value->field_preemptPriorityData.is_omit()) ret_val.preemptPriorityData() = OMIT_VALUE;
else if (single_value->field_preemptPriorityData.is_bound()) {
ret_val.preemptPriorityData() = single_value->field_preemptPriorityData.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void IntersectionGeometry_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.IntersectionGeometry.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IntersectionGeometry_template[list_length];
}

IntersectionGeometry_template& IntersectionGeometry_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.IntersectionGeometry.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.IntersectionGeometry.");
return value_list.list_value[list_index];
}

CHARSTRING_template& IntersectionGeometry_template::name()
{
set_specific();
return single_value->field_name;
}

const CHARSTRING_template& IntersectionGeometry_template::name() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field name of a non-specific template of type @DSRC.IntersectionGeometry.");
return single_value->field_name;
}

IntersectionReferenceID_template& IntersectionGeometry_template::id()
{
set_specific();
return single_value->field_id;
}

const IntersectionReferenceID_template& IntersectionGeometry_template::id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field id of a non-specific template of type @DSRC.IntersectionGeometry.");
return single_value->field_id;
}

INTEGER_template& IntersectionGeometry_template::revision()
{
set_specific();
return single_value->field_revision;
}

const INTEGER_template& IntersectionGeometry_template::revision() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field revision of a non-specific template of type @DSRC.IntersectionGeometry.");
return single_value->field_revision;
}

Position3D__2_template& IntersectionGeometry_template::refPoint()
{
set_specific();
return single_value->field_refPoint;
}

const Position3D__2_template& IntersectionGeometry_template::refPoint() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field refPoint of a non-specific template of type @DSRC.IntersectionGeometry.");
return single_value->field_refPoint;
}

INTEGER_template& IntersectionGeometry_template::laneWidth()
{
set_specific();
return single_value->field_laneWidth;
}

const INTEGER_template& IntersectionGeometry_template::laneWidth() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field laneWidth of a non-specific template of type @DSRC.IntersectionGeometry.");
return single_value->field_laneWidth;
}

SpeedLimitList_template& IntersectionGeometry_template::speedLimits()
{
set_specific();
return single_value->field_speedLimits;
}

const SpeedLimitList_template& IntersectionGeometry_template::speedLimits() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speedLimits of a non-specific template of type @DSRC.IntersectionGeometry.");
return single_value->field_speedLimits;
}

LaneList_template& IntersectionGeometry_template::laneSet()
{
set_specific();
return single_value->field_laneSet;
}

const LaneList_template& IntersectionGeometry_template::laneSet() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field laneSet of a non-specific template of type @DSRC.IntersectionGeometry.");
return single_value->field_laneSet;
}

PreemptPriorityList_template& IntersectionGeometry_template::preemptPriorityData()
{
set_specific();
return single_value->field_preemptPriorityData;
}

const PreemptPriorityList_template& IntersectionGeometry_template::preemptPriorityData() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field preemptPriorityData of a non-specific template of type @DSRC.IntersectionGeometry.");
return single_value->field_preemptPriorityData;
}

REGION::Reg__Intersection_template& IntersectionGeometry_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REGION::Reg__Intersection_template& IntersectionGeometry_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.IntersectionGeometry.");
return single_value->field_regional;
}

int IntersectionGeometry_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionGeometry which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 4;
      if (single_value->field_name.is_present()) ret_val++;
      if (single_value->field_laneWidth.is_present()) ret_val++;
      if (single_value->field_speedLimits.is_present()) ret_val++;
      if (single_value->field_preemptPriorityData.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.IntersectionGeometry containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionGeometry containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionGeometry containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionGeometry containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionGeometry containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.IntersectionGeometry.");
  }
  return 0;
}

void IntersectionGeometry_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ name := ");
single_value->field_name.log();
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log();
TTCN_Logger::log_event_str(", revision := ");
single_value->field_revision.log();
TTCN_Logger::log_event_str(", refPoint := ");
single_value->field_refPoint.log();
TTCN_Logger::log_event_str(", laneWidth := ");
single_value->field_laneWidth.log();
TTCN_Logger::log_event_str(", speedLimits := ");
single_value->field_speedLimits.log();
TTCN_Logger::log_event_str(", laneSet := ");
single_value->field_laneSet.log();
TTCN_Logger::log_event_str(", preemptPriorityData := ");
single_value->field_preemptPriorityData.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IntersectionGeometry_template::log_match(const IntersectionGeometry& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.name().ispresent()){
if(!single_value->field_name.match(match_value.name(), legacy)){
TTCN_Logger::log_logmatch_info(".name");
single_value->field_name.log_match(match_value.name(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_name.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".name := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_name.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_id.match(match_value.id(), legacy)){
TTCN_Logger::log_logmatch_info(".id");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_revision.match(match_value.revision(), legacy)){
TTCN_Logger::log_logmatch_info(".revision");
single_value->field_revision.log_match(match_value.revision(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_refPoint.match(match_value.refPoint(), legacy)){
TTCN_Logger::log_logmatch_info(".refPoint");
single_value->field_refPoint.log_match(match_value.refPoint(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.laneWidth().ispresent()){
if(!single_value->field_laneWidth.match(match_value.laneWidth(), legacy)){
TTCN_Logger::log_logmatch_info(".laneWidth");
single_value->field_laneWidth.log_match(match_value.laneWidth(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_laneWidth.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".laneWidth := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_laneWidth.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.speedLimits().ispresent()){
if(!single_value->field_speedLimits.match(match_value.speedLimits(), legacy)){
TTCN_Logger::log_logmatch_info(".speedLimits");
single_value->field_speedLimits.log_match(match_value.speedLimits(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_speedLimits.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".speedLimits := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_speedLimits.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_laneSet.match(match_value.laneSet(), legacy)){
TTCN_Logger::log_logmatch_info(".laneSet");
single_value->field_laneSet.log_match(match_value.laneSet(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.preemptPriorityData().ispresent()){
if(!single_value->field_preemptPriorityData.match(match_value.preemptPriorityData(), legacy)){
TTCN_Logger::log_logmatch_info(".preemptPriorityData");
single_value->field_preemptPriorityData.log_match(match_value.preemptPriorityData(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_preemptPriorityData.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".preemptPriorityData := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_preemptPriorityData.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ name := ");
if (match_value.name().ispresent()) single_value->field_name.log_match(match_value.name(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_name.log();
if (single_value->field_name.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::log_event_str(", revision := ");
single_value->field_revision.log_match(match_value.revision(), legacy);
TTCN_Logger::log_event_str(", refPoint := ");
single_value->field_refPoint.log_match(match_value.refPoint(), legacy);
TTCN_Logger::log_event_str(", laneWidth := ");
if (match_value.laneWidth().ispresent()) single_value->field_laneWidth.log_match(match_value.laneWidth(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_laneWidth.log();
if (single_value->field_laneWidth.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", speedLimits := ");
if (match_value.speedLimits().ispresent()) single_value->field_speedLimits.log_match(match_value.speedLimits(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_speedLimits.log();
if (single_value->field_speedLimits.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", laneSet := ");
single_value->field_laneSet.log_match(match_value.laneSet(), legacy);
TTCN_Logger::log_event_str(", preemptPriorityData := ");
if (match_value.preemptPriorityData().ispresent()) single_value->field_preemptPriorityData.log_match(match_value.preemptPriorityData(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_preemptPriorityData.log();
if (single_value->field_preemptPriorityData.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IntersectionGeometry_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_name.encode_text(text_buf);
single_value->field_id.encode_text(text_buf);
single_value->field_revision.encode_text(text_buf);
single_value->field_refPoint.encode_text(text_buf);
single_value->field_laneWidth.encode_text(text_buf);
single_value->field_speedLimits.encode_text(text_buf);
single_value->field_laneSet.encode_text(text_buf);
single_value->field_preemptPriorityData.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.IntersectionGeometry.");
}
}

void IntersectionGeometry_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_name.decode_text(text_buf);
single_value->field_id.decode_text(text_buf);
single_value->field_revision.decode_text(text_buf);
single_value->field_refPoint.decode_text(text_buf);
single_value->field_laneWidth.decode_text(text_buf);
single_value->field_speedLimits.decode_text(text_buf);
single_value->field_laneSet.decode_text(text_buf);
single_value->field_preemptPriorityData.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IntersectionGeometry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.IntersectionGeometry.");
}
}

void IntersectionGeometry_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.IntersectionGeometry'");
    }
    if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("revision", param_field) == 0) {
      revision().set_param(param);
      return;
    } else if (strcmp("refPoint", param_field) == 0) {
      refPoint().set_param(param);
      return;
    } else if (strcmp("laneWidth", param_field) == 0) {
      laneWidth().set_param(param);
      return;
    } else if (strcmp("speedLimits", param_field) == 0) {
      speedLimits().set_param(param);
      return;
    } else if (strcmp("laneSet", param_field) == 0) {
      laneSet().set_param(param);
      return;
    } else if (strcmp("preemptPriorityData", param_field) == 0) {
      preemptPriorityData().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.IntersectionGeometry'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IntersectionGeometry_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (9<mp->get_size()) {
      param.error("record template of type @DSRC.IntersectionGeometry has 9 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) revision().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) refPoint().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) laneWidth().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) speedLimits().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) laneSet().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) preemptPriorityData().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(8));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "revision")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          revision().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "refPoint")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          refPoint().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneWidth")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneWidth().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimits().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneSet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneSet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "preemptPriorityData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          preemptPriorityData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.IntersectionGeometry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.IntersectionGeometry");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* IntersectionGeometry_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.IntersectionGeometry'");
    }
    if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else if (strcmp("revision", param_field) == 0) {
      return revision().get_param(param_name);
    } else if (strcmp("refPoint", param_field) == 0) {
      return refPoint().get_param(param_name);
    } else if (strcmp("laneWidth", param_field) == 0) {
      return laneWidth().get_param(param_name);
    } else if (strcmp("speedLimits", param_field) == 0) {
      return speedLimits().get_param(param_name);
    } else if (strcmp("laneSet", param_field) == 0) {
      return laneSet().get_param(param_name);
    } else if (strcmp("preemptPriorityData", param_field) == 0) {
      return preemptPriorityData().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.IntersectionGeometry'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_name = single_value->field_name.get_param(param_name);
    mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
    mp->add_elem(mp_field_name);
    Module_Param* mp_field_id = single_value->field_id.get_param(param_name);
    mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
    mp->add_elem(mp_field_id);
    Module_Param* mp_field_revision = single_value->field_revision.get_param(param_name);
    mp_field_revision->set_id(new Module_Param_FieldName(mcopystr("revision")));
    mp->add_elem(mp_field_revision);
    Module_Param* mp_field_refPoint = single_value->field_refPoint.get_param(param_name);
    mp_field_refPoint->set_id(new Module_Param_FieldName(mcopystr("refPoint")));
    mp->add_elem(mp_field_refPoint);
    Module_Param* mp_field_laneWidth = single_value->field_laneWidth.get_param(param_name);
    mp_field_laneWidth->set_id(new Module_Param_FieldName(mcopystr("laneWidth")));
    mp->add_elem(mp_field_laneWidth);
    Module_Param* mp_field_speedLimits = single_value->field_speedLimits.get_param(param_name);
    mp_field_speedLimits->set_id(new Module_Param_FieldName(mcopystr("speedLimits")));
    mp->add_elem(mp_field_speedLimits);
    Module_Param* mp_field_laneSet = single_value->field_laneSet.get_param(param_name);
    mp_field_laneSet->set_id(new Module_Param_FieldName(mcopystr("laneSet")));
    mp->add_elem(mp_field_laneSet);
    Module_Param* mp_field_preemptPriorityData = single_value->field_preemptPriorityData.get_param(param_name);
    mp_field_preemptPriorityData->set_id(new Module_Param_FieldName(mcopystr("preemptPriorityData")));
    mp->add_elem(mp_field_preemptPriorityData);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void IntersectionGeometry_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_name.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometry");
single_value->field_id.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometry");
single_value->field_revision.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometry");
single_value->field_refPoint.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometry");
single_value->field_laneWidth.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometry");
single_value->field_speedLimits.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometry");
single_value->field_laneSet.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometry");
single_value->field_preemptPriorityData.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometry");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionGeometry");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.IntersectionGeometry");
}

boolean IntersectionGeometry_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IntersectionGeometry_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const REGION::Reg__SignalControlZone PreemptPriorityList::UNBOUND_ELEM;
PreemptPriorityList::PreemptPriorityList()
{
val_ptr = NULL;
}

PreemptPriorityList::PreemptPriorityList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

PreemptPriorityList::PreemptPriorityList(const PreemptPriorityList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.PreemptPriorityList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

PreemptPriorityList::~PreemptPriorityList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void PreemptPriorityList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

PreemptPriorityList& PreemptPriorityList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

PreemptPriorityList& PreemptPriorityList::operator=(const PreemptPriorityList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.PreemptPriorityList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean PreemptPriorityList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.PreemptPriorityList.");
return val_ptr->n_elements == 0 ;
}

boolean PreemptPriorityList::operator==(const PreemptPriorityList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.PreemptPriorityList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.PreemptPriorityList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

REGION::Reg__SignalControlZone& PreemptPriorityList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.PreemptPriorityList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (REGION::Reg__SignalControlZone**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new REGION::Reg__SignalControlZone(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new REGION::Reg__SignalControlZone;
}
return *val_ptr->value_elements[index_value];
}

REGION::Reg__SignalControlZone& PreemptPriorityList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.PreemptPriorityList.");
return (*this)[(int)index_value];
}

const REGION::Reg__SignalControlZone& PreemptPriorityList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.PreemptPriorityList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.PreemptPriorityList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.PreemptPriorityList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const REGION::Reg__SignalControlZone& PreemptPriorityList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.PreemptPriorityList.");
return (*this)[(int)index_value];
}

PreemptPriorityList PreemptPriorityList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

PreemptPriorityList PreemptPriorityList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

PreemptPriorityList PreemptPriorityList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

PreemptPriorityList PreemptPriorityList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.PreemptPriorityList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
PreemptPriorityList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new REGION::Reg__SignalControlZone(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

PreemptPriorityList PreemptPriorityList::operator+(const PreemptPriorityList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.PreemptPriorityList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
PreemptPriorityList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new REGION::Reg__SignalControlZone(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new REGION::Reg__SignalControlZone(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

PreemptPriorityList PreemptPriorityList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.PreemptPriorityList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.PreemptPriorityList","element");
PreemptPriorityList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new REGION::Reg__SignalControlZone(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

PreemptPriorityList PreemptPriorityList::replace(int index, int len, const PreemptPriorityList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.PreemptPriorityList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.PreemptPriorityList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.PreemptPriorityList","element");
PreemptPriorityList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new REGION::Reg__SignalControlZone(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new REGION::Reg__SignalControlZone(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new REGION::Reg__SignalControlZone(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

PreemptPriorityList PreemptPriorityList::replace(int index, int len, const PreemptPriorityList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void PreemptPriorityList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.PreemptPriorityList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (REGION::Reg__SignalControlZone**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new REGION::Reg__SignalControlZone(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (REGION::Reg__SignalControlZone**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.PreemptPriorityList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (REGION::Reg__SignalControlZone**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean PreemptPriorityList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int PreemptPriorityList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.PreemptPriorityList.");
return val_ptr->n_elements;
}

int PreemptPriorityList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.PreemptPriorityList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void PreemptPriorityList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void PreemptPriorityList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.PreemptPriorityList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.PreemptPriorityList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.PreemptPriorityList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* PreemptPriorityList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.PreemptPriorityList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void PreemptPriorityList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void PreemptPriorityList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.PreemptPriorityList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void PreemptPriorityList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.PreemptPriorityList.");
val_ptr->value_elements = (REGION::Reg__SignalControlZone**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new REGION::Reg__SignalControlZone;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void PreemptPriorityList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PreemptPriorityList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* PreemptPriorityList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean PreemptPriorityList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (REGION::Reg__SignalControlZone**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new REGION::Reg__SignalControlZone;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int PreemptPriorityList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.PreemptPriorityList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int PreemptPriorityList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    REGION::Reg__SignalControlZone* val = new REGION::Reg__SignalControlZone;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (REGION::Reg__SignalControlZone**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void PreemptPriorityList_template::copy_value(const PreemptPriorityList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.PreemptPriorityList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (REGION::Reg__SignalControlZone_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new REGION::Reg__SignalControlZone_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new REGION::Reg__SignalControlZone_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void PreemptPriorityList_template::copy_template(const PreemptPriorityList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (REGION::Reg__SignalControlZone_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new REGION::Reg__SignalControlZone_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new REGION::Reg__SignalControlZone_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PreemptPriorityList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.PreemptPriorityList.");
break;
}
set_selection(other_value);
}

boolean PreemptPriorityList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const PreemptPriorityList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const PreemptPriorityList*)value_ptr)[value_index], legacy);
else return ((const PreemptPriorityList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

PreemptPriorityList_template::PreemptPriorityList_template()
{
}

PreemptPriorityList_template::PreemptPriorityList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

PreemptPriorityList_template::PreemptPriorityList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

PreemptPriorityList_template::PreemptPriorityList_template(const PreemptPriorityList& other_value)
{
copy_value(other_value);
}

PreemptPriorityList_template::PreemptPriorityList_template(const OPTIONAL<PreemptPriorityList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PreemptPriorityList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.PreemptPriorityList from an unbound optional field.");
}
}

PreemptPriorityList_template::PreemptPriorityList_template(const PreemptPriorityList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

PreemptPriorityList_template::~PreemptPriorityList_template()
{
clean_up();
}

void PreemptPriorityList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PreemptPriorityList_template& PreemptPriorityList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PreemptPriorityList_template& PreemptPriorityList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

PreemptPriorityList_template& PreemptPriorityList_template::operator=(const PreemptPriorityList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PreemptPriorityList_template& PreemptPriorityList_template::operator=(const OPTIONAL<PreemptPriorityList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PreemptPriorityList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.PreemptPriorityList.");
}
return *this;
}

PreemptPriorityList_template& PreemptPriorityList_template::operator=(const PreemptPriorityList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

REGION::Reg__SignalControlZone_template& PreemptPriorityList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.PreemptPriorityList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.PreemptPriorityList.");
    break;
}
return *single_value.value_elements[index_value];
}

REGION::Reg__SignalControlZone_template& PreemptPriorityList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.PreemptPriorityList.");
return (*this)[(int)index_value];
}

const REGION::Reg__SignalControlZone_template& PreemptPriorityList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.PreemptPriorityList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.PreemptPriorityList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.PreemptPriorityList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const REGION::Reg__SignalControlZone_template& PreemptPriorityList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.PreemptPriorityList.");
return (*this)[(int)index_value];
}

void PreemptPriorityList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.PreemptPriorityList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (REGION::Reg__SignalControlZone_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new REGION::Reg__SignalControlZone_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new REGION::Reg__SignalControlZone_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (REGION::Reg__SignalControlZone_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int PreemptPriorityList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int PreemptPriorityList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.PreemptPriorityList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.PreemptPriorityList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.PreemptPriorityList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.PreemptPriorityList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.PreemptPriorityList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.PreemptPriorityList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.PreemptPriorityList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.PreemptPriorityList");
}

boolean PreemptPriorityList_template::match(const PreemptPriorityList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.PreemptPriorityList.");
}
return FALSE;
}

boolean PreemptPriorityList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

PreemptPriorityList PreemptPriorityList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.PreemptPriorityList.");
PreemptPriorityList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

PreemptPriorityList PreemptPriorityList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

PreemptPriorityList PreemptPriorityList_template::replace(int index, int len, const PreemptPriorityList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

PreemptPriorityList PreemptPriorityList_template::replace(int index, int len, const PreemptPriorityList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void PreemptPriorityList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new PreemptPriorityList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.PreemptPriorityList.");
}
set_selection(template_type);
}

PreemptPriorityList_template& PreemptPriorityList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.PreemptPriorityList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.PreemptPriorityList.");
return value_list.list_value[list_index];
}

void PreemptPriorityList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void PreemptPriorityList_template::log_match(const PreemptPriorityList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PreemptPriorityList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.PreemptPriorityList.");
}
}

void PreemptPriorityList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.PreemptPriorityList.");
single_value.value_elements = (REGION::Reg__SignalControlZone_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new REGION::Reg__SignalControlZone_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PreemptPriorityList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.PreemptPriorityList.");
}
}

boolean PreemptPriorityList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PreemptPriorityList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PreemptPriorityList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.PreemptPriorityList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PreemptPriorityList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.PreemptPriorityList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* PreemptPriorityList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.PreemptPriorityList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void PreemptPriorityList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.PreemptPriorityList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.PreemptPriorityList");
}


const RoadSegment RoadSegmentList::UNBOUND_ELEM;
RoadSegmentList::RoadSegmentList()
{
val_ptr = NULL;
}

RoadSegmentList::RoadSegmentList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

RoadSegmentList::RoadSegmentList(const RoadSegmentList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.RoadSegmentList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

RoadSegmentList::~RoadSegmentList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void RoadSegmentList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

RoadSegmentList& RoadSegmentList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

RoadSegmentList& RoadSegmentList::operator=(const RoadSegmentList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.RoadSegmentList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean RoadSegmentList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RoadSegmentList.");
return val_ptr->n_elements == 0 ;
}

boolean RoadSegmentList::operator==(const RoadSegmentList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RoadSegmentList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RoadSegmentList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

RoadSegment& RoadSegmentList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RoadSegmentList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (RoadSegment**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RoadSegment(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new RoadSegment;
}
return *val_ptr->value_elements[index_value];
}

RoadSegment& RoadSegmentList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RoadSegmentList.");
return (*this)[(int)index_value];
}

const RoadSegment& RoadSegmentList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.RoadSegmentList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RoadSegmentList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.RoadSegmentList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const RoadSegment& RoadSegmentList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RoadSegmentList.");
return (*this)[(int)index_value];
}

RoadSegmentList RoadSegmentList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

RoadSegmentList RoadSegmentList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

RoadSegmentList RoadSegmentList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

RoadSegmentList RoadSegmentList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.RoadSegmentList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
RoadSegmentList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new RoadSegment(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

RoadSegmentList RoadSegmentList::operator+(const RoadSegmentList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.RoadSegmentList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
RoadSegmentList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RoadSegment(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new RoadSegment(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

RoadSegmentList RoadSegmentList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.RoadSegmentList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.RoadSegmentList","element");
RoadSegmentList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new RoadSegment(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

RoadSegmentList RoadSegmentList::replace(int index, int len, const RoadSegmentList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.RoadSegmentList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.RoadSegmentList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.RoadSegmentList","element");
RoadSegmentList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RoadSegment(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new RoadSegment(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new RoadSegment(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

RoadSegmentList RoadSegmentList::replace(int index, int len, const RoadSegmentList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void RoadSegmentList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.RoadSegmentList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (RoadSegment**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RoadSegment(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (RoadSegment**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.RoadSegmentList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (RoadSegment**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean RoadSegmentList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int RoadSegmentList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.RoadSegmentList.");
return val_ptr->n_elements;
}

int RoadSegmentList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.RoadSegmentList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void RoadSegmentList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void RoadSegmentList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.RoadSegmentList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.RoadSegmentList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.RoadSegmentList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* RoadSegmentList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.RoadSegmentList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void RoadSegmentList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void RoadSegmentList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.RoadSegmentList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void RoadSegmentList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.RoadSegmentList.");
val_ptr->value_elements = (RoadSegment**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new RoadSegment;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void RoadSegmentList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RoadSegmentList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RoadSegmentList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RoadSegmentList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (RoadSegment**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new RoadSegment;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int RoadSegmentList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.RoadSegmentList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int RoadSegmentList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    RoadSegment* val = new RoadSegment;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (RoadSegment**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void RoadSegmentList_template::copy_value(const RoadSegmentList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.RoadSegmentList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (RoadSegment_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new RoadSegment_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new RoadSegment_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void RoadSegmentList_template::copy_template(const RoadSegmentList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (RoadSegment_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new RoadSegment_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new RoadSegment_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RoadSegmentList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.RoadSegmentList.");
break;
}
set_selection(other_value);
}

boolean RoadSegmentList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const RoadSegmentList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const RoadSegmentList*)value_ptr)[value_index], legacy);
else return ((const RoadSegmentList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

RoadSegmentList_template::RoadSegmentList_template()
{
}

RoadSegmentList_template::RoadSegmentList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

RoadSegmentList_template::RoadSegmentList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

RoadSegmentList_template::RoadSegmentList_template(const RoadSegmentList& other_value)
{
copy_value(other_value);
}

RoadSegmentList_template::RoadSegmentList_template(const OPTIONAL<RoadSegmentList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadSegmentList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.RoadSegmentList from an unbound optional field.");
}
}

RoadSegmentList_template::RoadSegmentList_template(const RoadSegmentList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

RoadSegmentList_template::~RoadSegmentList_template()
{
clean_up();
}

void RoadSegmentList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RoadSegmentList_template& RoadSegmentList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RoadSegmentList_template& RoadSegmentList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

RoadSegmentList_template& RoadSegmentList_template::operator=(const RoadSegmentList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RoadSegmentList_template& RoadSegmentList_template::operator=(const OPTIONAL<RoadSegmentList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadSegmentList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.RoadSegmentList.");
}
return *this;
}

RoadSegmentList_template& RoadSegmentList_template::operator=(const RoadSegmentList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

RoadSegment_template& RoadSegmentList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RoadSegmentList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.RoadSegmentList.");
    break;
}
return *single_value.value_elements[index_value];
}

RoadSegment_template& RoadSegmentList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RoadSegmentList.");
return (*this)[(int)index_value];
}

const RoadSegment_template& RoadSegmentList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RoadSegmentList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.RoadSegmentList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.RoadSegmentList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const RoadSegment_template& RoadSegmentList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RoadSegmentList.");
return (*this)[(int)index_value];
}

void RoadSegmentList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.RoadSegmentList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (RoadSegment_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RoadSegment_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RoadSegment_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (RoadSegment_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int RoadSegmentList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int RoadSegmentList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadSegmentList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadSegmentList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadSegmentList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadSegmentList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadSegmentList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadSegmentList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.RoadSegmentList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.RoadSegmentList");
}

boolean RoadSegmentList_template::match(const RoadSegmentList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.RoadSegmentList.");
}
return FALSE;
}

boolean RoadSegmentList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

RoadSegmentList RoadSegmentList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.RoadSegmentList.");
RoadSegmentList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

RoadSegmentList RoadSegmentList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

RoadSegmentList RoadSegmentList_template::replace(int index, int len, const RoadSegmentList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

RoadSegmentList RoadSegmentList_template::replace(int index, int len, const RoadSegmentList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void RoadSegmentList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new RoadSegmentList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.RoadSegmentList.");
}
set_selection(template_type);
}

RoadSegmentList_template& RoadSegmentList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.RoadSegmentList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.RoadSegmentList.");
return value_list.list_value[list_index];
}

void RoadSegmentList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void RoadSegmentList_template::log_match(const RoadSegmentList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RoadSegmentList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.RoadSegmentList.");
}
}

void RoadSegmentList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.RoadSegmentList.");
single_value.value_elements = (RoadSegment_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new RoadSegment_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RoadSegmentList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.RoadSegmentList.");
}
}

boolean RoadSegmentList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RoadSegmentList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RoadSegmentList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.RoadSegmentList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RoadSegmentList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.RoadSegmentList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* RoadSegmentList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.RoadSegmentList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void RoadSegmentList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegmentList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RoadSegmentList");
}

RoadSegmentReferenceID::RoadSegmentReferenceID()
{
  bound_flag = FALSE;
}

RoadSegmentReferenceID::RoadSegmentReferenceID(const OPTIONAL<INTEGER>& par_region,
    const INTEGER& par_id)
  :   field_region(par_region),
  field_id(par_id)
{
  bound_flag = TRUE;
}

RoadSegmentReferenceID::RoadSegmentReferenceID(const RoadSegmentReferenceID& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.RoadSegmentReferenceID.");
bound_flag = TRUE;
if (other_value.region().is_bound()) field_region = other_value.region();
else field_region.clean_up();
if (other_value.id().is_bound()) field_id = other_value.id();
else field_id.clean_up();
}

void RoadSegmentReferenceID::clean_up()
{
field_region.clean_up();
field_id.clean_up();
bound_flag = FALSE;
}

RoadSegmentReferenceID& RoadSegmentReferenceID::operator=(const RoadSegmentReferenceID& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.RoadSegmentReferenceID.");
  bound_flag = TRUE;
  if (other_value.region().is_bound()) field_region = other_value.region();
  else field_region.clean_up();
  if (other_value.id().is_bound()) field_id = other_value.id();
  else field_id.clean_up();
}
return *this;
}

boolean RoadSegmentReferenceID::operator==(const RoadSegmentReferenceID& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_region==other_value.field_region
  && field_id==other_value.field_id;
}

boolean RoadSegmentReferenceID::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_region.get_selection() || field_region.is_bound()) return TRUE;
if(field_id.is_bound()) return TRUE;
return FALSE;
}
boolean RoadSegmentReferenceID::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_region.get_selection() && !field_region.is_value()) return FALSE;
if(!field_id.is_value()) return FALSE;
return TRUE;
}
int RoadSegmentReferenceID::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.RoadSegmentReferenceID");
  int ret_val = 1;
  if (field_region.ispresent()) ret_val++;
  return ret_val;
}

void RoadSegmentReferenceID::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ region := ");
field_region.log();
TTCN_Logger::log_event_str(", id := ");
field_id.log();
TTCN_Logger::log_event_str(" }");
}

void RoadSegmentReferenceID::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.RoadSegmentReferenceID'");
    }
    if (strcmp("region", param_field) == 0) {
      region().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.RoadSegmentReferenceID'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @DSRC.RoadSegmentReferenceID has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) region().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.RoadSegmentReferenceID: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.RoadSegmentReferenceID");
  }
}

Module_Param* RoadSegmentReferenceID::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.RoadSegmentReferenceID'");
    }
    if (strcmp("region", param_field) == 0) {
      return region().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.RoadSegmentReferenceID'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_region = field_region.get_param(param_name);
  mp_field_region->set_id(new Module_Param_FieldName(mcopystr("region")));
  mp->add_elem(mp_field_region);
  Module_Param* mp_field_id = field_id.get_param(param_name);
  mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
  mp->add_elem(mp_field_id);
  return mp;
  }

void RoadSegmentReferenceID::set_implicit_omit()
{
if (!region().is_bound()) region() = OMIT_VALUE;
else region().set_implicit_omit();
if (id().is_bound()) id().set_implicit_omit();
}

void RoadSegmentReferenceID::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.RoadSegmentReferenceID.");
field_region.encode_text(text_buf);
field_id.encode_text(text_buf);
}

void RoadSegmentReferenceID::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_region.decode_text(text_buf);
field_id.decode_text(text_buf);
}

void RoadSegmentReferenceID::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RoadSegmentReferenceID::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RoadSegmentReferenceID::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("region': ");
  new_tlv->add_TLV(field_region.BER_encode_TLV(RoadSegmentReferenceID_region_descr_, p_coding));
  ec_1.set_msg("id': ");
  new_tlv->add_TLV(field_id.BER_encode_TLV(RoadSegmentReferenceID_id_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RoadSegmentReferenceID::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.RoadSegmentReferenceID' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("region': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_region=OMIT_VALUE;
    else {
      field_region.BER_decode_TLV(RoadSegmentReferenceID_region_descr_, tmp_tlv, L_form);
      if(field_region.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("id': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_id.BER_decode_TLV(RoadSegmentReferenceID_id_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int RoadSegmentReferenceID::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.RoadSegmentReferenceID.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_region.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "region");
    enc_len += field_region.JSON_encode(RoadSegmentReferenceID_region_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "id");
    enc_len += field_id.JSON_encode(RoadSegmentReferenceID_id_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RoadSegmentReferenceID::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "region", name_len)) {
         int ret_val = field_region.JSON_decode(RoadSegmentReferenceID_region_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "region");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (2 == name_len && 0 == strncmp(fld_name, "id", name_len)) {
         int ret_val = field_id.JSON_decode(RoadSegmentReferenceID_id_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "id");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_region.is_bound()) {
    field_region = OMIT_VALUE;
  }
if (!field_id.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "id");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct RoadSegmentReferenceID_template::single_value_struct {
INTEGER_template field_region;
INTEGER_template field_id;
};

void RoadSegmentReferenceID_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_region = ANY_OR_OMIT;
single_value->field_id = ANY_VALUE;
}
}
}

void RoadSegmentReferenceID_template::copy_value(const RoadSegmentReferenceID& other_value)
{
single_value = new single_value_struct;
if (other_value.region().is_bound()) {
  if (other_value.region().ispresent()) single_value->field_region = other_value.region()();
  else single_value->field_region = OMIT_VALUE;
} else {
  single_value->field_region.clean_up();
}
if (other_value.id().is_bound()) {
  single_value->field_id = other_value.id();
} else {
  single_value->field_id.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RoadSegmentReferenceID_template::copy_template(const RoadSegmentReferenceID_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.region().get_selection()) {
single_value->field_region = other_value.region();
} else {
single_value->field_region.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.id().get_selection()) {
single_value->field_id = other_value.id();
} else {
single_value->field_id.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RoadSegmentReferenceID_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.RoadSegmentReferenceID.");
break;
}
set_selection(other_value);
}

RoadSegmentReferenceID_template::RoadSegmentReferenceID_template()
{
}

RoadSegmentReferenceID_template::RoadSegmentReferenceID_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RoadSegmentReferenceID_template::RoadSegmentReferenceID_template(const RoadSegmentReferenceID& other_value)
{
copy_value(other_value);
}

RoadSegmentReferenceID_template::RoadSegmentReferenceID_template(const OPTIONAL<RoadSegmentReferenceID>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadSegmentReferenceID&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.RoadSegmentReferenceID from an unbound optional field.");
}
}

RoadSegmentReferenceID_template::RoadSegmentReferenceID_template(const RoadSegmentReferenceID_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RoadSegmentReferenceID_template::~RoadSegmentReferenceID_template()
{
clean_up();
}

RoadSegmentReferenceID_template& RoadSegmentReferenceID_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RoadSegmentReferenceID_template& RoadSegmentReferenceID_template::operator=(const RoadSegmentReferenceID& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RoadSegmentReferenceID_template& RoadSegmentReferenceID_template::operator=(const OPTIONAL<RoadSegmentReferenceID>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadSegmentReferenceID&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.RoadSegmentReferenceID.");
}
return *this;
}

RoadSegmentReferenceID_template& RoadSegmentReferenceID_template::operator=(const RoadSegmentReferenceID_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RoadSegmentReferenceID_template::match(const RoadSegmentReferenceID& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.region().is_bound()) return FALSE;
if((other_value.region().ispresent() ? !single_value->field_region.match((const INTEGER&)other_value.region(), legacy) : !single_value->field_region.match_omit(legacy)))return FALSE;
if(!other_value.id().is_bound()) return FALSE;
if(!single_value->field_id.match(other_value.id(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.RoadSegmentReferenceID.");
}
return FALSE;
}

boolean RoadSegmentReferenceID_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_region.is_omit() || single_value->field_region.is_bound()) return TRUE;
if (single_value->field_id.is_bound()) return TRUE;
return FALSE;
}

boolean RoadSegmentReferenceID_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_region.is_omit() && !single_value->field_region.is_value()) return FALSE;
if (!single_value->field_id.is_value()) return FALSE;
return TRUE;
}

void RoadSegmentReferenceID_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RoadSegmentReferenceID RoadSegmentReferenceID_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.RoadSegmentReferenceID.");
RoadSegmentReferenceID ret_val;
if (single_value->field_region.is_omit()) ret_val.region() = OMIT_VALUE;
else if (single_value->field_region.is_bound()) {
ret_val.region() = single_value->field_region.valueof();
}
if (single_value->field_id.is_bound()) {
ret_val.id() = single_value->field_id.valueof();
}
return ret_val;
}

void RoadSegmentReferenceID_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.RoadSegmentReferenceID.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RoadSegmentReferenceID_template[list_length];
}

RoadSegmentReferenceID_template& RoadSegmentReferenceID_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.RoadSegmentReferenceID.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.RoadSegmentReferenceID.");
return value_list.list_value[list_index];
}

INTEGER_template& RoadSegmentReferenceID_template::region()
{
set_specific();
return single_value->field_region;
}

const INTEGER_template& RoadSegmentReferenceID_template::region() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field region of a non-specific template of type @DSRC.RoadSegmentReferenceID.");
return single_value->field_region;
}

INTEGER_template& RoadSegmentReferenceID_template::id()
{
set_specific();
return single_value->field_id;
}

const INTEGER_template& RoadSegmentReferenceID_template::id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field id of a non-specific template of type @DSRC.RoadSegmentReferenceID.");
return single_value->field_id;
}

int RoadSegmentReferenceID_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegmentReferenceID which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_region.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.RoadSegmentReferenceID containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegmentReferenceID containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegmentReferenceID containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegmentReferenceID containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegmentReferenceID containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.RoadSegmentReferenceID.");
  }
  return 0;
}

void RoadSegmentReferenceID_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ region := ");
single_value->field_region.log();
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RoadSegmentReferenceID_template::log_match(const RoadSegmentReferenceID& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.region().ispresent()){
if(!single_value->field_region.match(match_value.region(), legacy)){
TTCN_Logger::log_logmatch_info(".region");
single_value->field_region.log_match(match_value.region(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_region.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".region := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_region.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_id.match(match_value.id(), legacy)){
TTCN_Logger::log_logmatch_info(".id");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ region := ");
if (match_value.region().ispresent()) single_value->field_region.log_match(match_value.region(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_region.log();
if (single_value->field_region.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RoadSegmentReferenceID_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_region.encode_text(text_buf);
single_value->field_id.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.RoadSegmentReferenceID.");
}
}

void RoadSegmentReferenceID_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_region.decode_text(text_buf);
single_value->field_id.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RoadSegmentReferenceID_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.RoadSegmentReferenceID.");
}
}

void RoadSegmentReferenceID_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.RoadSegmentReferenceID'");
    }
    if (strcmp("region", param_field) == 0) {
      region().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.RoadSegmentReferenceID'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RoadSegmentReferenceID_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @DSRC.RoadSegmentReferenceID has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) region().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.RoadSegmentReferenceID: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.RoadSegmentReferenceID");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RoadSegmentReferenceID_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.RoadSegmentReferenceID'");
    }
    if (strcmp("region", param_field) == 0) {
      return region().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.RoadSegmentReferenceID'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_region = single_value->field_region.get_param(param_name);
    mp_field_region->set_id(new Module_Param_FieldName(mcopystr("region")));
    mp->add_elem(mp_field_region);
    Module_Param* mp_field_id = single_value->field_id.get_param(param_name);
    mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
    mp->add_elem(mp_field_id);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RoadSegmentReferenceID_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_region.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegmentReferenceID");
single_value->field_id.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegmentReferenceID");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RoadSegmentReferenceID");
}

boolean RoadSegmentReferenceID_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RoadSegmentReferenceID_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const GenericLane RoadLaneSetList::UNBOUND_ELEM;
RoadLaneSetList::RoadLaneSetList()
{
val_ptr = NULL;
}

RoadLaneSetList::RoadLaneSetList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

RoadLaneSetList::RoadLaneSetList(const RoadLaneSetList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.RoadLaneSetList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

RoadLaneSetList::~RoadLaneSetList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void RoadLaneSetList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

RoadLaneSetList& RoadLaneSetList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

RoadLaneSetList& RoadLaneSetList::operator=(const RoadLaneSetList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.RoadLaneSetList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean RoadLaneSetList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RoadLaneSetList.");
return val_ptr->n_elements == 0 ;
}

boolean RoadLaneSetList::operator==(const RoadLaneSetList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RoadLaneSetList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RoadLaneSetList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

GenericLane& RoadLaneSetList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RoadLaneSetList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (GenericLane**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new GenericLane(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new GenericLane;
}
return *val_ptr->value_elements[index_value];
}

GenericLane& RoadLaneSetList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RoadLaneSetList.");
return (*this)[(int)index_value];
}

const GenericLane& RoadLaneSetList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.RoadLaneSetList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RoadLaneSetList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.RoadLaneSetList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const GenericLane& RoadLaneSetList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RoadLaneSetList.");
return (*this)[(int)index_value];
}

RoadLaneSetList RoadLaneSetList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

RoadLaneSetList RoadLaneSetList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

RoadLaneSetList RoadLaneSetList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

RoadLaneSetList RoadLaneSetList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.RoadLaneSetList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
RoadLaneSetList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new GenericLane(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

RoadLaneSetList RoadLaneSetList::operator+(const RoadLaneSetList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.RoadLaneSetList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
RoadLaneSetList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new GenericLane(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new GenericLane(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

RoadLaneSetList RoadLaneSetList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.RoadLaneSetList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.RoadLaneSetList","element");
RoadLaneSetList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new GenericLane(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

RoadLaneSetList RoadLaneSetList::replace(int index, int len, const RoadLaneSetList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.RoadLaneSetList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.RoadLaneSetList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.RoadLaneSetList","element");
RoadLaneSetList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new GenericLane(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new GenericLane(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new GenericLane(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

RoadLaneSetList RoadLaneSetList::replace(int index, int len, const RoadLaneSetList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void RoadLaneSetList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.RoadLaneSetList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (GenericLane**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new GenericLane(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (GenericLane**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.RoadLaneSetList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (GenericLane**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean RoadLaneSetList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int RoadLaneSetList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.RoadLaneSetList.");
return val_ptr->n_elements;
}

int RoadLaneSetList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.RoadLaneSetList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void RoadLaneSetList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void RoadLaneSetList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.RoadLaneSetList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.RoadLaneSetList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.RoadLaneSetList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* RoadLaneSetList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.RoadLaneSetList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void RoadLaneSetList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void RoadLaneSetList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.RoadLaneSetList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void RoadLaneSetList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.RoadLaneSetList.");
val_ptr->value_elements = (GenericLane**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new GenericLane;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void RoadLaneSetList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RoadLaneSetList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RoadLaneSetList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RoadLaneSetList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (GenericLane**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new GenericLane;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int RoadLaneSetList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.RoadLaneSetList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int RoadLaneSetList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    GenericLane* val = new GenericLane;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (GenericLane**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void RoadLaneSetList_template::copy_value(const RoadLaneSetList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.RoadLaneSetList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (GenericLane_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new GenericLane_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new GenericLane_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void RoadLaneSetList_template::copy_template(const RoadLaneSetList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (GenericLane_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new GenericLane_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new GenericLane_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RoadLaneSetList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.RoadLaneSetList.");
break;
}
set_selection(other_value);
}

boolean RoadLaneSetList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const RoadLaneSetList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const RoadLaneSetList*)value_ptr)[value_index], legacy);
else return ((const RoadLaneSetList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

RoadLaneSetList_template::RoadLaneSetList_template()
{
}

RoadLaneSetList_template::RoadLaneSetList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

RoadLaneSetList_template::RoadLaneSetList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

RoadLaneSetList_template::RoadLaneSetList_template(const RoadLaneSetList& other_value)
{
copy_value(other_value);
}

RoadLaneSetList_template::RoadLaneSetList_template(const OPTIONAL<RoadLaneSetList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadLaneSetList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.RoadLaneSetList from an unbound optional field.");
}
}

RoadLaneSetList_template::RoadLaneSetList_template(const RoadLaneSetList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

RoadLaneSetList_template::~RoadLaneSetList_template()
{
clean_up();
}

void RoadLaneSetList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RoadLaneSetList_template& RoadLaneSetList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RoadLaneSetList_template& RoadLaneSetList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

RoadLaneSetList_template& RoadLaneSetList_template::operator=(const RoadLaneSetList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RoadLaneSetList_template& RoadLaneSetList_template::operator=(const OPTIONAL<RoadLaneSetList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadLaneSetList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.RoadLaneSetList.");
}
return *this;
}

RoadLaneSetList_template& RoadLaneSetList_template::operator=(const RoadLaneSetList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

GenericLane_template& RoadLaneSetList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RoadLaneSetList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.RoadLaneSetList.");
    break;
}
return *single_value.value_elements[index_value];
}

GenericLane_template& RoadLaneSetList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RoadLaneSetList.");
return (*this)[(int)index_value];
}

const GenericLane_template& RoadLaneSetList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RoadLaneSetList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.RoadLaneSetList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.RoadLaneSetList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const GenericLane_template& RoadLaneSetList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RoadLaneSetList.");
return (*this)[(int)index_value];
}

void RoadLaneSetList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.RoadLaneSetList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (GenericLane_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new GenericLane_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new GenericLane_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (GenericLane_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int RoadLaneSetList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int RoadLaneSetList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadLaneSetList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadLaneSetList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadLaneSetList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadLaneSetList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadLaneSetList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RoadLaneSetList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.RoadLaneSetList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.RoadLaneSetList");
}

boolean RoadLaneSetList_template::match(const RoadLaneSetList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.RoadLaneSetList.");
}
return FALSE;
}

boolean RoadLaneSetList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

RoadLaneSetList RoadLaneSetList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.RoadLaneSetList.");
RoadLaneSetList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

RoadLaneSetList RoadLaneSetList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

RoadLaneSetList RoadLaneSetList_template::replace(int index, int len, const RoadLaneSetList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

RoadLaneSetList RoadLaneSetList_template::replace(int index, int len, const RoadLaneSetList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void RoadLaneSetList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new RoadLaneSetList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.RoadLaneSetList.");
}
set_selection(template_type);
}

RoadLaneSetList_template& RoadLaneSetList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.RoadLaneSetList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.RoadLaneSetList.");
return value_list.list_value[list_index];
}

void RoadLaneSetList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void RoadLaneSetList_template::log_match(const RoadLaneSetList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RoadLaneSetList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.RoadLaneSetList.");
}
}

void RoadLaneSetList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.RoadLaneSetList.");
single_value.value_elements = (GenericLane_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new GenericLane_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RoadLaneSetList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.RoadLaneSetList.");
}
}

boolean RoadLaneSetList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RoadLaneSetList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RoadLaneSetList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.RoadLaneSetList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RoadLaneSetList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.RoadLaneSetList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* RoadLaneSetList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.RoadLaneSetList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void RoadLaneSetList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.RoadLaneSetList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RoadLaneSetList");
}

RoadSegment::RoadSegment()
{
  bound_flag = FALSE;
}

RoadSegment::RoadSegment(const OPTIONAL<CHARSTRING>& par_name,
    const RoadSegmentReferenceID& par_id,
    const INTEGER& par_revision,
    const Position3D__2& par_refPoint,
    const OPTIONAL<INTEGER>& par_laneWidth,
    const OPTIONAL<SpeedLimitList>& par_speedLimits,
    const RoadLaneSetList& par_roadLaneSet,
    const OPTIONAL<REGION::Reg__RoadSegment>& par_regional)
  :   field_name(par_name),
  field_id(par_id),
  field_revision(par_revision),
  field_refPoint(par_refPoint),
  field_laneWidth(par_laneWidth),
  field_speedLimits(par_speedLimits),
  field_roadLaneSet(par_roadLaneSet),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

RoadSegment::RoadSegment(const RoadSegment& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.RoadSegment.");
bound_flag = TRUE;
if (other_value.name().is_bound()) field_name = other_value.name();
else field_name.clean_up();
if (other_value.id().is_bound()) field_id = other_value.id();
else field_id.clean_up();
if (other_value.revision().is_bound()) field_revision = other_value.revision();
else field_revision.clean_up();
if (other_value.refPoint().is_bound()) field_refPoint = other_value.refPoint();
else field_refPoint.clean_up();
if (other_value.laneWidth().is_bound()) field_laneWidth = other_value.laneWidth();
else field_laneWidth.clean_up();
if (other_value.speedLimits().is_bound()) field_speedLimits = other_value.speedLimits();
else field_speedLimits.clean_up();
if (other_value.roadLaneSet().is_bound()) field_roadLaneSet = other_value.roadLaneSet();
else field_roadLaneSet.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void RoadSegment::clean_up()
{
field_name.clean_up();
field_id.clean_up();
field_revision.clean_up();
field_refPoint.clean_up();
field_laneWidth.clean_up();
field_speedLimits.clean_up();
field_roadLaneSet.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

RoadSegment& RoadSegment::operator=(const RoadSegment& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.RoadSegment.");
  bound_flag = TRUE;
  if (other_value.name().is_bound()) field_name = other_value.name();
  else field_name.clean_up();
  if (other_value.id().is_bound()) field_id = other_value.id();
  else field_id.clean_up();
  if (other_value.revision().is_bound()) field_revision = other_value.revision();
  else field_revision.clean_up();
  if (other_value.refPoint().is_bound()) field_refPoint = other_value.refPoint();
  else field_refPoint.clean_up();
  if (other_value.laneWidth().is_bound()) field_laneWidth = other_value.laneWidth();
  else field_laneWidth.clean_up();
  if (other_value.speedLimits().is_bound()) field_speedLimits = other_value.speedLimits();
  else field_speedLimits.clean_up();
  if (other_value.roadLaneSet().is_bound()) field_roadLaneSet = other_value.roadLaneSet();
  else field_roadLaneSet.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean RoadSegment::operator==(const RoadSegment& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_name==other_value.field_name
  && field_id==other_value.field_id
  && field_revision==other_value.field_revision
  && field_refPoint==other_value.field_refPoint
  && field_laneWidth==other_value.field_laneWidth
  && field_speedLimits==other_value.field_speedLimits
  && field_roadLaneSet==other_value.field_roadLaneSet
  && field_regional==other_value.field_regional;
}

boolean RoadSegment::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_name.get_selection() || field_name.is_bound()) return TRUE;
if(field_id.is_bound()) return TRUE;
if(field_revision.is_bound()) return TRUE;
if(field_refPoint.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_laneWidth.get_selection() || field_laneWidth.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_speedLimits.get_selection() || field_speedLimits.is_bound()) return TRUE;
if(field_roadLaneSet.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean RoadSegment::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_name.get_selection() && !field_name.is_value()) return FALSE;
if(!field_id.is_value()) return FALSE;
if(!field_revision.is_value()) return FALSE;
if(!field_refPoint.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_laneWidth.get_selection() && !field_laneWidth.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_speedLimits.get_selection() && !field_speedLimits.is_value()) return FALSE;
if(!field_roadLaneSet.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int RoadSegment::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.RoadSegment");
  int ret_val = 4;
  if (field_name.ispresent()) ret_val++;
  if (field_laneWidth.ispresent()) ret_val++;
  if (field_speedLimits.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void RoadSegment::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ name := ");
field_name.log();
TTCN_Logger::log_event_str(", id := ");
field_id.log();
TTCN_Logger::log_event_str(", revision := ");
field_revision.log();
TTCN_Logger::log_event_str(", refPoint := ");
field_refPoint.log();
TTCN_Logger::log_event_str(", laneWidth := ");
field_laneWidth.log();
TTCN_Logger::log_event_str(", speedLimits := ");
field_speedLimits.log();
TTCN_Logger::log_event_str(", roadLaneSet := ");
field_roadLaneSet.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void RoadSegment::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.RoadSegment'");
    }
    if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("revision", param_field) == 0) {
      revision().set_param(param);
      return;
    } else if (strcmp("refPoint", param_field) == 0) {
      refPoint().set_param(param);
      return;
    } else if (strcmp("laneWidth", param_field) == 0) {
      laneWidth().set_param(param);
      return;
    } else if (strcmp("speedLimits", param_field) == 0) {
      speedLimits().set_param(param);
      return;
    } else if (strcmp("roadLaneSet", param_field) == 0) {
      roadLaneSet().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.RoadSegment'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record value of type @DSRC.RoadSegment has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) revision().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) refPoint().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) laneWidth().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) speedLimits().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) roadLaneSet().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "revision")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          revision().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "refPoint")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          refPoint().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneWidth")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneWidth().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimits().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadLaneSet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadLaneSet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.RoadSegment: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.RoadSegment");
  }
}

Module_Param* RoadSegment::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.RoadSegment'");
    }
    if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else if (strcmp("revision", param_field) == 0) {
      return revision().get_param(param_name);
    } else if (strcmp("refPoint", param_field) == 0) {
      return refPoint().get_param(param_name);
    } else if (strcmp("laneWidth", param_field) == 0) {
      return laneWidth().get_param(param_name);
    } else if (strcmp("speedLimits", param_field) == 0) {
      return speedLimits().get_param(param_name);
    } else if (strcmp("roadLaneSet", param_field) == 0) {
      return roadLaneSet().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.RoadSegment'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_name = field_name.get_param(param_name);
  mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
  mp->add_elem(mp_field_name);
  Module_Param* mp_field_id = field_id.get_param(param_name);
  mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
  mp->add_elem(mp_field_id);
  Module_Param* mp_field_revision = field_revision.get_param(param_name);
  mp_field_revision->set_id(new Module_Param_FieldName(mcopystr("revision")));
  mp->add_elem(mp_field_revision);
  Module_Param* mp_field_refPoint = field_refPoint.get_param(param_name);
  mp_field_refPoint->set_id(new Module_Param_FieldName(mcopystr("refPoint")));
  mp->add_elem(mp_field_refPoint);
  Module_Param* mp_field_laneWidth = field_laneWidth.get_param(param_name);
  mp_field_laneWidth->set_id(new Module_Param_FieldName(mcopystr("laneWidth")));
  mp->add_elem(mp_field_laneWidth);
  Module_Param* mp_field_speedLimits = field_speedLimits.get_param(param_name);
  mp_field_speedLimits->set_id(new Module_Param_FieldName(mcopystr("speedLimits")));
  mp->add_elem(mp_field_speedLimits);
  Module_Param* mp_field_roadLaneSet = field_roadLaneSet.get_param(param_name);
  mp_field_roadLaneSet->set_id(new Module_Param_FieldName(mcopystr("roadLaneSet")));
  mp->add_elem(mp_field_roadLaneSet);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void RoadSegment::set_implicit_omit()
{
if (!name().is_bound()) name() = OMIT_VALUE;
else name().set_implicit_omit();
if (id().is_bound()) id().set_implicit_omit();
if (revision().is_bound()) revision().set_implicit_omit();
if (refPoint().is_bound()) refPoint().set_implicit_omit();
if (!laneWidth().is_bound()) laneWidth() = OMIT_VALUE;
else laneWidth().set_implicit_omit();
if (!speedLimits().is_bound()) speedLimits() = OMIT_VALUE;
else speedLimits().set_implicit_omit();
if (roadLaneSet().is_bound()) roadLaneSet().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void RoadSegment::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.RoadSegment.");
field_name.encode_text(text_buf);
field_id.encode_text(text_buf);
field_revision.encode_text(text_buf);
field_refPoint.encode_text(text_buf);
field_laneWidth.encode_text(text_buf);
field_speedLimits.encode_text(text_buf);
field_roadLaneSet.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void RoadSegment::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_name.decode_text(text_buf);
field_id.decode_text(text_buf);
field_revision.decode_text(text_buf);
field_refPoint.decode_text(text_buf);
field_laneWidth.decode_text(text_buf);
field_speedLimits.decode_text(text_buf);
field_roadLaneSet.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void RoadSegment::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RoadSegment::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RoadSegment::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("name': ");
  new_tlv->add_TLV(field_name.BER_encode_TLV(RoadSegment_name_descr_, p_coding));
  ec_1.set_msg("id': ");
  new_tlv->add_TLV(field_id.BER_encode_TLV(RoadSegment_id_descr_, p_coding));
  ec_1.set_msg("revision': ");
  new_tlv->add_TLV(field_revision.BER_encode_TLV(RoadSegment_revision_descr_, p_coding));
  ec_1.set_msg("refPoint': ");
  new_tlv->add_TLV(field_refPoint.BER_encode_TLV(RoadSegment_refPoint_descr_, p_coding));
  ec_1.set_msg("laneWidth': ");
  new_tlv->add_TLV(field_laneWidth.BER_encode_TLV(RoadSegment_laneWidth_descr_, p_coding));
  ec_1.set_msg("speedLimits': ");
  new_tlv->add_TLV(field_speedLimits.BER_encode_TLV(RoadSegment_speedLimits_descr_, p_coding));
  ec_1.set_msg("roadLaneSet': ");
  new_tlv->add_TLV(field_roadLaneSet.BER_encode_TLV(RoadSegment_roadLaneSet_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(RoadSegment_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RoadSegment::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.RoadSegment' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("name': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_name=OMIT_VALUE;
    else {
      field_name.BER_decode_TLV(RoadSegment_name_descr_, tmp_tlv, L_form);
      if(field_name.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("id': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_id.BER_decode_TLV(RoadSegment_id_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("revision': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_revision.BER_decode_TLV(RoadSegment_revision_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("refPoint': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_refPoint.BER_decode_TLV(RoadSegment_refPoint_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("laneWidth': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_laneWidth=OMIT_VALUE;
    else {
      field_laneWidth.BER_decode_TLV(RoadSegment_laneWidth_descr_, tmp_tlv, L_form);
      if(field_laneWidth.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("speedLimits': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_speedLimits=OMIT_VALUE;
    else {
      field_speedLimits.BER_decode_TLV(RoadSegment_speedLimits_descr_, tmp_tlv, L_form);
      if(field_speedLimits.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("roadLaneSet': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_roadLaneSet.BER_decode_TLV(RoadSegment_roadLaneSet_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(RoadSegment_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int RoadSegment::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.RoadSegment.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_name.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "name");
    enc_len += field_name.JSON_encode(RoadSegment_name_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "id");
    enc_len += field_id.JSON_encode(RoadSegment_id_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "revision");
    enc_len += field_revision.JSON_encode(RoadSegment_revision_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "refPoint");
    enc_len += field_refPoint.JSON_encode(RoadSegment_refPoint_descr_, p_tok);
  }

  if (field_laneWidth.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "laneWidth");
    enc_len += field_laneWidth.JSON_encode(RoadSegment_laneWidth_descr_, p_tok);
  }

  if (field_speedLimits.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speedLimits");
    enc_len += field_speedLimits.JSON_encode(RoadSegment_speedLimits_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "roadLaneSet");
    enc_len += field_roadLaneSet.JSON_encode(RoadSegment_roadLaneSet_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(RoadSegment_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RoadSegment::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (4 == name_len && 0 == strncmp(fld_name, "name", name_len)) {
         int ret_val = field_name.JSON_decode(RoadSegment_name_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "name");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (2 == name_len && 0 == strncmp(fld_name, "id", name_len)) {
         int ret_val = field_id.JSON_decode(RoadSegment_id_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "id");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "revision", name_len)) {
         int ret_val = field_revision.JSON_decode(RoadSegment_revision_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "revision");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "refPoint", name_len)) {
         int ret_val = field_refPoint.JSON_decode(RoadSegment_refPoint_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "refPoint");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "laneWidth", name_len)) {
         int ret_val = field_laneWidth.JSON_decode(RoadSegment_laneWidth_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "laneWidth");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "speedLimits", name_len)) {
         int ret_val = field_speedLimits.JSON_decode(RoadSegment_speedLimits_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speedLimits");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "roadLaneSet", name_len)) {
         int ret_val = field_roadLaneSet.JSON_decode(RoadSegment_roadLaneSet_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "roadLaneSet");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(RoadSegment_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_name.is_bound()) {
    field_name = OMIT_VALUE;
  }
if (!field_id.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "id");
    return JSON_ERROR_FATAL;
  }
if (!field_revision.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "revision");
    return JSON_ERROR_FATAL;
  }
if (!field_refPoint.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "refPoint");
    return JSON_ERROR_FATAL;
  }
if (!field_laneWidth.is_bound()) {
    field_laneWidth = OMIT_VALUE;
  }
if (!field_speedLimits.is_bound()) {
    field_speedLimits = OMIT_VALUE;
  }
if (!field_roadLaneSet.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "roadLaneSet");
    return JSON_ERROR_FATAL;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct RoadSegment_template::single_value_struct {
CHARSTRING_template field_name;
RoadSegmentReferenceID_template field_id;
INTEGER_template field_revision;
Position3D__2_template field_refPoint;
INTEGER_template field_laneWidth;
SpeedLimitList_template field_speedLimits;
RoadLaneSetList_template field_roadLaneSet;
REGION::Reg__RoadSegment_template field_regional;
};

void RoadSegment_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_name = ANY_OR_OMIT;
single_value->field_id = ANY_VALUE;
single_value->field_revision = ANY_VALUE;
single_value->field_refPoint = ANY_VALUE;
single_value->field_laneWidth = ANY_OR_OMIT;
single_value->field_speedLimits = ANY_OR_OMIT;
single_value->field_roadLaneSet = ANY_VALUE;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void RoadSegment_template::copy_value(const RoadSegment& other_value)
{
single_value = new single_value_struct;
if (other_value.name().is_bound()) {
  if (other_value.name().ispresent()) single_value->field_name = other_value.name()();
  else single_value->field_name = OMIT_VALUE;
} else {
  single_value->field_name.clean_up();
}
if (other_value.id().is_bound()) {
  single_value->field_id = other_value.id();
} else {
  single_value->field_id.clean_up();
}
if (other_value.revision().is_bound()) {
  single_value->field_revision = other_value.revision();
} else {
  single_value->field_revision.clean_up();
}
if (other_value.refPoint().is_bound()) {
  single_value->field_refPoint = other_value.refPoint();
} else {
  single_value->field_refPoint.clean_up();
}
if (other_value.laneWidth().is_bound()) {
  if (other_value.laneWidth().ispresent()) single_value->field_laneWidth = other_value.laneWidth()();
  else single_value->field_laneWidth = OMIT_VALUE;
} else {
  single_value->field_laneWidth.clean_up();
}
if (other_value.speedLimits().is_bound()) {
  if (other_value.speedLimits().ispresent()) single_value->field_speedLimits = other_value.speedLimits()();
  else single_value->field_speedLimits = OMIT_VALUE;
} else {
  single_value->field_speedLimits.clean_up();
}
if (other_value.roadLaneSet().is_bound()) {
  single_value->field_roadLaneSet = other_value.roadLaneSet();
} else {
  single_value->field_roadLaneSet.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RoadSegment_template::copy_template(const RoadSegment_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.name().get_selection()) {
single_value->field_name = other_value.name();
} else {
single_value->field_name.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.id().get_selection()) {
single_value->field_id = other_value.id();
} else {
single_value->field_id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.revision().get_selection()) {
single_value->field_revision = other_value.revision();
} else {
single_value->field_revision.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.refPoint().get_selection()) {
single_value->field_refPoint = other_value.refPoint();
} else {
single_value->field_refPoint.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.laneWidth().get_selection()) {
single_value->field_laneWidth = other_value.laneWidth();
} else {
single_value->field_laneWidth.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speedLimits().get_selection()) {
single_value->field_speedLimits = other_value.speedLimits();
} else {
single_value->field_speedLimits.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.roadLaneSet().get_selection()) {
single_value->field_roadLaneSet = other_value.roadLaneSet();
} else {
single_value->field_roadLaneSet.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RoadSegment_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.RoadSegment.");
break;
}
set_selection(other_value);
}

RoadSegment_template::RoadSegment_template()
{
}

RoadSegment_template::RoadSegment_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RoadSegment_template::RoadSegment_template(const RoadSegment& other_value)
{
copy_value(other_value);
}

RoadSegment_template::RoadSegment_template(const OPTIONAL<RoadSegment>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadSegment&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.RoadSegment from an unbound optional field.");
}
}

RoadSegment_template::RoadSegment_template(const RoadSegment_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RoadSegment_template::~RoadSegment_template()
{
clean_up();
}

RoadSegment_template& RoadSegment_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RoadSegment_template& RoadSegment_template::operator=(const RoadSegment& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RoadSegment_template& RoadSegment_template::operator=(const OPTIONAL<RoadSegment>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadSegment&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.RoadSegment.");
}
return *this;
}

RoadSegment_template& RoadSegment_template::operator=(const RoadSegment_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RoadSegment_template::match(const RoadSegment& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.name().is_bound()) return FALSE;
if((other_value.name().ispresent() ? !single_value->field_name.match((const CHARSTRING&)other_value.name(), legacy) : !single_value->field_name.match_omit(legacy)))return FALSE;
if(!other_value.id().is_bound()) return FALSE;
if(!single_value->field_id.match(other_value.id(), legacy))return FALSE;
if(!other_value.revision().is_bound()) return FALSE;
if(!single_value->field_revision.match(other_value.revision(), legacy))return FALSE;
if(!other_value.refPoint().is_bound()) return FALSE;
if(!single_value->field_refPoint.match(other_value.refPoint(), legacy))return FALSE;
if(!other_value.laneWidth().is_bound()) return FALSE;
if((other_value.laneWidth().ispresent() ? !single_value->field_laneWidth.match((const INTEGER&)other_value.laneWidth(), legacy) : !single_value->field_laneWidth.match_omit(legacy)))return FALSE;
if(!other_value.speedLimits().is_bound()) return FALSE;
if((other_value.speedLimits().ispresent() ? !single_value->field_speedLimits.match((const SpeedLimitList&)other_value.speedLimits(), legacy) : !single_value->field_speedLimits.match_omit(legacy)))return FALSE;
if(!other_value.roadLaneSet().is_bound()) return FALSE;
if(!single_value->field_roadLaneSet.match(other_value.roadLaneSet(), legacy))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REGION::Reg__RoadSegment&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.RoadSegment.");
}
return FALSE;
}

boolean RoadSegment_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_name.is_omit() || single_value->field_name.is_bound()) return TRUE;
if (single_value->field_id.is_bound()) return TRUE;
if (single_value->field_revision.is_bound()) return TRUE;
if (single_value->field_refPoint.is_bound()) return TRUE;
if (single_value->field_laneWidth.is_omit() || single_value->field_laneWidth.is_bound()) return TRUE;
if (single_value->field_speedLimits.is_omit() || single_value->field_speedLimits.is_bound()) return TRUE;
if (single_value->field_roadLaneSet.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean RoadSegment_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_name.is_omit() && !single_value->field_name.is_value()) return FALSE;
if (!single_value->field_id.is_value()) return FALSE;
if (!single_value->field_revision.is_value()) return FALSE;
if (!single_value->field_refPoint.is_value()) return FALSE;
if (!single_value->field_laneWidth.is_omit() && !single_value->field_laneWidth.is_value()) return FALSE;
if (!single_value->field_speedLimits.is_omit() && !single_value->field_speedLimits.is_value()) return FALSE;
if (!single_value->field_roadLaneSet.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void RoadSegment_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RoadSegment RoadSegment_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.RoadSegment.");
RoadSegment ret_val;
if (single_value->field_name.is_omit()) ret_val.name() = OMIT_VALUE;
else if (single_value->field_name.is_bound()) {
ret_val.name() = single_value->field_name.valueof();
}
if (single_value->field_id.is_bound()) {
ret_val.id() = single_value->field_id.valueof();
}
if (single_value->field_revision.is_bound()) {
ret_val.revision() = single_value->field_revision.valueof();
}
if (single_value->field_refPoint.is_bound()) {
ret_val.refPoint() = single_value->field_refPoint.valueof();
}
if (single_value->field_laneWidth.is_omit()) ret_val.laneWidth() = OMIT_VALUE;
else if (single_value->field_laneWidth.is_bound()) {
ret_val.laneWidth() = single_value->field_laneWidth.valueof();
}
if (single_value->field_speedLimits.is_omit()) ret_val.speedLimits() = OMIT_VALUE;
else if (single_value->field_speedLimits.is_bound()) {
ret_val.speedLimits() = single_value->field_speedLimits.valueof();
}
if (single_value->field_roadLaneSet.is_bound()) {
ret_val.roadLaneSet() = single_value->field_roadLaneSet.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void RoadSegment_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.RoadSegment.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RoadSegment_template[list_length];
}

RoadSegment_template& RoadSegment_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.RoadSegment.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.RoadSegment.");
return value_list.list_value[list_index];
}

CHARSTRING_template& RoadSegment_template::name()
{
set_specific();
return single_value->field_name;
}

const CHARSTRING_template& RoadSegment_template::name() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field name of a non-specific template of type @DSRC.RoadSegment.");
return single_value->field_name;
}

RoadSegmentReferenceID_template& RoadSegment_template::id()
{
set_specific();
return single_value->field_id;
}

const RoadSegmentReferenceID_template& RoadSegment_template::id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field id of a non-specific template of type @DSRC.RoadSegment.");
return single_value->field_id;
}

INTEGER_template& RoadSegment_template::revision()
{
set_specific();
return single_value->field_revision;
}

const INTEGER_template& RoadSegment_template::revision() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field revision of a non-specific template of type @DSRC.RoadSegment.");
return single_value->field_revision;
}

Position3D__2_template& RoadSegment_template::refPoint()
{
set_specific();
return single_value->field_refPoint;
}

const Position3D__2_template& RoadSegment_template::refPoint() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field refPoint of a non-specific template of type @DSRC.RoadSegment.");
return single_value->field_refPoint;
}

INTEGER_template& RoadSegment_template::laneWidth()
{
set_specific();
return single_value->field_laneWidth;
}

const INTEGER_template& RoadSegment_template::laneWidth() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field laneWidth of a non-specific template of type @DSRC.RoadSegment.");
return single_value->field_laneWidth;
}

SpeedLimitList_template& RoadSegment_template::speedLimits()
{
set_specific();
return single_value->field_speedLimits;
}

const SpeedLimitList_template& RoadSegment_template::speedLimits() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speedLimits of a non-specific template of type @DSRC.RoadSegment.");
return single_value->field_speedLimits;
}

RoadLaneSetList_template& RoadSegment_template::roadLaneSet()
{
set_specific();
return single_value->field_roadLaneSet;
}

const RoadLaneSetList_template& RoadSegment_template::roadLaneSet() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field roadLaneSet of a non-specific template of type @DSRC.RoadSegment.");
return single_value->field_roadLaneSet;
}

REGION::Reg__RoadSegment_template& RoadSegment_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REGION::Reg__RoadSegment_template& RoadSegment_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.RoadSegment.");
return single_value->field_regional;
}

int RoadSegment_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegment which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 4;
      if (single_value->field_name.is_present()) ret_val++;
      if (single_value->field_laneWidth.is_present()) ret_val++;
      if (single_value->field_speedLimits.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.RoadSegment containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegment containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegment containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegment containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RoadSegment containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.RoadSegment.");
  }
  return 0;
}

void RoadSegment_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ name := ");
single_value->field_name.log();
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log();
TTCN_Logger::log_event_str(", revision := ");
single_value->field_revision.log();
TTCN_Logger::log_event_str(", refPoint := ");
single_value->field_refPoint.log();
TTCN_Logger::log_event_str(", laneWidth := ");
single_value->field_laneWidth.log();
TTCN_Logger::log_event_str(", speedLimits := ");
single_value->field_speedLimits.log();
TTCN_Logger::log_event_str(", roadLaneSet := ");
single_value->field_roadLaneSet.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RoadSegment_template::log_match(const RoadSegment& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.name().ispresent()){
if(!single_value->field_name.match(match_value.name(), legacy)){
TTCN_Logger::log_logmatch_info(".name");
single_value->field_name.log_match(match_value.name(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_name.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".name := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_name.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_id.match(match_value.id(), legacy)){
TTCN_Logger::log_logmatch_info(".id");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_revision.match(match_value.revision(), legacy)){
TTCN_Logger::log_logmatch_info(".revision");
single_value->field_revision.log_match(match_value.revision(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_refPoint.match(match_value.refPoint(), legacy)){
TTCN_Logger::log_logmatch_info(".refPoint");
single_value->field_refPoint.log_match(match_value.refPoint(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.laneWidth().ispresent()){
if(!single_value->field_laneWidth.match(match_value.laneWidth(), legacy)){
TTCN_Logger::log_logmatch_info(".laneWidth");
single_value->field_laneWidth.log_match(match_value.laneWidth(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_laneWidth.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".laneWidth := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_laneWidth.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.speedLimits().ispresent()){
if(!single_value->field_speedLimits.match(match_value.speedLimits(), legacy)){
TTCN_Logger::log_logmatch_info(".speedLimits");
single_value->field_speedLimits.log_match(match_value.speedLimits(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_speedLimits.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".speedLimits := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_speedLimits.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_roadLaneSet.match(match_value.roadLaneSet(), legacy)){
TTCN_Logger::log_logmatch_info(".roadLaneSet");
single_value->field_roadLaneSet.log_match(match_value.roadLaneSet(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ name := ");
if (match_value.name().ispresent()) single_value->field_name.log_match(match_value.name(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_name.log();
if (single_value->field_name.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::log_event_str(", revision := ");
single_value->field_revision.log_match(match_value.revision(), legacy);
TTCN_Logger::log_event_str(", refPoint := ");
single_value->field_refPoint.log_match(match_value.refPoint(), legacy);
TTCN_Logger::log_event_str(", laneWidth := ");
if (match_value.laneWidth().ispresent()) single_value->field_laneWidth.log_match(match_value.laneWidth(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_laneWidth.log();
if (single_value->field_laneWidth.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", speedLimits := ");
if (match_value.speedLimits().ispresent()) single_value->field_speedLimits.log_match(match_value.speedLimits(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_speedLimits.log();
if (single_value->field_speedLimits.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", roadLaneSet := ");
single_value->field_roadLaneSet.log_match(match_value.roadLaneSet(), legacy);
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RoadSegment_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_name.encode_text(text_buf);
single_value->field_id.encode_text(text_buf);
single_value->field_revision.encode_text(text_buf);
single_value->field_refPoint.encode_text(text_buf);
single_value->field_laneWidth.encode_text(text_buf);
single_value->field_speedLimits.encode_text(text_buf);
single_value->field_roadLaneSet.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.RoadSegment.");
}
}

void RoadSegment_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_name.decode_text(text_buf);
single_value->field_id.decode_text(text_buf);
single_value->field_revision.decode_text(text_buf);
single_value->field_refPoint.decode_text(text_buf);
single_value->field_laneWidth.decode_text(text_buf);
single_value->field_speedLimits.decode_text(text_buf);
single_value->field_roadLaneSet.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RoadSegment_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.RoadSegment.");
}
}

void RoadSegment_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.RoadSegment'");
    }
    if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("revision", param_field) == 0) {
      revision().set_param(param);
      return;
    } else if (strcmp("refPoint", param_field) == 0) {
      refPoint().set_param(param);
      return;
    } else if (strcmp("laneWidth", param_field) == 0) {
      laneWidth().set_param(param);
      return;
    } else if (strcmp("speedLimits", param_field) == 0) {
      speedLimits().set_param(param);
      return;
    } else if (strcmp("roadLaneSet", param_field) == 0) {
      roadLaneSet().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.RoadSegment'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RoadSegment_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record template of type @DSRC.RoadSegment has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) revision().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) refPoint().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) laneWidth().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) speedLimits().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) roadLaneSet().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "revision")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          revision().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "refPoint")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          refPoint().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "laneWidth")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          laneWidth().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimits")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimits().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadLaneSet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadLaneSet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.RoadSegment: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.RoadSegment");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RoadSegment_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.RoadSegment'");
    }
    if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else if (strcmp("revision", param_field) == 0) {
      return revision().get_param(param_name);
    } else if (strcmp("refPoint", param_field) == 0) {
      return refPoint().get_param(param_name);
    } else if (strcmp("laneWidth", param_field) == 0) {
      return laneWidth().get_param(param_name);
    } else if (strcmp("speedLimits", param_field) == 0) {
      return speedLimits().get_param(param_name);
    } else if (strcmp("roadLaneSet", param_field) == 0) {
      return roadLaneSet().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.RoadSegment'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_name = single_value->field_name.get_param(param_name);
    mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
    mp->add_elem(mp_field_name);
    Module_Param* mp_field_id = single_value->field_id.get_param(param_name);
    mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
    mp->add_elem(mp_field_id);
    Module_Param* mp_field_revision = single_value->field_revision.get_param(param_name);
    mp_field_revision->set_id(new Module_Param_FieldName(mcopystr("revision")));
    mp->add_elem(mp_field_revision);
    Module_Param* mp_field_refPoint = single_value->field_refPoint.get_param(param_name);
    mp_field_refPoint->set_id(new Module_Param_FieldName(mcopystr("refPoint")));
    mp->add_elem(mp_field_refPoint);
    Module_Param* mp_field_laneWidth = single_value->field_laneWidth.get_param(param_name);
    mp_field_laneWidth->set_id(new Module_Param_FieldName(mcopystr("laneWidth")));
    mp->add_elem(mp_field_laneWidth);
    Module_Param* mp_field_speedLimits = single_value->field_speedLimits.get_param(param_name);
    mp_field_speedLimits->set_id(new Module_Param_FieldName(mcopystr("speedLimits")));
    mp->add_elem(mp_field_speedLimits);
    Module_Param* mp_field_roadLaneSet = single_value->field_roadLaneSet.get_param(param_name);
    mp_field_roadLaneSet->set_id(new Module_Param_FieldName(mcopystr("roadLaneSet")));
    mp->add_elem(mp_field_roadLaneSet);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RoadSegment_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_name.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegment");
single_value->field_id.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegment");
single_value->field_revision.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegment");
single_value->field_refPoint.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegment");
single_value->field_laneWidth.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegment");
single_value->field_speedLimits.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegment");
single_value->field_roadLaneSet.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegment");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.RoadSegment");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RoadSegment");
}

boolean RoadSegment_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RoadSegment_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

DataParameters::DataParameters()
{
  bound_flag = FALSE;
}

DataParameters::DataParameters(const OPTIONAL<CHARSTRING>& par_processMethod,
    const OPTIONAL<CHARSTRING>& par_processAgency,
    const OPTIONAL<CHARSTRING>& par_lastCheckedDate,
    const OPTIONAL<CHARSTRING>& par_geoidUsed)
  :   field_processMethod(par_processMethod),
  field_processAgency(par_processAgency),
  field_lastCheckedDate(par_lastCheckedDate),
  field_geoidUsed(par_geoidUsed)
{
  bound_flag = TRUE;
}

DataParameters::DataParameters(const DataParameters& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.DataParameters.");
bound_flag = TRUE;
if (other_value.processMethod().is_bound()) field_processMethod = other_value.processMethod();
else field_processMethod.clean_up();
if (other_value.processAgency().is_bound()) field_processAgency = other_value.processAgency();
else field_processAgency.clean_up();
if (other_value.lastCheckedDate().is_bound()) field_lastCheckedDate = other_value.lastCheckedDate();
else field_lastCheckedDate.clean_up();
if (other_value.geoidUsed().is_bound()) field_geoidUsed = other_value.geoidUsed();
else field_geoidUsed.clean_up();
}

void DataParameters::clean_up()
{
field_processMethod.clean_up();
field_processAgency.clean_up();
field_lastCheckedDate.clean_up();
field_geoidUsed.clean_up();
bound_flag = FALSE;
}

DataParameters& DataParameters::operator=(const DataParameters& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.DataParameters.");
  bound_flag = TRUE;
  if (other_value.processMethod().is_bound()) field_processMethod = other_value.processMethod();
  else field_processMethod.clean_up();
  if (other_value.processAgency().is_bound()) field_processAgency = other_value.processAgency();
  else field_processAgency.clean_up();
  if (other_value.lastCheckedDate().is_bound()) field_lastCheckedDate = other_value.lastCheckedDate();
  else field_lastCheckedDate.clean_up();
  if (other_value.geoidUsed().is_bound()) field_geoidUsed = other_value.geoidUsed();
  else field_geoidUsed.clean_up();
}
return *this;
}

boolean DataParameters::operator==(const DataParameters& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_processMethod==other_value.field_processMethod
  && field_processAgency==other_value.field_processAgency
  && field_lastCheckedDate==other_value.field_lastCheckedDate
  && field_geoidUsed==other_value.field_geoidUsed;
}

boolean DataParameters::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_processMethod.get_selection() || field_processMethod.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_processAgency.get_selection() || field_processAgency.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_lastCheckedDate.get_selection() || field_lastCheckedDate.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_geoidUsed.get_selection() || field_geoidUsed.is_bound()) return TRUE;
return FALSE;
}
boolean DataParameters::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_processMethod.get_selection() && !field_processMethod.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_processAgency.get_selection() && !field_processAgency.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_lastCheckedDate.get_selection() && !field_lastCheckedDate.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_geoidUsed.get_selection() && !field_geoidUsed.is_value()) return FALSE;
return TRUE;
}
int DataParameters::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.DataParameters");
  int ret_val = 0;
  if (field_processMethod.ispresent()) ret_val++;
  if (field_processAgency.ispresent()) ret_val++;
  if (field_lastCheckedDate.ispresent()) ret_val++;
  if (field_geoidUsed.ispresent()) ret_val++;
  return ret_val;
}

void DataParameters::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ processMethod := ");
field_processMethod.log();
TTCN_Logger::log_event_str(", processAgency := ");
field_processAgency.log();
TTCN_Logger::log_event_str(", lastCheckedDate := ");
field_lastCheckedDate.log();
TTCN_Logger::log_event_str(", geoidUsed := ");
field_geoidUsed.log();
TTCN_Logger::log_event_str(" }");
}

void DataParameters::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.DataParameters'");
    }
    if (strcmp("processMethod", param_field) == 0) {
      processMethod().set_param(param);
      return;
    } else if (strcmp("processAgency", param_field) == 0) {
      processAgency().set_param(param);
      return;
    } else if (strcmp("lastCheckedDate", param_field) == 0) {
      lastCheckedDate().set_param(param);
      return;
    } else if (strcmp("geoidUsed", param_field) == 0) {
      geoidUsed().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.DataParameters'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @DSRC.DataParameters has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) processMethod().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) processAgency().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) lastCheckedDate().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) geoidUsed().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "processMethod")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          processMethod().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "processAgency")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          processAgency().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lastCheckedDate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lastCheckedDate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoidUsed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoidUsed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.DataParameters: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.DataParameters");
  }
}

Module_Param* DataParameters::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.DataParameters'");
    }
    if (strcmp("processMethod", param_field) == 0) {
      return processMethod().get_param(param_name);
    } else if (strcmp("processAgency", param_field) == 0) {
      return processAgency().get_param(param_name);
    } else if (strcmp("lastCheckedDate", param_field) == 0) {
      return lastCheckedDate().get_param(param_name);
    } else if (strcmp("geoidUsed", param_field) == 0) {
      return geoidUsed().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.DataParameters'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_processMethod = field_processMethod.get_param(param_name);
  mp_field_processMethod->set_id(new Module_Param_FieldName(mcopystr("processMethod")));
  mp->add_elem(mp_field_processMethod);
  Module_Param* mp_field_processAgency = field_processAgency.get_param(param_name);
  mp_field_processAgency->set_id(new Module_Param_FieldName(mcopystr("processAgency")));
  mp->add_elem(mp_field_processAgency);
  Module_Param* mp_field_lastCheckedDate = field_lastCheckedDate.get_param(param_name);
  mp_field_lastCheckedDate->set_id(new Module_Param_FieldName(mcopystr("lastCheckedDate")));
  mp->add_elem(mp_field_lastCheckedDate);
  Module_Param* mp_field_geoidUsed = field_geoidUsed.get_param(param_name);
  mp_field_geoidUsed->set_id(new Module_Param_FieldName(mcopystr("geoidUsed")));
  mp->add_elem(mp_field_geoidUsed);
  return mp;
  }

void DataParameters::set_implicit_omit()
{
if (!processMethod().is_bound()) processMethod() = OMIT_VALUE;
else processMethod().set_implicit_omit();
if (!processAgency().is_bound()) processAgency() = OMIT_VALUE;
else processAgency().set_implicit_omit();
if (!lastCheckedDate().is_bound()) lastCheckedDate() = OMIT_VALUE;
else lastCheckedDate().set_implicit_omit();
if (!geoidUsed().is_bound()) geoidUsed() = OMIT_VALUE;
else geoidUsed().set_implicit_omit();
}

void DataParameters::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.DataParameters.");
field_processMethod.encode_text(text_buf);
field_processAgency.encode_text(text_buf);
field_lastCheckedDate.encode_text(text_buf);
field_geoidUsed.encode_text(text_buf);
}

void DataParameters::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_processMethod.decode_text(text_buf);
field_processAgency.decode_text(text_buf);
field_lastCheckedDate.decode_text(text_buf);
field_geoidUsed.decode_text(text_buf);
}

void DataParameters::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DataParameters::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* DataParameters::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("processMethod': ");
  new_tlv->add_TLV(field_processMethod.BER_encode_TLV(DataParameters_processMethod_descr_, p_coding));
  ec_1.set_msg("processAgency': ");
  new_tlv->add_TLV(field_processAgency.BER_encode_TLV(DataParameters_processAgency_descr_, p_coding));
  ec_1.set_msg("lastCheckedDate': ");
  new_tlv->add_TLV(field_lastCheckedDate.BER_encode_TLV(DataParameters_lastCheckedDate_descr_, p_coding));
  ec_1.set_msg("geoidUsed': ");
  new_tlv->add_TLV(field_geoidUsed.BER_encode_TLV(DataParameters_geoidUsed_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean DataParameters::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.DataParameters' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("processMethod': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_processMethod=OMIT_VALUE;
    else {
      field_processMethod.BER_decode_TLV(DataParameters_processMethod_descr_, tmp_tlv, L_form);
      if(field_processMethod.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("processAgency': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_processAgency=OMIT_VALUE;
    else {
      field_processAgency.BER_decode_TLV(DataParameters_processAgency_descr_, tmp_tlv, L_form);
      if(field_processAgency.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("lastCheckedDate': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_lastCheckedDate=OMIT_VALUE;
    else {
      field_lastCheckedDate.BER_decode_TLV(DataParameters_lastCheckedDate_descr_, tmp_tlv, L_form);
      if(field_lastCheckedDate.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("geoidUsed': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_geoidUsed=OMIT_VALUE;
    else {
      field_geoidUsed.BER_decode_TLV(DataParameters_geoidUsed_descr_, tmp_tlv, L_form);
      if(field_geoidUsed.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int DataParameters::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.DataParameters.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_processMethod.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "processMethod");
    enc_len += field_processMethod.JSON_encode(DataParameters_processMethod_descr_, p_tok);
  }

  if (field_processAgency.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "processAgency");
    enc_len += field_processAgency.JSON_encode(DataParameters_processAgency_descr_, p_tok);
  }

  if (field_lastCheckedDate.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lastCheckedDate");
    enc_len += field_lastCheckedDate.JSON_encode(DataParameters_lastCheckedDate_descr_, p_tok);
  }

  if (field_geoidUsed.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoidUsed");
    enc_len += field_geoidUsed.JSON_encode(DataParameters_geoidUsed_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DataParameters::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (13 == name_len && 0 == strncmp(fld_name, "processMethod", name_len)) {
         int ret_val = field_processMethod.JSON_decode(DataParameters_processMethod_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "processMethod");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "processAgency", name_len)) {
         int ret_val = field_processAgency.JSON_decode(DataParameters_processAgency_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "processAgency");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "lastCheckedDate", name_len)) {
         int ret_val = field_lastCheckedDate.JSON_decode(DataParameters_lastCheckedDate_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lastCheckedDate");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "geoidUsed", name_len)) {
         int ret_val = field_geoidUsed.JSON_decode(DataParameters_geoidUsed_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoidUsed");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_processMethod.is_bound()) {
    field_processMethod = OMIT_VALUE;
  }
if (!field_processAgency.is_bound()) {
    field_processAgency = OMIT_VALUE;
  }
if (!field_lastCheckedDate.is_bound()) {
    field_lastCheckedDate = OMIT_VALUE;
  }
if (!field_geoidUsed.is_bound()) {
    field_geoidUsed = OMIT_VALUE;
  }

  return dec_len;
}

struct DataParameters_template::single_value_struct {
CHARSTRING_template field_processMethod;
CHARSTRING_template field_processAgency;
CHARSTRING_template field_lastCheckedDate;
CHARSTRING_template field_geoidUsed;
};

void DataParameters_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_processMethod = ANY_OR_OMIT;
single_value->field_processAgency = ANY_OR_OMIT;
single_value->field_lastCheckedDate = ANY_OR_OMIT;
single_value->field_geoidUsed = ANY_OR_OMIT;
}
}
}

void DataParameters_template::copy_value(const DataParameters& other_value)
{
single_value = new single_value_struct;
if (other_value.processMethod().is_bound()) {
  if (other_value.processMethod().ispresent()) single_value->field_processMethod = other_value.processMethod()();
  else single_value->field_processMethod = OMIT_VALUE;
} else {
  single_value->field_processMethod.clean_up();
}
if (other_value.processAgency().is_bound()) {
  if (other_value.processAgency().ispresent()) single_value->field_processAgency = other_value.processAgency()();
  else single_value->field_processAgency = OMIT_VALUE;
} else {
  single_value->field_processAgency.clean_up();
}
if (other_value.lastCheckedDate().is_bound()) {
  if (other_value.lastCheckedDate().ispresent()) single_value->field_lastCheckedDate = other_value.lastCheckedDate()();
  else single_value->field_lastCheckedDate = OMIT_VALUE;
} else {
  single_value->field_lastCheckedDate.clean_up();
}
if (other_value.geoidUsed().is_bound()) {
  if (other_value.geoidUsed().ispresent()) single_value->field_geoidUsed = other_value.geoidUsed()();
  else single_value->field_geoidUsed = OMIT_VALUE;
} else {
  single_value->field_geoidUsed.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void DataParameters_template::copy_template(const DataParameters_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.processMethod().get_selection()) {
single_value->field_processMethod = other_value.processMethod();
} else {
single_value->field_processMethod.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.processAgency().get_selection()) {
single_value->field_processAgency = other_value.processAgency();
} else {
single_value->field_processAgency.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lastCheckedDate().get_selection()) {
single_value->field_lastCheckedDate = other_value.lastCheckedDate();
} else {
single_value->field_lastCheckedDate.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoidUsed().get_selection()) {
single_value->field_geoidUsed = other_value.geoidUsed();
} else {
single_value->field_geoidUsed.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DataParameters_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.DataParameters.");
break;
}
set_selection(other_value);
}

DataParameters_template::DataParameters_template()
{
}

DataParameters_template::DataParameters_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DataParameters_template::DataParameters_template(const DataParameters& other_value)
{
copy_value(other_value);
}

DataParameters_template::DataParameters_template(const OPTIONAL<DataParameters>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DataParameters&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.DataParameters from an unbound optional field.");
}
}

DataParameters_template::DataParameters_template(const DataParameters_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

DataParameters_template::~DataParameters_template()
{
clean_up();
}

DataParameters_template& DataParameters_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DataParameters_template& DataParameters_template::operator=(const DataParameters& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DataParameters_template& DataParameters_template::operator=(const OPTIONAL<DataParameters>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DataParameters&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.DataParameters.");
}
return *this;
}

DataParameters_template& DataParameters_template::operator=(const DataParameters_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DataParameters_template::match(const DataParameters& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.processMethod().is_bound()) return FALSE;
if((other_value.processMethod().ispresent() ? !single_value->field_processMethod.match((const CHARSTRING&)other_value.processMethod(), legacy) : !single_value->field_processMethod.match_omit(legacy)))return FALSE;
if(!other_value.processAgency().is_bound()) return FALSE;
if((other_value.processAgency().ispresent() ? !single_value->field_processAgency.match((const CHARSTRING&)other_value.processAgency(), legacy) : !single_value->field_processAgency.match_omit(legacy)))return FALSE;
if(!other_value.lastCheckedDate().is_bound()) return FALSE;
if((other_value.lastCheckedDate().ispresent() ? !single_value->field_lastCheckedDate.match((const CHARSTRING&)other_value.lastCheckedDate(), legacy) : !single_value->field_lastCheckedDate.match_omit(legacy)))return FALSE;
if(!other_value.geoidUsed().is_bound()) return FALSE;
if((other_value.geoidUsed().ispresent() ? !single_value->field_geoidUsed.match((const CHARSTRING&)other_value.geoidUsed(), legacy) : !single_value->field_geoidUsed.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.DataParameters.");
}
return FALSE;
}

boolean DataParameters_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_processMethod.is_omit() || single_value->field_processMethod.is_bound()) return TRUE;
if (single_value->field_processAgency.is_omit() || single_value->field_processAgency.is_bound()) return TRUE;
if (single_value->field_lastCheckedDate.is_omit() || single_value->field_lastCheckedDate.is_bound()) return TRUE;
if (single_value->field_geoidUsed.is_omit() || single_value->field_geoidUsed.is_bound()) return TRUE;
return FALSE;
}

boolean DataParameters_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_processMethod.is_omit() && !single_value->field_processMethod.is_value()) return FALSE;
if (!single_value->field_processAgency.is_omit() && !single_value->field_processAgency.is_value()) return FALSE;
if (!single_value->field_lastCheckedDate.is_omit() && !single_value->field_lastCheckedDate.is_value()) return FALSE;
if (!single_value->field_geoidUsed.is_omit() && !single_value->field_geoidUsed.is_value()) return FALSE;
return TRUE;
}

void DataParameters_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DataParameters DataParameters_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.DataParameters.");
DataParameters ret_val;
if (single_value->field_processMethod.is_omit()) ret_val.processMethod() = OMIT_VALUE;
else if (single_value->field_processMethod.is_bound()) {
ret_val.processMethod() = single_value->field_processMethod.valueof();
}
if (single_value->field_processAgency.is_omit()) ret_val.processAgency() = OMIT_VALUE;
else if (single_value->field_processAgency.is_bound()) {
ret_val.processAgency() = single_value->field_processAgency.valueof();
}
if (single_value->field_lastCheckedDate.is_omit()) ret_val.lastCheckedDate() = OMIT_VALUE;
else if (single_value->field_lastCheckedDate.is_bound()) {
ret_val.lastCheckedDate() = single_value->field_lastCheckedDate.valueof();
}
if (single_value->field_geoidUsed.is_omit()) ret_val.geoidUsed() = OMIT_VALUE;
else if (single_value->field_geoidUsed.is_bound()) {
ret_val.geoidUsed() = single_value->field_geoidUsed.valueof();
}
return ret_val;
}

void DataParameters_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.DataParameters.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DataParameters_template[list_length];
}

DataParameters_template& DataParameters_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.DataParameters.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.DataParameters.");
return value_list.list_value[list_index];
}

CHARSTRING_template& DataParameters_template::processMethod()
{
set_specific();
return single_value->field_processMethod;
}

const CHARSTRING_template& DataParameters_template::processMethod() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field processMethod of a non-specific template of type @DSRC.DataParameters.");
return single_value->field_processMethod;
}

CHARSTRING_template& DataParameters_template::processAgency()
{
set_specific();
return single_value->field_processAgency;
}

const CHARSTRING_template& DataParameters_template::processAgency() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field processAgency of a non-specific template of type @DSRC.DataParameters.");
return single_value->field_processAgency;
}

CHARSTRING_template& DataParameters_template::lastCheckedDate()
{
set_specific();
return single_value->field_lastCheckedDate;
}

const CHARSTRING_template& DataParameters_template::lastCheckedDate() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lastCheckedDate of a non-specific template of type @DSRC.DataParameters.");
return single_value->field_lastCheckedDate;
}

CHARSTRING_template& DataParameters_template::geoidUsed()
{
set_specific();
return single_value->field_geoidUsed;
}

const CHARSTRING_template& DataParameters_template::geoidUsed() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoidUsed of a non-specific template of type @DSRC.DataParameters.");
return single_value->field_geoidUsed;
}

int DataParameters_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.DataParameters which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_processMethod.is_present()) ret_val++;
      if (single_value->field_processAgency.is_present()) ret_val++;
      if (single_value->field_lastCheckedDate.is_present()) ret_val++;
      if (single_value->field_geoidUsed.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.DataParameters containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.DataParameters containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.DataParameters containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.DataParameters containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.DataParameters containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.DataParameters.");
  }
  return 0;
}

void DataParameters_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ processMethod := ");
single_value->field_processMethod.log();
TTCN_Logger::log_event_str(", processAgency := ");
single_value->field_processAgency.log();
TTCN_Logger::log_event_str(", lastCheckedDate := ");
single_value->field_lastCheckedDate.log();
TTCN_Logger::log_event_str(", geoidUsed := ");
single_value->field_geoidUsed.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DataParameters_template::log_match(const DataParameters& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.processMethod().ispresent()){
if(!single_value->field_processMethod.match(match_value.processMethod(), legacy)){
TTCN_Logger::log_logmatch_info(".processMethod");
single_value->field_processMethod.log_match(match_value.processMethod(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_processMethod.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".processMethod := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_processMethod.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.processAgency().ispresent()){
if(!single_value->field_processAgency.match(match_value.processAgency(), legacy)){
TTCN_Logger::log_logmatch_info(".processAgency");
single_value->field_processAgency.log_match(match_value.processAgency(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_processAgency.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".processAgency := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_processAgency.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.lastCheckedDate().ispresent()){
if(!single_value->field_lastCheckedDate.match(match_value.lastCheckedDate(), legacy)){
TTCN_Logger::log_logmatch_info(".lastCheckedDate");
single_value->field_lastCheckedDate.log_match(match_value.lastCheckedDate(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_lastCheckedDate.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".lastCheckedDate := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_lastCheckedDate.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.geoidUsed().ispresent()){
if(!single_value->field_geoidUsed.match(match_value.geoidUsed(), legacy)){
TTCN_Logger::log_logmatch_info(".geoidUsed");
single_value->field_geoidUsed.log_match(match_value.geoidUsed(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_geoidUsed.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".geoidUsed := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_geoidUsed.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ processMethod := ");
if (match_value.processMethod().ispresent()) single_value->field_processMethod.log_match(match_value.processMethod(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_processMethod.log();
if (single_value->field_processMethod.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", processAgency := ");
if (match_value.processAgency().ispresent()) single_value->field_processAgency.log_match(match_value.processAgency(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_processAgency.log();
if (single_value->field_processAgency.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", lastCheckedDate := ");
if (match_value.lastCheckedDate().ispresent()) single_value->field_lastCheckedDate.log_match(match_value.lastCheckedDate(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_lastCheckedDate.log();
if (single_value->field_lastCheckedDate.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", geoidUsed := ");
if (match_value.geoidUsed().ispresent()) single_value->field_geoidUsed.log_match(match_value.geoidUsed(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_geoidUsed.log();
if (single_value->field_geoidUsed.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DataParameters_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_processMethod.encode_text(text_buf);
single_value->field_processAgency.encode_text(text_buf);
single_value->field_lastCheckedDate.encode_text(text_buf);
single_value->field_geoidUsed.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.DataParameters.");
}
}

void DataParameters_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_processMethod.decode_text(text_buf);
single_value->field_processAgency.decode_text(text_buf);
single_value->field_lastCheckedDate.decode_text(text_buf);
single_value->field_geoidUsed.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DataParameters_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.DataParameters.");
}
}

void DataParameters_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.DataParameters'");
    }
    if (strcmp("processMethod", param_field) == 0) {
      processMethod().set_param(param);
      return;
    } else if (strcmp("processAgency", param_field) == 0) {
      processAgency().set_param(param);
      return;
    } else if (strcmp("lastCheckedDate", param_field) == 0) {
      lastCheckedDate().set_param(param);
      return;
    } else if (strcmp("geoidUsed", param_field) == 0) {
      geoidUsed().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.DataParameters'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DataParameters_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @DSRC.DataParameters has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) processMethod().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) processAgency().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) lastCheckedDate().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) geoidUsed().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "processMethod")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          processMethod().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "processAgency")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          processAgency().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lastCheckedDate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lastCheckedDate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoidUsed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoidUsed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.DataParameters: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.DataParameters");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DataParameters_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.DataParameters'");
    }
    if (strcmp("processMethod", param_field) == 0) {
      return processMethod().get_param(param_name);
    } else if (strcmp("processAgency", param_field) == 0) {
      return processAgency().get_param(param_name);
    } else if (strcmp("lastCheckedDate", param_field) == 0) {
      return lastCheckedDate().get_param(param_name);
    } else if (strcmp("geoidUsed", param_field) == 0) {
      return geoidUsed().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.DataParameters'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_processMethod = single_value->field_processMethod.get_param(param_name);
    mp_field_processMethod->set_id(new Module_Param_FieldName(mcopystr("processMethod")));
    mp->add_elem(mp_field_processMethod);
    Module_Param* mp_field_processAgency = single_value->field_processAgency.get_param(param_name);
    mp_field_processAgency->set_id(new Module_Param_FieldName(mcopystr("processAgency")));
    mp->add_elem(mp_field_processAgency);
    Module_Param* mp_field_lastCheckedDate = single_value->field_lastCheckedDate.get_param(param_name);
    mp_field_lastCheckedDate->set_id(new Module_Param_FieldName(mcopystr("lastCheckedDate")));
    mp->add_elem(mp_field_lastCheckedDate);
    Module_Param* mp_field_geoidUsed = single_value->field_geoidUsed.get_param(param_name);
    mp_field_geoidUsed->set_id(new Module_Param_FieldName(mcopystr("geoidUsed")));
    mp->add_elem(mp_field_geoidUsed);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DataParameters_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_processMethod.check_restriction(t_res, t_name ? t_name : "@DSRC.DataParameters");
single_value->field_processAgency.check_restriction(t_res, t_name ? t_name : "@DSRC.DataParameters");
single_value->field_lastCheckedDate.check_restriction(t_res, t_name ? t_name : "@DSRC.DataParameters");
single_value->field_geoidUsed.check_restriction(t_res, t_name ? t_name : "@DSRC.DataParameters");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.DataParameters");
}

boolean DataParameters_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DataParameters_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const RestrictionClassAssignment RestrictionClassList::UNBOUND_ELEM;
RestrictionClassList::RestrictionClassList()
{
val_ptr = NULL;
}

RestrictionClassList::RestrictionClassList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

RestrictionClassList::RestrictionClassList(const RestrictionClassList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.RestrictionClassList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

RestrictionClassList::~RestrictionClassList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void RestrictionClassList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

RestrictionClassList& RestrictionClassList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

RestrictionClassList& RestrictionClassList::operator=(const RestrictionClassList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.RestrictionClassList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean RestrictionClassList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RestrictionClassList.");
return val_ptr->n_elements == 0 ;
}

boolean RestrictionClassList::operator==(const RestrictionClassList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RestrictionClassList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RestrictionClassList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

RestrictionClassAssignment& RestrictionClassList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RestrictionClassList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (RestrictionClassAssignment**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RestrictionClassAssignment(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new RestrictionClassAssignment;
}
return *val_ptr->value_elements[index_value];
}

RestrictionClassAssignment& RestrictionClassList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RestrictionClassList.");
return (*this)[(int)index_value];
}

const RestrictionClassAssignment& RestrictionClassList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.RestrictionClassList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RestrictionClassList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.RestrictionClassList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const RestrictionClassAssignment& RestrictionClassList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RestrictionClassList.");
return (*this)[(int)index_value];
}

RestrictionClassList RestrictionClassList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

RestrictionClassList RestrictionClassList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

RestrictionClassList RestrictionClassList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

RestrictionClassList RestrictionClassList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.RestrictionClassList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
RestrictionClassList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new RestrictionClassAssignment(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

RestrictionClassList RestrictionClassList::operator+(const RestrictionClassList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.RestrictionClassList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
RestrictionClassList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RestrictionClassAssignment(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new RestrictionClassAssignment(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

RestrictionClassList RestrictionClassList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.RestrictionClassList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.RestrictionClassList","element");
RestrictionClassList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new RestrictionClassAssignment(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

RestrictionClassList RestrictionClassList::replace(int index, int len, const RestrictionClassList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.RestrictionClassList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.RestrictionClassList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.RestrictionClassList","element");
RestrictionClassList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RestrictionClassAssignment(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new RestrictionClassAssignment(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new RestrictionClassAssignment(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

RestrictionClassList RestrictionClassList::replace(int index, int len, const RestrictionClassList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void RestrictionClassList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.RestrictionClassList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (RestrictionClassAssignment**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RestrictionClassAssignment(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (RestrictionClassAssignment**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.RestrictionClassList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (RestrictionClassAssignment**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean RestrictionClassList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int RestrictionClassList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.RestrictionClassList.");
return val_ptr->n_elements;
}

int RestrictionClassList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.RestrictionClassList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void RestrictionClassList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void RestrictionClassList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.RestrictionClassList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.RestrictionClassList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.RestrictionClassList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* RestrictionClassList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.RestrictionClassList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void RestrictionClassList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void RestrictionClassList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.RestrictionClassList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void RestrictionClassList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.RestrictionClassList.");
val_ptr->value_elements = (RestrictionClassAssignment**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new RestrictionClassAssignment;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void RestrictionClassList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RestrictionClassList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RestrictionClassList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RestrictionClassList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (RestrictionClassAssignment**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new RestrictionClassAssignment;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int RestrictionClassList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.RestrictionClassList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int RestrictionClassList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    RestrictionClassAssignment* val = new RestrictionClassAssignment;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (RestrictionClassAssignment**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void RestrictionClassList_template::copy_value(const RestrictionClassList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.RestrictionClassList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (RestrictionClassAssignment_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new RestrictionClassAssignment_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new RestrictionClassAssignment_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void RestrictionClassList_template::copy_template(const RestrictionClassList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (RestrictionClassAssignment_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new RestrictionClassAssignment_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new RestrictionClassAssignment_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RestrictionClassList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.RestrictionClassList.");
break;
}
set_selection(other_value);
}

boolean RestrictionClassList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const RestrictionClassList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const RestrictionClassList*)value_ptr)[value_index], legacy);
else return ((const RestrictionClassList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

RestrictionClassList_template::RestrictionClassList_template()
{
}

RestrictionClassList_template::RestrictionClassList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

RestrictionClassList_template::RestrictionClassList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

RestrictionClassList_template::RestrictionClassList_template(const RestrictionClassList& other_value)
{
copy_value(other_value);
}

RestrictionClassList_template::RestrictionClassList_template(const OPTIONAL<RestrictionClassList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RestrictionClassList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.RestrictionClassList from an unbound optional field.");
}
}

RestrictionClassList_template::RestrictionClassList_template(const RestrictionClassList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

RestrictionClassList_template::~RestrictionClassList_template()
{
clean_up();
}

void RestrictionClassList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RestrictionClassList_template& RestrictionClassList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RestrictionClassList_template& RestrictionClassList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

RestrictionClassList_template& RestrictionClassList_template::operator=(const RestrictionClassList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RestrictionClassList_template& RestrictionClassList_template::operator=(const OPTIONAL<RestrictionClassList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RestrictionClassList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.RestrictionClassList.");
}
return *this;
}

RestrictionClassList_template& RestrictionClassList_template::operator=(const RestrictionClassList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

RestrictionClassAssignment_template& RestrictionClassList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RestrictionClassList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.RestrictionClassList.");
    break;
}
return *single_value.value_elements[index_value];
}

RestrictionClassAssignment_template& RestrictionClassList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RestrictionClassList.");
return (*this)[(int)index_value];
}

const RestrictionClassAssignment_template& RestrictionClassList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RestrictionClassList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.RestrictionClassList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.RestrictionClassList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const RestrictionClassAssignment_template& RestrictionClassList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RestrictionClassList.");
return (*this)[(int)index_value];
}

void RestrictionClassList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.RestrictionClassList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (RestrictionClassAssignment_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RestrictionClassAssignment_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RestrictionClassAssignment_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (RestrictionClassAssignment_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int RestrictionClassList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int RestrictionClassList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionClassList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionClassList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionClassList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionClassList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionClassList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionClassList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.RestrictionClassList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.RestrictionClassList");
}

boolean RestrictionClassList_template::match(const RestrictionClassList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.RestrictionClassList.");
}
return FALSE;
}

boolean RestrictionClassList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

RestrictionClassList RestrictionClassList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.RestrictionClassList.");
RestrictionClassList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

RestrictionClassList RestrictionClassList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

RestrictionClassList RestrictionClassList_template::replace(int index, int len, const RestrictionClassList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

RestrictionClassList RestrictionClassList_template::replace(int index, int len, const RestrictionClassList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void RestrictionClassList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new RestrictionClassList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.RestrictionClassList.");
}
set_selection(template_type);
}

RestrictionClassList_template& RestrictionClassList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.RestrictionClassList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.RestrictionClassList.");
return value_list.list_value[list_index];
}

void RestrictionClassList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void RestrictionClassList_template::log_match(const RestrictionClassList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RestrictionClassList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.RestrictionClassList.");
}
}

void RestrictionClassList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.RestrictionClassList.");
single_value.value_elements = (RestrictionClassAssignment_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new RestrictionClassAssignment_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RestrictionClassList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.RestrictionClassList.");
}
}

boolean RestrictionClassList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RestrictionClassList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RestrictionClassList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.RestrictionClassList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RestrictionClassList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.RestrictionClassList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* RestrictionClassList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.RestrictionClassList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void RestrictionClassList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.RestrictionClassList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RestrictionClassList");
}


const RestrictionUserType RestrictionUserTypeList::UNBOUND_ELEM;
RestrictionUserTypeList::RestrictionUserTypeList()
{
val_ptr = NULL;
}

RestrictionUserTypeList::RestrictionUserTypeList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

RestrictionUserTypeList::RestrictionUserTypeList(const RestrictionUserTypeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.RestrictionUserTypeList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

RestrictionUserTypeList::~RestrictionUserTypeList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void RestrictionUserTypeList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

RestrictionUserTypeList& RestrictionUserTypeList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

RestrictionUserTypeList& RestrictionUserTypeList::operator=(const RestrictionUserTypeList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.RestrictionUserTypeList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean RestrictionUserTypeList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RestrictionUserTypeList.");
return val_ptr->n_elements == 0 ;
}

boolean RestrictionUserTypeList::operator==(const RestrictionUserTypeList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.RestrictionUserTypeList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RestrictionUserTypeList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

RestrictionUserType& RestrictionUserTypeList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RestrictionUserTypeList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (RestrictionUserType**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RestrictionUserType(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new RestrictionUserType;
}
return *val_ptr->value_elements[index_value];
}

RestrictionUserType& RestrictionUserTypeList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RestrictionUserTypeList.");
return (*this)[(int)index_value];
}

const RestrictionUserType& RestrictionUserTypeList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.RestrictionUserTypeList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.RestrictionUserTypeList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.RestrictionUserTypeList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const RestrictionUserType& RestrictionUserTypeList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.RestrictionUserTypeList.");
return (*this)[(int)index_value];
}

RestrictionUserTypeList RestrictionUserTypeList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

RestrictionUserTypeList RestrictionUserTypeList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

RestrictionUserTypeList RestrictionUserTypeList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

RestrictionUserTypeList RestrictionUserTypeList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.RestrictionUserTypeList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
RestrictionUserTypeList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new RestrictionUserType(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

RestrictionUserTypeList RestrictionUserTypeList::operator+(const RestrictionUserTypeList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.RestrictionUserTypeList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
RestrictionUserTypeList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RestrictionUserType(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new RestrictionUserType(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

RestrictionUserTypeList RestrictionUserTypeList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.RestrictionUserTypeList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.RestrictionUserTypeList","element");
RestrictionUserTypeList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new RestrictionUserType(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

RestrictionUserTypeList RestrictionUserTypeList::replace(int index, int len, const RestrictionUserTypeList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.RestrictionUserTypeList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.RestrictionUserTypeList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.RestrictionUserTypeList","element");
RestrictionUserTypeList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RestrictionUserType(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new RestrictionUserType(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new RestrictionUserType(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

RestrictionUserTypeList RestrictionUserTypeList::replace(int index, int len, const RestrictionUserTypeList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void RestrictionUserTypeList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.RestrictionUserTypeList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (RestrictionUserType**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RestrictionUserType(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (RestrictionUserType**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.RestrictionUserTypeList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (RestrictionUserType**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean RestrictionUserTypeList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int RestrictionUserTypeList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.RestrictionUserTypeList.");
return val_ptr->n_elements;
}

int RestrictionUserTypeList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.RestrictionUserTypeList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void RestrictionUserTypeList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void RestrictionUserTypeList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.RestrictionUserTypeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.RestrictionUserTypeList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.RestrictionUserTypeList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* RestrictionUserTypeList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.RestrictionUserTypeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void RestrictionUserTypeList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void RestrictionUserTypeList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.RestrictionUserTypeList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void RestrictionUserTypeList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.RestrictionUserTypeList.");
val_ptr->value_elements = (RestrictionUserType**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new RestrictionUserType;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void RestrictionUserTypeList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RestrictionUserTypeList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RestrictionUserTypeList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RestrictionUserTypeList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (RestrictionUserType**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new RestrictionUserType;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int RestrictionUserTypeList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.RestrictionUserTypeList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int RestrictionUserTypeList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    RestrictionUserType* val = new RestrictionUserType;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (RestrictionUserType**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void RestrictionUserTypeList_template::copy_value(const RestrictionUserTypeList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.RestrictionUserTypeList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (RestrictionUserType_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new RestrictionUserType_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new RestrictionUserType_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void RestrictionUserTypeList_template::copy_template(const RestrictionUserTypeList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (RestrictionUserType_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new RestrictionUserType_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new RestrictionUserType_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RestrictionUserTypeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.RestrictionUserTypeList.");
break;
}
set_selection(other_value);
}

boolean RestrictionUserTypeList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const RestrictionUserTypeList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const RestrictionUserTypeList*)value_ptr)[value_index], legacy);
else return ((const RestrictionUserTypeList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

RestrictionUserTypeList_template::RestrictionUserTypeList_template()
{
}

RestrictionUserTypeList_template::RestrictionUserTypeList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

RestrictionUserTypeList_template::RestrictionUserTypeList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

RestrictionUserTypeList_template::RestrictionUserTypeList_template(const RestrictionUserTypeList& other_value)
{
copy_value(other_value);
}

RestrictionUserTypeList_template::RestrictionUserTypeList_template(const OPTIONAL<RestrictionUserTypeList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RestrictionUserTypeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.RestrictionUserTypeList from an unbound optional field.");
}
}

RestrictionUserTypeList_template::RestrictionUserTypeList_template(const RestrictionUserTypeList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

RestrictionUserTypeList_template::~RestrictionUserTypeList_template()
{
clean_up();
}

void RestrictionUserTypeList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RestrictionUserTypeList_template& RestrictionUserTypeList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RestrictionUserTypeList_template& RestrictionUserTypeList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

RestrictionUserTypeList_template& RestrictionUserTypeList_template::operator=(const RestrictionUserTypeList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RestrictionUserTypeList_template& RestrictionUserTypeList_template::operator=(const OPTIONAL<RestrictionUserTypeList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RestrictionUserTypeList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.RestrictionUserTypeList.");
}
return *this;
}

RestrictionUserTypeList_template& RestrictionUserTypeList_template::operator=(const RestrictionUserTypeList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

RestrictionUserType_template& RestrictionUserTypeList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RestrictionUserTypeList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.RestrictionUserTypeList.");
    break;
}
return *single_value.value_elements[index_value];
}

RestrictionUserType_template& RestrictionUserTypeList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RestrictionUserTypeList.");
return (*this)[(int)index_value];
}

const RestrictionUserType_template& RestrictionUserTypeList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.RestrictionUserTypeList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.RestrictionUserTypeList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.RestrictionUserTypeList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const RestrictionUserType_template& RestrictionUserTypeList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.RestrictionUserTypeList.");
return (*this)[(int)index_value];
}

void RestrictionUserTypeList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.RestrictionUserTypeList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (RestrictionUserType_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RestrictionUserType_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RestrictionUserType_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (RestrictionUserType_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int RestrictionUserTypeList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int RestrictionUserTypeList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionUserTypeList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionUserTypeList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionUserTypeList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionUserTypeList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionUserTypeList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.RestrictionUserTypeList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.RestrictionUserTypeList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.RestrictionUserTypeList");
}

boolean RestrictionUserTypeList_template::match(const RestrictionUserTypeList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.RestrictionUserTypeList.");
}
return FALSE;
}

boolean RestrictionUserTypeList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

RestrictionUserTypeList RestrictionUserTypeList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.RestrictionUserTypeList.");
RestrictionUserTypeList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

RestrictionUserTypeList RestrictionUserTypeList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

RestrictionUserTypeList RestrictionUserTypeList_template::replace(int index, int len, const RestrictionUserTypeList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

RestrictionUserTypeList RestrictionUserTypeList_template::replace(int index, int len, const RestrictionUserTypeList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void RestrictionUserTypeList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new RestrictionUserTypeList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.RestrictionUserTypeList.");
}
set_selection(template_type);
}

RestrictionUserTypeList_template& RestrictionUserTypeList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.RestrictionUserTypeList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.RestrictionUserTypeList.");
return value_list.list_value[list_index];
}

void RestrictionUserTypeList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void RestrictionUserTypeList_template::log_match(const RestrictionUserTypeList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RestrictionUserTypeList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.RestrictionUserTypeList.");
}
}

void RestrictionUserTypeList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.RestrictionUserTypeList.");
single_value.value_elements = (RestrictionUserType_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new RestrictionUserType_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RestrictionUserTypeList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.RestrictionUserTypeList.");
}
}

boolean RestrictionUserTypeList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RestrictionUserTypeList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RestrictionUserTypeList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.RestrictionUserTypeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RestrictionUserTypeList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.RestrictionUserTypeList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* RestrictionUserTypeList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.RestrictionUserTypeList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void RestrictionUserTypeList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.RestrictionUserTypeList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RestrictionUserTypeList");
}

void RestrictionUserType::copy_value(const RestrictionUserType& other_value)
{
switch (other_value.union_selection) {
case ALT_basicType:
field_basicType = new RestrictionAppliesTo(*other_value.field_basicType);
break;
case ALT_regional:
field_regional = new REG__D::Reg__RestrictionUserType(*other_value.field_regional);
break;
default:
TTCN_error("Assignment of an unbound union value of type @DSRC.RestrictionUserType.");
}
union_selection = other_value.union_selection;
}

RestrictionUserType::RestrictionUserType()
{
union_selection = UNBOUND_VALUE;
}

RestrictionUserType::RestrictionUserType(const RestrictionUserType& other_value)
: Base_Type(){
copy_value(other_value);
}

RestrictionUserType::~RestrictionUserType()
{
clean_up();
}

RestrictionUserType& RestrictionUserType::operator=(const RestrictionUserType& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean RestrictionUserType::operator==(const RestrictionUserType& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @DSRC.RestrictionUserType.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @DSRC.RestrictionUserType.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_basicType:
return *field_basicType == *other_value.field_basicType;
case ALT_regional:
return *field_regional == *other_value.field_regional;
default:
return FALSE;
}
}

RestrictionAppliesTo& RestrictionUserType::basicType()
{
if (union_selection != ALT_basicType) {
clean_up();
field_basicType = new RestrictionAppliesTo;
union_selection = ALT_basicType;
}
return *field_basicType;
}

const RestrictionAppliesTo& RestrictionUserType::basicType() const
{
if (union_selection != ALT_basicType) TTCN_error("Using non-selected field basicType in a value of union type @DSRC.RestrictionUserType.");
return *field_basicType;
}

REG__D::Reg__RestrictionUserType& RestrictionUserType::regional()
{
if (union_selection != ALT_regional) {
clean_up();
field_regional = new REG__D::Reg__RestrictionUserType;
union_selection = ALT_regional;
}
return *field_regional;
}

const REG__D::Reg__RestrictionUserType& RestrictionUserType::regional() const
{
if (union_selection != ALT_regional) TTCN_error("Using non-selected field regional in a value of union type @DSRC.RestrictionUserType.");
return *field_regional;
}

boolean RestrictionUserType::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.RestrictionUserType.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @DSRC.RestrictionUserType.");
return union_selection == checked_selection;
}

boolean RestrictionUserType::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean RestrictionUserType::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_basicType: return field_basicType->is_value();
case ALT_regional: return field_regional->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void RestrictionUserType::clean_up()
{
switch (union_selection) {
case ALT_basicType:
  delete field_basicType;
  break;
case ALT_regional:
  delete field_regional;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void RestrictionUserType::log() const
{
switch (union_selection) {
case ALT_basicType:
TTCN_Logger::log_event_str("{ basicType := ");
field_basicType->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_regional:
TTCN_Logger::log_event_str("{ regional := ");
field_regional->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void RestrictionUserType::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@DSRC.RestrictionUserType'");
    }
    if (strcmp("basicType", param_field) == 0) {
      basicType().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@DSRC.RestrictionUserType'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "basicType")) {
    basicType().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "regional")) {
    regional().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @DSRC.RestrictionUserType.", mp_last->get_id()->get_name());
}

Module_Param* RestrictionUserType::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@DSRC.RestrictionUserType'");
    }
    if (strcmp("basicType", param_field) == 0) {
      return basicType().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `RestrictionUserType'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_basicType:
    mp_field = field_basicType->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("basicType")));
    break;
  case ALT_regional:
    mp_field = field_regional->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("regional")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void RestrictionUserType::set_implicit_omit()
{
switch (union_selection) {
case ALT_basicType:
field_basicType->set_implicit_omit(); break;
case ALT_regional:
field_regional->set_implicit_omit(); break;
default: break;
}
}

void RestrictionUserType::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_basicType:
field_basicType->encode_text(text_buf);
break;
case ALT_regional:
field_regional->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @DSRC.RestrictionUserType.");
}
}

void RestrictionUserType::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_basicType:
basicType().decode_text(text_buf);
break;
case ALT_regional:
regional().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @DSRC.RestrictionUserType.");
}
}

void RestrictionUserType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RestrictionUserType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t *RestrictionUserType::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv;
  TTCN_EncDec_ErrorContext ec_0("Alternative '");
  TTCN_EncDec_ErrorContext ec_1;
  switch (union_selection) {
  case ALT_basicType:
    ec_1.set_msg("basicType': ");
    new_tlv = field_basicType->BER_encode_TLV(RestrictionUserType_basicType_descr_, p_coding);
    break;
  case ALT_regional:
    ec_1.set_msg("regional': ");
    new_tlv = field_regional->BER_encode_TLV(RestrictionUserType_regional_descr_, p_coding);
    break;
  case UNBOUND_VALUE:
    new_tlv = BER_encode_chk_bound(FALSE);
    break;
  default:
    TTCN_EncDec_ErrorContext::error_internal("Unknown selection.");
    new_tlv = NULL;
  }
  return ASN_BER_V2TLV(new_tlv, p_td, p_coding);
}

boolean RestrictionUserType::BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv)
{
  clean_up();
  field_basicType = new RestrictionAppliesTo;
  union_selection = ALT_basicType;
  if (field_basicType->BER_decode_isMyMsg(RestrictionUserType_basicType_descr_, p_tlv)) return TRUE;
  delete field_basicType;
  field_regional = new REG__D::Reg__RestrictionUserType;
  union_selection = ALT_regional;
  if (field_regional->BER_decode_isMyMsg(RestrictionUserType_regional_descr_, p_tlv)) return TRUE;
  delete field_regional;
  union_selection = UNBOUND_VALUE;
  return FALSE;
}

boolean RestrictionUserType::BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv)
{
  if (p_td.ber->n_tags == 0) {
    RestrictionUserType tmp_type;
    return tmp_type.BER_decode_set_selection(p_tlv);
  } else return Base_Type::BER_decode_isMyMsg(p_td, p_tlv);
}

boolean RestrictionUserType::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.RestrictionUserType' type: ");
  ASN_BER_TLV_t tmp_tlv;
  if (!BER_decode_TLV_CHOICE(*p_td.ber, stripped_tlv, L_form, tmp_tlv) || !BER_decode_CHOICE_selection(BER_decode_set_selection(tmp_tlv), tmp_tlv)) return FALSE;
  TTCN_EncDec_ErrorContext ec_1("Alternative '");
  TTCN_EncDec_ErrorContext ec_2;
  switch (union_selection) {
  case ALT_basicType:
    ec_2.set_msg("basicType': ");
    field_basicType->BER_decode_TLV(RestrictionUserType_basicType_descr_, tmp_tlv, L_form);
    break;
  case ALT_regional:
    ec_2.set_msg("regional': ");
    field_regional->BER_decode_TLV(RestrictionUserType_regional_descr_, tmp_tlv, L_form);
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

int RestrictionUserType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_basicType:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "basicType");
    enc_len += field_basicType->JSON_encode(RestrictionUserType_basicType_descr_, p_tok);
    break;
  case ALT_regional:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional->JSON_encode(RestrictionUserType_regional_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @DSRC.RestrictionUserType.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RestrictionUserType::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "basicType", name_len)) {
      int ret_val = basicType().JSON_decode(RestrictionUserType_basicType_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "basicType");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "regional", name_len)) {
      int ret_val = regional().JSON_decode(RestrictionUserType_regional_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void RestrictionUserType_template::copy_value(const RestrictionUserType& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case RestrictionUserType::ALT_basicType:
single_value.field_basicType = new RestrictionAppliesTo_template(other_value.basicType());
break;
case RestrictionUserType::ALT_regional:
single_value.field_regional = new REG__D::Reg__RestrictionUserType_template(other_value.regional());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @DSRC.RestrictionUserType.");
}
set_selection(SPECIFIC_VALUE);
}

void RestrictionUserType_template::copy_template(const RestrictionUserType_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case RestrictionUserType::ALT_basicType:
single_value.field_basicType = new RestrictionAppliesTo_template(*other_value.single_value.field_basicType);
break;
case RestrictionUserType::ALT_regional:
single_value.field_regional = new REG__D::Reg__RestrictionUserType_template(*other_value.single_value.field_regional);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @DSRC.RestrictionUserType.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RestrictionUserType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @DSRC.RestrictionUserType.");
}
set_selection(other_value);
}

RestrictionUserType_template::RestrictionUserType_template()
{
}

RestrictionUserType_template::RestrictionUserType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RestrictionUserType_template::RestrictionUserType_template(const RestrictionUserType& other_value)
{
copy_value(other_value);
}

RestrictionUserType_template::RestrictionUserType_template(const OPTIONAL<RestrictionUserType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RestrictionUserType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @DSRC.RestrictionUserType from an unbound optional field.");
}
}

RestrictionUserType_template::RestrictionUserType_template(const RestrictionUserType_template& other_value)
: Base_Template(){
copy_template(other_value);
}

RestrictionUserType_template::~RestrictionUserType_template()
{
clean_up();
}

void RestrictionUserType_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case RestrictionUserType::ALT_basicType:
delete single_value.field_basicType;
break;
case RestrictionUserType::ALT_regional:
delete single_value.field_regional;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RestrictionUserType_template& RestrictionUserType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RestrictionUserType_template& RestrictionUserType_template::operator=(const RestrictionUserType& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RestrictionUserType_template& RestrictionUserType_template::operator=(const OPTIONAL<RestrictionUserType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RestrictionUserType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @DSRC.RestrictionUserType.");
}
return *this;
}

RestrictionUserType_template& RestrictionUserType_template::operator=(const RestrictionUserType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RestrictionUserType_template::match(const RestrictionUserType& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
RestrictionUserType::union_selection_type value_selection = other_value.get_selection();
if (value_selection == RestrictionUserType::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case RestrictionUserType::ALT_basicType:
return single_value.field_basicType->match(other_value.basicType(), legacy);
case RestrictionUserType::ALT_regional:
return single_value.field_regional->match(other_value.regional(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @DSRC.RestrictionUserType.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @DSRC.RestrictionUserType.");
}
return FALSE;
}

boolean RestrictionUserType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case RestrictionUserType::ALT_basicType:
return single_value.field_basicType->is_value();
case RestrictionUserType::ALT_regional:
return single_value.field_regional->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @DSRC.RestrictionUserType.");
}
}

RestrictionUserType RestrictionUserType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @DSRC.RestrictionUserType.");
RestrictionUserType ret_val;
switch (single_value.union_selection) {
case RestrictionUserType::ALT_basicType:
ret_val.basicType() = single_value.field_basicType->valueof();
break;
case RestrictionUserType::ALT_regional:
ret_val.regional() = single_value.field_regional->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @DSRC.RestrictionUserType.");
}
return ret_val;
}

RestrictionUserType_template& RestrictionUserType_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @DSRC.RestrictionUserType.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @DSRC.RestrictionUserType.");
return value_list.list_value[list_index];
}
void RestrictionUserType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @DSRC.RestrictionUserType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RestrictionUserType_template[list_length];
}

RestrictionAppliesTo_template& RestrictionUserType_template::basicType()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != RestrictionUserType::ALT_basicType) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_basicType = new RestrictionAppliesTo_template(ANY_VALUE);
else single_value.field_basicType = new RestrictionAppliesTo_template;
single_value.union_selection = RestrictionUserType::ALT_basicType;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_basicType;
}

const RestrictionAppliesTo_template& RestrictionUserType_template::basicType() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field basicType in a non-specific template of union type @DSRC.RestrictionUserType.");
if (single_value.union_selection != RestrictionUserType::ALT_basicType) TTCN_error("Accessing non-selected field basicType in a template of union type @DSRC.RestrictionUserType.");
return *single_value.field_basicType;
}

REG__D::Reg__RestrictionUserType_template& RestrictionUserType_template::regional()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != RestrictionUserType::ALT_regional) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_regional = new REG__D::Reg__RestrictionUserType_template(ANY_VALUE);
else single_value.field_regional = new REG__D::Reg__RestrictionUserType_template;
single_value.union_selection = RestrictionUserType::ALT_regional;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_regional;
}

const REG__D::Reg__RestrictionUserType_template& RestrictionUserType_template::regional() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field regional in a non-specific template of union type @DSRC.RestrictionUserType.");
if (single_value.union_selection != RestrictionUserType::ALT_regional) TTCN_error("Accessing non-selected field regional in a template of union type @DSRC.RestrictionUserType.");
return *single_value.field_regional;
}

boolean RestrictionUserType_template::ischosen(RestrictionUserType::union_selection_type checked_selection) const
{
if (checked_selection == RestrictionUserType::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @DSRC.RestrictionUserType.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == RestrictionUserType::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @DSRC.RestrictionUserType.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @DSRC.RestrictionUserType containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @DSRC.RestrictionUserType, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @DSRC.RestrictionUserType");
}
return FALSE;
}

void RestrictionUserType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case RestrictionUserType::ALT_basicType:
TTCN_Logger::log_event_str("{ basicType := ");
single_value.field_basicType->log();
TTCN_Logger::log_event_str(" }");
break;
case RestrictionUserType::ALT_regional:
TTCN_Logger::log_event_str("{ regional := ");
single_value.field_regional->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RestrictionUserType_template::log_match(const RestrictionUserType& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case RestrictionUserType::ALT_basicType:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".basicType");
single_value.field_basicType->log_match(match_value.basicType(), legacy);
} else {
TTCN_Logger::log_event_str("{ basicType := ");
single_value.field_basicType->log_match(match_value.basicType(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case RestrictionUserType::ALT_regional:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".regional");
single_value.field_regional->log_match(match_value.regional(), legacy);
} else {
TTCN_Logger::log_event_str("{ regional := ");
single_value.field_regional->log_match(match_value.regional(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RestrictionUserType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case RestrictionUserType::ALT_basicType:
single_value.field_basicType->encode_text(text_buf);
break;
case RestrictionUserType::ALT_regional:
single_value.field_regional->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @DSRC.RestrictionUserType.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @DSRC.RestrictionUserType.");
}
}

void RestrictionUserType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = RestrictionUserType::UNBOUND_VALUE;
RestrictionUserType::union_selection_type new_selection = (RestrictionUserType::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case RestrictionUserType::ALT_basicType:
single_value.field_basicType = new RestrictionAppliesTo_template;
single_value.field_basicType->decode_text(text_buf);
break;
case RestrictionUserType::ALT_regional:
single_value.field_regional = new REG__D::Reg__RestrictionUserType_template;
single_value.field_regional->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @DSRC.RestrictionUserType.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RestrictionUserType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @DSRC.RestrictionUserType.");
}
}

boolean RestrictionUserType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RestrictionUserType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RestrictionUserType_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@DSRC.RestrictionUserType'");
    }
    if (strcmp("basicType", param_field) == 0) {
      basicType().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@DSRC.RestrictionUserType'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RestrictionUserType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@DSRC.RestrictionUserType");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "basicType")) {
      basicType().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "regional")) {
      regional().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @DSRC.RestrictionUserType.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@DSRC.RestrictionUserType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RestrictionUserType_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@DSRC.RestrictionUserType'");
    }
    if (strcmp("basicType", param_field) == 0) {
      return basicType().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `RestrictionUserType'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case RestrictionUserType::ALT_basicType:
      mp_field = single_value.field_basicType->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("basicType")));
      break;
    case RestrictionUserType::ALT_regional:
      mp_field = single_value.field_regional->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("regional")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RestrictionUserType_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case RestrictionUserType::ALT_basicType:
single_value.field_basicType->check_restriction(t_res, t_name ? t_name : "@DSRC.RestrictionUserType");
return;
case RestrictionUserType::ALT_regional:
single_value.field_regional->check_restriction(t_res, t_name ? t_name : "@DSRC.RestrictionUserType");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @DSRC.RestrictionUserType.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RestrictionUserType");
}

RestrictionAppliesTo::RestrictionAppliesTo()
{
enum_value = UNBOUND_VALUE;
}

RestrictionAppliesTo::RestrictionAppliesTo(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @DSRC.RestrictionAppliesTo with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

RestrictionAppliesTo::RestrictionAppliesTo(enum_type other_value)
{
enum_value = other_value;
}

RestrictionAppliesTo::RestrictionAppliesTo(const RestrictionAppliesTo& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
enum_value = other_value.enum_value;
}

RestrictionAppliesTo& RestrictionAppliesTo::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @DSRC.RestrictionAppliesTo.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

RestrictionAppliesTo& RestrictionAppliesTo::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

RestrictionAppliesTo& RestrictionAppliesTo::operator=(const RestrictionAppliesTo& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
enum_value = other_value.enum_value;
return *this;
}

boolean RestrictionAppliesTo::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
return enum_value == other_value;
}

boolean RestrictionAppliesTo::operator==(const RestrictionAppliesTo& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
return enum_value == other_value.enum_value;
}

boolean RestrictionAppliesTo::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
return enum_value < other_value;
}

boolean RestrictionAppliesTo::operator<(const RestrictionAppliesTo& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
return enum_value < other_value.enum_value;
}

boolean RestrictionAppliesTo::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
return enum_value > other_value;
}

boolean RestrictionAppliesTo::operator>(const RestrictionAppliesTo& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
return enum_value > other_value.enum_value;
}

const char *RestrictionAppliesTo::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case none__: return "none_";
case equippedTransit: return "equippedTransit";
case equippedTaxis: return "equippedTaxis";
case equippedOther: return "equippedOther";
case emissionCompliant: return "emissionCompliant";
case equippedBicycle: return "equippedBicycle";
case weightCompliant: return "weightCompliant";
case heightCompliant: return "heightCompliant";
case pedestrians: return "pedestrians";
case slowMovingPersons: return "slowMovingPersons";
case wheelchairUsers: return "wheelchairUsers";
case visualDisabilities: return "visualDisabilities";
case audioDisabilities: return "audioDisabilities";
case otherUnknownDisabilities: return "otherUnknownDisabilities";
default: return "<unknown>";
}
}

RestrictionAppliesTo::enum_type RestrictionAppliesTo::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "none_")) return none__;
else if (!strcmp(str_par, "equippedTransit")) return equippedTransit;
else if (!strcmp(str_par, "equippedTaxis")) return equippedTaxis;
else if (!strcmp(str_par, "equippedOther")) return equippedOther;
else if (!strcmp(str_par, "emissionCompliant")) return emissionCompliant;
else if (!strcmp(str_par, "equippedBicycle")) return equippedBicycle;
else if (!strcmp(str_par, "weightCompliant")) return weightCompliant;
else if (!strcmp(str_par, "heightCompliant")) return heightCompliant;
else if (!strcmp(str_par, "pedestrians")) return pedestrians;
else if (!strcmp(str_par, "slowMovingPersons")) return slowMovingPersons;
else if (!strcmp(str_par, "wheelchairUsers")) return wheelchairUsers;
else if (!strcmp(str_par, "visualDisabilities")) return visualDisabilities;
else if (!strcmp(str_par, "audioDisabilities")) return audioDisabilities;
else if (!strcmp(str_par, "otherUnknownDisabilities")) return otherUnknownDisabilities;
else return UNKNOWN_VALUE;
}

boolean RestrictionAppliesTo::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
return TRUE;
default:
return FALSE;
}
}

int RestrictionAppliesTo::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.RestrictionAppliesTo.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int RestrictionAppliesTo::enum2int(const RestrictionAppliesTo& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.RestrictionAppliesTo.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void RestrictionAppliesTo::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @DSRC.RestrictionAppliesTo.", int_val);
enum_value = (enum_type)int_val;
}

RestrictionAppliesTo::operator RestrictionAppliesTo::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @DSRC.RestrictionAppliesTo.");
return enum_value;
}

void RestrictionAppliesTo::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void RestrictionAppliesTo::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@DSRC.RestrictionAppliesTo");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @DSRC.RestrictionAppliesTo.");
  }
}

Module_Param* RestrictionAppliesTo::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void RestrictionAppliesTo::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
text_buf.push_int(enum_value);
}

void RestrictionAppliesTo::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @DSRC.RestrictionAppliesTo.", enum_value);
}

void RestrictionAppliesTo::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RestrictionAppliesTo::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RestrictionAppliesTo::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RestrictionAppliesTo::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @DSRC.RestrictionAppliesTo: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int RestrictionAppliesTo::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int RestrictionAppliesTo::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void RestrictionAppliesTo_template::copy_template(const RestrictionAppliesTo_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RestrictionAppliesTo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @DSRC.RestrictionAppliesTo.");
}
}

RestrictionAppliesTo_template::RestrictionAppliesTo_template()
{
}

RestrictionAppliesTo_template::RestrictionAppliesTo_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RestrictionAppliesTo_template::RestrictionAppliesTo_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!RestrictionAppliesTo::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @DSRC.RestrictionAppliesTo with unknown numeric value %d.", other_value);
single_value = (RestrictionAppliesTo::enum_type)other_value;
}

RestrictionAppliesTo_template::RestrictionAppliesTo_template(RestrictionAppliesTo::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

RestrictionAppliesTo_template::RestrictionAppliesTo_template(const RestrictionAppliesTo& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == RestrictionAppliesTo::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @DSRC.RestrictionAppliesTo.");
single_value = other_value.enum_value;
}

RestrictionAppliesTo_template::RestrictionAppliesTo_template(const OPTIONAL<RestrictionAppliesTo>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RestrictionAppliesTo::enum_type)(const RestrictionAppliesTo&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @DSRC.RestrictionAppliesTo from an unbound optional field.");
}
}

RestrictionAppliesTo_template::RestrictionAppliesTo_template(const RestrictionAppliesTo_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

RestrictionAppliesTo_template::~RestrictionAppliesTo_template()
{
clean_up();
}

boolean RestrictionAppliesTo_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean RestrictionAppliesTo_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != RestrictionAppliesTo::UNBOUND_VALUE;
}

void RestrictionAppliesTo_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

RestrictionAppliesTo_template& RestrictionAppliesTo_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RestrictionAppliesTo_template& RestrictionAppliesTo_template::operator=(int other_value)
{
if (!RestrictionAppliesTo::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @DSRC.RestrictionAppliesTo.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (RestrictionAppliesTo::enum_type)other_value;
return *this;
}

RestrictionAppliesTo_template& RestrictionAppliesTo_template::operator=(RestrictionAppliesTo::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

RestrictionAppliesTo_template& RestrictionAppliesTo_template::operator=(const RestrictionAppliesTo& other_value)
{
if (other_value.enum_value == RestrictionAppliesTo::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.RestrictionAppliesTo to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

RestrictionAppliesTo_template& RestrictionAppliesTo_template::operator=(const OPTIONAL<RestrictionAppliesTo>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RestrictionAppliesTo::enum_type)(const RestrictionAppliesTo&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @DSRC.RestrictionAppliesTo.");
}
return *this;
}

RestrictionAppliesTo_template& RestrictionAppliesTo_template::operator=(const RestrictionAppliesTo_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RestrictionAppliesTo_template::match(RestrictionAppliesTo::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @DSRC.RestrictionAppliesTo.");
}
return FALSE;
}

boolean RestrictionAppliesTo_template::match(const RestrictionAppliesTo& other_value, boolean) const
{
if (other_value.enum_value == RestrictionAppliesTo::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @DSRC.RestrictionAppliesTo with an unbound value.");
return match(other_value.enum_value);
}

RestrictionAppliesTo::enum_type RestrictionAppliesTo_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @DSRC.RestrictionAppliesTo.");
return single_value;
}

void RestrictionAppliesTo_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @DSRC.RestrictionAppliesTo.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RestrictionAppliesTo_template[list_length];
}

RestrictionAppliesTo_template& RestrictionAppliesTo_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @DSRC.RestrictionAppliesTo.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @DSRC.RestrictionAppliesTo.");
return value_list.list_value[list_index];
}

void RestrictionAppliesTo_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(RestrictionAppliesTo::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RestrictionAppliesTo_template::log_match(const RestrictionAppliesTo& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void RestrictionAppliesTo_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @DSRC.RestrictionAppliesTo.");
}
}

void RestrictionAppliesTo_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (RestrictionAppliesTo::enum_type)text_buf.pull_int().get_val();
if (!RestrictionAppliesTo::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @DSRC.RestrictionAppliesTo.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RestrictionAppliesTo_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @DSRC.RestrictionAppliesTo.");
}
}

boolean RestrictionAppliesTo_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RestrictionAppliesTo_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RestrictionAppliesTo_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    RestrictionAppliesTo::enum_type enum_val = (enum_name != NULL) ? RestrictionAppliesTo::str_to_enum(enum_name) : RestrictionAppliesTo::UNKNOWN_VALUE;
    if (RestrictionAppliesTo::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RestrictionAppliesTo_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    RestrictionAppliesTo::enum_type enum_val = RestrictionAppliesTo::str_to_enum(mp->get_enumerated());
    if (!RestrictionAppliesTo::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @DSRC.RestrictionAppliesTo.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@DSRC.RestrictionAppliesTo");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RestrictionAppliesTo_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(RestrictionAppliesTo::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RestrictionAppliesTo_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RestrictionAppliesTo");
}

RestrictionClassAssignment::RestrictionClassAssignment()
{
  bound_flag = FALSE;
}

RestrictionClassAssignment::RestrictionClassAssignment(const INTEGER& par_id,
    const RestrictionUserTypeList& par_users)
  :   field_id(par_id),
  field_users(par_users)
{
  bound_flag = TRUE;
}

RestrictionClassAssignment::RestrictionClassAssignment(const RestrictionClassAssignment& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.RestrictionClassAssignment.");
bound_flag = TRUE;
if (other_value.id().is_bound()) field_id = other_value.id();
else field_id.clean_up();
if (other_value.users().is_bound()) field_users = other_value.users();
else field_users.clean_up();
}

void RestrictionClassAssignment::clean_up()
{
field_id.clean_up();
field_users.clean_up();
bound_flag = FALSE;
}

RestrictionClassAssignment& RestrictionClassAssignment::operator=(const RestrictionClassAssignment& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.RestrictionClassAssignment.");
  bound_flag = TRUE;
  if (other_value.id().is_bound()) field_id = other_value.id();
  else field_id.clean_up();
  if (other_value.users().is_bound()) field_users = other_value.users();
  else field_users.clean_up();
}
return *this;
}

boolean RestrictionClassAssignment::operator==(const RestrictionClassAssignment& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_id==other_value.field_id
  && field_users==other_value.field_users;
}

boolean RestrictionClassAssignment::is_bound() const
{
if (bound_flag) return TRUE;
if(field_id.is_bound()) return TRUE;
if(field_users.is_bound()) return TRUE;
return FALSE;
}
boolean RestrictionClassAssignment::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_id.is_value()) return FALSE;
if(!field_users.is_value()) return FALSE;
return TRUE;
}
int RestrictionClassAssignment::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.RestrictionClassAssignment");
  return 2;
}

void RestrictionClassAssignment::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ id := ");
field_id.log();
TTCN_Logger::log_event_str(", users := ");
field_users.log();
TTCN_Logger::log_event_str(" }");
}

void RestrictionClassAssignment::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.RestrictionClassAssignment'");
    }
    if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("users", param_field) == 0) {
      users().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.RestrictionClassAssignment'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @DSRC.RestrictionClassAssignment has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) users().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "users")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          users().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.RestrictionClassAssignment: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.RestrictionClassAssignment");
  }
}

Module_Param* RestrictionClassAssignment::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.RestrictionClassAssignment'");
    }
    if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else if (strcmp("users", param_field) == 0) {
      return users().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.RestrictionClassAssignment'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_id = field_id.get_param(param_name);
  mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
  mp->add_elem(mp_field_id);
  Module_Param* mp_field_users = field_users.get_param(param_name);
  mp_field_users->set_id(new Module_Param_FieldName(mcopystr("users")));
  mp->add_elem(mp_field_users);
  return mp;
  }

void RestrictionClassAssignment::set_implicit_omit()
{
if (id().is_bound()) id().set_implicit_omit();
if (users().is_bound()) users().set_implicit_omit();
}

void RestrictionClassAssignment::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.RestrictionClassAssignment.");
field_id.encode_text(text_buf);
field_users.encode_text(text_buf);
}

void RestrictionClassAssignment::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_id.decode_text(text_buf);
field_users.decode_text(text_buf);
}

void RestrictionClassAssignment::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RestrictionClassAssignment::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RestrictionClassAssignment::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("id': ");
  new_tlv->add_TLV(field_id.BER_encode_TLV(RestrictionClassAssignment_id_descr_, p_coding));
  ec_1.set_msg("users': ");
  new_tlv->add_TLV(field_users.BER_encode_TLV(RestrictionClassAssignment_users_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RestrictionClassAssignment::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.RestrictionClassAssignment' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("id': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_id.BER_decode_TLV(RestrictionClassAssignment_id_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("users': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_users.BER_decode_TLV(RestrictionClassAssignment_users_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int RestrictionClassAssignment::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.RestrictionClassAssignment.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "id");
    enc_len += field_id.JSON_encode(RestrictionClassAssignment_id_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "users");
    enc_len += field_users.JSON_encode(RestrictionClassAssignment_users_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RestrictionClassAssignment::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (2 == name_len && 0 == strncmp(fld_name, "id", name_len)) {
         int ret_val = field_id.JSON_decode(RestrictionClassAssignment_id_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "id");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "users", name_len)) {
         int ret_val = field_users.JSON_decode(RestrictionClassAssignment_users_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "users");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_id.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "id");
    return JSON_ERROR_FATAL;
  }
if (!field_users.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "users");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct RestrictionClassAssignment_template::single_value_struct {
INTEGER_template field_id;
RestrictionUserTypeList_template field_users;
};

void RestrictionClassAssignment_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_id = ANY_VALUE;
single_value->field_users = ANY_VALUE;
}
}
}

void RestrictionClassAssignment_template::copy_value(const RestrictionClassAssignment& other_value)
{
single_value = new single_value_struct;
if (other_value.id().is_bound()) {
  single_value->field_id = other_value.id();
} else {
  single_value->field_id.clean_up();
}
if (other_value.users().is_bound()) {
  single_value->field_users = other_value.users();
} else {
  single_value->field_users.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RestrictionClassAssignment_template::copy_template(const RestrictionClassAssignment_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.id().get_selection()) {
single_value->field_id = other_value.id();
} else {
single_value->field_id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.users().get_selection()) {
single_value->field_users = other_value.users();
} else {
single_value->field_users.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RestrictionClassAssignment_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.RestrictionClassAssignment.");
break;
}
set_selection(other_value);
}

RestrictionClassAssignment_template::RestrictionClassAssignment_template()
{
}

RestrictionClassAssignment_template::RestrictionClassAssignment_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RestrictionClassAssignment_template::RestrictionClassAssignment_template(const RestrictionClassAssignment& other_value)
{
copy_value(other_value);
}

RestrictionClassAssignment_template::RestrictionClassAssignment_template(const OPTIONAL<RestrictionClassAssignment>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RestrictionClassAssignment&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.RestrictionClassAssignment from an unbound optional field.");
}
}

RestrictionClassAssignment_template::RestrictionClassAssignment_template(const RestrictionClassAssignment_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RestrictionClassAssignment_template::~RestrictionClassAssignment_template()
{
clean_up();
}

RestrictionClassAssignment_template& RestrictionClassAssignment_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RestrictionClassAssignment_template& RestrictionClassAssignment_template::operator=(const RestrictionClassAssignment& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RestrictionClassAssignment_template& RestrictionClassAssignment_template::operator=(const OPTIONAL<RestrictionClassAssignment>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RestrictionClassAssignment&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.RestrictionClassAssignment.");
}
return *this;
}

RestrictionClassAssignment_template& RestrictionClassAssignment_template::operator=(const RestrictionClassAssignment_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RestrictionClassAssignment_template::match(const RestrictionClassAssignment& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.id().is_bound()) return FALSE;
if(!single_value->field_id.match(other_value.id(), legacy))return FALSE;
if(!other_value.users().is_bound()) return FALSE;
if(!single_value->field_users.match(other_value.users(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.RestrictionClassAssignment.");
}
return FALSE;
}

boolean RestrictionClassAssignment_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_id.is_bound()) return TRUE;
if (single_value->field_users.is_bound()) return TRUE;
return FALSE;
}

boolean RestrictionClassAssignment_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_id.is_value()) return FALSE;
if (!single_value->field_users.is_value()) return FALSE;
return TRUE;
}

void RestrictionClassAssignment_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RestrictionClassAssignment RestrictionClassAssignment_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.RestrictionClassAssignment.");
RestrictionClassAssignment ret_val;
if (single_value->field_id.is_bound()) {
ret_val.id() = single_value->field_id.valueof();
}
if (single_value->field_users.is_bound()) {
ret_val.users() = single_value->field_users.valueof();
}
return ret_val;
}

void RestrictionClassAssignment_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.RestrictionClassAssignment.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RestrictionClassAssignment_template[list_length];
}

RestrictionClassAssignment_template& RestrictionClassAssignment_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.RestrictionClassAssignment.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.RestrictionClassAssignment.");
return value_list.list_value[list_index];
}

INTEGER_template& RestrictionClassAssignment_template::id()
{
set_specific();
return single_value->field_id;
}

const INTEGER_template& RestrictionClassAssignment_template::id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field id of a non-specific template of type @DSRC.RestrictionClassAssignment.");
return single_value->field_id;
}

RestrictionUserTypeList_template& RestrictionClassAssignment_template::users()
{
set_specific();
return single_value->field_users;
}

const RestrictionUserTypeList_template& RestrictionClassAssignment_template::users() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field users of a non-specific template of type @DSRC.RestrictionClassAssignment.");
return single_value->field_users;
}

int RestrictionClassAssignment_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.RestrictionClassAssignment which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.RestrictionClassAssignment containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.RestrictionClassAssignment containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RestrictionClassAssignment containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RestrictionClassAssignment containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.RestrictionClassAssignment containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.RestrictionClassAssignment.");
  }
  return 0;
}

void RestrictionClassAssignment_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ id := ");
single_value->field_id.log();
TTCN_Logger::log_event_str(", users := ");
single_value->field_users.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RestrictionClassAssignment_template::log_match(const RestrictionClassAssignment& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_id.match(match_value.id(), legacy)){
TTCN_Logger::log_logmatch_info(".id");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_users.match(match_value.users(), legacy)){
TTCN_Logger::log_logmatch_info(".users");
single_value->field_users.log_match(match_value.users(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ id := ");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::log_event_str(", users := ");
single_value->field_users.log_match(match_value.users(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RestrictionClassAssignment_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_id.encode_text(text_buf);
single_value->field_users.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.RestrictionClassAssignment.");
}
}

void RestrictionClassAssignment_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_id.decode_text(text_buf);
single_value->field_users.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RestrictionClassAssignment_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.RestrictionClassAssignment.");
}
}

void RestrictionClassAssignment_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.RestrictionClassAssignment'");
    }
    if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("users", param_field) == 0) {
      users().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.RestrictionClassAssignment'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RestrictionClassAssignment_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @DSRC.RestrictionClassAssignment has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) users().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "users")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          users().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.RestrictionClassAssignment: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.RestrictionClassAssignment");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RestrictionClassAssignment_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.RestrictionClassAssignment'");
    }
    if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else if (strcmp("users", param_field) == 0) {
      return users().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.RestrictionClassAssignment'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_id = single_value->field_id.get_param(param_name);
    mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
    mp->add_elem(mp_field_id);
    Module_Param* mp_field_users = single_value->field_users.get_param(param_name);
    mp_field_users->set_id(new Module_Param_FieldName(mcopystr("users")));
    mp->add_elem(mp_field_users);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RestrictionClassAssignment_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_id.check_restriction(t_res, t_name ? t_name : "@DSRC.RestrictionClassAssignment");
single_value->field_users.check_restriction(t_res, t_name ? t_name : "@DSRC.RestrictionClassAssignment");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.RestrictionClassAssignment");
}

boolean RestrictionClassAssignment_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RestrictionClassAssignment_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const IntersectionState IntersectionStateList::UNBOUND_ELEM;
IntersectionStateList::IntersectionStateList()
{
val_ptr = NULL;
}

IntersectionStateList::IntersectionStateList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

IntersectionStateList::IntersectionStateList(const IntersectionStateList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.IntersectionStateList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

IntersectionStateList::~IntersectionStateList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void IntersectionStateList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

IntersectionStateList& IntersectionStateList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

IntersectionStateList& IntersectionStateList::operator=(const IntersectionStateList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.IntersectionStateList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean IntersectionStateList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.IntersectionStateList.");
return val_ptr->n_elements == 0 ;
}

boolean IntersectionStateList::operator==(const IntersectionStateList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.IntersectionStateList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.IntersectionStateList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

IntersectionState& IntersectionStateList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.IntersectionStateList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (IntersectionState**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new IntersectionState(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new IntersectionState;
}
return *val_ptr->value_elements[index_value];
}

IntersectionState& IntersectionStateList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.IntersectionStateList.");
return (*this)[(int)index_value];
}

const IntersectionState& IntersectionStateList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.IntersectionStateList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.IntersectionStateList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.IntersectionStateList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const IntersectionState& IntersectionStateList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.IntersectionStateList.");
return (*this)[(int)index_value];
}

IntersectionStateList IntersectionStateList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

IntersectionStateList IntersectionStateList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

IntersectionStateList IntersectionStateList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

IntersectionStateList IntersectionStateList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.IntersectionStateList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
IntersectionStateList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new IntersectionState(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

IntersectionStateList IntersectionStateList::operator+(const IntersectionStateList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.IntersectionStateList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
IntersectionStateList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new IntersectionState(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new IntersectionState(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

IntersectionStateList IntersectionStateList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.IntersectionStateList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.IntersectionStateList","element");
IntersectionStateList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new IntersectionState(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

IntersectionStateList IntersectionStateList::replace(int index, int len, const IntersectionStateList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.IntersectionStateList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.IntersectionStateList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.IntersectionStateList","element");
IntersectionStateList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new IntersectionState(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new IntersectionState(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new IntersectionState(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

IntersectionStateList IntersectionStateList::replace(int index, int len, const IntersectionStateList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void IntersectionStateList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.IntersectionStateList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (IntersectionState**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new IntersectionState(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (IntersectionState**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.IntersectionStateList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (IntersectionState**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean IntersectionStateList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int IntersectionStateList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.IntersectionStateList.");
return val_ptr->n_elements;
}

int IntersectionStateList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.IntersectionStateList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void IntersectionStateList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void IntersectionStateList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.IntersectionStateList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.IntersectionStateList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.IntersectionStateList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* IntersectionStateList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.IntersectionStateList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void IntersectionStateList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void IntersectionStateList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.IntersectionStateList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void IntersectionStateList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.IntersectionStateList.");
val_ptr->value_elements = (IntersectionState**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new IntersectionState;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void IntersectionStateList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IntersectionStateList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* IntersectionStateList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean IntersectionStateList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (IntersectionState**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new IntersectionState;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int IntersectionStateList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.IntersectionStateList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int IntersectionStateList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    IntersectionState* val = new IntersectionState;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (IntersectionState**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void IntersectionStateList_template::copy_value(const IntersectionStateList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.IntersectionStateList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (IntersectionState_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new IntersectionState_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new IntersectionState_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void IntersectionStateList_template::copy_template(const IntersectionStateList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (IntersectionState_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new IntersectionState_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new IntersectionState_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IntersectionStateList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.IntersectionStateList.");
break;
}
set_selection(other_value);
}

boolean IntersectionStateList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const IntersectionStateList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const IntersectionStateList*)value_ptr)[value_index], legacy);
else return ((const IntersectionStateList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

IntersectionStateList_template::IntersectionStateList_template()
{
}

IntersectionStateList_template::IntersectionStateList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

IntersectionStateList_template::IntersectionStateList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

IntersectionStateList_template::IntersectionStateList_template(const IntersectionStateList& other_value)
{
copy_value(other_value);
}

IntersectionStateList_template::IntersectionStateList_template(const OPTIONAL<IntersectionStateList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionStateList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.IntersectionStateList from an unbound optional field.");
}
}

IntersectionStateList_template::IntersectionStateList_template(const IntersectionStateList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

IntersectionStateList_template::~IntersectionStateList_template()
{
clean_up();
}

void IntersectionStateList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IntersectionStateList_template& IntersectionStateList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IntersectionStateList_template& IntersectionStateList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

IntersectionStateList_template& IntersectionStateList_template::operator=(const IntersectionStateList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IntersectionStateList_template& IntersectionStateList_template::operator=(const OPTIONAL<IntersectionStateList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionStateList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.IntersectionStateList.");
}
return *this;
}

IntersectionStateList_template& IntersectionStateList_template::operator=(const IntersectionStateList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

IntersectionState_template& IntersectionStateList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.IntersectionStateList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.IntersectionStateList.");
    break;
}
return *single_value.value_elements[index_value];
}

IntersectionState_template& IntersectionStateList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.IntersectionStateList.");
return (*this)[(int)index_value];
}

const IntersectionState_template& IntersectionStateList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.IntersectionStateList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.IntersectionStateList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.IntersectionStateList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const IntersectionState_template& IntersectionStateList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.IntersectionStateList.");
return (*this)[(int)index_value];
}

void IntersectionStateList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.IntersectionStateList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (IntersectionState_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new IntersectionState_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new IntersectionState_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (IntersectionState_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int IntersectionStateList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int IntersectionStateList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionStateList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionStateList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionStateList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionStateList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionStateList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.IntersectionStateList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.IntersectionStateList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.IntersectionStateList");
}

boolean IntersectionStateList_template::match(const IntersectionStateList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.IntersectionStateList.");
}
return FALSE;
}

boolean IntersectionStateList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

IntersectionStateList IntersectionStateList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.IntersectionStateList.");
IntersectionStateList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

IntersectionStateList IntersectionStateList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

IntersectionStateList IntersectionStateList_template::replace(int index, int len, const IntersectionStateList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

IntersectionStateList IntersectionStateList_template::replace(int index, int len, const IntersectionStateList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void IntersectionStateList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new IntersectionStateList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.IntersectionStateList.");
}
set_selection(template_type);
}

IntersectionStateList_template& IntersectionStateList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.IntersectionStateList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.IntersectionStateList.");
return value_list.list_value[list_index];
}

void IntersectionStateList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void IntersectionStateList_template::log_match(const IntersectionStateList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IntersectionStateList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.IntersectionStateList.");
}
}

void IntersectionStateList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.IntersectionStateList.");
single_value.value_elements = (IntersectionState_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new IntersectionState_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IntersectionStateList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.IntersectionStateList.");
}
}

boolean IntersectionStateList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IntersectionStateList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void IntersectionStateList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.IntersectionStateList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IntersectionStateList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.IntersectionStateList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* IntersectionStateList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.IntersectionStateList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void IntersectionStateList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionStateList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.IntersectionStateList");
}


const MovementState MovementList::UNBOUND_ELEM;
MovementList::MovementList()
{
val_ptr = NULL;
}

MovementList::MovementList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

MovementList::MovementList(const MovementList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.MovementList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

MovementList::~MovementList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void MovementList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

MovementList& MovementList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

MovementList& MovementList::operator=(const MovementList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.MovementList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean MovementList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.MovementList.");
return val_ptr->n_elements == 0 ;
}

boolean MovementList::operator==(const MovementList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.MovementList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.MovementList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

MovementState& MovementList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.MovementList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (MovementState**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new MovementState(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new MovementState;
}
return *val_ptr->value_elements[index_value];
}

MovementState& MovementList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.MovementList.");
return (*this)[(int)index_value];
}

const MovementState& MovementList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.MovementList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.MovementList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.MovementList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const MovementState& MovementList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.MovementList.");
return (*this)[(int)index_value];
}

MovementList MovementList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

MovementList MovementList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

MovementList MovementList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

MovementList MovementList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.MovementList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
MovementList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new MovementState(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

MovementList MovementList::operator+(const MovementList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.MovementList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
MovementList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new MovementState(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new MovementState(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

MovementList MovementList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.MovementList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.MovementList","element");
MovementList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new MovementState(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

MovementList MovementList::replace(int index, int len, const MovementList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.MovementList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.MovementList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.MovementList","element");
MovementList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new MovementState(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new MovementState(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new MovementState(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

MovementList MovementList::replace(int index, int len, const MovementList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void MovementList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.MovementList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (MovementState**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new MovementState(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (MovementState**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.MovementList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (MovementState**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean MovementList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int MovementList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.MovementList.");
return val_ptr->n_elements;
}

int MovementList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.MovementList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void MovementList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void MovementList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.MovementList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.MovementList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.MovementList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* MovementList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.MovementList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void MovementList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void MovementList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.MovementList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void MovementList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.MovementList.");
val_ptr->value_elements = (MovementState**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new MovementState;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void MovementList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MovementList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* MovementList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean MovementList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (MovementState**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new MovementState;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int MovementList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.MovementList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int MovementList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    MovementState* val = new MovementState;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (MovementState**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void MovementList_template::copy_value(const MovementList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.MovementList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (MovementState_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new MovementState_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new MovementState_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void MovementList_template::copy_template(const MovementList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (MovementState_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new MovementState_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new MovementState_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MovementList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.MovementList.");
break;
}
set_selection(other_value);
}

boolean MovementList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const MovementList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const MovementList*)value_ptr)[value_index], legacy);
else return ((const MovementList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

MovementList_template::MovementList_template()
{
}

MovementList_template::MovementList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

MovementList_template::MovementList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

MovementList_template::MovementList_template(const MovementList& other_value)
{
copy_value(other_value);
}

MovementList_template::MovementList_template(const OPTIONAL<MovementList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MovementList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.MovementList from an unbound optional field.");
}
}

MovementList_template::MovementList_template(const MovementList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

MovementList_template::~MovementList_template()
{
clean_up();
}

void MovementList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MovementList_template& MovementList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MovementList_template& MovementList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

MovementList_template& MovementList_template::operator=(const MovementList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MovementList_template& MovementList_template::operator=(const OPTIONAL<MovementList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MovementList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.MovementList.");
}
return *this;
}

MovementList_template& MovementList_template::operator=(const MovementList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

MovementState_template& MovementList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.MovementList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.MovementList.");
    break;
}
return *single_value.value_elements[index_value];
}

MovementState_template& MovementList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.MovementList.");
return (*this)[(int)index_value];
}

const MovementState_template& MovementList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.MovementList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.MovementList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.MovementList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const MovementState_template& MovementList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.MovementList.");
return (*this)[(int)index_value];
}

void MovementList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.MovementList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (MovementState_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new MovementState_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new MovementState_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (MovementState_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int MovementList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int MovementList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.MovementList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.MovementList");
}

boolean MovementList_template::match(const MovementList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.MovementList.");
}
return FALSE;
}

boolean MovementList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

MovementList MovementList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.MovementList.");
MovementList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

MovementList MovementList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

MovementList MovementList_template::replace(int index, int len, const MovementList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

MovementList MovementList_template::replace(int index, int len, const MovementList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void MovementList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new MovementList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.MovementList.");
}
set_selection(template_type);
}

MovementList_template& MovementList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.MovementList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.MovementList.");
return value_list.list_value[list_index];
}

void MovementList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void MovementList_template::log_match(const MovementList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MovementList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.MovementList.");
}
}

void MovementList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.MovementList.");
single_value.value_elements = (MovementState_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new MovementState_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MovementList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.MovementList.");
}
}

boolean MovementList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MovementList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MovementList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.MovementList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MovementList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.MovementList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* MovementList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.MovementList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void MovementList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.MovementList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.MovementList");
}


const MovementEvent MovementEventList::UNBOUND_ELEM;
MovementEventList::MovementEventList()
{
val_ptr = NULL;
}

MovementEventList::MovementEventList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

MovementEventList::MovementEventList(const MovementEventList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.MovementEventList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

MovementEventList::~MovementEventList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void MovementEventList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

MovementEventList& MovementEventList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

MovementEventList& MovementEventList::operator=(const MovementEventList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.MovementEventList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean MovementEventList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.MovementEventList.");
return val_ptr->n_elements == 0 ;
}

boolean MovementEventList::operator==(const MovementEventList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.MovementEventList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.MovementEventList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

MovementEvent& MovementEventList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.MovementEventList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (MovementEvent**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new MovementEvent(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new MovementEvent;
}
return *val_ptr->value_elements[index_value];
}

MovementEvent& MovementEventList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.MovementEventList.");
return (*this)[(int)index_value];
}

const MovementEvent& MovementEventList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.MovementEventList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.MovementEventList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.MovementEventList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const MovementEvent& MovementEventList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.MovementEventList.");
return (*this)[(int)index_value];
}

MovementEventList MovementEventList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

MovementEventList MovementEventList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

MovementEventList MovementEventList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

MovementEventList MovementEventList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.MovementEventList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
MovementEventList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new MovementEvent(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

MovementEventList MovementEventList::operator+(const MovementEventList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.MovementEventList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
MovementEventList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new MovementEvent(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new MovementEvent(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

MovementEventList MovementEventList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.MovementEventList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.MovementEventList","element");
MovementEventList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new MovementEvent(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

MovementEventList MovementEventList::replace(int index, int len, const MovementEventList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.MovementEventList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.MovementEventList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.MovementEventList","element");
MovementEventList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new MovementEvent(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new MovementEvent(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new MovementEvent(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

MovementEventList MovementEventList::replace(int index, int len, const MovementEventList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void MovementEventList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.MovementEventList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (MovementEvent**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new MovementEvent(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (MovementEvent**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.MovementEventList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (MovementEvent**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean MovementEventList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int MovementEventList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.MovementEventList.");
return val_ptr->n_elements;
}

int MovementEventList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.MovementEventList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void MovementEventList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void MovementEventList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.MovementEventList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.MovementEventList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.MovementEventList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* MovementEventList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.MovementEventList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void MovementEventList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void MovementEventList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.MovementEventList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void MovementEventList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.MovementEventList.");
val_ptr->value_elements = (MovementEvent**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new MovementEvent;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void MovementEventList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MovementEventList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* MovementEventList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean MovementEventList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (MovementEvent**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new MovementEvent;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int MovementEventList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.MovementEventList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int MovementEventList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    MovementEvent* val = new MovementEvent;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (MovementEvent**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void MovementEventList_template::copy_value(const MovementEventList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.MovementEventList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (MovementEvent_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new MovementEvent_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new MovementEvent_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void MovementEventList_template::copy_template(const MovementEventList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (MovementEvent_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new MovementEvent_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new MovementEvent_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MovementEventList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.MovementEventList.");
break;
}
set_selection(other_value);
}

boolean MovementEventList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const MovementEventList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const MovementEventList*)value_ptr)[value_index], legacy);
else return ((const MovementEventList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

MovementEventList_template::MovementEventList_template()
{
}

MovementEventList_template::MovementEventList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

MovementEventList_template::MovementEventList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

MovementEventList_template::MovementEventList_template(const MovementEventList& other_value)
{
copy_value(other_value);
}

MovementEventList_template::MovementEventList_template(const OPTIONAL<MovementEventList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MovementEventList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.MovementEventList from an unbound optional field.");
}
}

MovementEventList_template::MovementEventList_template(const MovementEventList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

MovementEventList_template::~MovementEventList_template()
{
clean_up();
}

void MovementEventList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MovementEventList_template& MovementEventList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MovementEventList_template& MovementEventList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

MovementEventList_template& MovementEventList_template::operator=(const MovementEventList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MovementEventList_template& MovementEventList_template::operator=(const OPTIONAL<MovementEventList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MovementEventList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.MovementEventList.");
}
return *this;
}

MovementEventList_template& MovementEventList_template::operator=(const MovementEventList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

MovementEvent_template& MovementEventList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.MovementEventList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.MovementEventList.");
    break;
}
return *single_value.value_elements[index_value];
}

MovementEvent_template& MovementEventList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.MovementEventList.");
return (*this)[(int)index_value];
}

const MovementEvent_template& MovementEventList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.MovementEventList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.MovementEventList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.MovementEventList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const MovementEvent_template& MovementEventList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.MovementEventList.");
return (*this)[(int)index_value];
}

void MovementEventList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.MovementEventList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (MovementEvent_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new MovementEvent_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new MovementEvent_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (MovementEvent_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int MovementEventList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int MovementEventList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementEventList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementEventList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementEventList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementEventList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementEventList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.MovementEventList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.MovementEventList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.MovementEventList");
}

boolean MovementEventList_template::match(const MovementEventList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.MovementEventList.");
}
return FALSE;
}

boolean MovementEventList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

MovementEventList MovementEventList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.MovementEventList.");
MovementEventList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

MovementEventList MovementEventList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

MovementEventList MovementEventList_template::replace(int index, int len, const MovementEventList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

MovementEventList MovementEventList_template::replace(int index, int len, const MovementEventList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void MovementEventList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new MovementEventList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.MovementEventList.");
}
set_selection(template_type);
}

MovementEventList_template& MovementEventList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.MovementEventList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.MovementEventList.");
return value_list.list_value[list_index];
}

void MovementEventList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void MovementEventList_template::log_match(const MovementEventList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MovementEventList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.MovementEventList.");
}
}

void MovementEventList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.MovementEventList.");
single_value.value_elements = (MovementEvent_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new MovementEvent_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MovementEventList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.MovementEventList.");
}
}

boolean MovementEventList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MovementEventList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MovementEventList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.MovementEventList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MovementEventList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.MovementEventList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* MovementEventList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.MovementEventList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void MovementEventList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.MovementEventList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.MovementEventList");
}

MovementPhaseState::MovementPhaseState()
{
enum_value = UNBOUND_VALUE;
}

MovementPhaseState::MovementPhaseState(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @DSRC.MovementPhaseState with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

MovementPhaseState::MovementPhaseState(enum_type other_value)
{
enum_value = other_value;
}

MovementPhaseState::MovementPhaseState(const MovementPhaseState& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @DSRC.MovementPhaseState.");
enum_value = other_value.enum_value;
}

MovementPhaseState& MovementPhaseState::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @DSRC.MovementPhaseState.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

MovementPhaseState& MovementPhaseState::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

MovementPhaseState& MovementPhaseState::operator=(const MovementPhaseState& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.MovementPhaseState.");
enum_value = other_value.enum_value;
return *this;
}

boolean MovementPhaseState::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.MovementPhaseState.");
return enum_value == other_value;
}

boolean MovementPhaseState::operator==(const MovementPhaseState& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.MovementPhaseState.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.MovementPhaseState.");
return enum_value == other_value.enum_value;
}

boolean MovementPhaseState::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.MovementPhaseState.");
return enum_value < other_value;
}

boolean MovementPhaseState::operator<(const MovementPhaseState& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.MovementPhaseState.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.MovementPhaseState.");
return enum_value < other_value.enum_value;
}

boolean MovementPhaseState::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.MovementPhaseState.");
return enum_value > other_value;
}

boolean MovementPhaseState::operator>(const MovementPhaseState& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.MovementPhaseState.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.MovementPhaseState.");
return enum_value > other_value.enum_value;
}

const char *MovementPhaseState::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case unavailable: return "unavailable";
case dark: return "dark";
case stop__Then__Proceed: return "stop_Then_Proceed";
case stop__And__Remain: return "stop_And_Remain";
case pre__Movement: return "pre_Movement";
case permissive__Movement__Allowed: return "permissive_Movement_Allowed";
case protected__Movement__Allowed: return "protected_Movement_Allowed";
case permissive__clearance: return "permissive_clearance";
case protected__clearance: return "protected_clearance";
case caution__Conflicting__Traffic: return "caution_Conflicting_Traffic";
default: return "<unknown>";
}
}

MovementPhaseState::enum_type MovementPhaseState::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "unavailable")) return unavailable;
else if (!strcmp(str_par, "dark")) return dark;
else if (!strcmp(str_par, "stop_Then_Proceed")) return stop__Then__Proceed;
else if (!strcmp(str_par, "stop_And_Remain")) return stop__And__Remain;
else if (!strcmp(str_par, "pre_Movement")) return pre__Movement;
else if (!strcmp(str_par, "permissive_Movement_Allowed")) return permissive__Movement__Allowed;
else if (!strcmp(str_par, "protected_Movement_Allowed")) return protected__Movement__Allowed;
else if (!strcmp(str_par, "permissive_clearance")) return permissive__clearance;
else if (!strcmp(str_par, "protected_clearance")) return protected__clearance;
else if (!strcmp(str_par, "caution_Conflicting_Traffic")) return caution__Conflicting__Traffic;
else return UNKNOWN_VALUE;
}

boolean MovementPhaseState::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
return TRUE;
default:
return FALSE;
}
}

int MovementPhaseState::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.MovementPhaseState.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int MovementPhaseState::enum2int(const MovementPhaseState& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.MovementPhaseState.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void MovementPhaseState::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @DSRC.MovementPhaseState.", int_val);
enum_value = (enum_type)int_val;
}

MovementPhaseState::operator MovementPhaseState::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @DSRC.MovementPhaseState.");
return enum_value;
}

void MovementPhaseState::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void MovementPhaseState::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@DSRC.MovementPhaseState");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @DSRC.MovementPhaseState.");
  }
}

Module_Param* MovementPhaseState::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void MovementPhaseState::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @DSRC.MovementPhaseState.");
text_buf.push_int(enum_value);
}

void MovementPhaseState::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @DSRC.MovementPhaseState.", enum_value);
}

void MovementPhaseState::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MovementPhaseState::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* MovementPhaseState::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean MovementPhaseState::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @DSRC.MovementPhaseState: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int MovementPhaseState::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @DSRC.MovementPhaseState.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int MovementPhaseState::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void MovementPhaseState_template::copy_template(const MovementPhaseState_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MovementPhaseState_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @DSRC.MovementPhaseState.");
}
}

MovementPhaseState_template::MovementPhaseState_template()
{
}

MovementPhaseState_template::MovementPhaseState_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MovementPhaseState_template::MovementPhaseState_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!MovementPhaseState::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @DSRC.MovementPhaseState with unknown numeric value %d.", other_value);
single_value = (MovementPhaseState::enum_type)other_value;
}

MovementPhaseState_template::MovementPhaseState_template(MovementPhaseState::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

MovementPhaseState_template::MovementPhaseState_template(const MovementPhaseState& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == MovementPhaseState::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @DSRC.MovementPhaseState.");
single_value = other_value.enum_value;
}

MovementPhaseState_template::MovementPhaseState_template(const OPTIONAL<MovementPhaseState>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (MovementPhaseState::enum_type)(const MovementPhaseState&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @DSRC.MovementPhaseState from an unbound optional field.");
}
}

MovementPhaseState_template::MovementPhaseState_template(const MovementPhaseState_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

MovementPhaseState_template::~MovementPhaseState_template()
{
clean_up();
}

boolean MovementPhaseState_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean MovementPhaseState_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != MovementPhaseState::UNBOUND_VALUE;
}

void MovementPhaseState_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

MovementPhaseState_template& MovementPhaseState_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MovementPhaseState_template& MovementPhaseState_template::operator=(int other_value)
{
if (!MovementPhaseState::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @DSRC.MovementPhaseState.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (MovementPhaseState::enum_type)other_value;
return *this;
}

MovementPhaseState_template& MovementPhaseState_template::operator=(MovementPhaseState::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

MovementPhaseState_template& MovementPhaseState_template::operator=(const MovementPhaseState& other_value)
{
if (other_value.enum_value == MovementPhaseState::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.MovementPhaseState to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

MovementPhaseState_template& MovementPhaseState_template::operator=(const OPTIONAL<MovementPhaseState>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (MovementPhaseState::enum_type)(const MovementPhaseState&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @DSRC.MovementPhaseState.");
}
return *this;
}

MovementPhaseState_template& MovementPhaseState_template::operator=(const MovementPhaseState_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MovementPhaseState_template::match(MovementPhaseState::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @DSRC.MovementPhaseState.");
}
return FALSE;
}

boolean MovementPhaseState_template::match(const MovementPhaseState& other_value, boolean) const
{
if (other_value.enum_value == MovementPhaseState::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @DSRC.MovementPhaseState with an unbound value.");
return match(other_value.enum_value);
}

MovementPhaseState::enum_type MovementPhaseState_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @DSRC.MovementPhaseState.");
return single_value;
}

void MovementPhaseState_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @DSRC.MovementPhaseState.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MovementPhaseState_template[list_length];
}

MovementPhaseState_template& MovementPhaseState_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @DSRC.MovementPhaseState.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @DSRC.MovementPhaseState.");
return value_list.list_value[list_index];
}

void MovementPhaseState_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(MovementPhaseState::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MovementPhaseState_template::log_match(const MovementPhaseState& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void MovementPhaseState_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @DSRC.MovementPhaseState.");
}
}

void MovementPhaseState_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (MovementPhaseState::enum_type)text_buf.pull_int().get_val();
if (!MovementPhaseState::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @DSRC.MovementPhaseState.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MovementPhaseState_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @DSRC.MovementPhaseState.");
}
}

boolean MovementPhaseState_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MovementPhaseState_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MovementPhaseState_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    MovementPhaseState::enum_type enum_val = (enum_name != NULL) ? MovementPhaseState::str_to_enum(enum_name) : MovementPhaseState::UNKNOWN_VALUE;
    if (MovementPhaseState::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MovementPhaseState_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    MovementPhaseState::enum_type enum_val = MovementPhaseState::str_to_enum(mp->get_enumerated());
    if (!MovementPhaseState::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @DSRC.MovementPhaseState.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@DSRC.MovementPhaseState");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* MovementPhaseState_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(MovementPhaseState::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void MovementPhaseState_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.MovementPhaseState");
}

MovementEvent::MovementEvent()
{
  bound_flag = FALSE;
}

MovementEvent::MovementEvent(const MovementPhaseState& par_eventState,
    const OPTIONAL<TimeChangeDetails>& par_timing,
    const OPTIONAL<AdvisorySpeedList>& par_speeds,
    const OPTIONAL<REGION::Reg__MovementEvent>& par_regional)
  :   field_eventState(par_eventState),
  field_timing(par_timing),
  field_speeds(par_speeds),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

MovementEvent::MovementEvent(const MovementEvent& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.MovementEvent.");
bound_flag = TRUE;
if (other_value.eventState().is_bound()) field_eventState = other_value.eventState();
else field_eventState.clean_up();
if (other_value.timing().is_bound()) field_timing = other_value.timing();
else field_timing.clean_up();
if (other_value.speeds().is_bound()) field_speeds = other_value.speeds();
else field_speeds.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void MovementEvent::clean_up()
{
field_eventState.clean_up();
field_timing.clean_up();
field_speeds.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

MovementEvent& MovementEvent::operator=(const MovementEvent& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.MovementEvent.");
  bound_flag = TRUE;
  if (other_value.eventState().is_bound()) field_eventState = other_value.eventState();
  else field_eventState.clean_up();
  if (other_value.timing().is_bound()) field_timing = other_value.timing();
  else field_timing.clean_up();
  if (other_value.speeds().is_bound()) field_speeds = other_value.speeds();
  else field_speeds.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean MovementEvent::operator==(const MovementEvent& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_eventState==other_value.field_eventState
  && field_timing==other_value.field_timing
  && field_speeds==other_value.field_speeds
  && field_regional==other_value.field_regional;
}

boolean MovementEvent::is_bound() const
{
if (bound_flag) return TRUE;
if(field_eventState.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_timing.get_selection() || field_timing.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_speeds.get_selection() || field_speeds.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean MovementEvent::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_eventState.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_timing.get_selection() && !field_timing.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_speeds.get_selection() && !field_speeds.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int MovementEvent::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.MovementEvent");
  int ret_val = 1;
  if (field_timing.ispresent()) ret_val++;
  if (field_speeds.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void MovementEvent::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ eventState := ");
field_eventState.log();
TTCN_Logger::log_event_str(", timing := ");
field_timing.log();
TTCN_Logger::log_event_str(", speeds := ");
field_speeds.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void MovementEvent::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.MovementEvent'");
    }
    if (strcmp("eventState", param_field) == 0) {
      eventState().set_param(param);
      return;
    } else if (strcmp("timing", param_field) == 0) {
      timing().set_param(param);
      return;
    } else if (strcmp("speeds", param_field) == 0) {
      speeds().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.MovementEvent'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @DSRC.MovementEvent has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) eventState().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) timing().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) speeds().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventState")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventState().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "timing")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          timing().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speeds")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speeds().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.MovementEvent: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.MovementEvent");
  }
}

Module_Param* MovementEvent::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.MovementEvent'");
    }
    if (strcmp("eventState", param_field) == 0) {
      return eventState().get_param(param_name);
    } else if (strcmp("timing", param_field) == 0) {
      return timing().get_param(param_name);
    } else if (strcmp("speeds", param_field) == 0) {
      return speeds().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.MovementEvent'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_eventState = field_eventState.get_param(param_name);
  mp_field_eventState->set_id(new Module_Param_FieldName(mcopystr("eventState")));
  mp->add_elem(mp_field_eventState);
  Module_Param* mp_field_timing = field_timing.get_param(param_name);
  mp_field_timing->set_id(new Module_Param_FieldName(mcopystr("timing")));
  mp->add_elem(mp_field_timing);
  Module_Param* mp_field_speeds = field_speeds.get_param(param_name);
  mp_field_speeds->set_id(new Module_Param_FieldName(mcopystr("speeds")));
  mp->add_elem(mp_field_speeds);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void MovementEvent::set_implicit_omit()
{
if (eventState().is_bound()) eventState().set_implicit_omit();
if (!timing().is_bound()) timing() = OMIT_VALUE;
else timing().set_implicit_omit();
if (!speeds().is_bound()) speeds() = OMIT_VALUE;
else speeds().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void MovementEvent::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.MovementEvent.");
field_eventState.encode_text(text_buf);
field_timing.encode_text(text_buf);
field_speeds.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void MovementEvent::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_eventState.decode_text(text_buf);
field_timing.decode_text(text_buf);
field_speeds.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void MovementEvent::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MovementEvent::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* MovementEvent::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("eventState': ");
  new_tlv->add_TLV(field_eventState.BER_encode_TLV(MovementEvent_eventState_descr_, p_coding));
  ec_1.set_msg("timing': ");
  new_tlv->add_TLV(field_timing.BER_encode_TLV(MovementEvent_timing_descr_, p_coding));
  ec_1.set_msg("speeds': ");
  new_tlv->add_TLV(field_speeds.BER_encode_TLV(MovementEvent_speeds_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(MovementEvent_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean MovementEvent::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.MovementEvent' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("eventState': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_eventState.BER_decode_TLV(MovementEvent_eventState_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("timing': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_timing=OMIT_VALUE;
    else {
      field_timing.BER_decode_TLV(MovementEvent_timing_descr_, tmp_tlv, L_form);
      if(field_timing.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("speeds': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_speeds=OMIT_VALUE;
    else {
      field_speeds.BER_decode_TLV(MovementEvent_speeds_descr_, tmp_tlv, L_form);
      if(field_speeds.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(MovementEvent_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int MovementEvent::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.MovementEvent.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eventState");
    enc_len += field_eventState.JSON_encode(MovementEvent_eventState_descr_, p_tok);
  }

  if (field_timing.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "timing");
    enc_len += field_timing.JSON_encode(MovementEvent_timing_descr_, p_tok);
  }

  if (field_speeds.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speeds");
    enc_len += field_speeds.JSON_encode(MovementEvent_speeds_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(MovementEvent_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int MovementEvent::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "eventState", name_len)) {
         int ret_val = field_eventState.JSON_decode(MovementEvent_eventState_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eventState");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "timing", name_len)) {
         int ret_val = field_timing.JSON_decode(MovementEvent_timing_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "timing");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "speeds", name_len)) {
         int ret_val = field_speeds.JSON_decode(MovementEvent_speeds_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speeds");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(MovementEvent_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_eventState.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "eventState");
    return JSON_ERROR_FATAL;
  }
if (!field_timing.is_bound()) {
    field_timing = OMIT_VALUE;
  }
if (!field_speeds.is_bound()) {
    field_speeds = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct MovementEvent_template::single_value_struct {
MovementPhaseState_template field_eventState;
TimeChangeDetails_template field_timing;
AdvisorySpeedList_template field_speeds;
REGION::Reg__MovementEvent_template field_regional;
};

void MovementEvent_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_eventState = ANY_VALUE;
single_value->field_timing = ANY_OR_OMIT;
single_value->field_speeds = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void MovementEvent_template::copy_value(const MovementEvent& other_value)
{
single_value = new single_value_struct;
if (other_value.eventState().is_bound()) {
  single_value->field_eventState = other_value.eventState();
} else {
  single_value->field_eventState.clean_up();
}
if (other_value.timing().is_bound()) {
  if (other_value.timing().ispresent()) single_value->field_timing = other_value.timing()();
  else single_value->field_timing = OMIT_VALUE;
} else {
  single_value->field_timing.clean_up();
}
if (other_value.speeds().is_bound()) {
  if (other_value.speeds().ispresent()) single_value->field_speeds = other_value.speeds()();
  else single_value->field_speeds = OMIT_VALUE;
} else {
  single_value->field_speeds.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MovementEvent_template::copy_template(const MovementEvent_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.eventState().get_selection()) {
single_value->field_eventState = other_value.eventState();
} else {
single_value->field_eventState.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.timing().get_selection()) {
single_value->field_timing = other_value.timing();
} else {
single_value->field_timing.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speeds().get_selection()) {
single_value->field_speeds = other_value.speeds();
} else {
single_value->field_speeds.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MovementEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.MovementEvent.");
break;
}
set_selection(other_value);
}

MovementEvent_template::MovementEvent_template()
{
}

MovementEvent_template::MovementEvent_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MovementEvent_template::MovementEvent_template(const MovementEvent& other_value)
{
copy_value(other_value);
}

MovementEvent_template::MovementEvent_template(const OPTIONAL<MovementEvent>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MovementEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.MovementEvent from an unbound optional field.");
}
}

MovementEvent_template::MovementEvent_template(const MovementEvent_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MovementEvent_template::~MovementEvent_template()
{
clean_up();
}

MovementEvent_template& MovementEvent_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MovementEvent_template& MovementEvent_template::operator=(const MovementEvent& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MovementEvent_template& MovementEvent_template::operator=(const OPTIONAL<MovementEvent>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MovementEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.MovementEvent.");
}
return *this;
}

MovementEvent_template& MovementEvent_template::operator=(const MovementEvent_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MovementEvent_template::match(const MovementEvent& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.eventState().is_bound()) return FALSE;
if(!single_value->field_eventState.match(other_value.eventState(), legacy))return FALSE;
if(!other_value.timing().is_bound()) return FALSE;
if((other_value.timing().ispresent() ? !single_value->field_timing.match((const TimeChangeDetails&)other_value.timing(), legacy) : !single_value->field_timing.match_omit(legacy)))return FALSE;
if(!other_value.speeds().is_bound()) return FALSE;
if((other_value.speeds().ispresent() ? !single_value->field_speeds.match((const AdvisorySpeedList&)other_value.speeds(), legacy) : !single_value->field_speeds.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REGION::Reg__MovementEvent&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.MovementEvent.");
}
return FALSE;
}

boolean MovementEvent_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_eventState.is_bound()) return TRUE;
if (single_value->field_timing.is_omit() || single_value->field_timing.is_bound()) return TRUE;
if (single_value->field_speeds.is_omit() || single_value->field_speeds.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean MovementEvent_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_eventState.is_value()) return FALSE;
if (!single_value->field_timing.is_omit() && !single_value->field_timing.is_value()) return FALSE;
if (!single_value->field_speeds.is_omit() && !single_value->field_speeds.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void MovementEvent_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MovementEvent MovementEvent_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.MovementEvent.");
MovementEvent ret_val;
if (single_value->field_eventState.is_bound()) {
ret_val.eventState() = single_value->field_eventState.valueof();
}
if (single_value->field_timing.is_omit()) ret_val.timing() = OMIT_VALUE;
else if (single_value->field_timing.is_bound()) {
ret_val.timing() = single_value->field_timing.valueof();
}
if (single_value->field_speeds.is_omit()) ret_val.speeds() = OMIT_VALUE;
else if (single_value->field_speeds.is_bound()) {
ret_val.speeds() = single_value->field_speeds.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void MovementEvent_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.MovementEvent.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MovementEvent_template[list_length];
}

MovementEvent_template& MovementEvent_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.MovementEvent.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.MovementEvent.");
return value_list.list_value[list_index];
}

MovementPhaseState_template& MovementEvent_template::eventState()
{
set_specific();
return single_value->field_eventState;
}

const MovementPhaseState_template& MovementEvent_template::eventState() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field eventState of a non-specific template of type @DSRC.MovementEvent.");
return single_value->field_eventState;
}

TimeChangeDetails_template& MovementEvent_template::timing()
{
set_specific();
return single_value->field_timing;
}

const TimeChangeDetails_template& MovementEvent_template::timing() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field timing of a non-specific template of type @DSRC.MovementEvent.");
return single_value->field_timing;
}

AdvisorySpeedList_template& MovementEvent_template::speeds()
{
set_specific();
return single_value->field_speeds;
}

const AdvisorySpeedList_template& MovementEvent_template::speeds() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speeds of a non-specific template of type @DSRC.MovementEvent.");
return single_value->field_speeds;
}

REGION::Reg__MovementEvent_template& MovementEvent_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REGION::Reg__MovementEvent_template& MovementEvent_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.MovementEvent.");
return single_value->field_regional;
}

int MovementEvent_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementEvent which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_timing.is_present()) ret_val++;
      if (single_value->field_speeds.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.MovementEvent containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementEvent containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementEvent containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementEvent containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementEvent containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.MovementEvent.");
  }
  return 0;
}

void MovementEvent_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ eventState := ");
single_value->field_eventState.log();
TTCN_Logger::log_event_str(", timing := ");
single_value->field_timing.log();
TTCN_Logger::log_event_str(", speeds := ");
single_value->field_speeds.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MovementEvent_template::log_match(const MovementEvent& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_eventState.match(match_value.eventState(), legacy)){
TTCN_Logger::log_logmatch_info(".eventState");
single_value->field_eventState.log_match(match_value.eventState(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.timing().ispresent()){
if(!single_value->field_timing.match(match_value.timing(), legacy)){
TTCN_Logger::log_logmatch_info(".timing");
single_value->field_timing.log_match(match_value.timing(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_timing.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".timing := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_timing.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.speeds().ispresent()){
if(!single_value->field_speeds.match(match_value.speeds(), legacy)){
TTCN_Logger::log_logmatch_info(".speeds");
single_value->field_speeds.log_match(match_value.speeds(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_speeds.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".speeds := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_speeds.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ eventState := ");
single_value->field_eventState.log_match(match_value.eventState(), legacy);
TTCN_Logger::log_event_str(", timing := ");
if (match_value.timing().ispresent()) single_value->field_timing.log_match(match_value.timing(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_timing.log();
if (single_value->field_timing.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", speeds := ");
if (match_value.speeds().ispresent()) single_value->field_speeds.log_match(match_value.speeds(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_speeds.log();
if (single_value->field_speeds.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MovementEvent_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_eventState.encode_text(text_buf);
single_value->field_timing.encode_text(text_buf);
single_value->field_speeds.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.MovementEvent.");
}
}

void MovementEvent_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_eventState.decode_text(text_buf);
single_value->field_timing.decode_text(text_buf);
single_value->field_speeds.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MovementEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.MovementEvent.");
}
}

void MovementEvent_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.MovementEvent'");
    }
    if (strcmp("eventState", param_field) == 0) {
      eventState().set_param(param);
      return;
    } else if (strcmp("timing", param_field) == 0) {
      timing().set_param(param);
      return;
    } else if (strcmp("speeds", param_field) == 0) {
      speeds().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.MovementEvent'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MovementEvent_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @DSRC.MovementEvent has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) eventState().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) timing().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) speeds().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventState")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventState().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "timing")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          timing().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speeds")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speeds().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.MovementEvent: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.MovementEvent");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* MovementEvent_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.MovementEvent'");
    }
    if (strcmp("eventState", param_field) == 0) {
      return eventState().get_param(param_name);
    } else if (strcmp("timing", param_field) == 0) {
      return timing().get_param(param_name);
    } else if (strcmp("speeds", param_field) == 0) {
      return speeds().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.MovementEvent'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_eventState = single_value->field_eventState.get_param(param_name);
    mp_field_eventState->set_id(new Module_Param_FieldName(mcopystr("eventState")));
    mp->add_elem(mp_field_eventState);
    Module_Param* mp_field_timing = single_value->field_timing.get_param(param_name);
    mp_field_timing->set_id(new Module_Param_FieldName(mcopystr("timing")));
    mp->add_elem(mp_field_timing);
    Module_Param* mp_field_speeds = single_value->field_speeds.get_param(param_name);
    mp_field_speeds->set_id(new Module_Param_FieldName(mcopystr("speeds")));
    mp->add_elem(mp_field_speeds);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void MovementEvent_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_eventState.check_restriction(t_res, t_name ? t_name : "@DSRC.MovementEvent");
single_value->field_timing.check_restriction(t_res, t_name ? t_name : "@DSRC.MovementEvent");
single_value->field_speeds.check_restriction(t_res, t_name ? t_name : "@DSRC.MovementEvent");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.MovementEvent");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.MovementEvent");
}

boolean MovementEvent_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MovementEvent_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

TimeChangeDetails::TimeChangeDetails()
{
  bound_flag = FALSE;
}

TimeChangeDetails::TimeChangeDetails(const OPTIONAL<INTEGER>& par_startTime,
    const INTEGER& par_minEndTime,
    const OPTIONAL<INTEGER>& par_maxEndTime,
    const OPTIONAL<INTEGER>& par_likelyTime,
    const OPTIONAL<INTEGER>& par_confidence,
    const OPTIONAL<INTEGER>& par_nextTime)
  :   field_startTime(par_startTime),
  field_minEndTime(par_minEndTime),
  field_maxEndTime(par_maxEndTime),
  field_likelyTime(par_likelyTime),
  field_confidence(par_confidence),
  field_nextTime(par_nextTime)
{
  bound_flag = TRUE;
}

TimeChangeDetails::TimeChangeDetails(const TimeChangeDetails& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.TimeChangeDetails.");
bound_flag = TRUE;
if (other_value.startTime().is_bound()) field_startTime = other_value.startTime();
else field_startTime.clean_up();
if (other_value.minEndTime().is_bound()) field_minEndTime = other_value.minEndTime();
else field_minEndTime.clean_up();
if (other_value.maxEndTime().is_bound()) field_maxEndTime = other_value.maxEndTime();
else field_maxEndTime.clean_up();
if (other_value.likelyTime().is_bound()) field_likelyTime = other_value.likelyTime();
else field_likelyTime.clean_up();
if (other_value.confidence().is_bound()) field_confidence = other_value.confidence();
else field_confidence.clean_up();
if (other_value.nextTime().is_bound()) field_nextTime = other_value.nextTime();
else field_nextTime.clean_up();
}

void TimeChangeDetails::clean_up()
{
field_startTime.clean_up();
field_minEndTime.clean_up();
field_maxEndTime.clean_up();
field_likelyTime.clean_up();
field_confidence.clean_up();
field_nextTime.clean_up();
bound_flag = FALSE;
}

TimeChangeDetails& TimeChangeDetails::operator=(const TimeChangeDetails& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.TimeChangeDetails.");
  bound_flag = TRUE;
  if (other_value.startTime().is_bound()) field_startTime = other_value.startTime();
  else field_startTime.clean_up();
  if (other_value.minEndTime().is_bound()) field_minEndTime = other_value.minEndTime();
  else field_minEndTime.clean_up();
  if (other_value.maxEndTime().is_bound()) field_maxEndTime = other_value.maxEndTime();
  else field_maxEndTime.clean_up();
  if (other_value.likelyTime().is_bound()) field_likelyTime = other_value.likelyTime();
  else field_likelyTime.clean_up();
  if (other_value.confidence().is_bound()) field_confidence = other_value.confidence();
  else field_confidence.clean_up();
  if (other_value.nextTime().is_bound()) field_nextTime = other_value.nextTime();
  else field_nextTime.clean_up();
}
return *this;
}

boolean TimeChangeDetails::operator==(const TimeChangeDetails& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_startTime==other_value.field_startTime
  && field_minEndTime==other_value.field_minEndTime
  && field_maxEndTime==other_value.field_maxEndTime
  && field_likelyTime==other_value.field_likelyTime
  && field_confidence==other_value.field_confidence
  && field_nextTime==other_value.field_nextTime;
}

boolean TimeChangeDetails::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_startTime.get_selection() || field_startTime.is_bound()) return TRUE;
if(field_minEndTime.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_maxEndTime.get_selection() || field_maxEndTime.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_likelyTime.get_selection() || field_likelyTime.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_confidence.get_selection() || field_confidence.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_nextTime.get_selection() || field_nextTime.is_bound()) return TRUE;
return FALSE;
}
boolean TimeChangeDetails::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_startTime.get_selection() && !field_startTime.is_value()) return FALSE;
if(!field_minEndTime.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_maxEndTime.get_selection() && !field_maxEndTime.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_likelyTime.get_selection() && !field_likelyTime.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_confidence.get_selection() && !field_confidence.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_nextTime.get_selection() && !field_nextTime.is_value()) return FALSE;
return TRUE;
}
int TimeChangeDetails::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.TimeChangeDetails");
  int ret_val = 1;
  if (field_startTime.ispresent()) ret_val++;
  if (field_maxEndTime.ispresent()) ret_val++;
  if (field_likelyTime.ispresent()) ret_val++;
  if (field_confidence.ispresent()) ret_val++;
  if (field_nextTime.ispresent()) ret_val++;
  return ret_val;
}

void TimeChangeDetails::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ startTime := ");
field_startTime.log();
TTCN_Logger::log_event_str(", minEndTime := ");
field_minEndTime.log();
TTCN_Logger::log_event_str(", maxEndTime := ");
field_maxEndTime.log();
TTCN_Logger::log_event_str(", likelyTime := ");
field_likelyTime.log();
TTCN_Logger::log_event_str(", confidence := ");
field_confidence.log();
TTCN_Logger::log_event_str(", nextTime := ");
field_nextTime.log();
TTCN_Logger::log_event_str(" }");
}

void TimeChangeDetails::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.TimeChangeDetails'");
    }
    if (strcmp("startTime", param_field) == 0) {
      startTime().set_param(param);
      return;
    } else if (strcmp("minEndTime", param_field) == 0) {
      minEndTime().set_param(param);
      return;
    } else if (strcmp("maxEndTime", param_field) == 0) {
      maxEndTime().set_param(param);
      return;
    } else if (strcmp("likelyTime", param_field) == 0) {
      likelyTime().set_param(param);
      return;
    } else if (strcmp("confidence", param_field) == 0) {
      confidence().set_param(param);
      return;
    } else if (strcmp("nextTime", param_field) == 0) {
      nextTime().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.TimeChangeDetails'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record value of type @DSRC.TimeChangeDetails has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) startTime().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) minEndTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) maxEndTime().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) likelyTime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) confidence().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) nextTime().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "startTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          startTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "minEndTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          minEndTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maxEndTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maxEndTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "likelyTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          likelyTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "confidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          confidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.TimeChangeDetails: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.TimeChangeDetails");
  }
}

Module_Param* TimeChangeDetails::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.TimeChangeDetails'");
    }
    if (strcmp("startTime", param_field) == 0) {
      return startTime().get_param(param_name);
    } else if (strcmp("minEndTime", param_field) == 0) {
      return minEndTime().get_param(param_name);
    } else if (strcmp("maxEndTime", param_field) == 0) {
      return maxEndTime().get_param(param_name);
    } else if (strcmp("likelyTime", param_field) == 0) {
      return likelyTime().get_param(param_name);
    } else if (strcmp("confidence", param_field) == 0) {
      return confidence().get_param(param_name);
    } else if (strcmp("nextTime", param_field) == 0) {
      return nextTime().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.TimeChangeDetails'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_startTime = field_startTime.get_param(param_name);
  mp_field_startTime->set_id(new Module_Param_FieldName(mcopystr("startTime")));
  mp->add_elem(mp_field_startTime);
  Module_Param* mp_field_minEndTime = field_minEndTime.get_param(param_name);
  mp_field_minEndTime->set_id(new Module_Param_FieldName(mcopystr("minEndTime")));
  mp->add_elem(mp_field_minEndTime);
  Module_Param* mp_field_maxEndTime = field_maxEndTime.get_param(param_name);
  mp_field_maxEndTime->set_id(new Module_Param_FieldName(mcopystr("maxEndTime")));
  mp->add_elem(mp_field_maxEndTime);
  Module_Param* mp_field_likelyTime = field_likelyTime.get_param(param_name);
  mp_field_likelyTime->set_id(new Module_Param_FieldName(mcopystr("likelyTime")));
  mp->add_elem(mp_field_likelyTime);
  Module_Param* mp_field_confidence = field_confidence.get_param(param_name);
  mp_field_confidence->set_id(new Module_Param_FieldName(mcopystr("confidence")));
  mp->add_elem(mp_field_confidence);
  Module_Param* mp_field_nextTime = field_nextTime.get_param(param_name);
  mp_field_nextTime->set_id(new Module_Param_FieldName(mcopystr("nextTime")));
  mp->add_elem(mp_field_nextTime);
  return mp;
  }

void TimeChangeDetails::set_implicit_omit()
{
if (!startTime().is_bound()) startTime() = OMIT_VALUE;
else startTime().set_implicit_omit();
if (minEndTime().is_bound()) minEndTime().set_implicit_omit();
if (!maxEndTime().is_bound()) maxEndTime() = OMIT_VALUE;
else maxEndTime().set_implicit_omit();
if (!likelyTime().is_bound()) likelyTime() = OMIT_VALUE;
else likelyTime().set_implicit_omit();
if (!confidence().is_bound()) confidence() = OMIT_VALUE;
else confidence().set_implicit_omit();
if (!nextTime().is_bound()) nextTime() = OMIT_VALUE;
else nextTime().set_implicit_omit();
}

void TimeChangeDetails::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.TimeChangeDetails.");
field_startTime.encode_text(text_buf);
field_minEndTime.encode_text(text_buf);
field_maxEndTime.encode_text(text_buf);
field_likelyTime.encode_text(text_buf);
field_confidence.encode_text(text_buf);
field_nextTime.encode_text(text_buf);
}

void TimeChangeDetails::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_startTime.decode_text(text_buf);
field_minEndTime.decode_text(text_buf);
field_maxEndTime.decode_text(text_buf);
field_likelyTime.decode_text(text_buf);
field_confidence.decode_text(text_buf);
field_nextTime.decode_text(text_buf);
}

void TimeChangeDetails::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TimeChangeDetails::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* TimeChangeDetails::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("startTime': ");
  new_tlv->add_TLV(field_startTime.BER_encode_TLV(TimeChangeDetails_startTime_descr_, p_coding));
  ec_1.set_msg("minEndTime': ");
  new_tlv->add_TLV(field_minEndTime.BER_encode_TLV(TimeChangeDetails_minEndTime_descr_, p_coding));
  ec_1.set_msg("maxEndTime': ");
  new_tlv->add_TLV(field_maxEndTime.BER_encode_TLV(TimeChangeDetails_maxEndTime_descr_, p_coding));
  ec_1.set_msg("likelyTime': ");
  new_tlv->add_TLV(field_likelyTime.BER_encode_TLV(TimeChangeDetails_likelyTime_descr_, p_coding));
  ec_1.set_msg("confidence': ");
  new_tlv->add_TLV(field_confidence.BER_encode_TLV(TimeChangeDetails_confidence_descr_, p_coding));
  ec_1.set_msg("nextTime': ");
  new_tlv->add_TLV(field_nextTime.BER_encode_TLV(TimeChangeDetails_nextTime_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean TimeChangeDetails::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.TimeChangeDetails' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("startTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_startTime=OMIT_VALUE;
    else {
      field_startTime.BER_decode_TLV(TimeChangeDetails_startTime_descr_, tmp_tlv, L_form);
      if(field_startTime.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("minEndTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_minEndTime.BER_decode_TLV(TimeChangeDetails_minEndTime_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("maxEndTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_maxEndTime=OMIT_VALUE;
    else {
      field_maxEndTime.BER_decode_TLV(TimeChangeDetails_maxEndTime_descr_, tmp_tlv, L_form);
      if(field_maxEndTime.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("likelyTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_likelyTime=OMIT_VALUE;
    else {
      field_likelyTime.BER_decode_TLV(TimeChangeDetails_likelyTime_descr_, tmp_tlv, L_form);
      if(field_likelyTime.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("confidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_confidence=OMIT_VALUE;
    else {
      field_confidence.BER_decode_TLV(TimeChangeDetails_confidence_descr_, tmp_tlv, L_form);
      if(field_confidence.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("nextTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_nextTime=OMIT_VALUE;
    else {
      field_nextTime.BER_decode_TLV(TimeChangeDetails_nextTime_descr_, tmp_tlv, L_form);
      if(field_nextTime.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int TimeChangeDetails::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.TimeChangeDetails.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_startTime.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "startTime");
    enc_len += field_startTime.JSON_encode(TimeChangeDetails_startTime_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "minEndTime");
    enc_len += field_minEndTime.JSON_encode(TimeChangeDetails_minEndTime_descr_, p_tok);
  }

  if (field_maxEndTime.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "maxEndTime");
    enc_len += field_maxEndTime.JSON_encode(TimeChangeDetails_maxEndTime_descr_, p_tok);
  }

  if (field_likelyTime.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "likelyTime");
    enc_len += field_likelyTime.JSON_encode(TimeChangeDetails_likelyTime_descr_, p_tok);
  }

  if (field_confidence.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "confidence");
    enc_len += field_confidence.JSON_encode(TimeChangeDetails_confidence_descr_, p_tok);
  }

  if (field_nextTime.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nextTime");
    enc_len += field_nextTime.JSON_encode(TimeChangeDetails_nextTime_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TimeChangeDetails::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "startTime", name_len)) {
         int ret_val = field_startTime.JSON_decode(TimeChangeDetails_startTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "startTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "minEndTime", name_len)) {
         int ret_val = field_minEndTime.JSON_decode(TimeChangeDetails_minEndTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "minEndTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "maxEndTime", name_len)) {
         int ret_val = field_maxEndTime.JSON_decode(TimeChangeDetails_maxEndTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "maxEndTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "likelyTime", name_len)) {
         int ret_val = field_likelyTime.JSON_decode(TimeChangeDetails_likelyTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "likelyTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "confidence", name_len)) {
         int ret_val = field_confidence.JSON_decode(TimeChangeDetails_confidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "confidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "nextTime", name_len)) {
         int ret_val = field_nextTime.JSON_decode(TimeChangeDetails_nextTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nextTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_startTime.is_bound()) {
    field_startTime = OMIT_VALUE;
  }
if (!field_minEndTime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "minEndTime");
    return JSON_ERROR_FATAL;
  }
if (!field_maxEndTime.is_bound()) {
    field_maxEndTime = OMIT_VALUE;
  }
if (!field_likelyTime.is_bound()) {
    field_likelyTime = OMIT_VALUE;
  }
if (!field_confidence.is_bound()) {
    field_confidence = OMIT_VALUE;
  }
if (!field_nextTime.is_bound()) {
    field_nextTime = OMIT_VALUE;
  }

  return dec_len;
}

struct TimeChangeDetails_template::single_value_struct {
INTEGER_template field_startTime;
INTEGER_template field_minEndTime;
INTEGER_template field_maxEndTime;
INTEGER_template field_likelyTime;
INTEGER_template field_confidence;
INTEGER_template field_nextTime;
};

void TimeChangeDetails_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_startTime = ANY_OR_OMIT;
single_value->field_minEndTime = ANY_VALUE;
single_value->field_maxEndTime = ANY_OR_OMIT;
single_value->field_likelyTime = ANY_OR_OMIT;
single_value->field_confidence = ANY_OR_OMIT;
single_value->field_nextTime = ANY_OR_OMIT;
}
}
}

void TimeChangeDetails_template::copy_value(const TimeChangeDetails& other_value)
{
single_value = new single_value_struct;
if (other_value.startTime().is_bound()) {
  if (other_value.startTime().ispresent()) single_value->field_startTime = other_value.startTime()();
  else single_value->field_startTime = OMIT_VALUE;
} else {
  single_value->field_startTime.clean_up();
}
if (other_value.minEndTime().is_bound()) {
  single_value->field_minEndTime = other_value.minEndTime();
} else {
  single_value->field_minEndTime.clean_up();
}
if (other_value.maxEndTime().is_bound()) {
  if (other_value.maxEndTime().ispresent()) single_value->field_maxEndTime = other_value.maxEndTime()();
  else single_value->field_maxEndTime = OMIT_VALUE;
} else {
  single_value->field_maxEndTime.clean_up();
}
if (other_value.likelyTime().is_bound()) {
  if (other_value.likelyTime().ispresent()) single_value->field_likelyTime = other_value.likelyTime()();
  else single_value->field_likelyTime = OMIT_VALUE;
} else {
  single_value->field_likelyTime.clean_up();
}
if (other_value.confidence().is_bound()) {
  if (other_value.confidence().ispresent()) single_value->field_confidence = other_value.confidence()();
  else single_value->field_confidence = OMIT_VALUE;
} else {
  single_value->field_confidence.clean_up();
}
if (other_value.nextTime().is_bound()) {
  if (other_value.nextTime().ispresent()) single_value->field_nextTime = other_value.nextTime()();
  else single_value->field_nextTime = OMIT_VALUE;
} else {
  single_value->field_nextTime.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TimeChangeDetails_template::copy_template(const TimeChangeDetails_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.startTime().get_selection()) {
single_value->field_startTime = other_value.startTime();
} else {
single_value->field_startTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.minEndTime().get_selection()) {
single_value->field_minEndTime = other_value.minEndTime();
} else {
single_value->field_minEndTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.maxEndTime().get_selection()) {
single_value->field_maxEndTime = other_value.maxEndTime();
} else {
single_value->field_maxEndTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.likelyTime().get_selection()) {
single_value->field_likelyTime = other_value.likelyTime();
} else {
single_value->field_likelyTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.confidence().get_selection()) {
single_value->field_confidence = other_value.confidence();
} else {
single_value->field_confidence.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nextTime().get_selection()) {
single_value->field_nextTime = other_value.nextTime();
} else {
single_value->field_nextTime.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TimeChangeDetails_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.TimeChangeDetails.");
break;
}
set_selection(other_value);
}

TimeChangeDetails_template::TimeChangeDetails_template()
{
}

TimeChangeDetails_template::TimeChangeDetails_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TimeChangeDetails_template::TimeChangeDetails_template(const TimeChangeDetails& other_value)
{
copy_value(other_value);
}

TimeChangeDetails_template::TimeChangeDetails_template(const OPTIONAL<TimeChangeDetails>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TimeChangeDetails&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.TimeChangeDetails from an unbound optional field.");
}
}

TimeChangeDetails_template::TimeChangeDetails_template(const TimeChangeDetails_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TimeChangeDetails_template::~TimeChangeDetails_template()
{
clean_up();
}

TimeChangeDetails_template& TimeChangeDetails_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TimeChangeDetails_template& TimeChangeDetails_template::operator=(const TimeChangeDetails& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TimeChangeDetails_template& TimeChangeDetails_template::operator=(const OPTIONAL<TimeChangeDetails>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TimeChangeDetails&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.TimeChangeDetails.");
}
return *this;
}

TimeChangeDetails_template& TimeChangeDetails_template::operator=(const TimeChangeDetails_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TimeChangeDetails_template::match(const TimeChangeDetails& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.startTime().is_bound()) return FALSE;
if((other_value.startTime().ispresent() ? !single_value->field_startTime.match((const INTEGER&)other_value.startTime(), legacy) : !single_value->field_startTime.match_omit(legacy)))return FALSE;
if(!other_value.minEndTime().is_bound()) return FALSE;
if(!single_value->field_minEndTime.match(other_value.minEndTime(), legacy))return FALSE;
if(!other_value.maxEndTime().is_bound()) return FALSE;
if((other_value.maxEndTime().ispresent() ? !single_value->field_maxEndTime.match((const INTEGER&)other_value.maxEndTime(), legacy) : !single_value->field_maxEndTime.match_omit(legacy)))return FALSE;
if(!other_value.likelyTime().is_bound()) return FALSE;
if((other_value.likelyTime().ispresent() ? !single_value->field_likelyTime.match((const INTEGER&)other_value.likelyTime(), legacy) : !single_value->field_likelyTime.match_omit(legacy)))return FALSE;
if(!other_value.confidence().is_bound()) return FALSE;
if((other_value.confidence().ispresent() ? !single_value->field_confidence.match((const INTEGER&)other_value.confidence(), legacy) : !single_value->field_confidence.match_omit(legacy)))return FALSE;
if(!other_value.nextTime().is_bound()) return FALSE;
if((other_value.nextTime().ispresent() ? !single_value->field_nextTime.match((const INTEGER&)other_value.nextTime(), legacy) : !single_value->field_nextTime.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.TimeChangeDetails.");
}
return FALSE;
}

boolean TimeChangeDetails_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_startTime.is_omit() || single_value->field_startTime.is_bound()) return TRUE;
if (single_value->field_minEndTime.is_bound()) return TRUE;
if (single_value->field_maxEndTime.is_omit() || single_value->field_maxEndTime.is_bound()) return TRUE;
if (single_value->field_likelyTime.is_omit() || single_value->field_likelyTime.is_bound()) return TRUE;
if (single_value->field_confidence.is_omit() || single_value->field_confidence.is_bound()) return TRUE;
if (single_value->field_nextTime.is_omit() || single_value->field_nextTime.is_bound()) return TRUE;
return FALSE;
}

boolean TimeChangeDetails_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_startTime.is_omit() && !single_value->field_startTime.is_value()) return FALSE;
if (!single_value->field_minEndTime.is_value()) return FALSE;
if (!single_value->field_maxEndTime.is_omit() && !single_value->field_maxEndTime.is_value()) return FALSE;
if (!single_value->field_likelyTime.is_omit() && !single_value->field_likelyTime.is_value()) return FALSE;
if (!single_value->field_confidence.is_omit() && !single_value->field_confidence.is_value()) return FALSE;
if (!single_value->field_nextTime.is_omit() && !single_value->field_nextTime.is_value()) return FALSE;
return TRUE;
}

void TimeChangeDetails_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TimeChangeDetails TimeChangeDetails_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.TimeChangeDetails.");
TimeChangeDetails ret_val;
if (single_value->field_startTime.is_omit()) ret_val.startTime() = OMIT_VALUE;
else if (single_value->field_startTime.is_bound()) {
ret_val.startTime() = single_value->field_startTime.valueof();
}
if (single_value->field_minEndTime.is_bound()) {
ret_val.minEndTime() = single_value->field_minEndTime.valueof();
}
if (single_value->field_maxEndTime.is_omit()) ret_val.maxEndTime() = OMIT_VALUE;
else if (single_value->field_maxEndTime.is_bound()) {
ret_val.maxEndTime() = single_value->field_maxEndTime.valueof();
}
if (single_value->field_likelyTime.is_omit()) ret_val.likelyTime() = OMIT_VALUE;
else if (single_value->field_likelyTime.is_bound()) {
ret_val.likelyTime() = single_value->field_likelyTime.valueof();
}
if (single_value->field_confidence.is_omit()) ret_val.confidence() = OMIT_VALUE;
else if (single_value->field_confidence.is_bound()) {
ret_val.confidence() = single_value->field_confidence.valueof();
}
if (single_value->field_nextTime.is_omit()) ret_val.nextTime() = OMIT_VALUE;
else if (single_value->field_nextTime.is_bound()) {
ret_val.nextTime() = single_value->field_nextTime.valueof();
}
return ret_val;
}

void TimeChangeDetails_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.TimeChangeDetails.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TimeChangeDetails_template[list_length];
}

TimeChangeDetails_template& TimeChangeDetails_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.TimeChangeDetails.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.TimeChangeDetails.");
return value_list.list_value[list_index];
}

INTEGER_template& TimeChangeDetails_template::startTime()
{
set_specific();
return single_value->field_startTime;
}

const INTEGER_template& TimeChangeDetails_template::startTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field startTime of a non-specific template of type @DSRC.TimeChangeDetails.");
return single_value->field_startTime;
}

INTEGER_template& TimeChangeDetails_template::minEndTime()
{
set_specific();
return single_value->field_minEndTime;
}

const INTEGER_template& TimeChangeDetails_template::minEndTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field minEndTime of a non-specific template of type @DSRC.TimeChangeDetails.");
return single_value->field_minEndTime;
}

INTEGER_template& TimeChangeDetails_template::maxEndTime()
{
set_specific();
return single_value->field_maxEndTime;
}

const INTEGER_template& TimeChangeDetails_template::maxEndTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field maxEndTime of a non-specific template of type @DSRC.TimeChangeDetails.");
return single_value->field_maxEndTime;
}

INTEGER_template& TimeChangeDetails_template::likelyTime()
{
set_specific();
return single_value->field_likelyTime;
}

const INTEGER_template& TimeChangeDetails_template::likelyTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field likelyTime of a non-specific template of type @DSRC.TimeChangeDetails.");
return single_value->field_likelyTime;
}

INTEGER_template& TimeChangeDetails_template::confidence()
{
set_specific();
return single_value->field_confidence;
}

const INTEGER_template& TimeChangeDetails_template::confidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field confidence of a non-specific template of type @DSRC.TimeChangeDetails.");
return single_value->field_confidence;
}

INTEGER_template& TimeChangeDetails_template::nextTime()
{
set_specific();
return single_value->field_nextTime;
}

const INTEGER_template& TimeChangeDetails_template::nextTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nextTime of a non-specific template of type @DSRC.TimeChangeDetails.");
return single_value->field_nextTime;
}

int TimeChangeDetails_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.TimeChangeDetails which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_startTime.is_present()) ret_val++;
      if (single_value->field_maxEndTime.is_present()) ret_val++;
      if (single_value->field_likelyTime.is_present()) ret_val++;
      if (single_value->field_confidence.is_present()) ret_val++;
      if (single_value->field_nextTime.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.TimeChangeDetails containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.TimeChangeDetails containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.TimeChangeDetails containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.TimeChangeDetails containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.TimeChangeDetails containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.TimeChangeDetails.");
  }
  return 0;
}

void TimeChangeDetails_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ startTime := ");
single_value->field_startTime.log();
TTCN_Logger::log_event_str(", minEndTime := ");
single_value->field_minEndTime.log();
TTCN_Logger::log_event_str(", maxEndTime := ");
single_value->field_maxEndTime.log();
TTCN_Logger::log_event_str(", likelyTime := ");
single_value->field_likelyTime.log();
TTCN_Logger::log_event_str(", confidence := ");
single_value->field_confidence.log();
TTCN_Logger::log_event_str(", nextTime := ");
single_value->field_nextTime.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TimeChangeDetails_template::log_match(const TimeChangeDetails& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.startTime().ispresent()){
if(!single_value->field_startTime.match(match_value.startTime(), legacy)){
TTCN_Logger::log_logmatch_info(".startTime");
single_value->field_startTime.log_match(match_value.startTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_startTime.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".startTime := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_startTime.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_minEndTime.match(match_value.minEndTime(), legacy)){
TTCN_Logger::log_logmatch_info(".minEndTime");
single_value->field_minEndTime.log_match(match_value.minEndTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.maxEndTime().ispresent()){
if(!single_value->field_maxEndTime.match(match_value.maxEndTime(), legacy)){
TTCN_Logger::log_logmatch_info(".maxEndTime");
single_value->field_maxEndTime.log_match(match_value.maxEndTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_maxEndTime.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".maxEndTime := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_maxEndTime.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.likelyTime().ispresent()){
if(!single_value->field_likelyTime.match(match_value.likelyTime(), legacy)){
TTCN_Logger::log_logmatch_info(".likelyTime");
single_value->field_likelyTime.log_match(match_value.likelyTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_likelyTime.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".likelyTime := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_likelyTime.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.confidence().ispresent()){
if(!single_value->field_confidence.match(match_value.confidence(), legacy)){
TTCN_Logger::log_logmatch_info(".confidence");
single_value->field_confidence.log_match(match_value.confidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_confidence.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".confidence := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_confidence.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.nextTime().ispresent()){
if(!single_value->field_nextTime.match(match_value.nextTime(), legacy)){
TTCN_Logger::log_logmatch_info(".nextTime");
single_value->field_nextTime.log_match(match_value.nextTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_nextTime.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".nextTime := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_nextTime.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ startTime := ");
if (match_value.startTime().ispresent()) single_value->field_startTime.log_match(match_value.startTime(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_startTime.log();
if (single_value->field_startTime.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", minEndTime := ");
single_value->field_minEndTime.log_match(match_value.minEndTime(), legacy);
TTCN_Logger::log_event_str(", maxEndTime := ");
if (match_value.maxEndTime().ispresent()) single_value->field_maxEndTime.log_match(match_value.maxEndTime(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_maxEndTime.log();
if (single_value->field_maxEndTime.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", likelyTime := ");
if (match_value.likelyTime().ispresent()) single_value->field_likelyTime.log_match(match_value.likelyTime(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_likelyTime.log();
if (single_value->field_likelyTime.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", confidence := ");
if (match_value.confidence().ispresent()) single_value->field_confidence.log_match(match_value.confidence(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_confidence.log();
if (single_value->field_confidence.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", nextTime := ");
if (match_value.nextTime().ispresent()) single_value->field_nextTime.log_match(match_value.nextTime(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_nextTime.log();
if (single_value->field_nextTime.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TimeChangeDetails_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_startTime.encode_text(text_buf);
single_value->field_minEndTime.encode_text(text_buf);
single_value->field_maxEndTime.encode_text(text_buf);
single_value->field_likelyTime.encode_text(text_buf);
single_value->field_confidence.encode_text(text_buf);
single_value->field_nextTime.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.TimeChangeDetails.");
}
}

void TimeChangeDetails_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_startTime.decode_text(text_buf);
single_value->field_minEndTime.decode_text(text_buf);
single_value->field_maxEndTime.decode_text(text_buf);
single_value->field_likelyTime.decode_text(text_buf);
single_value->field_confidence.decode_text(text_buf);
single_value->field_nextTime.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TimeChangeDetails_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.TimeChangeDetails.");
}
}

void TimeChangeDetails_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.TimeChangeDetails'");
    }
    if (strcmp("startTime", param_field) == 0) {
      startTime().set_param(param);
      return;
    } else if (strcmp("minEndTime", param_field) == 0) {
      minEndTime().set_param(param);
      return;
    } else if (strcmp("maxEndTime", param_field) == 0) {
      maxEndTime().set_param(param);
      return;
    } else if (strcmp("likelyTime", param_field) == 0) {
      likelyTime().set_param(param);
      return;
    } else if (strcmp("confidence", param_field) == 0) {
      confidence().set_param(param);
      return;
    } else if (strcmp("nextTime", param_field) == 0) {
      nextTime().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.TimeChangeDetails'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TimeChangeDetails_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record template of type @DSRC.TimeChangeDetails has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) startTime().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) minEndTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) maxEndTime().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) likelyTime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) confidence().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) nextTime().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "startTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          startTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "minEndTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          minEndTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maxEndTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maxEndTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "likelyTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          likelyTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "confidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          confidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.TimeChangeDetails: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.TimeChangeDetails");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TimeChangeDetails_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.TimeChangeDetails'");
    }
    if (strcmp("startTime", param_field) == 0) {
      return startTime().get_param(param_name);
    } else if (strcmp("minEndTime", param_field) == 0) {
      return minEndTime().get_param(param_name);
    } else if (strcmp("maxEndTime", param_field) == 0) {
      return maxEndTime().get_param(param_name);
    } else if (strcmp("likelyTime", param_field) == 0) {
      return likelyTime().get_param(param_name);
    } else if (strcmp("confidence", param_field) == 0) {
      return confidence().get_param(param_name);
    } else if (strcmp("nextTime", param_field) == 0) {
      return nextTime().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.TimeChangeDetails'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_startTime = single_value->field_startTime.get_param(param_name);
    mp_field_startTime->set_id(new Module_Param_FieldName(mcopystr("startTime")));
    mp->add_elem(mp_field_startTime);
    Module_Param* mp_field_minEndTime = single_value->field_minEndTime.get_param(param_name);
    mp_field_minEndTime->set_id(new Module_Param_FieldName(mcopystr("minEndTime")));
    mp->add_elem(mp_field_minEndTime);
    Module_Param* mp_field_maxEndTime = single_value->field_maxEndTime.get_param(param_name);
    mp_field_maxEndTime->set_id(new Module_Param_FieldName(mcopystr("maxEndTime")));
    mp->add_elem(mp_field_maxEndTime);
    Module_Param* mp_field_likelyTime = single_value->field_likelyTime.get_param(param_name);
    mp_field_likelyTime->set_id(new Module_Param_FieldName(mcopystr("likelyTime")));
    mp->add_elem(mp_field_likelyTime);
    Module_Param* mp_field_confidence = single_value->field_confidence.get_param(param_name);
    mp_field_confidence->set_id(new Module_Param_FieldName(mcopystr("confidence")));
    mp->add_elem(mp_field_confidence);
    Module_Param* mp_field_nextTime = single_value->field_nextTime.get_param(param_name);
    mp_field_nextTime->set_id(new Module_Param_FieldName(mcopystr("nextTime")));
    mp->add_elem(mp_field_nextTime);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TimeChangeDetails_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_startTime.check_restriction(t_res, t_name ? t_name : "@DSRC.TimeChangeDetails");
single_value->field_minEndTime.check_restriction(t_res, t_name ? t_name : "@DSRC.TimeChangeDetails");
single_value->field_maxEndTime.check_restriction(t_res, t_name ? t_name : "@DSRC.TimeChangeDetails");
single_value->field_likelyTime.check_restriction(t_res, t_name ? t_name : "@DSRC.TimeChangeDetails");
single_value->field_confidence.check_restriction(t_res, t_name ? t_name : "@DSRC.TimeChangeDetails");
single_value->field_nextTime.check_restriction(t_res, t_name ? t_name : "@DSRC.TimeChangeDetails");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.TimeChangeDetails");
}

boolean TimeChangeDetails_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TimeChangeDetails_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const AdvisorySpeed AdvisorySpeedList::UNBOUND_ELEM;
AdvisorySpeedList::AdvisorySpeedList()
{
val_ptr = NULL;
}

AdvisorySpeedList::AdvisorySpeedList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

AdvisorySpeedList::AdvisorySpeedList(const AdvisorySpeedList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.AdvisorySpeedList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

AdvisorySpeedList::~AdvisorySpeedList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void AdvisorySpeedList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

AdvisorySpeedList& AdvisorySpeedList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

AdvisorySpeedList& AdvisorySpeedList::operator=(const AdvisorySpeedList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.AdvisorySpeedList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean AdvisorySpeedList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.AdvisorySpeedList.");
return val_ptr->n_elements == 0 ;
}

boolean AdvisorySpeedList::operator==(const AdvisorySpeedList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.AdvisorySpeedList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.AdvisorySpeedList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

AdvisorySpeed& AdvisorySpeedList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.AdvisorySpeedList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (AdvisorySpeed**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new AdvisorySpeed(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new AdvisorySpeed;
}
return *val_ptr->value_elements[index_value];
}

AdvisorySpeed& AdvisorySpeedList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.AdvisorySpeedList.");
return (*this)[(int)index_value];
}

const AdvisorySpeed& AdvisorySpeedList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.AdvisorySpeedList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.AdvisorySpeedList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.AdvisorySpeedList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const AdvisorySpeed& AdvisorySpeedList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.AdvisorySpeedList.");
return (*this)[(int)index_value];
}

AdvisorySpeedList AdvisorySpeedList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

AdvisorySpeedList AdvisorySpeedList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

AdvisorySpeedList AdvisorySpeedList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

AdvisorySpeedList AdvisorySpeedList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.AdvisorySpeedList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
AdvisorySpeedList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new AdvisorySpeed(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

AdvisorySpeedList AdvisorySpeedList::operator+(const AdvisorySpeedList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.AdvisorySpeedList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
AdvisorySpeedList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new AdvisorySpeed(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new AdvisorySpeed(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

AdvisorySpeedList AdvisorySpeedList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.AdvisorySpeedList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.AdvisorySpeedList","element");
AdvisorySpeedList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new AdvisorySpeed(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

AdvisorySpeedList AdvisorySpeedList::replace(int index, int len, const AdvisorySpeedList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.AdvisorySpeedList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.AdvisorySpeedList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.AdvisorySpeedList","element");
AdvisorySpeedList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new AdvisorySpeed(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new AdvisorySpeed(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new AdvisorySpeed(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

AdvisorySpeedList AdvisorySpeedList::replace(int index, int len, const AdvisorySpeedList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void AdvisorySpeedList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.AdvisorySpeedList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (AdvisorySpeed**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new AdvisorySpeed(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (AdvisorySpeed**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.AdvisorySpeedList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (AdvisorySpeed**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean AdvisorySpeedList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int AdvisorySpeedList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.AdvisorySpeedList.");
return val_ptr->n_elements;
}

int AdvisorySpeedList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.AdvisorySpeedList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void AdvisorySpeedList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void AdvisorySpeedList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.AdvisorySpeedList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.AdvisorySpeedList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.AdvisorySpeedList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* AdvisorySpeedList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.AdvisorySpeedList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void AdvisorySpeedList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void AdvisorySpeedList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.AdvisorySpeedList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void AdvisorySpeedList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.AdvisorySpeedList.");
val_ptr->value_elements = (AdvisorySpeed**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new AdvisorySpeed;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void AdvisorySpeedList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AdvisorySpeedList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* AdvisorySpeedList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean AdvisorySpeedList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (AdvisorySpeed**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new AdvisorySpeed;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int AdvisorySpeedList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.AdvisorySpeedList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int AdvisorySpeedList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    AdvisorySpeed* val = new AdvisorySpeed;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (AdvisorySpeed**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void AdvisorySpeedList_template::copy_value(const AdvisorySpeedList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.AdvisorySpeedList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (AdvisorySpeed_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new AdvisorySpeed_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new AdvisorySpeed_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void AdvisorySpeedList_template::copy_template(const AdvisorySpeedList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (AdvisorySpeed_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new AdvisorySpeed_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new AdvisorySpeed_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AdvisorySpeedList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.AdvisorySpeedList.");
break;
}
set_selection(other_value);
}

boolean AdvisorySpeedList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const AdvisorySpeedList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const AdvisorySpeedList*)value_ptr)[value_index], legacy);
else return ((const AdvisorySpeedList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

AdvisorySpeedList_template::AdvisorySpeedList_template()
{
}

AdvisorySpeedList_template::AdvisorySpeedList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

AdvisorySpeedList_template::AdvisorySpeedList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

AdvisorySpeedList_template::AdvisorySpeedList_template(const AdvisorySpeedList& other_value)
{
copy_value(other_value);
}

AdvisorySpeedList_template::AdvisorySpeedList_template(const OPTIONAL<AdvisorySpeedList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AdvisorySpeedList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.AdvisorySpeedList from an unbound optional field.");
}
}

AdvisorySpeedList_template::AdvisorySpeedList_template(const AdvisorySpeedList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

AdvisorySpeedList_template::~AdvisorySpeedList_template()
{
clean_up();
}

void AdvisorySpeedList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AdvisorySpeedList_template& AdvisorySpeedList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AdvisorySpeedList_template& AdvisorySpeedList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

AdvisorySpeedList_template& AdvisorySpeedList_template::operator=(const AdvisorySpeedList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AdvisorySpeedList_template& AdvisorySpeedList_template::operator=(const OPTIONAL<AdvisorySpeedList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AdvisorySpeedList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.AdvisorySpeedList.");
}
return *this;
}

AdvisorySpeedList_template& AdvisorySpeedList_template::operator=(const AdvisorySpeedList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

AdvisorySpeed_template& AdvisorySpeedList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.AdvisorySpeedList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.AdvisorySpeedList.");
    break;
}
return *single_value.value_elements[index_value];
}

AdvisorySpeed_template& AdvisorySpeedList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.AdvisorySpeedList.");
return (*this)[(int)index_value];
}

const AdvisorySpeed_template& AdvisorySpeedList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.AdvisorySpeedList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.AdvisorySpeedList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.AdvisorySpeedList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const AdvisorySpeed_template& AdvisorySpeedList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.AdvisorySpeedList.");
return (*this)[(int)index_value];
}

void AdvisorySpeedList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.AdvisorySpeedList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (AdvisorySpeed_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new AdvisorySpeed_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new AdvisorySpeed_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (AdvisorySpeed_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int AdvisorySpeedList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int AdvisorySpeedList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.AdvisorySpeedList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.AdvisorySpeedList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.AdvisorySpeedList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.AdvisorySpeedList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.AdvisorySpeedList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.AdvisorySpeedList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.AdvisorySpeedList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.AdvisorySpeedList");
}

boolean AdvisorySpeedList_template::match(const AdvisorySpeedList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.AdvisorySpeedList.");
}
return FALSE;
}

boolean AdvisorySpeedList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

AdvisorySpeedList AdvisorySpeedList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.AdvisorySpeedList.");
AdvisorySpeedList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

AdvisorySpeedList AdvisorySpeedList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

AdvisorySpeedList AdvisorySpeedList_template::replace(int index, int len, const AdvisorySpeedList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

AdvisorySpeedList AdvisorySpeedList_template::replace(int index, int len, const AdvisorySpeedList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void AdvisorySpeedList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new AdvisorySpeedList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.AdvisorySpeedList.");
}
set_selection(template_type);
}

AdvisorySpeedList_template& AdvisorySpeedList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.AdvisorySpeedList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.AdvisorySpeedList.");
return value_list.list_value[list_index];
}

void AdvisorySpeedList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void AdvisorySpeedList_template::log_match(const AdvisorySpeedList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AdvisorySpeedList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.AdvisorySpeedList.");
}
}

void AdvisorySpeedList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.AdvisorySpeedList.");
single_value.value_elements = (AdvisorySpeed_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new AdvisorySpeed_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AdvisorySpeedList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.AdvisorySpeedList.");
}
}

boolean AdvisorySpeedList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AdvisorySpeedList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AdvisorySpeedList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.AdvisorySpeedList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AdvisorySpeedList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.AdvisorySpeedList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* AdvisorySpeedList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.AdvisorySpeedList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void AdvisorySpeedList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.AdvisorySpeedList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.AdvisorySpeedList");
}

AdvisorySpeedType::AdvisorySpeedType()
{
enum_value = UNBOUND_VALUE;
}

AdvisorySpeedType::AdvisorySpeedType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @DSRC.AdvisorySpeedType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

AdvisorySpeedType::AdvisorySpeedType(enum_type other_value)
{
enum_value = other_value;
}

AdvisorySpeedType::AdvisorySpeedType(const AdvisorySpeedType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
enum_value = other_value.enum_value;
}

AdvisorySpeedType& AdvisorySpeedType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @DSRC.AdvisorySpeedType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

AdvisorySpeedType& AdvisorySpeedType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

AdvisorySpeedType& AdvisorySpeedType::operator=(const AdvisorySpeedType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
enum_value = other_value.enum_value;
return *this;
}

boolean AdvisorySpeedType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
return enum_value == other_value;
}

boolean AdvisorySpeedType::operator==(const AdvisorySpeedType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
return enum_value == other_value.enum_value;
}

boolean AdvisorySpeedType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
return enum_value < other_value;
}

boolean AdvisorySpeedType::operator<(const AdvisorySpeedType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
return enum_value < other_value.enum_value;
}

boolean AdvisorySpeedType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
return enum_value > other_value;
}

boolean AdvisorySpeedType::operator>(const AdvisorySpeedType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
return enum_value > other_value.enum_value;
}

const char *AdvisorySpeedType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case none__: return "none_";
case greenwave: return "greenwave";
case ecoDrive: return "ecoDrive";
case transit: return "transit";
default: return "<unknown>";
}
}

AdvisorySpeedType::enum_type AdvisorySpeedType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "none_")) return none__;
else if (!strcmp(str_par, "greenwave")) return greenwave;
else if (!strcmp(str_par, "ecoDrive")) return ecoDrive;
else if (!strcmp(str_par, "transit")) return transit;
else return UNKNOWN_VALUE;
}

boolean AdvisorySpeedType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int AdvisorySpeedType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.AdvisorySpeedType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int AdvisorySpeedType::enum2int(const AdvisorySpeedType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DSRC.AdvisorySpeedType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void AdvisorySpeedType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @DSRC.AdvisorySpeedType.", int_val);
enum_value = (enum_type)int_val;
}

AdvisorySpeedType::operator AdvisorySpeedType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @DSRC.AdvisorySpeedType.");
return enum_value;
}

void AdvisorySpeedType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void AdvisorySpeedType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@DSRC.AdvisorySpeedType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @DSRC.AdvisorySpeedType.");
  }
}

Module_Param* AdvisorySpeedType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void AdvisorySpeedType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
text_buf.push_int(enum_value);
}

void AdvisorySpeedType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @DSRC.AdvisorySpeedType.", enum_value);
}

void AdvisorySpeedType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AdvisorySpeedType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* AdvisorySpeedType::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean AdvisorySpeedType::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @DSRC.AdvisorySpeedType: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int AdvisorySpeedType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int AdvisorySpeedType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void AdvisorySpeedType_template::copy_template(const AdvisorySpeedType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AdvisorySpeedType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @DSRC.AdvisorySpeedType.");
}
}

AdvisorySpeedType_template::AdvisorySpeedType_template()
{
}

AdvisorySpeedType_template::AdvisorySpeedType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AdvisorySpeedType_template::AdvisorySpeedType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!AdvisorySpeedType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @DSRC.AdvisorySpeedType with unknown numeric value %d.", other_value);
single_value = (AdvisorySpeedType::enum_type)other_value;
}

AdvisorySpeedType_template::AdvisorySpeedType_template(AdvisorySpeedType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

AdvisorySpeedType_template::AdvisorySpeedType_template(const AdvisorySpeedType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == AdvisorySpeedType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @DSRC.AdvisorySpeedType.");
single_value = other_value.enum_value;
}

AdvisorySpeedType_template::AdvisorySpeedType_template(const OPTIONAL<AdvisorySpeedType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (AdvisorySpeedType::enum_type)(const AdvisorySpeedType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @DSRC.AdvisorySpeedType from an unbound optional field.");
}
}

AdvisorySpeedType_template::AdvisorySpeedType_template(const AdvisorySpeedType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

AdvisorySpeedType_template::~AdvisorySpeedType_template()
{
clean_up();
}

boolean AdvisorySpeedType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean AdvisorySpeedType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != AdvisorySpeedType::UNBOUND_VALUE;
}

void AdvisorySpeedType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

AdvisorySpeedType_template& AdvisorySpeedType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AdvisorySpeedType_template& AdvisorySpeedType_template::operator=(int other_value)
{
if (!AdvisorySpeedType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @DSRC.AdvisorySpeedType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (AdvisorySpeedType::enum_type)other_value;
return *this;
}

AdvisorySpeedType_template& AdvisorySpeedType_template::operator=(AdvisorySpeedType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

AdvisorySpeedType_template& AdvisorySpeedType_template::operator=(const AdvisorySpeedType& other_value)
{
if (other_value.enum_value == AdvisorySpeedType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DSRC.AdvisorySpeedType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

AdvisorySpeedType_template& AdvisorySpeedType_template::operator=(const OPTIONAL<AdvisorySpeedType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (AdvisorySpeedType::enum_type)(const AdvisorySpeedType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @DSRC.AdvisorySpeedType.");
}
return *this;
}

AdvisorySpeedType_template& AdvisorySpeedType_template::operator=(const AdvisorySpeedType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AdvisorySpeedType_template::match(AdvisorySpeedType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @DSRC.AdvisorySpeedType.");
}
return FALSE;
}

boolean AdvisorySpeedType_template::match(const AdvisorySpeedType& other_value, boolean) const
{
if (other_value.enum_value == AdvisorySpeedType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @DSRC.AdvisorySpeedType with an unbound value.");
return match(other_value.enum_value);
}

AdvisorySpeedType::enum_type AdvisorySpeedType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @DSRC.AdvisorySpeedType.");
return single_value;
}

void AdvisorySpeedType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @DSRC.AdvisorySpeedType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AdvisorySpeedType_template[list_length];
}

AdvisorySpeedType_template& AdvisorySpeedType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @DSRC.AdvisorySpeedType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @DSRC.AdvisorySpeedType.");
return value_list.list_value[list_index];
}

void AdvisorySpeedType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(AdvisorySpeedType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AdvisorySpeedType_template::log_match(const AdvisorySpeedType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void AdvisorySpeedType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @DSRC.AdvisorySpeedType.");
}
}

void AdvisorySpeedType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (AdvisorySpeedType::enum_type)text_buf.pull_int().get_val();
if (!AdvisorySpeedType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @DSRC.AdvisorySpeedType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AdvisorySpeedType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @DSRC.AdvisorySpeedType.");
}
}

boolean AdvisorySpeedType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AdvisorySpeedType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AdvisorySpeedType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    AdvisorySpeedType::enum_type enum_val = (enum_name != NULL) ? AdvisorySpeedType::str_to_enum(enum_name) : AdvisorySpeedType::UNKNOWN_VALUE;
    if (AdvisorySpeedType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AdvisorySpeedType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    AdvisorySpeedType::enum_type enum_val = AdvisorySpeedType::str_to_enum(mp->get_enumerated());
    if (!AdvisorySpeedType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @DSRC.AdvisorySpeedType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@DSRC.AdvisorySpeedType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AdvisorySpeedType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(AdvisorySpeedType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AdvisorySpeedType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.AdvisorySpeedType");
}

AdvisorySpeed::AdvisorySpeed()
{
  bound_flag = FALSE;
}

AdvisorySpeed::AdvisorySpeed(const AdvisorySpeedType& par_type__,
    const OPTIONAL<INTEGER>& par_speed,
    const OPTIONAL<INTEGER>& par_confidence,
    const OPTIONAL<INTEGER>& par_distance,
    const OPTIONAL<INTEGER>& par_class_,
    const OPTIONAL<REGION::Reg__AdvisorySpeed>& par_regional)
  :   field_type__(par_type__),
  field_speed(par_speed),
  field_confidence(par_confidence),
  field_distance(par_distance),
  field_class_(par_class_),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

AdvisorySpeed::AdvisorySpeed(const AdvisorySpeed& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.AdvisorySpeed.");
bound_flag = TRUE;
if (other_value.type__().is_bound()) field_type__ = other_value.type__();
else field_type__.clean_up();
if (other_value.speed().is_bound()) field_speed = other_value.speed();
else field_speed.clean_up();
if (other_value.confidence().is_bound()) field_confidence = other_value.confidence();
else field_confidence.clean_up();
if (other_value.distance().is_bound()) field_distance = other_value.distance();
else field_distance.clean_up();
if (other_value.class_().is_bound()) field_class_ = other_value.class_();
else field_class_.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void AdvisorySpeed::clean_up()
{
field_type__.clean_up();
field_speed.clean_up();
field_confidence.clean_up();
field_distance.clean_up();
field_class_.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

AdvisorySpeed& AdvisorySpeed::operator=(const AdvisorySpeed& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.AdvisorySpeed.");
  bound_flag = TRUE;
  if (other_value.type__().is_bound()) field_type__ = other_value.type__();
  else field_type__.clean_up();
  if (other_value.speed().is_bound()) field_speed = other_value.speed();
  else field_speed.clean_up();
  if (other_value.confidence().is_bound()) field_confidence = other_value.confidence();
  else field_confidence.clean_up();
  if (other_value.distance().is_bound()) field_distance = other_value.distance();
  else field_distance.clean_up();
  if (other_value.class_().is_bound()) field_class_ = other_value.class_();
  else field_class_.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean AdvisorySpeed::operator==(const AdvisorySpeed& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_type__==other_value.field_type__
  && field_speed==other_value.field_speed
  && field_confidence==other_value.field_confidence
  && field_distance==other_value.field_distance
  && field_class_==other_value.field_class_
  && field_regional==other_value.field_regional;
}

boolean AdvisorySpeed::is_bound() const
{
if (bound_flag) return TRUE;
if(field_type__.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_speed.get_selection() || field_speed.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_confidence.get_selection() || field_confidence.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_distance.get_selection() || field_distance.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_class_.get_selection() || field_class_.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean AdvisorySpeed::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_type__.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_speed.get_selection() && !field_speed.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_confidence.get_selection() && !field_confidence.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_distance.get_selection() && !field_distance.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_class_.get_selection() && !field_class_.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int AdvisorySpeed::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.AdvisorySpeed");
  int ret_val = 1;
  if (field_speed.ispresent()) ret_val++;
  if (field_confidence.ispresent()) ret_val++;
  if (field_distance.ispresent()) ret_val++;
  if (field_class_.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void AdvisorySpeed::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ type_ := ");
field_type__.log();
TTCN_Logger::log_event_str(", speed := ");
field_speed.log();
TTCN_Logger::log_event_str(", confidence := ");
field_confidence.log();
TTCN_Logger::log_event_str(", distance := ");
field_distance.log();
TTCN_Logger::log_event_str(", class := ");
field_class_.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void AdvisorySpeed::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.AdvisorySpeed'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("speed", param_field) == 0) {
      speed().set_param(param);
      return;
    } else if (strcmp("confidence", param_field) == 0) {
      confidence().set_param(param);
      return;
    } else if (strcmp("distance", param_field) == 0) {
      distance().set_param(param);
      return;
    } else if (strcmp("class", param_field) == 0) {
      class_().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.AdvisorySpeed'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record value of type @DSRC.AdvisorySpeed has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) speed().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) confidence().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) distance().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) class_().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "confidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          confidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distance")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distance().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "class")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          class_().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.AdvisorySpeed: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.AdvisorySpeed");
  }
}

Module_Param* AdvisorySpeed::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.AdvisorySpeed'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("speed", param_field) == 0) {
      return speed().get_param(param_name);
    } else if (strcmp("confidence", param_field) == 0) {
      return confidence().get_param(param_name);
    } else if (strcmp("distance", param_field) == 0) {
      return distance().get_param(param_name);
    } else if (strcmp("class", param_field) == 0) {
      return class_().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.AdvisorySpeed'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_type__ = field_type__.get_param(param_name);
  mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
  mp->add_elem(mp_field_type__);
  Module_Param* mp_field_speed = field_speed.get_param(param_name);
  mp_field_speed->set_id(new Module_Param_FieldName(mcopystr("speed")));
  mp->add_elem(mp_field_speed);
  Module_Param* mp_field_confidence = field_confidence.get_param(param_name);
  mp_field_confidence->set_id(new Module_Param_FieldName(mcopystr("confidence")));
  mp->add_elem(mp_field_confidence);
  Module_Param* mp_field_distance = field_distance.get_param(param_name);
  mp_field_distance->set_id(new Module_Param_FieldName(mcopystr("distance")));
  mp->add_elem(mp_field_distance);
  Module_Param* mp_field_class_ = field_class_.get_param(param_name);
  mp_field_class_->set_id(new Module_Param_FieldName(mcopystr("class")));
  mp->add_elem(mp_field_class_);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void AdvisorySpeed::set_implicit_omit()
{
if (type__().is_bound()) type__().set_implicit_omit();
if (!speed().is_bound()) speed() = OMIT_VALUE;
else speed().set_implicit_omit();
if (!confidence().is_bound()) confidence() = OMIT_VALUE;
else confidence().set_implicit_omit();
if (!distance().is_bound()) distance() = OMIT_VALUE;
else distance().set_implicit_omit();
if (!class_().is_bound()) class_() = OMIT_VALUE;
else class_().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void AdvisorySpeed::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.AdvisorySpeed.");
field_type__.encode_text(text_buf);
field_speed.encode_text(text_buf);
field_confidence.encode_text(text_buf);
field_distance.encode_text(text_buf);
field_class_.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void AdvisorySpeed::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_type__.decode_text(text_buf);
field_speed.decode_text(text_buf);
field_confidence.decode_text(text_buf);
field_distance.decode_text(text_buf);
field_class_.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void AdvisorySpeed::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AdvisorySpeed::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* AdvisorySpeed::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("type_': ");
  new_tlv->add_TLV(field_type__.BER_encode_TLV(AdvisorySpeed_type___descr_, p_coding));
  ec_1.set_msg("speed': ");
  new_tlv->add_TLV(field_speed.BER_encode_TLV(AdvisorySpeed_speed_descr_, p_coding));
  ec_1.set_msg("confidence': ");
  new_tlv->add_TLV(field_confidence.BER_encode_TLV(AdvisorySpeed_confidence_descr_, p_coding));
  ec_1.set_msg("distance': ");
  new_tlv->add_TLV(field_distance.BER_encode_TLV(AdvisorySpeed_distance_descr_, p_coding));
  ec_1.set_msg("class': ");
  new_tlv->add_TLV(field_class_.BER_encode_TLV(AdvisorySpeed_class__descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(AdvisorySpeed_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean AdvisorySpeed::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.AdvisorySpeed' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("type_': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_type__.BER_decode_TLV(AdvisorySpeed_type___descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("speed': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_speed=OMIT_VALUE;
    else {
      field_speed.BER_decode_TLV(AdvisorySpeed_speed_descr_, tmp_tlv, L_form);
      if(field_speed.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("confidence': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_confidence=OMIT_VALUE;
    else {
      field_confidence.BER_decode_TLV(AdvisorySpeed_confidence_descr_, tmp_tlv, L_form);
      if(field_confidence.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("distance': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_distance=OMIT_VALUE;
    else {
      field_distance.BER_decode_TLV(AdvisorySpeed_distance_descr_, tmp_tlv, L_form);
      if(field_distance.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("class': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_class_=OMIT_VALUE;
    else {
      field_class_.BER_decode_TLV(AdvisorySpeed_class__descr_, tmp_tlv, L_form);
      if(field_class_.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(AdvisorySpeed_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int AdvisorySpeed::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.AdvisorySpeed.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "type_");
    enc_len += field_type__.JSON_encode(AdvisorySpeed_type___descr_, p_tok);
  }

  if (field_speed.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speed");
    enc_len += field_speed.JSON_encode(AdvisorySpeed_speed_descr_, p_tok);
  }

  if (field_confidence.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "confidence");
    enc_len += field_confidence.JSON_encode(AdvisorySpeed_confidence_descr_, p_tok);
  }

  if (field_distance.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "distance");
    enc_len += field_distance.JSON_encode(AdvisorySpeed_distance_descr_, p_tok);
  }

  if (field_class_.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "class");
    enc_len += field_class_.JSON_encode(AdvisorySpeed_class__descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(AdvisorySpeed_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AdvisorySpeed::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "type_", name_len)) {
         int ret_val = field_type__.JSON_decode(AdvisorySpeed_type___descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "type_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "speed", name_len)) {
         int ret_val = field_speed.JSON_decode(AdvisorySpeed_speed_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speed");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "confidence", name_len)) {
         int ret_val = field_confidence.JSON_decode(AdvisorySpeed_confidence_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "confidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "distance", name_len)) {
         int ret_val = field_distance.JSON_decode(AdvisorySpeed_distance_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "distance");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "class", name_len)) {
         int ret_val = field_class_.JSON_decode(AdvisorySpeed_class__descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "class");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(AdvisorySpeed_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_type__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "type_");
    return JSON_ERROR_FATAL;
  }
if (!field_speed.is_bound()) {
    field_speed = OMIT_VALUE;
  }
if (!field_confidence.is_bound()) {
    field_confidence = OMIT_VALUE;
  }
if (!field_distance.is_bound()) {
    field_distance = OMIT_VALUE;
  }
if (!field_class_.is_bound()) {
    field_class_ = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct AdvisorySpeed_template::single_value_struct {
AdvisorySpeedType_template field_type__;
INTEGER_template field_speed;
INTEGER_template field_confidence;
INTEGER_template field_distance;
INTEGER_template field_class_;
REGION::Reg__AdvisorySpeed_template field_regional;
};

void AdvisorySpeed_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_type__ = ANY_VALUE;
single_value->field_speed = ANY_OR_OMIT;
single_value->field_confidence = ANY_OR_OMIT;
single_value->field_distance = ANY_OR_OMIT;
single_value->field_class_ = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void AdvisorySpeed_template::copy_value(const AdvisorySpeed& other_value)
{
single_value = new single_value_struct;
if (other_value.type__().is_bound()) {
  single_value->field_type__ = other_value.type__();
} else {
  single_value->field_type__.clean_up();
}
if (other_value.speed().is_bound()) {
  if (other_value.speed().ispresent()) single_value->field_speed = other_value.speed()();
  else single_value->field_speed = OMIT_VALUE;
} else {
  single_value->field_speed.clean_up();
}
if (other_value.confidence().is_bound()) {
  if (other_value.confidence().ispresent()) single_value->field_confidence = other_value.confidence()();
  else single_value->field_confidence = OMIT_VALUE;
} else {
  single_value->field_confidence.clean_up();
}
if (other_value.distance().is_bound()) {
  if (other_value.distance().ispresent()) single_value->field_distance = other_value.distance()();
  else single_value->field_distance = OMIT_VALUE;
} else {
  single_value->field_distance.clean_up();
}
if (other_value.class_().is_bound()) {
  if (other_value.class_().ispresent()) single_value->field_class_ = other_value.class_()();
  else single_value->field_class_ = OMIT_VALUE;
} else {
  single_value->field_class_.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AdvisorySpeed_template::copy_template(const AdvisorySpeed_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.type__().get_selection()) {
single_value->field_type__ = other_value.type__();
} else {
single_value->field_type__.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speed().get_selection()) {
single_value->field_speed = other_value.speed();
} else {
single_value->field_speed.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.confidence().get_selection()) {
single_value->field_confidence = other_value.confidence();
} else {
single_value->field_confidence.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.distance().get_selection()) {
single_value->field_distance = other_value.distance();
} else {
single_value->field_distance.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.class_().get_selection()) {
single_value->field_class_ = other_value.class_();
} else {
single_value->field_class_.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AdvisorySpeed_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.AdvisorySpeed.");
break;
}
set_selection(other_value);
}

AdvisorySpeed_template::AdvisorySpeed_template()
{
}

AdvisorySpeed_template::AdvisorySpeed_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AdvisorySpeed_template::AdvisorySpeed_template(const AdvisorySpeed& other_value)
{
copy_value(other_value);
}

AdvisorySpeed_template::AdvisorySpeed_template(const OPTIONAL<AdvisorySpeed>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AdvisorySpeed&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.AdvisorySpeed from an unbound optional field.");
}
}

AdvisorySpeed_template::AdvisorySpeed_template(const AdvisorySpeed_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AdvisorySpeed_template::~AdvisorySpeed_template()
{
clean_up();
}

AdvisorySpeed_template& AdvisorySpeed_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AdvisorySpeed_template& AdvisorySpeed_template::operator=(const AdvisorySpeed& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AdvisorySpeed_template& AdvisorySpeed_template::operator=(const OPTIONAL<AdvisorySpeed>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AdvisorySpeed&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.AdvisorySpeed.");
}
return *this;
}

AdvisorySpeed_template& AdvisorySpeed_template::operator=(const AdvisorySpeed_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AdvisorySpeed_template::match(const AdvisorySpeed& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.type__().is_bound()) return FALSE;
if(!single_value->field_type__.match(other_value.type__(), legacy))return FALSE;
if(!other_value.speed().is_bound()) return FALSE;
if((other_value.speed().ispresent() ? !single_value->field_speed.match((const INTEGER&)other_value.speed(), legacy) : !single_value->field_speed.match_omit(legacy)))return FALSE;
if(!other_value.confidence().is_bound()) return FALSE;
if((other_value.confidence().ispresent() ? !single_value->field_confidence.match((const INTEGER&)other_value.confidence(), legacy) : !single_value->field_confidence.match_omit(legacy)))return FALSE;
if(!other_value.distance().is_bound()) return FALSE;
if((other_value.distance().ispresent() ? !single_value->field_distance.match((const INTEGER&)other_value.distance(), legacy) : !single_value->field_distance.match_omit(legacy)))return FALSE;
if(!other_value.class_().is_bound()) return FALSE;
if((other_value.class_().ispresent() ? !single_value->field_class_.match((const INTEGER&)other_value.class_(), legacy) : !single_value->field_class_.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REGION::Reg__AdvisorySpeed&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.AdvisorySpeed.");
}
return FALSE;
}

boolean AdvisorySpeed_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_type__.is_bound()) return TRUE;
if (single_value->field_speed.is_omit() || single_value->field_speed.is_bound()) return TRUE;
if (single_value->field_confidence.is_omit() || single_value->field_confidence.is_bound()) return TRUE;
if (single_value->field_distance.is_omit() || single_value->field_distance.is_bound()) return TRUE;
if (single_value->field_class_.is_omit() || single_value->field_class_.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean AdvisorySpeed_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_type__.is_value()) return FALSE;
if (!single_value->field_speed.is_omit() && !single_value->field_speed.is_value()) return FALSE;
if (!single_value->field_confidence.is_omit() && !single_value->field_confidence.is_value()) return FALSE;
if (!single_value->field_distance.is_omit() && !single_value->field_distance.is_value()) return FALSE;
if (!single_value->field_class_.is_omit() && !single_value->field_class_.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void AdvisorySpeed_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AdvisorySpeed AdvisorySpeed_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.AdvisorySpeed.");
AdvisorySpeed ret_val;
if (single_value->field_type__.is_bound()) {
ret_val.type__() = single_value->field_type__.valueof();
}
if (single_value->field_speed.is_omit()) ret_val.speed() = OMIT_VALUE;
else if (single_value->field_speed.is_bound()) {
ret_val.speed() = single_value->field_speed.valueof();
}
if (single_value->field_confidence.is_omit()) ret_val.confidence() = OMIT_VALUE;
else if (single_value->field_confidence.is_bound()) {
ret_val.confidence() = single_value->field_confidence.valueof();
}
if (single_value->field_distance.is_omit()) ret_val.distance() = OMIT_VALUE;
else if (single_value->field_distance.is_bound()) {
ret_val.distance() = single_value->field_distance.valueof();
}
if (single_value->field_class_.is_omit()) ret_val.class_() = OMIT_VALUE;
else if (single_value->field_class_.is_bound()) {
ret_val.class_() = single_value->field_class_.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void AdvisorySpeed_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.AdvisorySpeed.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AdvisorySpeed_template[list_length];
}

AdvisorySpeed_template& AdvisorySpeed_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.AdvisorySpeed.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.AdvisorySpeed.");
return value_list.list_value[list_index];
}

AdvisorySpeedType_template& AdvisorySpeed_template::type__()
{
set_specific();
return single_value->field_type__;
}

const AdvisorySpeedType_template& AdvisorySpeed_template::type__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field type_ of a non-specific template of type @DSRC.AdvisorySpeed.");
return single_value->field_type__;
}

INTEGER_template& AdvisorySpeed_template::speed()
{
set_specific();
return single_value->field_speed;
}

const INTEGER_template& AdvisorySpeed_template::speed() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speed of a non-specific template of type @DSRC.AdvisorySpeed.");
return single_value->field_speed;
}

INTEGER_template& AdvisorySpeed_template::confidence()
{
set_specific();
return single_value->field_confidence;
}

const INTEGER_template& AdvisorySpeed_template::confidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field confidence of a non-specific template of type @DSRC.AdvisorySpeed.");
return single_value->field_confidence;
}

INTEGER_template& AdvisorySpeed_template::distance()
{
set_specific();
return single_value->field_distance;
}

const INTEGER_template& AdvisorySpeed_template::distance() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field distance of a non-specific template of type @DSRC.AdvisorySpeed.");
return single_value->field_distance;
}

INTEGER_template& AdvisorySpeed_template::class_()
{
set_specific();
return single_value->field_class_;
}

const INTEGER_template& AdvisorySpeed_template::class_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field class of a non-specific template of type @DSRC.AdvisorySpeed.");
return single_value->field_class_;
}

REGION::Reg__AdvisorySpeed_template& AdvisorySpeed_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REGION::Reg__AdvisorySpeed_template& AdvisorySpeed_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.AdvisorySpeed.");
return single_value->field_regional;
}

int AdvisorySpeed_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.AdvisorySpeed which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_speed.is_present()) ret_val++;
      if (single_value->field_confidence.is_present()) ret_val++;
      if (single_value->field_distance.is_present()) ret_val++;
      if (single_value->field_class_.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.AdvisorySpeed containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.AdvisorySpeed containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.AdvisorySpeed containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.AdvisorySpeed containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.AdvisorySpeed containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.AdvisorySpeed.");
  }
  return 0;
}

void AdvisorySpeed_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log();
TTCN_Logger::log_event_str(", speed := ");
single_value->field_speed.log();
TTCN_Logger::log_event_str(", confidence := ");
single_value->field_confidence.log();
TTCN_Logger::log_event_str(", distance := ");
single_value->field_distance.log();
TTCN_Logger::log_event_str(", class := ");
single_value->field_class_.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AdvisorySpeed_template::log_match(const AdvisorySpeed& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_type__.match(match_value.type__(), legacy)){
TTCN_Logger::log_logmatch_info(".type_");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.speed().ispresent()){
if(!single_value->field_speed.match(match_value.speed(), legacy)){
TTCN_Logger::log_logmatch_info(".speed");
single_value->field_speed.log_match(match_value.speed(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_speed.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".speed := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_speed.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.confidence().ispresent()){
if(!single_value->field_confidence.match(match_value.confidence(), legacy)){
TTCN_Logger::log_logmatch_info(".confidence");
single_value->field_confidence.log_match(match_value.confidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_confidence.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".confidence := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_confidence.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.distance().ispresent()){
if(!single_value->field_distance.match(match_value.distance(), legacy)){
TTCN_Logger::log_logmatch_info(".distance");
single_value->field_distance.log_match(match_value.distance(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_distance.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".distance := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_distance.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.class_().ispresent()){
if(!single_value->field_class_.match(match_value.class_(), legacy)){
TTCN_Logger::log_logmatch_info(".class");
single_value->field_class_.log_match(match_value.class_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_class_.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".class := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_class_.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::log_event_str(", speed := ");
if (match_value.speed().ispresent()) single_value->field_speed.log_match(match_value.speed(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_speed.log();
if (single_value->field_speed.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", confidence := ");
if (match_value.confidence().ispresent()) single_value->field_confidence.log_match(match_value.confidence(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_confidence.log();
if (single_value->field_confidence.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", distance := ");
if (match_value.distance().ispresent()) single_value->field_distance.log_match(match_value.distance(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_distance.log();
if (single_value->field_distance.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", class := ");
if (match_value.class_().ispresent()) single_value->field_class_.log_match(match_value.class_(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_class_.log();
if (single_value->field_class_.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AdvisorySpeed_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_type__.encode_text(text_buf);
single_value->field_speed.encode_text(text_buf);
single_value->field_confidence.encode_text(text_buf);
single_value->field_distance.encode_text(text_buf);
single_value->field_class_.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.AdvisorySpeed.");
}
}

void AdvisorySpeed_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_type__.decode_text(text_buf);
single_value->field_speed.decode_text(text_buf);
single_value->field_confidence.decode_text(text_buf);
single_value->field_distance.decode_text(text_buf);
single_value->field_class_.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AdvisorySpeed_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.AdvisorySpeed.");
}
}

void AdvisorySpeed_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.AdvisorySpeed'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("speed", param_field) == 0) {
      speed().set_param(param);
      return;
    } else if (strcmp("confidence", param_field) == 0) {
      confidence().set_param(param);
      return;
    } else if (strcmp("distance", param_field) == 0) {
      distance().set_param(param);
      return;
    } else if (strcmp("class", param_field) == 0) {
      class_().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.AdvisorySpeed'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AdvisorySpeed_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record template of type @DSRC.AdvisorySpeed has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) speed().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) confidence().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) distance().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) class_().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "confidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          confidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distance")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distance().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "class")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          class_().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.AdvisorySpeed: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.AdvisorySpeed");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AdvisorySpeed_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.AdvisorySpeed'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("speed", param_field) == 0) {
      return speed().get_param(param_name);
    } else if (strcmp("confidence", param_field) == 0) {
      return confidence().get_param(param_name);
    } else if (strcmp("distance", param_field) == 0) {
      return distance().get_param(param_name);
    } else if (strcmp("class", param_field) == 0) {
      return class_().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.AdvisorySpeed'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_type__ = single_value->field_type__.get_param(param_name);
    mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
    mp->add_elem(mp_field_type__);
    Module_Param* mp_field_speed = single_value->field_speed.get_param(param_name);
    mp_field_speed->set_id(new Module_Param_FieldName(mcopystr("speed")));
    mp->add_elem(mp_field_speed);
    Module_Param* mp_field_confidence = single_value->field_confidence.get_param(param_name);
    mp_field_confidence->set_id(new Module_Param_FieldName(mcopystr("confidence")));
    mp->add_elem(mp_field_confidence);
    Module_Param* mp_field_distance = single_value->field_distance.get_param(param_name);
    mp_field_distance->set_id(new Module_Param_FieldName(mcopystr("distance")));
    mp->add_elem(mp_field_distance);
    Module_Param* mp_field_class_ = single_value->field_class_.get_param(param_name);
    mp_field_class_->set_id(new Module_Param_FieldName(mcopystr("class")));
    mp->add_elem(mp_field_class_);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AdvisorySpeed_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_type__.check_restriction(t_res, t_name ? t_name : "@DSRC.AdvisorySpeed");
single_value->field_speed.check_restriction(t_res, t_name ? t_name : "@DSRC.AdvisorySpeed");
single_value->field_confidence.check_restriction(t_res, t_name ? t_name : "@DSRC.AdvisorySpeed");
single_value->field_distance.check_restriction(t_res, t_name ? t_name : "@DSRC.AdvisorySpeed");
single_value->field_class_.check_restriction(t_res, t_name ? t_name : "@DSRC.AdvisorySpeed");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.AdvisorySpeed");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.AdvisorySpeed");
}

boolean AdvisorySpeed_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AdvisorySpeed_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MovementState::MovementState()
{
  bound_flag = FALSE;
}

MovementState::MovementState(const OPTIONAL<CHARSTRING>& par_movementName,
    const INTEGER& par_signalGroup,
    const MovementEventList& par_state__time__speed,
    const OPTIONAL<ManeuverAssistList>& par_maneuverAssistList,
    const OPTIONAL<REGION::Reg__MovementState>& par_regional)
  :   field_movementName(par_movementName),
  field_signalGroup(par_signalGroup),
  field_state__time__speed(par_state__time__speed),
  field_maneuverAssistList(par_maneuverAssistList),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

MovementState::MovementState(const MovementState& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.MovementState.");
bound_flag = TRUE;
if (other_value.movementName().is_bound()) field_movementName = other_value.movementName();
else field_movementName.clean_up();
if (other_value.signalGroup().is_bound()) field_signalGroup = other_value.signalGroup();
else field_signalGroup.clean_up();
if (other_value.state__time__speed().is_bound()) field_state__time__speed = other_value.state__time__speed();
else field_state__time__speed.clean_up();
if (other_value.maneuverAssistList().is_bound()) field_maneuverAssistList = other_value.maneuverAssistList();
else field_maneuverAssistList.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void MovementState::clean_up()
{
field_movementName.clean_up();
field_signalGroup.clean_up();
field_state__time__speed.clean_up();
field_maneuverAssistList.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

MovementState& MovementState::operator=(const MovementState& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.MovementState.");
  bound_flag = TRUE;
  if (other_value.movementName().is_bound()) field_movementName = other_value.movementName();
  else field_movementName.clean_up();
  if (other_value.signalGroup().is_bound()) field_signalGroup = other_value.signalGroup();
  else field_signalGroup.clean_up();
  if (other_value.state__time__speed().is_bound()) field_state__time__speed = other_value.state__time__speed();
  else field_state__time__speed.clean_up();
  if (other_value.maneuverAssistList().is_bound()) field_maneuverAssistList = other_value.maneuverAssistList();
  else field_maneuverAssistList.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean MovementState::operator==(const MovementState& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_movementName==other_value.field_movementName
  && field_signalGroup==other_value.field_signalGroup
  && field_state__time__speed==other_value.field_state__time__speed
  && field_maneuverAssistList==other_value.field_maneuverAssistList
  && field_regional==other_value.field_regional;
}

boolean MovementState::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_movementName.get_selection() || field_movementName.is_bound()) return TRUE;
if(field_signalGroup.is_bound()) return TRUE;
if(field_state__time__speed.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_maneuverAssistList.get_selection() || field_maneuverAssistList.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean MovementState::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_movementName.get_selection() && !field_movementName.is_value()) return FALSE;
if(!field_signalGroup.is_value()) return FALSE;
if(!field_state__time__speed.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_maneuverAssistList.get_selection() && !field_maneuverAssistList.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int MovementState::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.MovementState");
  int ret_val = 2;
  if (field_movementName.ispresent()) ret_val++;
  if (field_maneuverAssistList.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void MovementState::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ movementName := ");
field_movementName.log();
TTCN_Logger::log_event_str(", signalGroup := ");
field_signalGroup.log();
TTCN_Logger::log_event_str(", state_time_speed := ");
field_state__time__speed.log();
TTCN_Logger::log_event_str(", maneuverAssistList := ");
field_maneuverAssistList.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void MovementState::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.MovementState'");
    }
    if (strcmp("movementName", param_field) == 0) {
      movementName().set_param(param);
      return;
    } else if (strcmp("signalGroup", param_field) == 0) {
      signalGroup().set_param(param);
      return;
    } else if (strcmp("state_time_speed", param_field) == 0) {
      state__time__speed().set_param(param);
      return;
    } else if (strcmp("maneuverAssistList", param_field) == 0) {
      maneuverAssistList().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.MovementState'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record value of type @DSRC.MovementState has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) movementName().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signalGroup().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) state__time__speed().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) maneuverAssistList().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "movementName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          movementName().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signalGroup")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signalGroup().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "state_time_speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          state__time__speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maneuverAssistList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maneuverAssistList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.MovementState: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.MovementState");
  }
}

Module_Param* MovementState::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.MovementState'");
    }
    if (strcmp("movementName", param_field) == 0) {
      return movementName().get_param(param_name);
    } else if (strcmp("signalGroup", param_field) == 0) {
      return signalGroup().get_param(param_name);
    } else if (strcmp("state_time_speed", param_field) == 0) {
      return state__time__speed().get_param(param_name);
    } else if (strcmp("maneuverAssistList", param_field) == 0) {
      return maneuverAssistList().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.MovementState'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_movementName = field_movementName.get_param(param_name);
  mp_field_movementName->set_id(new Module_Param_FieldName(mcopystr("movementName")));
  mp->add_elem(mp_field_movementName);
  Module_Param* mp_field_signalGroup = field_signalGroup.get_param(param_name);
  mp_field_signalGroup->set_id(new Module_Param_FieldName(mcopystr("signalGroup")));
  mp->add_elem(mp_field_signalGroup);
  Module_Param* mp_field_state__time__speed = field_state__time__speed.get_param(param_name);
  mp_field_state__time__speed->set_id(new Module_Param_FieldName(mcopystr("state_time_speed")));
  mp->add_elem(mp_field_state__time__speed);
  Module_Param* mp_field_maneuverAssistList = field_maneuverAssistList.get_param(param_name);
  mp_field_maneuverAssistList->set_id(new Module_Param_FieldName(mcopystr("maneuverAssistList")));
  mp->add_elem(mp_field_maneuverAssistList);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void MovementState::set_implicit_omit()
{
if (!movementName().is_bound()) movementName() = OMIT_VALUE;
else movementName().set_implicit_omit();
if (signalGroup().is_bound()) signalGroup().set_implicit_omit();
if (state__time__speed().is_bound()) state__time__speed().set_implicit_omit();
if (!maneuverAssistList().is_bound()) maneuverAssistList() = OMIT_VALUE;
else maneuverAssistList().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void MovementState::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.MovementState.");
field_movementName.encode_text(text_buf);
field_signalGroup.encode_text(text_buf);
field_state__time__speed.encode_text(text_buf);
field_maneuverAssistList.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void MovementState::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_movementName.decode_text(text_buf);
field_signalGroup.decode_text(text_buf);
field_state__time__speed.decode_text(text_buf);
field_maneuverAssistList.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void MovementState::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void MovementState::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* MovementState::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("movementName': ");
  new_tlv->add_TLV(field_movementName.BER_encode_TLV(MovementState_movementName_descr_, p_coding));
  ec_1.set_msg("signalGroup': ");
  new_tlv->add_TLV(field_signalGroup.BER_encode_TLV(MovementState_signalGroup_descr_, p_coding));
  ec_1.set_msg("state_time_speed': ");
  new_tlv->add_TLV(field_state__time__speed.BER_encode_TLV(MovementState_state__time__speed_descr_, p_coding));
  ec_1.set_msg("maneuverAssistList': ");
  new_tlv->add_TLV(field_maneuverAssistList.BER_encode_TLV(MovementState_maneuverAssistList_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(MovementState_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean MovementState::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.MovementState' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("movementName': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_movementName=OMIT_VALUE;
    else {
      field_movementName.BER_decode_TLV(MovementState_movementName_descr_, tmp_tlv, L_form);
      if(field_movementName.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("signalGroup': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_signalGroup.BER_decode_TLV(MovementState_signalGroup_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("state_time_speed': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_state__time__speed.BER_decode_TLV(MovementState_state__time__speed_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("maneuverAssistList': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_maneuverAssistList=OMIT_VALUE;
    else {
      field_maneuverAssistList.BER_decode_TLV(MovementState_maneuverAssistList_descr_, tmp_tlv, L_form);
      if(field_maneuverAssistList.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(MovementState_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int MovementState::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.MovementState.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_movementName.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "movementName");
    enc_len += field_movementName.JSON_encode(MovementState_movementName_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signalGroup");
    enc_len += field_signalGroup.JSON_encode(MovementState_signalGroup_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "state_time_speed");
    enc_len += field_state__time__speed.JSON_encode(MovementState_state__time__speed_descr_, p_tok);
  }

  if (field_maneuverAssistList.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "maneuverAssistList");
    enc_len += field_maneuverAssistList.JSON_encode(MovementState_maneuverAssistList_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(MovementState_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int MovementState::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "movementName", name_len)) {
         int ret_val = field_movementName.JSON_decode(MovementState_movementName_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "movementName");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "signalGroup", name_len)) {
         int ret_val = field_signalGroup.JSON_decode(MovementState_signalGroup_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signalGroup");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "state_time_speed", name_len)) {
         int ret_val = field_state__time__speed.JSON_decode(MovementState_state__time__speed_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "state_time_speed");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "maneuverAssistList", name_len)) {
         int ret_val = field_maneuverAssistList.JSON_decode(MovementState_maneuverAssistList_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "maneuverAssistList");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(MovementState_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_movementName.is_bound()) {
    field_movementName = OMIT_VALUE;
  }
if (!field_signalGroup.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "signalGroup");
    return JSON_ERROR_FATAL;
  }
if (!field_state__time__speed.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "state_time_speed");
    return JSON_ERROR_FATAL;
  }
if (!field_maneuverAssistList.is_bound()) {
    field_maneuverAssistList = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct MovementState_template::single_value_struct {
CHARSTRING_template field_movementName;
INTEGER_template field_signalGroup;
MovementEventList_template field_state__time__speed;
ManeuverAssistList_template field_maneuverAssistList;
REGION::Reg__MovementState_template field_regional;
};

void MovementState_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_movementName = ANY_OR_OMIT;
single_value->field_signalGroup = ANY_VALUE;
single_value->field_state__time__speed = ANY_VALUE;
single_value->field_maneuverAssistList = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void MovementState_template::copy_value(const MovementState& other_value)
{
single_value = new single_value_struct;
if (other_value.movementName().is_bound()) {
  if (other_value.movementName().ispresent()) single_value->field_movementName = other_value.movementName()();
  else single_value->field_movementName = OMIT_VALUE;
} else {
  single_value->field_movementName.clean_up();
}
if (other_value.signalGroup().is_bound()) {
  single_value->field_signalGroup = other_value.signalGroup();
} else {
  single_value->field_signalGroup.clean_up();
}
if (other_value.state__time__speed().is_bound()) {
  single_value->field_state__time__speed = other_value.state__time__speed();
} else {
  single_value->field_state__time__speed.clean_up();
}
if (other_value.maneuverAssistList().is_bound()) {
  if (other_value.maneuverAssistList().ispresent()) single_value->field_maneuverAssistList = other_value.maneuverAssistList()();
  else single_value->field_maneuverAssistList = OMIT_VALUE;
} else {
  single_value->field_maneuverAssistList.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MovementState_template::copy_template(const MovementState_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.movementName().get_selection()) {
single_value->field_movementName = other_value.movementName();
} else {
single_value->field_movementName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signalGroup().get_selection()) {
single_value->field_signalGroup = other_value.signalGroup();
} else {
single_value->field_signalGroup.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.state__time__speed().get_selection()) {
single_value->field_state__time__speed = other_value.state__time__speed();
} else {
single_value->field_state__time__speed.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.maneuverAssistList().get_selection()) {
single_value->field_maneuverAssistList = other_value.maneuverAssistList();
} else {
single_value->field_maneuverAssistList.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MovementState_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.MovementState.");
break;
}
set_selection(other_value);
}

MovementState_template::MovementState_template()
{
}

MovementState_template::MovementState_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MovementState_template::MovementState_template(const MovementState& other_value)
{
copy_value(other_value);
}

MovementState_template::MovementState_template(const OPTIONAL<MovementState>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MovementState&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.MovementState from an unbound optional field.");
}
}

MovementState_template::MovementState_template(const MovementState_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MovementState_template::~MovementState_template()
{
clean_up();
}

MovementState_template& MovementState_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MovementState_template& MovementState_template::operator=(const MovementState& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MovementState_template& MovementState_template::operator=(const OPTIONAL<MovementState>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MovementState&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.MovementState.");
}
return *this;
}

MovementState_template& MovementState_template::operator=(const MovementState_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MovementState_template::match(const MovementState& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.movementName().is_bound()) return FALSE;
if((other_value.movementName().ispresent() ? !single_value->field_movementName.match((const CHARSTRING&)other_value.movementName(), legacy) : !single_value->field_movementName.match_omit(legacy)))return FALSE;
if(!other_value.signalGroup().is_bound()) return FALSE;
if(!single_value->field_signalGroup.match(other_value.signalGroup(), legacy))return FALSE;
if(!other_value.state__time__speed().is_bound()) return FALSE;
if(!single_value->field_state__time__speed.match(other_value.state__time__speed(), legacy))return FALSE;
if(!other_value.maneuverAssistList().is_bound()) return FALSE;
if((other_value.maneuverAssistList().ispresent() ? !single_value->field_maneuverAssistList.match((const ManeuverAssistList&)other_value.maneuverAssistList(), legacy) : !single_value->field_maneuverAssistList.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REGION::Reg__MovementState&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.MovementState.");
}
return FALSE;
}

boolean MovementState_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_movementName.is_omit() || single_value->field_movementName.is_bound()) return TRUE;
if (single_value->field_signalGroup.is_bound()) return TRUE;
if (single_value->field_state__time__speed.is_bound()) return TRUE;
if (single_value->field_maneuverAssistList.is_omit() || single_value->field_maneuverAssistList.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean MovementState_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_movementName.is_omit() && !single_value->field_movementName.is_value()) return FALSE;
if (!single_value->field_signalGroup.is_value()) return FALSE;
if (!single_value->field_state__time__speed.is_value()) return FALSE;
if (!single_value->field_maneuverAssistList.is_omit() && !single_value->field_maneuverAssistList.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void MovementState_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MovementState MovementState_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.MovementState.");
MovementState ret_val;
if (single_value->field_movementName.is_omit()) ret_val.movementName() = OMIT_VALUE;
else if (single_value->field_movementName.is_bound()) {
ret_val.movementName() = single_value->field_movementName.valueof();
}
if (single_value->field_signalGroup.is_bound()) {
ret_val.signalGroup() = single_value->field_signalGroup.valueof();
}
if (single_value->field_state__time__speed.is_bound()) {
ret_val.state__time__speed() = single_value->field_state__time__speed.valueof();
}
if (single_value->field_maneuverAssistList.is_omit()) ret_val.maneuverAssistList() = OMIT_VALUE;
else if (single_value->field_maneuverAssistList.is_bound()) {
ret_val.maneuverAssistList() = single_value->field_maneuverAssistList.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void MovementState_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.MovementState.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MovementState_template[list_length];
}

MovementState_template& MovementState_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.MovementState.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.MovementState.");
return value_list.list_value[list_index];
}

CHARSTRING_template& MovementState_template::movementName()
{
set_specific();
return single_value->field_movementName;
}

const CHARSTRING_template& MovementState_template::movementName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field movementName of a non-specific template of type @DSRC.MovementState.");
return single_value->field_movementName;
}

INTEGER_template& MovementState_template::signalGroup()
{
set_specific();
return single_value->field_signalGroup;
}

const INTEGER_template& MovementState_template::signalGroup() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signalGroup of a non-specific template of type @DSRC.MovementState.");
return single_value->field_signalGroup;
}

MovementEventList_template& MovementState_template::state__time__speed()
{
set_specific();
return single_value->field_state__time__speed;
}

const MovementEventList_template& MovementState_template::state__time__speed() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field state_time_speed of a non-specific template of type @DSRC.MovementState.");
return single_value->field_state__time__speed;
}

ManeuverAssistList_template& MovementState_template::maneuverAssistList()
{
set_specific();
return single_value->field_maneuverAssistList;
}

const ManeuverAssistList_template& MovementState_template::maneuverAssistList() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field maneuverAssistList of a non-specific template of type @DSRC.MovementState.");
return single_value->field_maneuverAssistList;
}

REGION::Reg__MovementState_template& MovementState_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REGION::Reg__MovementState_template& MovementState_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.MovementState.");
return single_value->field_regional;
}

int MovementState_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementState which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_movementName.is_present()) ret_val++;
      if (single_value->field_maneuverAssistList.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.MovementState containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementState containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementState containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementState containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.MovementState containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.MovementState.");
  }
  return 0;
}

void MovementState_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ movementName := ");
single_value->field_movementName.log();
TTCN_Logger::log_event_str(", signalGroup := ");
single_value->field_signalGroup.log();
TTCN_Logger::log_event_str(", state_time_speed := ");
single_value->field_state__time__speed.log();
TTCN_Logger::log_event_str(", maneuverAssistList := ");
single_value->field_maneuverAssistList.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MovementState_template::log_match(const MovementState& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.movementName().ispresent()){
if(!single_value->field_movementName.match(match_value.movementName(), legacy)){
TTCN_Logger::log_logmatch_info(".movementName");
single_value->field_movementName.log_match(match_value.movementName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_movementName.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".movementName := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_movementName.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_signalGroup.match(match_value.signalGroup(), legacy)){
TTCN_Logger::log_logmatch_info(".signalGroup");
single_value->field_signalGroup.log_match(match_value.signalGroup(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_state__time__speed.match(match_value.state__time__speed(), legacy)){
TTCN_Logger::log_logmatch_info(".state_time_speed");
single_value->field_state__time__speed.log_match(match_value.state__time__speed(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.maneuverAssistList().ispresent()){
if(!single_value->field_maneuverAssistList.match(match_value.maneuverAssistList(), legacy)){
TTCN_Logger::log_logmatch_info(".maneuverAssistList");
single_value->field_maneuverAssistList.log_match(match_value.maneuverAssistList(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_maneuverAssistList.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".maneuverAssistList := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_maneuverAssistList.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ movementName := ");
if (match_value.movementName().ispresent()) single_value->field_movementName.log_match(match_value.movementName(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_movementName.log();
if (single_value->field_movementName.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", signalGroup := ");
single_value->field_signalGroup.log_match(match_value.signalGroup(), legacy);
TTCN_Logger::log_event_str(", state_time_speed := ");
single_value->field_state__time__speed.log_match(match_value.state__time__speed(), legacy);
TTCN_Logger::log_event_str(", maneuverAssistList := ");
if (match_value.maneuverAssistList().ispresent()) single_value->field_maneuverAssistList.log_match(match_value.maneuverAssistList(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_maneuverAssistList.log();
if (single_value->field_maneuverAssistList.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MovementState_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_movementName.encode_text(text_buf);
single_value->field_signalGroup.encode_text(text_buf);
single_value->field_state__time__speed.encode_text(text_buf);
single_value->field_maneuverAssistList.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.MovementState.");
}
}

void MovementState_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_movementName.decode_text(text_buf);
single_value->field_signalGroup.decode_text(text_buf);
single_value->field_state__time__speed.decode_text(text_buf);
single_value->field_maneuverAssistList.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MovementState_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.MovementState.");
}
}

void MovementState_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.MovementState'");
    }
    if (strcmp("movementName", param_field) == 0) {
      movementName().set_param(param);
      return;
    } else if (strcmp("signalGroup", param_field) == 0) {
      signalGroup().set_param(param);
      return;
    } else if (strcmp("state_time_speed", param_field) == 0) {
      state__time__speed().set_param(param);
      return;
    } else if (strcmp("maneuverAssistList", param_field) == 0) {
      maneuverAssistList().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.MovementState'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MovementState_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record template of type @DSRC.MovementState has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) movementName().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signalGroup().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) state__time__speed().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) maneuverAssistList().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "movementName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          movementName().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signalGroup")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signalGroup().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "state_time_speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          state__time__speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maneuverAssistList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maneuverAssistList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.MovementState: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.MovementState");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* MovementState_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.MovementState'");
    }
    if (strcmp("movementName", param_field) == 0) {
      return movementName().get_param(param_name);
    } else if (strcmp("signalGroup", param_field) == 0) {
      return signalGroup().get_param(param_name);
    } else if (strcmp("state_time_speed", param_field) == 0) {
      return state__time__speed().get_param(param_name);
    } else if (strcmp("maneuverAssistList", param_field) == 0) {
      return maneuverAssistList().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.MovementState'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_movementName = single_value->field_movementName.get_param(param_name);
    mp_field_movementName->set_id(new Module_Param_FieldName(mcopystr("movementName")));
    mp->add_elem(mp_field_movementName);
    Module_Param* mp_field_signalGroup = single_value->field_signalGroup.get_param(param_name);
    mp_field_signalGroup->set_id(new Module_Param_FieldName(mcopystr("signalGroup")));
    mp->add_elem(mp_field_signalGroup);
    Module_Param* mp_field_state__time__speed = single_value->field_state__time__speed.get_param(param_name);
    mp_field_state__time__speed->set_id(new Module_Param_FieldName(mcopystr("state_time_speed")));
    mp->add_elem(mp_field_state__time__speed);
    Module_Param* mp_field_maneuverAssistList = single_value->field_maneuverAssistList.get_param(param_name);
    mp_field_maneuverAssistList->set_id(new Module_Param_FieldName(mcopystr("maneuverAssistList")));
    mp->add_elem(mp_field_maneuverAssistList);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void MovementState_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_movementName.check_restriction(t_res, t_name ? t_name : "@DSRC.MovementState");
single_value->field_signalGroup.check_restriction(t_res, t_name ? t_name : "@DSRC.MovementState");
single_value->field_state__time__speed.check_restriction(t_res, t_name ? t_name : "@DSRC.MovementState");
single_value->field_maneuverAssistList.check_restriction(t_res, t_name ? t_name : "@DSRC.MovementState");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.MovementState");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.MovementState");
}

boolean MovementState_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MovementState_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const ConnectionManeuverAssist ManeuverAssistList::UNBOUND_ELEM;
ManeuverAssistList::ManeuverAssistList()
{
val_ptr = NULL;
}

ManeuverAssistList::ManeuverAssistList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

ManeuverAssistList::ManeuverAssistList(const ManeuverAssistList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.ManeuverAssistList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

ManeuverAssistList::~ManeuverAssistList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void ManeuverAssistList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

ManeuverAssistList& ManeuverAssistList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

ManeuverAssistList& ManeuverAssistList::operator=(const ManeuverAssistList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DSRC.ManeuverAssistList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean ManeuverAssistList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DSRC.ManeuverAssistList.");
return val_ptr->n_elements == 0 ;
}

boolean ManeuverAssistList::operator==(const ManeuverAssistList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DSRC.ManeuverAssistList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DSRC.ManeuverAssistList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

ConnectionManeuverAssist& ManeuverAssistList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.ManeuverAssistList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (ConnectionManeuverAssist**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ConnectionManeuverAssist(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new ConnectionManeuverAssist;
}
return *val_ptr->value_elements[index_value];
}

ConnectionManeuverAssist& ManeuverAssistList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.ManeuverAssistList.");
return (*this)[(int)index_value];
}

const ConnectionManeuverAssist& ManeuverAssistList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DSRC.ManeuverAssistList.");
if (index_value < 0) TTCN_error("Accessing an element of type @DSRC.ManeuverAssistList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DSRC.ManeuverAssistList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const ConnectionManeuverAssist& ManeuverAssistList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DSRC.ManeuverAssistList.");
return (*this)[(int)index_value];
}

ManeuverAssistList ManeuverAssistList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

ManeuverAssistList ManeuverAssistList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

ManeuverAssistList ManeuverAssistList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

ManeuverAssistList ManeuverAssistList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DSRC.ManeuverAssistList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
ManeuverAssistList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new ConnectionManeuverAssist(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

ManeuverAssistList ManeuverAssistList::operator+(const ManeuverAssistList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DSRC.ManeuverAssistList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
ManeuverAssistList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ConnectionManeuverAssist(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new ConnectionManeuverAssist(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

ManeuverAssistList ManeuverAssistList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DSRC.ManeuverAssistList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DSRC.ManeuverAssistList","element");
ManeuverAssistList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new ConnectionManeuverAssist(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

ManeuverAssistList ManeuverAssistList::replace(int index, int len, const ManeuverAssistList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DSRC.ManeuverAssistList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DSRC.ManeuverAssistList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DSRC.ManeuverAssistList","element");
ManeuverAssistList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ConnectionManeuverAssist(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new ConnectionManeuverAssist(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new ConnectionManeuverAssist(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

ManeuverAssistList ManeuverAssistList::replace(int index, int len, const ManeuverAssistList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void ManeuverAssistList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DSRC.ManeuverAssistList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (ConnectionManeuverAssist**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ConnectionManeuverAssist(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (ConnectionManeuverAssist**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DSRC.ManeuverAssistList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (ConnectionManeuverAssist**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean ManeuverAssistList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int ManeuverAssistList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DSRC.ManeuverAssistList.");
return val_ptr->n_elements;
}

int ManeuverAssistList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DSRC.ManeuverAssistList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void ManeuverAssistList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void ManeuverAssistList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DSRC.ManeuverAssistList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DSRC.ManeuverAssistList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DSRC.ManeuverAssistList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* ManeuverAssistList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DSRC.ManeuverAssistList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void ManeuverAssistList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void ManeuverAssistList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DSRC.ManeuverAssistList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void ManeuverAssistList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DSRC.ManeuverAssistList.");
val_ptr->value_elements = (ConnectionManeuverAssist**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new ConnectionManeuverAssist;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void ManeuverAssistList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ManeuverAssistList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ManeuverAssistList::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ManeuverAssistList::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (ConnectionManeuverAssist**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new ConnectionManeuverAssist;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int ManeuverAssistList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.ManeuverAssistList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int ManeuverAssistList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    ConnectionManeuverAssist* val = new ConnectionManeuverAssist;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (ConnectionManeuverAssist**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ManeuverAssistList_template::copy_value(const ManeuverAssistList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DSRC.ManeuverAssistList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (ConnectionManeuverAssist_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new ConnectionManeuverAssist_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new ConnectionManeuverAssist_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void ManeuverAssistList_template::copy_template(const ManeuverAssistList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (ConnectionManeuverAssist_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new ConnectionManeuverAssist_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new ConnectionManeuverAssist_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ManeuverAssistList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.ManeuverAssistList.");
break;
}
set_selection(other_value);
}

boolean ManeuverAssistList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ManeuverAssistList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const ManeuverAssistList*)value_ptr)[value_index], legacy);
else return ((const ManeuverAssistList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

ManeuverAssistList_template::ManeuverAssistList_template()
{
}

ManeuverAssistList_template::ManeuverAssistList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

ManeuverAssistList_template::ManeuverAssistList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

ManeuverAssistList_template::ManeuverAssistList_template(const ManeuverAssistList& other_value)
{
copy_value(other_value);
}

ManeuverAssistList_template::ManeuverAssistList_template(const OPTIONAL<ManeuverAssistList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ManeuverAssistList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.ManeuverAssistList from an unbound optional field.");
}
}

ManeuverAssistList_template::ManeuverAssistList_template(const ManeuverAssistList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

ManeuverAssistList_template::~ManeuverAssistList_template()
{
clean_up();
}

void ManeuverAssistList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ManeuverAssistList_template& ManeuverAssistList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ManeuverAssistList_template& ManeuverAssistList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

ManeuverAssistList_template& ManeuverAssistList_template::operator=(const ManeuverAssistList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ManeuverAssistList_template& ManeuverAssistList_template::operator=(const OPTIONAL<ManeuverAssistList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ManeuverAssistList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.ManeuverAssistList.");
}
return *this;
}

ManeuverAssistList_template& ManeuverAssistList_template::operator=(const ManeuverAssistList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

ConnectionManeuverAssist_template& ManeuverAssistList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.ManeuverAssistList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DSRC.ManeuverAssistList.");
    break;
}
return *single_value.value_elements[index_value];
}

ConnectionManeuverAssist_template& ManeuverAssistList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.ManeuverAssistList.");
return (*this)[(int)index_value];
}

const ConnectionManeuverAssist_template& ManeuverAssistList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DSRC.ManeuverAssistList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DSRC.ManeuverAssistList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DSRC.ManeuverAssistList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const ConnectionManeuverAssist_template& ManeuverAssistList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DSRC.ManeuverAssistList.");
return (*this)[(int)index_value];
}

void ManeuverAssistList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DSRC.ManeuverAssistList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (ConnectionManeuverAssist_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ConnectionManeuverAssist_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ConnectionManeuverAssist_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (ConnectionManeuverAssist_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int ManeuverAssistList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int ManeuverAssistList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DSRC.ManeuverAssistList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DSRC.ManeuverAssistList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.ManeuverAssistList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DSRC.ManeuverAssistList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DSRC.ManeuverAssistList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DSRC.ManeuverAssistList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DSRC.ManeuverAssistList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DSRC.ManeuverAssistList");
}

boolean ManeuverAssistList_template::match(const ManeuverAssistList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DSRC.ManeuverAssistList.");
}
return FALSE;
}

boolean ManeuverAssistList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

ManeuverAssistList ManeuverAssistList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DSRC.ManeuverAssistList.");
ManeuverAssistList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

ManeuverAssistList ManeuverAssistList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

ManeuverAssistList ManeuverAssistList_template::replace(int index, int len, const ManeuverAssistList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

ManeuverAssistList ManeuverAssistList_template::replace(int index, int len, const ManeuverAssistList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void ManeuverAssistList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new ManeuverAssistList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DSRC.ManeuverAssistList.");
}
set_selection(template_type);
}

ManeuverAssistList_template& ManeuverAssistList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DSRC.ManeuverAssistList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DSRC.ManeuverAssistList.");
return value_list.list_value[list_index];
}

void ManeuverAssistList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void ManeuverAssistList_template::log_match(const ManeuverAssistList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ManeuverAssistList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.ManeuverAssistList.");
}
}

void ManeuverAssistList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DSRC.ManeuverAssistList.");
single_value.value_elements = (ConnectionManeuverAssist_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new ConnectionManeuverAssist_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ManeuverAssistList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DSRC.ManeuverAssistList.");
}
}

boolean ManeuverAssistList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ManeuverAssistList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ManeuverAssistList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DSRC.ManeuverAssistList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ManeuverAssistList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DSRC.ManeuverAssistList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* ManeuverAssistList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DSRC.ManeuverAssistList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void ManeuverAssistList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DSRC.ManeuverAssistList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.ManeuverAssistList");
}

ConnectionManeuverAssist::ConnectionManeuverAssist()
{
  bound_flag = FALSE;
}

ConnectionManeuverAssist::ConnectionManeuverAssist(const INTEGER& par_connectionID,
    const OPTIONAL<INTEGER>& par_queueLength,
    const OPTIONAL<INTEGER>& par_availableStorageLength,
    const OPTIONAL<BOOLEAN>& par_waitOnStop,
    const OPTIONAL<BOOLEAN>& par_pedBicycleDetect,
    const OPTIONAL<REG__D::Reg__ConnectionManeuverAssist>& par_regional)
  :   field_connectionID(par_connectionID),
  field_queueLength(par_queueLength),
  field_availableStorageLength(par_availableStorageLength),
  field_waitOnStop(par_waitOnStop),
  field_pedBicycleDetect(par_pedBicycleDetect),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

ConnectionManeuverAssist::ConnectionManeuverAssist(const ConnectionManeuverAssist& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.ConnectionManeuverAssist.");
bound_flag = TRUE;
if (other_value.connectionID().is_bound()) field_connectionID = other_value.connectionID();
else field_connectionID.clean_up();
if (other_value.queueLength().is_bound()) field_queueLength = other_value.queueLength();
else field_queueLength.clean_up();
if (other_value.availableStorageLength().is_bound()) field_availableStorageLength = other_value.availableStorageLength();
else field_availableStorageLength.clean_up();
if (other_value.waitOnStop().is_bound()) field_waitOnStop = other_value.waitOnStop();
else field_waitOnStop.clean_up();
if (other_value.pedBicycleDetect().is_bound()) field_pedBicycleDetect = other_value.pedBicycleDetect();
else field_pedBicycleDetect.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void ConnectionManeuverAssist::clean_up()
{
field_connectionID.clean_up();
field_queueLength.clean_up();
field_availableStorageLength.clean_up();
field_waitOnStop.clean_up();
field_pedBicycleDetect.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

ConnectionManeuverAssist& ConnectionManeuverAssist::operator=(const ConnectionManeuverAssist& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.ConnectionManeuverAssist.");
  bound_flag = TRUE;
  if (other_value.connectionID().is_bound()) field_connectionID = other_value.connectionID();
  else field_connectionID.clean_up();
  if (other_value.queueLength().is_bound()) field_queueLength = other_value.queueLength();
  else field_queueLength.clean_up();
  if (other_value.availableStorageLength().is_bound()) field_availableStorageLength = other_value.availableStorageLength();
  else field_availableStorageLength.clean_up();
  if (other_value.waitOnStop().is_bound()) field_waitOnStop = other_value.waitOnStop();
  else field_waitOnStop.clean_up();
  if (other_value.pedBicycleDetect().is_bound()) field_pedBicycleDetect = other_value.pedBicycleDetect();
  else field_pedBicycleDetect.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean ConnectionManeuverAssist::operator==(const ConnectionManeuverAssist& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_connectionID==other_value.field_connectionID
  && field_queueLength==other_value.field_queueLength
  && field_availableStorageLength==other_value.field_availableStorageLength
  && field_waitOnStop==other_value.field_waitOnStop
  && field_pedBicycleDetect==other_value.field_pedBicycleDetect
  && field_regional==other_value.field_regional;
}

boolean ConnectionManeuverAssist::is_bound() const
{
if (bound_flag) return TRUE;
if(field_connectionID.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_queueLength.get_selection() || field_queueLength.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_availableStorageLength.get_selection() || field_availableStorageLength.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_waitOnStop.get_selection() || field_waitOnStop.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_pedBicycleDetect.get_selection() || field_pedBicycleDetect.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean ConnectionManeuverAssist::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_connectionID.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_queueLength.get_selection() && !field_queueLength.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_availableStorageLength.get_selection() && !field_availableStorageLength.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_waitOnStop.get_selection() && !field_waitOnStop.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_pedBicycleDetect.get_selection() && !field_pedBicycleDetect.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int ConnectionManeuverAssist::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.ConnectionManeuverAssist");
  int ret_val = 1;
  if (field_queueLength.ispresent()) ret_val++;
  if (field_availableStorageLength.ispresent()) ret_val++;
  if (field_waitOnStop.ispresent()) ret_val++;
  if (field_pedBicycleDetect.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void ConnectionManeuverAssist::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ connectionID := ");
field_connectionID.log();
TTCN_Logger::log_event_str(", queueLength := ");
field_queueLength.log();
TTCN_Logger::log_event_str(", availableStorageLength := ");
field_availableStorageLength.log();
TTCN_Logger::log_event_str(", waitOnStop := ");
field_waitOnStop.log();
TTCN_Logger::log_event_str(", pedBicycleDetect := ");
field_pedBicycleDetect.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void ConnectionManeuverAssist::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.ConnectionManeuverAssist'");
    }
    if (strcmp("connectionID", param_field) == 0) {
      connectionID().set_param(param);
      return;
    } else if (strcmp("queueLength", param_field) == 0) {
      queueLength().set_param(param);
      return;
    } else if (strcmp("availableStorageLength", param_field) == 0) {
      availableStorageLength().set_param(param);
      return;
    } else if (strcmp("waitOnStop", param_field) == 0) {
      waitOnStop().set_param(param);
      return;
    } else if (strcmp("pedBicycleDetect", param_field) == 0) {
      pedBicycleDetect().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.ConnectionManeuverAssist'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record value of type @DSRC.ConnectionManeuverAssist has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connectionID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) queueLength().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) availableStorageLength().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) waitOnStop().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) pedBicycleDetect().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connectionID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connectionID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "queueLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          queueLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "availableStorageLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          availableStorageLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "waitOnStop")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          waitOnStop().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pedBicycleDetect")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pedBicycleDetect().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.ConnectionManeuverAssist: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.ConnectionManeuverAssist");
  }
}

Module_Param* ConnectionManeuverAssist::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.ConnectionManeuverAssist'");
    }
    if (strcmp("connectionID", param_field) == 0) {
      return connectionID().get_param(param_name);
    } else if (strcmp("queueLength", param_field) == 0) {
      return queueLength().get_param(param_name);
    } else if (strcmp("availableStorageLength", param_field) == 0) {
      return availableStorageLength().get_param(param_name);
    } else if (strcmp("waitOnStop", param_field) == 0) {
      return waitOnStop().get_param(param_name);
    } else if (strcmp("pedBicycleDetect", param_field) == 0) {
      return pedBicycleDetect().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.ConnectionManeuverAssist'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_connectionID = field_connectionID.get_param(param_name);
  mp_field_connectionID->set_id(new Module_Param_FieldName(mcopystr("connectionID")));
  mp->add_elem(mp_field_connectionID);
  Module_Param* mp_field_queueLength = field_queueLength.get_param(param_name);
  mp_field_queueLength->set_id(new Module_Param_FieldName(mcopystr("queueLength")));
  mp->add_elem(mp_field_queueLength);
  Module_Param* mp_field_availableStorageLength = field_availableStorageLength.get_param(param_name);
  mp_field_availableStorageLength->set_id(new Module_Param_FieldName(mcopystr("availableStorageLength")));
  mp->add_elem(mp_field_availableStorageLength);
  Module_Param* mp_field_waitOnStop = field_waitOnStop.get_param(param_name);
  mp_field_waitOnStop->set_id(new Module_Param_FieldName(mcopystr("waitOnStop")));
  mp->add_elem(mp_field_waitOnStop);
  Module_Param* mp_field_pedBicycleDetect = field_pedBicycleDetect.get_param(param_name);
  mp_field_pedBicycleDetect->set_id(new Module_Param_FieldName(mcopystr("pedBicycleDetect")));
  mp->add_elem(mp_field_pedBicycleDetect);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void ConnectionManeuverAssist::set_implicit_omit()
{
if (connectionID().is_bound()) connectionID().set_implicit_omit();
if (!queueLength().is_bound()) queueLength() = OMIT_VALUE;
else queueLength().set_implicit_omit();
if (!availableStorageLength().is_bound()) availableStorageLength() = OMIT_VALUE;
else availableStorageLength().set_implicit_omit();
if (!waitOnStop().is_bound()) waitOnStop() = OMIT_VALUE;
else waitOnStop().set_implicit_omit();
if (!pedBicycleDetect().is_bound()) pedBicycleDetect() = OMIT_VALUE;
else pedBicycleDetect().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void ConnectionManeuverAssist::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.ConnectionManeuverAssist.");
field_connectionID.encode_text(text_buf);
field_queueLength.encode_text(text_buf);
field_availableStorageLength.encode_text(text_buf);
field_waitOnStop.encode_text(text_buf);
field_pedBicycleDetect.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void ConnectionManeuverAssist::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_connectionID.decode_text(text_buf);
field_queueLength.decode_text(text_buf);
field_availableStorageLength.decode_text(text_buf);
field_waitOnStop.decode_text(text_buf);
field_pedBicycleDetect.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void ConnectionManeuverAssist::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ConnectionManeuverAssist::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ConnectionManeuverAssist::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("connectionID': ");
  new_tlv->add_TLV(field_connectionID.BER_encode_TLV(ConnectionManeuverAssist_connectionID_descr_, p_coding));
  ec_1.set_msg("queueLength': ");
  new_tlv->add_TLV(field_queueLength.BER_encode_TLV(ConnectionManeuverAssist_queueLength_descr_, p_coding));
  ec_1.set_msg("availableStorageLength': ");
  new_tlv->add_TLV(field_availableStorageLength.BER_encode_TLV(ConnectionManeuverAssist_availableStorageLength_descr_, p_coding));
  ec_1.set_msg("waitOnStop': ");
  new_tlv->add_TLV(field_waitOnStop.BER_encode_TLV(ConnectionManeuverAssist_waitOnStop_descr_, p_coding));
  ec_1.set_msg("pedBicycleDetect': ");
  new_tlv->add_TLV(field_pedBicycleDetect.BER_encode_TLV(ConnectionManeuverAssist_pedBicycleDetect_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(ConnectionManeuverAssist_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ConnectionManeuverAssist::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.ConnectionManeuverAssist' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("connectionID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_connectionID.BER_decode_TLV(ConnectionManeuverAssist_connectionID_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("queueLength': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_queueLength=OMIT_VALUE;
    else {
      field_queueLength.BER_decode_TLV(ConnectionManeuverAssist_queueLength_descr_, tmp_tlv, L_form);
      if(field_queueLength.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("availableStorageLength': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_availableStorageLength=OMIT_VALUE;
    else {
      field_availableStorageLength.BER_decode_TLV(ConnectionManeuverAssist_availableStorageLength_descr_, tmp_tlv, L_form);
      if(field_availableStorageLength.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("waitOnStop': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_waitOnStop=OMIT_VALUE;
    else {
      field_waitOnStop.BER_decode_TLV(ConnectionManeuverAssist_waitOnStop_descr_, tmp_tlv, L_form);
      if(field_waitOnStop.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("pedBicycleDetect': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_pedBicycleDetect=OMIT_VALUE;
    else {
      field_pedBicycleDetect.BER_decode_TLV(ConnectionManeuverAssist_pedBicycleDetect_descr_, tmp_tlv, L_form);
      if(field_pedBicycleDetect.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(ConnectionManeuverAssist_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ConnectionManeuverAssist::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.ConnectionManeuverAssist.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "connectionID");
    enc_len += field_connectionID.JSON_encode(ConnectionManeuverAssist_connectionID_descr_, p_tok);
  }

  if (field_queueLength.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "queueLength");
    enc_len += field_queueLength.JSON_encode(ConnectionManeuverAssist_queueLength_descr_, p_tok);
  }

  if (field_availableStorageLength.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "availableStorageLength");
    enc_len += field_availableStorageLength.JSON_encode(ConnectionManeuverAssist_availableStorageLength_descr_, p_tok);
  }

  if (field_waitOnStop.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "waitOnStop");
    enc_len += field_waitOnStop.JSON_encode(ConnectionManeuverAssist_waitOnStop_descr_, p_tok);
  }

  if (field_pedBicycleDetect.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "pedBicycleDetect");
    enc_len += field_pedBicycleDetect.JSON_encode(ConnectionManeuverAssist_pedBicycleDetect_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(ConnectionManeuverAssist_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ConnectionManeuverAssist::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "connectionID", name_len)) {
         int ret_val = field_connectionID.JSON_decode(ConnectionManeuverAssist_connectionID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "connectionID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "queueLength", name_len)) {
         int ret_val = field_queueLength.JSON_decode(ConnectionManeuverAssist_queueLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "queueLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (22 == name_len && 0 == strncmp(fld_name, "availableStorageLength", name_len)) {
         int ret_val = field_availableStorageLength.JSON_decode(ConnectionManeuverAssist_availableStorageLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "availableStorageLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "waitOnStop", name_len)) {
         int ret_val = field_waitOnStop.JSON_decode(ConnectionManeuverAssist_waitOnStop_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "waitOnStop");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "pedBicycleDetect", name_len)) {
         int ret_val = field_pedBicycleDetect.JSON_decode(ConnectionManeuverAssist_pedBicycleDetect_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "pedBicycleDetect");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(ConnectionManeuverAssist_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_connectionID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "connectionID");
    return JSON_ERROR_FATAL;
  }
if (!field_queueLength.is_bound()) {
    field_queueLength = OMIT_VALUE;
  }
if (!field_availableStorageLength.is_bound()) {
    field_availableStorageLength = OMIT_VALUE;
  }
if (!field_waitOnStop.is_bound()) {
    field_waitOnStop = OMIT_VALUE;
  }
if (!field_pedBicycleDetect.is_bound()) {
    field_pedBicycleDetect = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct ConnectionManeuverAssist_template::single_value_struct {
INTEGER_template field_connectionID;
INTEGER_template field_queueLength;
INTEGER_template field_availableStorageLength;
BOOLEAN_template field_waitOnStop;
BOOLEAN_template field_pedBicycleDetect;
REG__D::Reg__ConnectionManeuverAssist_template field_regional;
};

void ConnectionManeuverAssist_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_connectionID = ANY_VALUE;
single_value->field_queueLength = ANY_OR_OMIT;
single_value->field_availableStorageLength = ANY_OR_OMIT;
single_value->field_waitOnStop = ANY_OR_OMIT;
single_value->field_pedBicycleDetect = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void ConnectionManeuverAssist_template::copy_value(const ConnectionManeuverAssist& other_value)
{
single_value = new single_value_struct;
if (other_value.connectionID().is_bound()) {
  single_value->field_connectionID = other_value.connectionID();
} else {
  single_value->field_connectionID.clean_up();
}
if (other_value.queueLength().is_bound()) {
  if (other_value.queueLength().ispresent()) single_value->field_queueLength = other_value.queueLength()();
  else single_value->field_queueLength = OMIT_VALUE;
} else {
  single_value->field_queueLength.clean_up();
}
if (other_value.availableStorageLength().is_bound()) {
  if (other_value.availableStorageLength().ispresent()) single_value->field_availableStorageLength = other_value.availableStorageLength()();
  else single_value->field_availableStorageLength = OMIT_VALUE;
} else {
  single_value->field_availableStorageLength.clean_up();
}
if (other_value.waitOnStop().is_bound()) {
  if (other_value.waitOnStop().ispresent()) single_value->field_waitOnStop = other_value.waitOnStop()();
  else single_value->field_waitOnStop = OMIT_VALUE;
} else {
  single_value->field_waitOnStop.clean_up();
}
if (other_value.pedBicycleDetect().is_bound()) {
  if (other_value.pedBicycleDetect().ispresent()) single_value->field_pedBicycleDetect = other_value.pedBicycleDetect()();
  else single_value->field_pedBicycleDetect = OMIT_VALUE;
} else {
  single_value->field_pedBicycleDetect.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ConnectionManeuverAssist_template::copy_template(const ConnectionManeuverAssist_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.connectionID().get_selection()) {
single_value->field_connectionID = other_value.connectionID();
} else {
single_value->field_connectionID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.queueLength().get_selection()) {
single_value->field_queueLength = other_value.queueLength();
} else {
single_value->field_queueLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.availableStorageLength().get_selection()) {
single_value->field_availableStorageLength = other_value.availableStorageLength();
} else {
single_value->field_availableStorageLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.waitOnStop().get_selection()) {
single_value->field_waitOnStop = other_value.waitOnStop();
} else {
single_value->field_waitOnStop.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.pedBicycleDetect().get_selection()) {
single_value->field_pedBicycleDetect = other_value.pedBicycleDetect();
} else {
single_value->field_pedBicycleDetect.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ConnectionManeuverAssist_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.ConnectionManeuverAssist.");
break;
}
set_selection(other_value);
}

ConnectionManeuverAssist_template::ConnectionManeuverAssist_template()
{
}

ConnectionManeuverAssist_template::ConnectionManeuverAssist_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ConnectionManeuverAssist_template::ConnectionManeuverAssist_template(const ConnectionManeuverAssist& other_value)
{
copy_value(other_value);
}

ConnectionManeuverAssist_template::ConnectionManeuverAssist_template(const OPTIONAL<ConnectionManeuverAssist>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ConnectionManeuverAssist&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.ConnectionManeuverAssist from an unbound optional field.");
}
}

ConnectionManeuverAssist_template::ConnectionManeuverAssist_template(const ConnectionManeuverAssist_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ConnectionManeuverAssist_template::~ConnectionManeuverAssist_template()
{
clean_up();
}

ConnectionManeuverAssist_template& ConnectionManeuverAssist_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ConnectionManeuverAssist_template& ConnectionManeuverAssist_template::operator=(const ConnectionManeuverAssist& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ConnectionManeuverAssist_template& ConnectionManeuverAssist_template::operator=(const OPTIONAL<ConnectionManeuverAssist>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ConnectionManeuverAssist&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.ConnectionManeuverAssist.");
}
return *this;
}

ConnectionManeuverAssist_template& ConnectionManeuverAssist_template::operator=(const ConnectionManeuverAssist_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ConnectionManeuverAssist_template::match(const ConnectionManeuverAssist& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.connectionID().is_bound()) return FALSE;
if(!single_value->field_connectionID.match(other_value.connectionID(), legacy))return FALSE;
if(!other_value.queueLength().is_bound()) return FALSE;
if((other_value.queueLength().ispresent() ? !single_value->field_queueLength.match((const INTEGER&)other_value.queueLength(), legacy) : !single_value->field_queueLength.match_omit(legacy)))return FALSE;
if(!other_value.availableStorageLength().is_bound()) return FALSE;
if((other_value.availableStorageLength().ispresent() ? !single_value->field_availableStorageLength.match((const INTEGER&)other_value.availableStorageLength(), legacy) : !single_value->field_availableStorageLength.match_omit(legacy)))return FALSE;
if(!other_value.waitOnStop().is_bound()) return FALSE;
if((other_value.waitOnStop().ispresent() ? !single_value->field_waitOnStop.match((const BOOLEAN&)other_value.waitOnStop(), legacy) : !single_value->field_waitOnStop.match_omit(legacy)))return FALSE;
if(!other_value.pedBicycleDetect().is_bound()) return FALSE;
if((other_value.pedBicycleDetect().ispresent() ? !single_value->field_pedBicycleDetect.match((const BOOLEAN&)other_value.pedBicycleDetect(), legacy) : !single_value->field_pedBicycleDetect.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REG__D::Reg__ConnectionManeuverAssist&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.ConnectionManeuverAssist.");
}
return FALSE;
}

boolean ConnectionManeuverAssist_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_connectionID.is_bound()) return TRUE;
if (single_value->field_queueLength.is_omit() || single_value->field_queueLength.is_bound()) return TRUE;
if (single_value->field_availableStorageLength.is_omit() || single_value->field_availableStorageLength.is_bound()) return TRUE;
if (single_value->field_waitOnStop.is_omit() || single_value->field_waitOnStop.is_bound()) return TRUE;
if (single_value->field_pedBicycleDetect.is_omit() || single_value->field_pedBicycleDetect.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean ConnectionManeuverAssist_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_connectionID.is_value()) return FALSE;
if (!single_value->field_queueLength.is_omit() && !single_value->field_queueLength.is_value()) return FALSE;
if (!single_value->field_availableStorageLength.is_omit() && !single_value->field_availableStorageLength.is_value()) return FALSE;
if (!single_value->field_waitOnStop.is_omit() && !single_value->field_waitOnStop.is_value()) return FALSE;
if (!single_value->field_pedBicycleDetect.is_omit() && !single_value->field_pedBicycleDetect.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void ConnectionManeuverAssist_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ConnectionManeuverAssist ConnectionManeuverAssist_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.ConnectionManeuverAssist.");
ConnectionManeuverAssist ret_val;
if (single_value->field_connectionID.is_bound()) {
ret_val.connectionID() = single_value->field_connectionID.valueof();
}
if (single_value->field_queueLength.is_omit()) ret_val.queueLength() = OMIT_VALUE;
else if (single_value->field_queueLength.is_bound()) {
ret_val.queueLength() = single_value->field_queueLength.valueof();
}
if (single_value->field_availableStorageLength.is_omit()) ret_val.availableStorageLength() = OMIT_VALUE;
else if (single_value->field_availableStorageLength.is_bound()) {
ret_val.availableStorageLength() = single_value->field_availableStorageLength.valueof();
}
if (single_value->field_waitOnStop.is_omit()) ret_val.waitOnStop() = OMIT_VALUE;
else if (single_value->field_waitOnStop.is_bound()) {
ret_val.waitOnStop() = single_value->field_waitOnStop.valueof();
}
if (single_value->field_pedBicycleDetect.is_omit()) ret_val.pedBicycleDetect() = OMIT_VALUE;
else if (single_value->field_pedBicycleDetect.is_bound()) {
ret_val.pedBicycleDetect() = single_value->field_pedBicycleDetect.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void ConnectionManeuverAssist_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.ConnectionManeuverAssist.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ConnectionManeuverAssist_template[list_length];
}

ConnectionManeuverAssist_template& ConnectionManeuverAssist_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.ConnectionManeuverAssist.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.ConnectionManeuverAssist.");
return value_list.list_value[list_index];
}

INTEGER_template& ConnectionManeuverAssist_template::connectionID()
{
set_specific();
return single_value->field_connectionID;
}

const INTEGER_template& ConnectionManeuverAssist_template::connectionID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connectionID of a non-specific template of type @DSRC.ConnectionManeuverAssist.");
return single_value->field_connectionID;
}

INTEGER_template& ConnectionManeuverAssist_template::queueLength()
{
set_specific();
return single_value->field_queueLength;
}

const INTEGER_template& ConnectionManeuverAssist_template::queueLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field queueLength of a non-specific template of type @DSRC.ConnectionManeuverAssist.");
return single_value->field_queueLength;
}

INTEGER_template& ConnectionManeuverAssist_template::availableStorageLength()
{
set_specific();
return single_value->field_availableStorageLength;
}

const INTEGER_template& ConnectionManeuverAssist_template::availableStorageLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field availableStorageLength of a non-specific template of type @DSRC.ConnectionManeuverAssist.");
return single_value->field_availableStorageLength;
}

BOOLEAN_template& ConnectionManeuverAssist_template::waitOnStop()
{
set_specific();
return single_value->field_waitOnStop;
}

const BOOLEAN_template& ConnectionManeuverAssist_template::waitOnStop() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field waitOnStop of a non-specific template of type @DSRC.ConnectionManeuverAssist.");
return single_value->field_waitOnStop;
}

BOOLEAN_template& ConnectionManeuverAssist_template::pedBicycleDetect()
{
set_specific();
return single_value->field_pedBicycleDetect;
}

const BOOLEAN_template& ConnectionManeuverAssist_template::pedBicycleDetect() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field pedBicycleDetect of a non-specific template of type @DSRC.ConnectionManeuverAssist.");
return single_value->field_pedBicycleDetect;
}

REG__D::Reg__ConnectionManeuverAssist_template& ConnectionManeuverAssist_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REG__D::Reg__ConnectionManeuverAssist_template& ConnectionManeuverAssist_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.ConnectionManeuverAssist.");
return single_value->field_regional;
}

int ConnectionManeuverAssist_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectionManeuverAssist which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_queueLength.is_present()) ret_val++;
      if (single_value->field_availableStorageLength.is_present()) ret_val++;
      if (single_value->field_waitOnStop.is_present()) ret_val++;
      if (single_value->field_pedBicycleDetect.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.ConnectionManeuverAssist containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectionManeuverAssist containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectionManeuverAssist containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectionManeuverAssist containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.ConnectionManeuverAssist containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.ConnectionManeuverAssist.");
  }
  return 0;
}

void ConnectionManeuverAssist_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ connectionID := ");
single_value->field_connectionID.log();
TTCN_Logger::log_event_str(", queueLength := ");
single_value->field_queueLength.log();
TTCN_Logger::log_event_str(", availableStorageLength := ");
single_value->field_availableStorageLength.log();
TTCN_Logger::log_event_str(", waitOnStop := ");
single_value->field_waitOnStop.log();
TTCN_Logger::log_event_str(", pedBicycleDetect := ");
single_value->field_pedBicycleDetect.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ConnectionManeuverAssist_template::log_match(const ConnectionManeuverAssist& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_connectionID.match(match_value.connectionID(), legacy)){
TTCN_Logger::log_logmatch_info(".connectionID");
single_value->field_connectionID.log_match(match_value.connectionID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.queueLength().ispresent()){
if(!single_value->field_queueLength.match(match_value.queueLength(), legacy)){
TTCN_Logger::log_logmatch_info(".queueLength");
single_value->field_queueLength.log_match(match_value.queueLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_queueLength.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".queueLength := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_queueLength.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.availableStorageLength().ispresent()){
if(!single_value->field_availableStorageLength.match(match_value.availableStorageLength(), legacy)){
TTCN_Logger::log_logmatch_info(".availableStorageLength");
single_value->field_availableStorageLength.log_match(match_value.availableStorageLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_availableStorageLength.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".availableStorageLength := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_availableStorageLength.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.waitOnStop().ispresent()){
if(!single_value->field_waitOnStop.match(match_value.waitOnStop(), legacy)){
TTCN_Logger::log_logmatch_info(".waitOnStop");
single_value->field_waitOnStop.log_match(match_value.waitOnStop(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_waitOnStop.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".waitOnStop := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_waitOnStop.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.pedBicycleDetect().ispresent()){
if(!single_value->field_pedBicycleDetect.match(match_value.pedBicycleDetect(), legacy)){
TTCN_Logger::log_logmatch_info(".pedBicycleDetect");
single_value->field_pedBicycleDetect.log_match(match_value.pedBicycleDetect(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_pedBicycleDetect.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".pedBicycleDetect := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_pedBicycleDetect.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ connectionID := ");
single_value->field_connectionID.log_match(match_value.connectionID(), legacy);
TTCN_Logger::log_event_str(", queueLength := ");
if (match_value.queueLength().ispresent()) single_value->field_queueLength.log_match(match_value.queueLength(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_queueLength.log();
if (single_value->field_queueLength.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", availableStorageLength := ");
if (match_value.availableStorageLength().ispresent()) single_value->field_availableStorageLength.log_match(match_value.availableStorageLength(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_availableStorageLength.log();
if (single_value->field_availableStorageLength.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", waitOnStop := ");
if (match_value.waitOnStop().ispresent()) single_value->field_waitOnStop.log_match(match_value.waitOnStop(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_waitOnStop.log();
if (single_value->field_waitOnStop.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", pedBicycleDetect := ");
if (match_value.pedBicycleDetect().ispresent()) single_value->field_pedBicycleDetect.log_match(match_value.pedBicycleDetect(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_pedBicycleDetect.log();
if (single_value->field_pedBicycleDetect.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ConnectionManeuverAssist_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_connectionID.encode_text(text_buf);
single_value->field_queueLength.encode_text(text_buf);
single_value->field_availableStorageLength.encode_text(text_buf);
single_value->field_waitOnStop.encode_text(text_buf);
single_value->field_pedBicycleDetect.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.ConnectionManeuverAssist.");
}
}

void ConnectionManeuverAssist_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_connectionID.decode_text(text_buf);
single_value->field_queueLength.decode_text(text_buf);
single_value->field_availableStorageLength.decode_text(text_buf);
single_value->field_waitOnStop.decode_text(text_buf);
single_value->field_pedBicycleDetect.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ConnectionManeuverAssist_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.ConnectionManeuverAssist.");
}
}

void ConnectionManeuverAssist_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.ConnectionManeuverAssist'");
    }
    if (strcmp("connectionID", param_field) == 0) {
      connectionID().set_param(param);
      return;
    } else if (strcmp("queueLength", param_field) == 0) {
      queueLength().set_param(param);
      return;
    } else if (strcmp("availableStorageLength", param_field) == 0) {
      availableStorageLength().set_param(param);
      return;
    } else if (strcmp("waitOnStop", param_field) == 0) {
      waitOnStop().set_param(param);
      return;
    } else if (strcmp("pedBicycleDetect", param_field) == 0) {
      pedBicycleDetect().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.ConnectionManeuverAssist'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ConnectionManeuverAssist_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record template of type @DSRC.ConnectionManeuverAssist has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connectionID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) queueLength().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) availableStorageLength().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) waitOnStop().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) pedBicycleDetect().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connectionID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connectionID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "queueLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          queueLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "availableStorageLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          availableStorageLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "waitOnStop")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          waitOnStop().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pedBicycleDetect")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pedBicycleDetect().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.ConnectionManeuverAssist: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.ConnectionManeuverAssist");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ConnectionManeuverAssist_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.ConnectionManeuverAssist'");
    }
    if (strcmp("connectionID", param_field) == 0) {
      return connectionID().get_param(param_name);
    } else if (strcmp("queueLength", param_field) == 0) {
      return queueLength().get_param(param_name);
    } else if (strcmp("availableStorageLength", param_field) == 0) {
      return availableStorageLength().get_param(param_name);
    } else if (strcmp("waitOnStop", param_field) == 0) {
      return waitOnStop().get_param(param_name);
    } else if (strcmp("pedBicycleDetect", param_field) == 0) {
      return pedBicycleDetect().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.ConnectionManeuverAssist'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_connectionID = single_value->field_connectionID.get_param(param_name);
    mp_field_connectionID->set_id(new Module_Param_FieldName(mcopystr("connectionID")));
    mp->add_elem(mp_field_connectionID);
    Module_Param* mp_field_queueLength = single_value->field_queueLength.get_param(param_name);
    mp_field_queueLength->set_id(new Module_Param_FieldName(mcopystr("queueLength")));
    mp->add_elem(mp_field_queueLength);
    Module_Param* mp_field_availableStorageLength = single_value->field_availableStorageLength.get_param(param_name);
    mp_field_availableStorageLength->set_id(new Module_Param_FieldName(mcopystr("availableStorageLength")));
    mp->add_elem(mp_field_availableStorageLength);
    Module_Param* mp_field_waitOnStop = single_value->field_waitOnStop.get_param(param_name);
    mp_field_waitOnStop->set_id(new Module_Param_FieldName(mcopystr("waitOnStop")));
    mp->add_elem(mp_field_waitOnStop);
    Module_Param* mp_field_pedBicycleDetect = single_value->field_pedBicycleDetect.get_param(param_name);
    mp_field_pedBicycleDetect->set_id(new Module_Param_FieldName(mcopystr("pedBicycleDetect")));
    mp->add_elem(mp_field_pedBicycleDetect);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ConnectionManeuverAssist_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_connectionID.check_restriction(t_res, t_name ? t_name : "@DSRC.ConnectionManeuverAssist");
single_value->field_queueLength.check_restriction(t_res, t_name ? t_name : "@DSRC.ConnectionManeuverAssist");
single_value->field_availableStorageLength.check_restriction(t_res, t_name ? t_name : "@DSRC.ConnectionManeuverAssist");
single_value->field_waitOnStop.check_restriction(t_res, t_name ? t_name : "@DSRC.ConnectionManeuverAssist");
single_value->field_pedBicycleDetect.check_restriction(t_res, t_name ? t_name : "@DSRC.ConnectionManeuverAssist");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.ConnectionManeuverAssist");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.ConnectionManeuverAssist");
}

boolean ConnectionManeuverAssist_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ConnectionManeuverAssist_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

IntersectionState::IntersectionState()
{
  bound_flag = FALSE;
}

IntersectionState::IntersectionState(const OPTIONAL<CHARSTRING>& par_name,
    const IntersectionReferenceID& par_id,
    const INTEGER& par_revision,
    const BITSTRING& par_status,
    const OPTIONAL<INTEGER>& par_moy,
    const OPTIONAL<INTEGER>& par_timeStamp,
    const OPTIONAL<EnabledLaneList>& par_enabledLanes,
    const MovementList& par_states,
    const OPTIONAL<ManeuverAssistList>& par_maneuverAssistList,
    const OPTIONAL<OCTETSTRING>& par_priority,
    const OPTIONAL<OCTETSTRING>& par_preempt,
    const OPTIONAL<REG__D::Reg__IntersectionState>& par_regional)
  :   field_name(par_name),
  field_id(par_id),
  field_revision(par_revision),
  field_status(par_status),
  field_moy(par_moy),
  field_timeStamp(par_timeStamp),
  field_enabledLanes(par_enabledLanes),
  field_states(par_states),
  field_maneuverAssistList(par_maneuverAssistList),
  field_priority(par_priority),
  field_preempt(par_preempt),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

IntersectionState::IntersectionState(const IntersectionState& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.IntersectionState.");
bound_flag = TRUE;
if (other_value.name().is_bound()) field_name = other_value.name();
else field_name.clean_up();
if (other_value.id().is_bound()) field_id = other_value.id();
else field_id.clean_up();
if (other_value.revision().is_bound()) field_revision = other_value.revision();
else field_revision.clean_up();
if (other_value.status().is_bound()) field_status = other_value.status();
else field_status.clean_up();
if (other_value.moy().is_bound()) field_moy = other_value.moy();
else field_moy.clean_up();
if (other_value.timeStamp().is_bound()) field_timeStamp = other_value.timeStamp();
else field_timeStamp.clean_up();
if (other_value.enabledLanes().is_bound()) field_enabledLanes = other_value.enabledLanes();
else field_enabledLanes.clean_up();
if (other_value.states().is_bound()) field_states = other_value.states();
else field_states.clean_up();
if (other_value.maneuverAssistList().is_bound()) field_maneuverAssistList = other_value.maneuverAssistList();
else field_maneuverAssistList.clean_up();
if (other_value.priority().is_bound()) field_priority = other_value.priority();
else field_priority.clean_up();
if (other_value.preempt().is_bound()) field_preempt = other_value.preempt();
else field_preempt.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void IntersectionState::clean_up()
{
field_name.clean_up();
field_id.clean_up();
field_revision.clean_up();
field_status.clean_up();
field_moy.clean_up();
field_timeStamp.clean_up();
field_enabledLanes.clean_up();
field_states.clean_up();
field_maneuverAssistList.clean_up();
field_priority.clean_up();
field_preempt.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

IntersectionState& IntersectionState::operator=(const IntersectionState& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.IntersectionState.");
  bound_flag = TRUE;
  if (other_value.name().is_bound()) field_name = other_value.name();
  else field_name.clean_up();
  if (other_value.id().is_bound()) field_id = other_value.id();
  else field_id.clean_up();
  if (other_value.revision().is_bound()) field_revision = other_value.revision();
  else field_revision.clean_up();
  if (other_value.status().is_bound()) field_status = other_value.status();
  else field_status.clean_up();
  if (other_value.moy().is_bound()) field_moy = other_value.moy();
  else field_moy.clean_up();
  if (other_value.timeStamp().is_bound()) field_timeStamp = other_value.timeStamp();
  else field_timeStamp.clean_up();
  if (other_value.enabledLanes().is_bound()) field_enabledLanes = other_value.enabledLanes();
  else field_enabledLanes.clean_up();
  if (other_value.states().is_bound()) field_states = other_value.states();
  else field_states.clean_up();
  if (other_value.maneuverAssistList().is_bound()) field_maneuverAssistList = other_value.maneuverAssistList();
  else field_maneuverAssistList.clean_up();
  if (other_value.priority().is_bound()) field_priority = other_value.priority();
  else field_priority.clean_up();
  if (other_value.preempt().is_bound()) field_preempt = other_value.preempt();
  else field_preempt.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean IntersectionState::operator==(const IntersectionState& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_name==other_value.field_name
  && field_id==other_value.field_id
  && field_revision==other_value.field_revision
  && field_status==other_value.field_status
  && field_moy==other_value.field_moy
  && field_timeStamp==other_value.field_timeStamp
  && field_enabledLanes==other_value.field_enabledLanes
  && field_states==other_value.field_states
  && field_maneuverAssistList==other_value.field_maneuverAssistList
  && field_priority==other_value.field_priority
  && field_preempt==other_value.field_preempt
  && field_regional==other_value.field_regional;
}

boolean IntersectionState::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_name.get_selection() || field_name.is_bound()) return TRUE;
if(field_id.is_bound()) return TRUE;
if(field_revision.is_bound()) return TRUE;
if(field_status.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_moy.get_selection() || field_moy.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_timeStamp.get_selection() || field_timeStamp.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_enabledLanes.get_selection() || field_enabledLanes.is_bound()) return TRUE;
if(field_states.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_maneuverAssistList.get_selection() || field_maneuverAssistList.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_priority.get_selection() || field_priority.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_preempt.get_selection() || field_preempt.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean IntersectionState::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_name.get_selection() && !field_name.is_value()) return FALSE;
if(!field_id.is_value()) return FALSE;
if(!field_revision.is_value()) return FALSE;
if(!field_status.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_moy.get_selection() && !field_moy.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_timeStamp.get_selection() && !field_timeStamp.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_enabledLanes.get_selection() && !field_enabledLanes.is_value()) return FALSE;
if(!field_states.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_maneuverAssistList.get_selection() && !field_maneuverAssistList.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_priority.get_selection() && !field_priority.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_preempt.get_selection() && !field_preempt.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int IntersectionState::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.IntersectionState");
  int ret_val = 4;
  if (field_name.ispresent()) ret_val++;
  if (field_moy.ispresent()) ret_val++;
  if (field_timeStamp.ispresent()) ret_val++;
  if (field_enabledLanes.ispresent()) ret_val++;
  if (field_maneuverAssistList.ispresent()) ret_val++;
  if (field_priority.ispresent()) ret_val++;
  if (field_preempt.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void IntersectionState::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ name := ");
field_name.log();
TTCN_Logger::log_event_str(", id := ");
field_id.log();
TTCN_Logger::log_event_str(", revision := ");
field_revision.log();
TTCN_Logger::log_event_str(", status := ");
field_status.log();
TTCN_Logger::log_event_str(", moy := ");
field_moy.log();
TTCN_Logger::log_event_str(", timeStamp := ");
field_timeStamp.log();
TTCN_Logger::log_event_str(", enabledLanes := ");
field_enabledLanes.log();
TTCN_Logger::log_event_str(", states := ");
field_states.log();
TTCN_Logger::log_event_str(", maneuverAssistList := ");
field_maneuverAssistList.log();
TTCN_Logger::log_event_str(", priority := ");
field_priority.log();
TTCN_Logger::log_event_str(", preempt := ");
field_preempt.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void IntersectionState::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.IntersectionState'");
    }
    if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("revision", param_field) == 0) {
      revision().set_param(param);
      return;
    } else if (strcmp("status", param_field) == 0) {
      status().set_param(param);
      return;
    } else if (strcmp("moy", param_field) == 0) {
      moy().set_param(param);
      return;
    } else if (strcmp("timeStamp", param_field) == 0) {
      timeStamp().set_param(param);
      return;
    } else if (strcmp("enabledLanes", param_field) == 0) {
      enabledLanes().set_param(param);
      return;
    } else if (strcmp("states", param_field) == 0) {
      states().set_param(param);
      return;
    } else if (strcmp("maneuverAssistList", param_field) == 0) {
      maneuverAssistList().set_param(param);
      return;
    } else if (strcmp("priority", param_field) == 0) {
      priority().set_param(param);
      return;
    } else if (strcmp("preempt", param_field) == 0) {
      preempt().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.IntersectionState'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (12<mp->get_size()) {
      param.error("record value of type @DSRC.IntersectionState has 12 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) revision().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) status().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) moy().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) timeStamp().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) enabledLanes().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) states().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) maneuverAssistList().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) priority().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) preempt().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(11));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "revision")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          revision().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "status")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          status().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "moy")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          moy().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "timeStamp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          timeStamp().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enabledLanes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enabledLanes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "states")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          states().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maneuverAssistList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maneuverAssistList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "priority")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          priority().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "preempt")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          preempt().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.IntersectionState: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.IntersectionState");
  }
}

Module_Param* IntersectionState::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.IntersectionState'");
    }
    if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else if (strcmp("revision", param_field) == 0) {
      return revision().get_param(param_name);
    } else if (strcmp("status", param_field) == 0) {
      return status().get_param(param_name);
    } else if (strcmp("moy", param_field) == 0) {
      return moy().get_param(param_name);
    } else if (strcmp("timeStamp", param_field) == 0) {
      return timeStamp().get_param(param_name);
    } else if (strcmp("enabledLanes", param_field) == 0) {
      return enabledLanes().get_param(param_name);
    } else if (strcmp("states", param_field) == 0) {
      return states().get_param(param_name);
    } else if (strcmp("maneuverAssistList", param_field) == 0) {
      return maneuverAssistList().get_param(param_name);
    } else if (strcmp("priority", param_field) == 0) {
      return priority().get_param(param_name);
    } else if (strcmp("preempt", param_field) == 0) {
      return preempt().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.IntersectionState'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_name = field_name.get_param(param_name);
  mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
  mp->add_elem(mp_field_name);
  Module_Param* mp_field_id = field_id.get_param(param_name);
  mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
  mp->add_elem(mp_field_id);
  Module_Param* mp_field_revision = field_revision.get_param(param_name);
  mp_field_revision->set_id(new Module_Param_FieldName(mcopystr("revision")));
  mp->add_elem(mp_field_revision);
  Module_Param* mp_field_status = field_status.get_param(param_name);
  mp_field_status->set_id(new Module_Param_FieldName(mcopystr("status")));
  mp->add_elem(mp_field_status);
  Module_Param* mp_field_moy = field_moy.get_param(param_name);
  mp_field_moy->set_id(new Module_Param_FieldName(mcopystr("moy")));
  mp->add_elem(mp_field_moy);
  Module_Param* mp_field_timeStamp = field_timeStamp.get_param(param_name);
  mp_field_timeStamp->set_id(new Module_Param_FieldName(mcopystr("timeStamp")));
  mp->add_elem(mp_field_timeStamp);
  Module_Param* mp_field_enabledLanes = field_enabledLanes.get_param(param_name);
  mp_field_enabledLanes->set_id(new Module_Param_FieldName(mcopystr("enabledLanes")));
  mp->add_elem(mp_field_enabledLanes);
  Module_Param* mp_field_states = field_states.get_param(param_name);
  mp_field_states->set_id(new Module_Param_FieldName(mcopystr("states")));
  mp->add_elem(mp_field_states);
  Module_Param* mp_field_maneuverAssistList = field_maneuverAssistList.get_param(param_name);
  mp_field_maneuverAssistList->set_id(new Module_Param_FieldName(mcopystr("maneuverAssistList")));
  mp->add_elem(mp_field_maneuverAssistList);
  Module_Param* mp_field_priority = field_priority.get_param(param_name);
  mp_field_priority->set_id(new Module_Param_FieldName(mcopystr("priority")));
  mp->add_elem(mp_field_priority);
  Module_Param* mp_field_preempt = field_preempt.get_param(param_name);
  mp_field_preempt->set_id(new Module_Param_FieldName(mcopystr("preempt")));
  mp->add_elem(mp_field_preempt);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void IntersectionState::set_implicit_omit()
{
if (!name().is_bound()) name() = OMIT_VALUE;
else name().set_implicit_omit();
if (id().is_bound()) id().set_implicit_omit();
if (revision().is_bound()) revision().set_implicit_omit();
if (status().is_bound()) status().set_implicit_omit();
if (!moy().is_bound()) moy() = OMIT_VALUE;
else moy().set_implicit_omit();
if (!timeStamp().is_bound()) timeStamp() = OMIT_VALUE;
else timeStamp().set_implicit_omit();
if (!enabledLanes().is_bound()) enabledLanes() = OMIT_VALUE;
else enabledLanes().set_implicit_omit();
if (states().is_bound()) states().set_implicit_omit();
if (!maneuverAssistList().is_bound()) maneuverAssistList() = OMIT_VALUE;
else maneuverAssistList().set_implicit_omit();
if (!priority().is_bound()) priority() = OMIT_VALUE;
else priority().set_implicit_omit();
if (!preempt().is_bound()) preempt() = OMIT_VALUE;
else preempt().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void IntersectionState::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.IntersectionState.");
field_name.encode_text(text_buf);
field_id.encode_text(text_buf);
field_revision.encode_text(text_buf);
field_status.encode_text(text_buf);
field_moy.encode_text(text_buf);
field_timeStamp.encode_text(text_buf);
field_enabledLanes.encode_text(text_buf);
field_states.encode_text(text_buf);
field_maneuverAssistList.encode_text(text_buf);
field_priority.encode_text(text_buf);
field_preempt.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void IntersectionState::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_name.decode_text(text_buf);
field_id.decode_text(text_buf);
field_revision.decode_text(text_buf);
field_status.decode_text(text_buf);
field_moy.decode_text(text_buf);
field_timeStamp.decode_text(text_buf);
field_enabledLanes.decode_text(text_buf);
field_states.decode_text(text_buf);
field_maneuverAssistList.decode_text(text_buf);
field_priority.decode_text(text_buf);
field_preempt.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void IntersectionState::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IntersectionState::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* IntersectionState::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("name': ");
  new_tlv->add_TLV(field_name.BER_encode_TLV(IntersectionState_name_descr_, p_coding));
  ec_1.set_msg("id': ");
  new_tlv->add_TLV(field_id.BER_encode_TLV(IntersectionState_id_descr_, p_coding));
  ec_1.set_msg("revision': ");
  new_tlv->add_TLV(field_revision.BER_encode_TLV(IntersectionState_revision_descr_, p_coding));
  ec_1.set_msg("status': ");
  new_tlv->add_TLV(field_status.BER_encode_TLV(IntersectionState_status_descr_, p_coding));
  ec_1.set_msg("moy': ");
  new_tlv->add_TLV(field_moy.BER_encode_TLV(IntersectionState_moy_descr_, p_coding));
  ec_1.set_msg("timeStamp': ");
  new_tlv->add_TLV(field_timeStamp.BER_encode_TLV(IntersectionState_timeStamp_descr_, p_coding));
  ec_1.set_msg("enabledLanes': ");
  new_tlv->add_TLV(field_enabledLanes.BER_encode_TLV(IntersectionState_enabledLanes_descr_, p_coding));
  ec_1.set_msg("states': ");
  new_tlv->add_TLV(field_states.BER_encode_TLV(IntersectionState_states_descr_, p_coding));
  ec_1.set_msg("maneuverAssistList': ");
  new_tlv->add_TLV(field_maneuverAssistList.BER_encode_TLV(IntersectionState_maneuverAssistList_descr_, p_coding));
  ec_1.set_msg("priority': ");
  new_tlv->add_TLV(field_priority.BER_encode_TLV(IntersectionState_priority_descr_, p_coding));
  ec_1.set_msg("preempt': ");
  new_tlv->add_TLV(field_preempt.BER_encode_TLV(IntersectionState_preempt_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(IntersectionState_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean IntersectionState::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.IntersectionState' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("name': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_name=OMIT_VALUE;
    else {
      field_name.BER_decode_TLV(IntersectionState_name_descr_, tmp_tlv, L_form);
      if(field_name.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("id': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_id.BER_decode_TLV(IntersectionState_id_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("revision': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_revision.BER_decode_TLV(IntersectionState_revision_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("status': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_status.BER_decode_TLV(IntersectionState_status_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("moy': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_moy=OMIT_VALUE;
    else {
      field_moy.BER_decode_TLV(IntersectionState_moy_descr_, tmp_tlv, L_form);
      if(field_moy.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("timeStamp': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_timeStamp=OMIT_VALUE;
    else {
      field_timeStamp.BER_decode_TLV(IntersectionState_timeStamp_descr_, tmp_tlv, L_form);
      if(field_timeStamp.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("enabledLanes': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_enabledLanes=OMIT_VALUE;
    else {
      field_enabledLanes.BER_decode_TLV(IntersectionState_enabledLanes_descr_, tmp_tlv, L_form);
      if(field_enabledLanes.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("states': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_states.BER_decode_TLV(IntersectionState_states_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("maneuverAssistList': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_maneuverAssistList=OMIT_VALUE;
    else {
      field_maneuverAssistList.BER_decode_TLV(IntersectionState_maneuverAssistList_descr_, tmp_tlv, L_form);
      if(field_maneuverAssistList.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("priority': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_priority=OMIT_VALUE;
    else {
      field_priority.BER_decode_TLV(IntersectionState_priority_descr_, tmp_tlv, L_form);
      if(field_priority.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("preempt': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_preempt=OMIT_VALUE;
    else {
      field_preempt.BER_decode_TLV(IntersectionState_preempt_descr_, tmp_tlv, L_form);
      if(field_preempt.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(IntersectionState_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int IntersectionState::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.IntersectionState.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_name.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "name");
    enc_len += field_name.JSON_encode(IntersectionState_name_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "id");
    enc_len += field_id.JSON_encode(IntersectionState_id_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "revision");
    enc_len += field_revision.JSON_encode(IntersectionState_revision_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "status");
    enc_len += field_status.JSON_encode(IntersectionState_status_descr_, p_tok);
  }

  if (field_moy.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "moy");
    enc_len += field_moy.JSON_encode(IntersectionState_moy_descr_, p_tok);
  }

  if (field_timeStamp.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "timeStamp");
    enc_len += field_timeStamp.JSON_encode(IntersectionState_timeStamp_descr_, p_tok);
  }

  if (field_enabledLanes.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "enabledLanes");
    enc_len += field_enabledLanes.JSON_encode(IntersectionState_enabledLanes_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "states");
    enc_len += field_states.JSON_encode(IntersectionState_states_descr_, p_tok);
  }

  if (field_maneuverAssistList.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "maneuverAssistList");
    enc_len += field_maneuverAssistList.JSON_encode(IntersectionState_maneuverAssistList_descr_, p_tok);
  }

  if (field_priority.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "priority");
    enc_len += field_priority.JSON_encode(IntersectionState_priority_descr_, p_tok);
  }

  if (field_preempt.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "preempt");
    enc_len += field_preempt.JSON_encode(IntersectionState_preempt_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(IntersectionState_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IntersectionState::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (4 == name_len && 0 == strncmp(fld_name, "name", name_len)) {
         int ret_val = field_name.JSON_decode(IntersectionState_name_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "name");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (2 == name_len && 0 == strncmp(fld_name, "id", name_len)) {
         int ret_val = field_id.JSON_decode(IntersectionState_id_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "id");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "revision", name_len)) {
         int ret_val = field_revision.JSON_decode(IntersectionState_revision_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "revision");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "status", name_len)) {
         int ret_val = field_status.JSON_decode(IntersectionState_status_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "status");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (3 == name_len && 0 == strncmp(fld_name, "moy", name_len)) {
         int ret_val = field_moy.JSON_decode(IntersectionState_moy_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "moy");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "timeStamp", name_len)) {
         int ret_val = field_timeStamp.JSON_decode(IntersectionState_timeStamp_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "timeStamp");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "enabledLanes", name_len)) {
         int ret_val = field_enabledLanes.JSON_decode(IntersectionState_enabledLanes_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "enabledLanes");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "states", name_len)) {
         int ret_val = field_states.JSON_decode(IntersectionState_states_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "states");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "maneuverAssistList", name_len)) {
         int ret_val = field_maneuverAssistList.JSON_decode(IntersectionState_maneuverAssistList_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "maneuverAssistList");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "priority", name_len)) {
         int ret_val = field_priority.JSON_decode(IntersectionState_priority_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "priority");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "preempt", name_len)) {
         int ret_val = field_preempt.JSON_decode(IntersectionState_preempt_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "preempt");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(IntersectionState_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_name.is_bound()) {
    field_name = OMIT_VALUE;
  }
if (!field_id.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "id");
    return JSON_ERROR_FATAL;
  }
if (!field_revision.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "revision");
    return JSON_ERROR_FATAL;
  }
if (!field_status.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "status");
    return JSON_ERROR_FATAL;
  }
if (!field_moy.is_bound()) {
    field_moy = OMIT_VALUE;
  }
if (!field_timeStamp.is_bound()) {
    field_timeStamp = OMIT_VALUE;
  }
if (!field_enabledLanes.is_bound()) {
    field_enabledLanes = OMIT_VALUE;
  }
if (!field_states.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "states");
    return JSON_ERROR_FATAL;
  }
if (!field_maneuverAssistList.is_bound()) {
    field_maneuverAssistList = OMIT_VALUE;
  }
if (!field_priority.is_bound()) {
    field_priority = OMIT_VALUE;
  }
if (!field_preempt.is_bound()) {
    field_preempt = OMIT_VALUE;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct IntersectionState_template::single_value_struct {
CHARSTRING_template field_name;
IntersectionReferenceID_template field_id;
INTEGER_template field_revision;
BITSTRING_template field_status;
INTEGER_template field_moy;
INTEGER_template field_timeStamp;
EnabledLaneList_template field_enabledLanes;
MovementList_template field_states;
ManeuverAssistList_template field_maneuverAssistList;
OCTETSTRING_template field_priority;
OCTETSTRING_template field_preempt;
REG__D::Reg__IntersectionState_template field_regional;
};

void IntersectionState_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_name = ANY_OR_OMIT;
single_value->field_id = ANY_VALUE;
single_value->field_revision = ANY_VALUE;
single_value->field_status = ANY_VALUE;
single_value->field_moy = ANY_OR_OMIT;
single_value->field_timeStamp = ANY_OR_OMIT;
single_value->field_enabledLanes = ANY_OR_OMIT;
single_value->field_states = ANY_VALUE;
single_value->field_maneuverAssistList = ANY_OR_OMIT;
single_value->field_priority = ANY_OR_OMIT;
single_value->field_preempt = ANY_OR_OMIT;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void IntersectionState_template::copy_value(const IntersectionState& other_value)
{
single_value = new single_value_struct;
if (other_value.name().is_bound()) {
  if (other_value.name().ispresent()) single_value->field_name = other_value.name()();
  else single_value->field_name = OMIT_VALUE;
} else {
  single_value->field_name.clean_up();
}
if (other_value.id().is_bound()) {
  single_value->field_id = other_value.id();
} else {
  single_value->field_id.clean_up();
}
if (other_value.revision().is_bound()) {
  single_value->field_revision = other_value.revision();
} else {
  single_value->field_revision.clean_up();
}
if (other_value.status().is_bound()) {
  single_value->field_status = other_value.status();
} else {
  single_value->field_status.clean_up();
}
if (other_value.moy().is_bound()) {
  if (other_value.moy().ispresent()) single_value->field_moy = other_value.moy()();
  else single_value->field_moy = OMIT_VALUE;
} else {
  single_value->field_moy.clean_up();
}
if (other_value.timeStamp().is_bound()) {
  if (other_value.timeStamp().ispresent()) single_value->field_timeStamp = other_value.timeStamp()();
  else single_value->field_timeStamp = OMIT_VALUE;
} else {
  single_value->field_timeStamp.clean_up();
}
if (other_value.enabledLanes().is_bound()) {
  if (other_value.enabledLanes().ispresent()) single_value->field_enabledLanes = other_value.enabledLanes()();
  else single_value->field_enabledLanes = OMIT_VALUE;
} else {
  single_value->field_enabledLanes.clean_up();
}
if (other_value.states().is_bound()) {
  single_value->field_states = other_value.states();
} else {
  single_value->field_states.clean_up();
}
if (other_value.maneuverAssistList().is_bound()) {
  if (other_value.maneuverAssistList().ispresent()) single_value->field_maneuverAssistList = other_value.maneuverAssistList()();
  else single_value->field_maneuverAssistList = OMIT_VALUE;
} else {
  single_value->field_maneuverAssistList.clean_up();
}
if (other_value.priority().is_bound()) {
  if (other_value.priority().ispresent()) single_value->field_priority = other_value.priority()();
  else single_value->field_priority = OMIT_VALUE;
} else {
  single_value->field_priority.clean_up();
}
if (other_value.preempt().is_bound()) {
  if (other_value.preempt().ispresent()) single_value->field_preempt = other_value.preempt()();
  else single_value->field_preempt = OMIT_VALUE;
} else {
  single_value->field_preempt.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IntersectionState_template::copy_template(const IntersectionState_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.name().get_selection()) {
single_value->field_name = other_value.name();
} else {
single_value->field_name.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.id().get_selection()) {
single_value->field_id = other_value.id();
} else {
single_value->field_id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.revision().get_selection()) {
single_value->field_revision = other_value.revision();
} else {
single_value->field_revision.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.status().get_selection()) {
single_value->field_status = other_value.status();
} else {
single_value->field_status.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.moy().get_selection()) {
single_value->field_moy = other_value.moy();
} else {
single_value->field_moy.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.timeStamp().get_selection()) {
single_value->field_timeStamp = other_value.timeStamp();
} else {
single_value->field_timeStamp.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.enabledLanes().get_selection()) {
single_value->field_enabledLanes = other_value.enabledLanes();
} else {
single_value->field_enabledLanes.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.states().get_selection()) {
single_value->field_states = other_value.states();
} else {
single_value->field_states.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.maneuverAssistList().get_selection()) {
single_value->field_maneuverAssistList = other_value.maneuverAssistList();
} else {
single_value->field_maneuverAssistList.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.priority().get_selection()) {
single_value->field_priority = other_value.priority();
} else {
single_value->field_priority.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.preempt().get_selection()) {
single_value->field_preempt = other_value.preempt();
} else {
single_value->field_preempt.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IntersectionState_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.IntersectionState.");
break;
}
set_selection(other_value);
}

IntersectionState_template::IntersectionState_template()
{
}

IntersectionState_template::IntersectionState_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IntersectionState_template::IntersectionState_template(const IntersectionState& other_value)
{
copy_value(other_value);
}

IntersectionState_template::IntersectionState_template(const OPTIONAL<IntersectionState>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionState&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.IntersectionState from an unbound optional field.");
}
}

IntersectionState_template::IntersectionState_template(const IntersectionState_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IntersectionState_template::~IntersectionState_template()
{
clean_up();
}

IntersectionState_template& IntersectionState_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IntersectionState_template& IntersectionState_template::operator=(const IntersectionState& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IntersectionState_template& IntersectionState_template::operator=(const OPTIONAL<IntersectionState>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IntersectionState&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.IntersectionState.");
}
return *this;
}

IntersectionState_template& IntersectionState_template::operator=(const IntersectionState_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IntersectionState_template::match(const IntersectionState& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.name().is_bound()) return FALSE;
if((other_value.name().ispresent() ? !single_value->field_name.match((const CHARSTRING&)other_value.name(), legacy) : !single_value->field_name.match_omit(legacy)))return FALSE;
if(!other_value.id().is_bound()) return FALSE;
if(!single_value->field_id.match(other_value.id(), legacy))return FALSE;
if(!other_value.revision().is_bound()) return FALSE;
if(!single_value->field_revision.match(other_value.revision(), legacy))return FALSE;
if(!other_value.status().is_bound()) return FALSE;
if(!single_value->field_status.match(other_value.status(), legacy))return FALSE;
if(!other_value.moy().is_bound()) return FALSE;
if((other_value.moy().ispresent() ? !single_value->field_moy.match((const INTEGER&)other_value.moy(), legacy) : !single_value->field_moy.match_omit(legacy)))return FALSE;
if(!other_value.timeStamp().is_bound()) return FALSE;
if((other_value.timeStamp().ispresent() ? !single_value->field_timeStamp.match((const INTEGER&)other_value.timeStamp(), legacy) : !single_value->field_timeStamp.match_omit(legacy)))return FALSE;
if(!other_value.enabledLanes().is_bound()) return FALSE;
if((other_value.enabledLanes().ispresent() ? !single_value->field_enabledLanes.match((const EnabledLaneList&)other_value.enabledLanes(), legacy) : !single_value->field_enabledLanes.match_omit(legacy)))return FALSE;
if(!other_value.states().is_bound()) return FALSE;
if(!single_value->field_states.match(other_value.states(), legacy))return FALSE;
if(!other_value.maneuverAssistList().is_bound()) return FALSE;
if((other_value.maneuverAssistList().ispresent() ? !single_value->field_maneuverAssistList.match((const ManeuverAssistList&)other_value.maneuverAssistList(), legacy) : !single_value->field_maneuverAssistList.match_omit(legacy)))return FALSE;
if(!other_value.priority().is_bound()) return FALSE;
if((other_value.priority().ispresent() ? !single_value->field_priority.match((const OCTETSTRING&)other_value.priority(), legacy) : !single_value->field_priority.match_omit(legacy)))return FALSE;
if(!other_value.preempt().is_bound()) return FALSE;
if((other_value.preempt().ispresent() ? !single_value->field_preempt.match((const OCTETSTRING&)other_value.preempt(), legacy) : !single_value->field_preempt.match_omit(legacy)))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REG__D::Reg__IntersectionState&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.IntersectionState.");
}
return FALSE;
}

boolean IntersectionState_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_name.is_omit() || single_value->field_name.is_bound()) return TRUE;
if (single_value->field_id.is_bound()) return TRUE;
if (single_value->field_revision.is_bound()) return TRUE;
if (single_value->field_status.is_bound()) return TRUE;
if (single_value->field_moy.is_omit() || single_value->field_moy.is_bound()) return TRUE;
if (single_value->field_timeStamp.is_omit() || single_value->field_timeStamp.is_bound()) return TRUE;
if (single_value->field_enabledLanes.is_omit() || single_value->field_enabledLanes.is_bound()) return TRUE;
if (single_value->field_states.is_bound()) return TRUE;
if (single_value->field_maneuverAssistList.is_omit() || single_value->field_maneuverAssistList.is_bound()) return TRUE;
if (single_value->field_priority.is_omit() || single_value->field_priority.is_bound()) return TRUE;
if (single_value->field_preempt.is_omit() || single_value->field_preempt.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean IntersectionState_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_name.is_omit() && !single_value->field_name.is_value()) return FALSE;
if (!single_value->field_id.is_value()) return FALSE;
if (!single_value->field_revision.is_value()) return FALSE;
if (!single_value->field_status.is_value()) return FALSE;
if (!single_value->field_moy.is_omit() && !single_value->field_moy.is_value()) return FALSE;
if (!single_value->field_timeStamp.is_omit() && !single_value->field_timeStamp.is_value()) return FALSE;
if (!single_value->field_enabledLanes.is_omit() && !single_value->field_enabledLanes.is_value()) return FALSE;
if (!single_value->field_states.is_value()) return FALSE;
if (!single_value->field_maneuverAssistList.is_omit() && !single_value->field_maneuverAssistList.is_value()) return FALSE;
if (!single_value->field_priority.is_omit() && !single_value->field_priority.is_value()) return FALSE;
if (!single_value->field_preempt.is_omit() && !single_value->field_preempt.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void IntersectionState_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IntersectionState IntersectionState_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.IntersectionState.");
IntersectionState ret_val;
if (single_value->field_name.is_omit()) ret_val.name() = OMIT_VALUE;
else if (single_value->field_name.is_bound()) {
ret_val.name() = single_value->field_name.valueof();
}
if (single_value->field_id.is_bound()) {
ret_val.id() = single_value->field_id.valueof();
}
if (single_value->field_revision.is_bound()) {
ret_val.revision() = single_value->field_revision.valueof();
}
if (single_value->field_status.is_bound()) {
ret_val.status() = single_value->field_status.valueof();
}
if (single_value->field_moy.is_omit()) ret_val.moy() = OMIT_VALUE;
else if (single_value->field_moy.is_bound()) {
ret_val.moy() = single_value->field_moy.valueof();
}
if (single_value->field_timeStamp.is_omit()) ret_val.timeStamp() = OMIT_VALUE;
else if (single_value->field_timeStamp.is_bound()) {
ret_val.timeStamp() = single_value->field_timeStamp.valueof();
}
if (single_value->field_enabledLanes.is_omit()) ret_val.enabledLanes() = OMIT_VALUE;
else if (single_value->field_enabledLanes.is_bound()) {
ret_val.enabledLanes() = single_value->field_enabledLanes.valueof();
}
if (single_value->field_states.is_bound()) {
ret_val.states() = single_value->field_states.valueof();
}
if (single_value->field_maneuverAssistList.is_omit()) ret_val.maneuverAssistList() = OMIT_VALUE;
else if (single_value->field_maneuverAssistList.is_bound()) {
ret_val.maneuverAssistList() = single_value->field_maneuverAssistList.valueof();
}
if (single_value->field_priority.is_omit()) ret_val.priority() = OMIT_VALUE;
else if (single_value->field_priority.is_bound()) {
ret_val.priority() = single_value->field_priority.valueof();
}
if (single_value->field_preempt.is_omit()) ret_val.preempt() = OMIT_VALUE;
else if (single_value->field_preempt.is_bound()) {
ret_val.preempt() = single_value->field_preempt.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void IntersectionState_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.IntersectionState.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IntersectionState_template[list_length];
}

IntersectionState_template& IntersectionState_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.IntersectionState.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.IntersectionState.");
return value_list.list_value[list_index];
}

CHARSTRING_template& IntersectionState_template::name()
{
set_specific();
return single_value->field_name;
}

const CHARSTRING_template& IntersectionState_template::name() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field name of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_name;
}

IntersectionReferenceID_template& IntersectionState_template::id()
{
set_specific();
return single_value->field_id;
}

const IntersectionReferenceID_template& IntersectionState_template::id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field id of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_id;
}

INTEGER_template& IntersectionState_template::revision()
{
set_specific();
return single_value->field_revision;
}

const INTEGER_template& IntersectionState_template::revision() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field revision of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_revision;
}

BITSTRING_template& IntersectionState_template::status()
{
set_specific();
return single_value->field_status;
}

const BITSTRING_template& IntersectionState_template::status() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field status of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_status;
}

INTEGER_template& IntersectionState_template::moy()
{
set_specific();
return single_value->field_moy;
}

const INTEGER_template& IntersectionState_template::moy() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field moy of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_moy;
}

INTEGER_template& IntersectionState_template::timeStamp()
{
set_specific();
return single_value->field_timeStamp;
}

const INTEGER_template& IntersectionState_template::timeStamp() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field timeStamp of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_timeStamp;
}

EnabledLaneList_template& IntersectionState_template::enabledLanes()
{
set_specific();
return single_value->field_enabledLanes;
}

const EnabledLaneList_template& IntersectionState_template::enabledLanes() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field enabledLanes of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_enabledLanes;
}

MovementList_template& IntersectionState_template::states()
{
set_specific();
return single_value->field_states;
}

const MovementList_template& IntersectionState_template::states() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field states of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_states;
}

ManeuverAssistList_template& IntersectionState_template::maneuverAssistList()
{
set_specific();
return single_value->field_maneuverAssistList;
}

const ManeuverAssistList_template& IntersectionState_template::maneuverAssistList() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field maneuverAssistList of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_maneuverAssistList;
}

OCTETSTRING_template& IntersectionState_template::priority()
{
set_specific();
return single_value->field_priority;
}

const OCTETSTRING_template& IntersectionState_template::priority() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field priority of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_priority;
}

OCTETSTRING_template& IntersectionState_template::preempt()
{
set_specific();
return single_value->field_preempt;
}

const OCTETSTRING_template& IntersectionState_template::preempt() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field preempt of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_preempt;
}

REG__D::Reg__IntersectionState_template& IntersectionState_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REG__D::Reg__IntersectionState_template& IntersectionState_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.IntersectionState.");
return single_value->field_regional;
}

int IntersectionState_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionState which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 4;
      if (single_value->field_name.is_present()) ret_val++;
      if (single_value->field_moy.is_present()) ret_val++;
      if (single_value->field_timeStamp.is_present()) ret_val++;
      if (single_value->field_enabledLanes.is_present()) ret_val++;
      if (single_value->field_maneuverAssistList.is_present()) ret_val++;
      if (single_value->field_priority.is_present()) ret_val++;
      if (single_value->field_preempt.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.IntersectionState containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionState containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionState containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionState containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.IntersectionState containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.IntersectionState.");
  }
  return 0;
}

void IntersectionState_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ name := ");
single_value->field_name.log();
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log();
TTCN_Logger::log_event_str(", revision := ");
single_value->field_revision.log();
TTCN_Logger::log_event_str(", status := ");
single_value->field_status.log();
TTCN_Logger::log_event_str(", moy := ");
single_value->field_moy.log();
TTCN_Logger::log_event_str(", timeStamp := ");
single_value->field_timeStamp.log();
TTCN_Logger::log_event_str(", enabledLanes := ");
single_value->field_enabledLanes.log();
TTCN_Logger::log_event_str(", states := ");
single_value->field_states.log();
TTCN_Logger::log_event_str(", maneuverAssistList := ");
single_value->field_maneuverAssistList.log();
TTCN_Logger::log_event_str(", priority := ");
single_value->field_priority.log();
TTCN_Logger::log_event_str(", preempt := ");
single_value->field_preempt.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IntersectionState_template::log_match(const IntersectionState& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.name().ispresent()){
if(!single_value->field_name.match(match_value.name(), legacy)){
TTCN_Logger::log_logmatch_info(".name");
single_value->field_name.log_match(match_value.name(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_name.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".name := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_name.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_id.match(match_value.id(), legacy)){
TTCN_Logger::log_logmatch_info(".id");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_revision.match(match_value.revision(), legacy)){
TTCN_Logger::log_logmatch_info(".revision");
single_value->field_revision.log_match(match_value.revision(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_status.match(match_value.status(), legacy)){
TTCN_Logger::log_logmatch_info(".status");
single_value->field_status.log_match(match_value.status(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.moy().ispresent()){
if(!single_value->field_moy.match(match_value.moy(), legacy)){
TTCN_Logger::log_logmatch_info(".moy");
single_value->field_moy.log_match(match_value.moy(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_moy.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".moy := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_moy.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.timeStamp().ispresent()){
if(!single_value->field_timeStamp.match(match_value.timeStamp(), legacy)){
TTCN_Logger::log_logmatch_info(".timeStamp");
single_value->field_timeStamp.log_match(match_value.timeStamp(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_timeStamp.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".timeStamp := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_timeStamp.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.enabledLanes().ispresent()){
if(!single_value->field_enabledLanes.match(match_value.enabledLanes(), legacy)){
TTCN_Logger::log_logmatch_info(".enabledLanes");
single_value->field_enabledLanes.log_match(match_value.enabledLanes(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_enabledLanes.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".enabledLanes := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_enabledLanes.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_states.match(match_value.states(), legacy)){
TTCN_Logger::log_logmatch_info(".states");
single_value->field_states.log_match(match_value.states(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.maneuverAssistList().ispresent()){
if(!single_value->field_maneuverAssistList.match(match_value.maneuverAssistList(), legacy)){
TTCN_Logger::log_logmatch_info(".maneuverAssistList");
single_value->field_maneuverAssistList.log_match(match_value.maneuverAssistList(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_maneuverAssistList.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".maneuverAssistList := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_maneuverAssistList.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.priority().ispresent()){
if(!single_value->field_priority.match(match_value.priority(), legacy)){
TTCN_Logger::log_logmatch_info(".priority");
single_value->field_priority.log_match(match_value.priority(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_priority.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".priority := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_priority.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.preempt().ispresent()){
if(!single_value->field_preempt.match(match_value.preempt(), legacy)){
TTCN_Logger::log_logmatch_info(".preempt");
single_value->field_preempt.log_match(match_value.preempt(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_preempt.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".preempt := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_preempt.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ name := ");
if (match_value.name().ispresent()) single_value->field_name.log_match(match_value.name(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_name.log();
if (single_value->field_name.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", id := ");
single_value->field_id.log_match(match_value.id(), legacy);
TTCN_Logger::log_event_str(", revision := ");
single_value->field_revision.log_match(match_value.revision(), legacy);
TTCN_Logger::log_event_str(", status := ");
single_value->field_status.log_match(match_value.status(), legacy);
TTCN_Logger::log_event_str(", moy := ");
if (match_value.moy().ispresent()) single_value->field_moy.log_match(match_value.moy(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_moy.log();
if (single_value->field_moy.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", timeStamp := ");
if (match_value.timeStamp().ispresent()) single_value->field_timeStamp.log_match(match_value.timeStamp(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_timeStamp.log();
if (single_value->field_timeStamp.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", enabledLanes := ");
if (match_value.enabledLanes().ispresent()) single_value->field_enabledLanes.log_match(match_value.enabledLanes(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_enabledLanes.log();
if (single_value->field_enabledLanes.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", states := ");
single_value->field_states.log_match(match_value.states(), legacy);
TTCN_Logger::log_event_str(", maneuverAssistList := ");
if (match_value.maneuverAssistList().ispresent()) single_value->field_maneuverAssistList.log_match(match_value.maneuverAssistList(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_maneuverAssistList.log();
if (single_value->field_maneuverAssistList.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", priority := ");
if (match_value.priority().ispresent()) single_value->field_priority.log_match(match_value.priority(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_priority.log();
if (single_value->field_priority.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", preempt := ");
if (match_value.preempt().ispresent()) single_value->field_preempt.log_match(match_value.preempt(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_preempt.log();
if (single_value->field_preempt.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IntersectionState_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_name.encode_text(text_buf);
single_value->field_id.encode_text(text_buf);
single_value->field_revision.encode_text(text_buf);
single_value->field_status.encode_text(text_buf);
single_value->field_moy.encode_text(text_buf);
single_value->field_timeStamp.encode_text(text_buf);
single_value->field_enabledLanes.encode_text(text_buf);
single_value->field_states.encode_text(text_buf);
single_value->field_maneuverAssistList.encode_text(text_buf);
single_value->field_priority.encode_text(text_buf);
single_value->field_preempt.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.IntersectionState.");
}
}

void IntersectionState_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_name.decode_text(text_buf);
single_value->field_id.decode_text(text_buf);
single_value->field_revision.decode_text(text_buf);
single_value->field_status.decode_text(text_buf);
single_value->field_moy.decode_text(text_buf);
single_value->field_timeStamp.decode_text(text_buf);
single_value->field_enabledLanes.decode_text(text_buf);
single_value->field_states.decode_text(text_buf);
single_value->field_maneuverAssistList.decode_text(text_buf);
single_value->field_priority.decode_text(text_buf);
single_value->field_preempt.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IntersectionState_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.IntersectionState.");
}
}

void IntersectionState_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.IntersectionState'");
    }
    if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("id", param_field) == 0) {
      id().set_param(param);
      return;
    } else if (strcmp("revision", param_field) == 0) {
      revision().set_param(param);
      return;
    } else if (strcmp("status", param_field) == 0) {
      status().set_param(param);
      return;
    } else if (strcmp("moy", param_field) == 0) {
      moy().set_param(param);
      return;
    } else if (strcmp("timeStamp", param_field) == 0) {
      timeStamp().set_param(param);
      return;
    } else if (strcmp("enabledLanes", param_field) == 0) {
      enabledLanes().set_param(param);
      return;
    } else if (strcmp("states", param_field) == 0) {
      states().set_param(param);
      return;
    } else if (strcmp("maneuverAssistList", param_field) == 0) {
      maneuverAssistList().set_param(param);
      return;
    } else if (strcmp("priority", param_field) == 0) {
      priority().set_param(param);
      return;
    } else if (strcmp("preempt", param_field) == 0) {
      preempt().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.IntersectionState'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IntersectionState_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (12<mp->get_size()) {
      param.error("record template of type @DSRC.IntersectionState has 12 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) id().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) revision().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) status().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) moy().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) timeStamp().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) enabledLanes().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) states().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) maneuverAssistList().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) priority().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) preempt().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(11));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "revision")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          revision().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "status")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          status().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "moy")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          moy().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "timeStamp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          timeStamp().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enabledLanes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enabledLanes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "states")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          states().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maneuverAssistList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maneuverAssistList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "priority")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          priority().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "preempt")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          preempt().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.IntersectionState: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.IntersectionState");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* IntersectionState_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.IntersectionState'");
    }
    if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("id", param_field) == 0) {
      return id().get_param(param_name);
    } else if (strcmp("revision", param_field) == 0) {
      return revision().get_param(param_name);
    } else if (strcmp("status", param_field) == 0) {
      return status().get_param(param_name);
    } else if (strcmp("moy", param_field) == 0) {
      return moy().get_param(param_name);
    } else if (strcmp("timeStamp", param_field) == 0) {
      return timeStamp().get_param(param_name);
    } else if (strcmp("enabledLanes", param_field) == 0) {
      return enabledLanes().get_param(param_name);
    } else if (strcmp("states", param_field) == 0) {
      return states().get_param(param_name);
    } else if (strcmp("maneuverAssistList", param_field) == 0) {
      return maneuverAssistList().get_param(param_name);
    } else if (strcmp("priority", param_field) == 0) {
      return priority().get_param(param_name);
    } else if (strcmp("preempt", param_field) == 0) {
      return preempt().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.IntersectionState'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_name = single_value->field_name.get_param(param_name);
    mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
    mp->add_elem(mp_field_name);
    Module_Param* mp_field_id = single_value->field_id.get_param(param_name);
    mp_field_id->set_id(new Module_Param_FieldName(mcopystr("id")));
    mp->add_elem(mp_field_id);
    Module_Param* mp_field_revision = single_value->field_revision.get_param(param_name);
    mp_field_revision->set_id(new Module_Param_FieldName(mcopystr("revision")));
    mp->add_elem(mp_field_revision);
    Module_Param* mp_field_status = single_value->field_status.get_param(param_name);
    mp_field_status->set_id(new Module_Param_FieldName(mcopystr("status")));
    mp->add_elem(mp_field_status);
    Module_Param* mp_field_moy = single_value->field_moy.get_param(param_name);
    mp_field_moy->set_id(new Module_Param_FieldName(mcopystr("moy")));
    mp->add_elem(mp_field_moy);
    Module_Param* mp_field_timeStamp = single_value->field_timeStamp.get_param(param_name);
    mp_field_timeStamp->set_id(new Module_Param_FieldName(mcopystr("timeStamp")));
    mp->add_elem(mp_field_timeStamp);
    Module_Param* mp_field_enabledLanes = single_value->field_enabledLanes.get_param(param_name);
    mp_field_enabledLanes->set_id(new Module_Param_FieldName(mcopystr("enabledLanes")));
    mp->add_elem(mp_field_enabledLanes);
    Module_Param* mp_field_states = single_value->field_states.get_param(param_name);
    mp_field_states->set_id(new Module_Param_FieldName(mcopystr("states")));
    mp->add_elem(mp_field_states);
    Module_Param* mp_field_maneuverAssistList = single_value->field_maneuverAssistList.get_param(param_name);
    mp_field_maneuverAssistList->set_id(new Module_Param_FieldName(mcopystr("maneuverAssistList")));
    mp->add_elem(mp_field_maneuverAssistList);
    Module_Param* mp_field_priority = single_value->field_priority.get_param(param_name);
    mp_field_priority->set_id(new Module_Param_FieldName(mcopystr("priority")));
    mp->add_elem(mp_field_priority);
    Module_Param* mp_field_preempt = single_value->field_preempt.get_param(param_name);
    mp_field_preempt->set_id(new Module_Param_FieldName(mcopystr("preempt")));
    mp->add_elem(mp_field_preempt);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void IntersectionState_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_name.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_id.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_revision.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_status.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_moy.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_timeStamp.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_enabledLanes.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_states.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_maneuverAssistList.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_priority.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_preempt.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.IntersectionState");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.IntersectionState");
}

boolean IntersectionState_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IntersectionState_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SPAT::SPAT()
{
  bound_flag = FALSE;
}

SPAT::SPAT(const INTEGER& par_msgID,
    const OPTIONAL<INTEGER>& par_msgSubID,
    const OPTIONAL<CHARSTRING>& par_name,
    const IntersectionStateList& par_intersections,
    const OPTIONAL<REGION::Reg__SPAT>& par_regional)
  :   field_msgID(par_msgID),
  field_msgSubID(par_msgSubID),
  field_name(par_name),
  field_intersections(par_intersections),
  field_regional(par_regional)
{
  bound_flag = TRUE;
}

SPAT::SPAT(const SPAT& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DSRC.SPAT.");
bound_flag = TRUE;
if (other_value.msgID().is_bound()) field_msgID = other_value.msgID();
else field_msgID.clean_up();
if (other_value.msgSubID().is_bound()) field_msgSubID = other_value.msgSubID();
else field_msgSubID.clean_up();
if (other_value.name().is_bound()) field_name = other_value.name();
else field_name.clean_up();
if (other_value.intersections().is_bound()) field_intersections = other_value.intersections();
else field_intersections.clean_up();
if (other_value.regional().is_bound()) field_regional = other_value.regional();
else field_regional.clean_up();
}

void SPAT::clean_up()
{
field_msgID.clean_up();
field_msgSubID.clean_up();
field_name.clean_up();
field_intersections.clean_up();
field_regional.clean_up();
bound_flag = FALSE;
}

SPAT& SPAT::operator=(const SPAT& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DSRC.SPAT.");
  bound_flag = TRUE;
  if (other_value.msgID().is_bound()) field_msgID = other_value.msgID();
  else field_msgID.clean_up();
  if (other_value.msgSubID().is_bound()) field_msgSubID = other_value.msgSubID();
  else field_msgSubID.clean_up();
  if (other_value.name().is_bound()) field_name = other_value.name();
  else field_name.clean_up();
  if (other_value.intersections().is_bound()) field_intersections = other_value.intersections();
  else field_intersections.clean_up();
  if (other_value.regional().is_bound()) field_regional = other_value.regional();
  else field_regional.clean_up();
}
return *this;
}

boolean SPAT::operator==(const SPAT& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgID==other_value.field_msgID
  && field_msgSubID==other_value.field_msgSubID
  && field_name==other_value.field_name
  && field_intersections==other_value.field_intersections
  && field_regional==other_value.field_regional;
}

boolean SPAT::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgID.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_msgSubID.get_selection() || field_msgSubID.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_name.get_selection() || field_name.is_bound()) return TRUE;
if(field_intersections.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_regional.get_selection() || field_regional.is_bound()) return TRUE;
return FALSE;
}
boolean SPAT::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgID.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_msgSubID.get_selection() && !field_msgSubID.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_name.get_selection() && !field_name.is_value()) return FALSE;
if(!field_intersections.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_regional.get_selection() && !field_regional.is_value()) return FALSE;
return TRUE;
}
int SPAT::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DSRC.SPAT");
  int ret_val = 2;
  if (field_msgSubID.ispresent()) ret_val++;
  if (field_name.ispresent()) ret_val++;
  if (field_regional.ispresent()) ret_val++;
  return ret_val;
}

void SPAT::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgID := ");
field_msgID.log();
TTCN_Logger::log_event_str(", msgSubID := ");
field_msgSubID.log();
TTCN_Logger::log_event_str(", name := ");
field_name.log();
TTCN_Logger::log_event_str(", intersections := ");
field_intersections.log();
TTCN_Logger::log_event_str(", regional := ");
field_regional.log();
TTCN_Logger::log_event_str(" }");
}

void SPAT::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DSRC.SPAT'");
    }
    if (strcmp("msgID", param_field) == 0) {
      msgID().set_param(param);
      return;
    } else if (strcmp("msgSubID", param_field) == 0) {
      msgSubID().set_param(param);
      return;
    } else if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("intersections", param_field) == 0) {
      intersections().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DSRC.SPAT'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record value of type @DSRC.SPAT has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) msgSubID().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) intersections().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgSubID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgSubID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "intersections")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          intersections().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.SPAT: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DSRC.SPAT");
  }
}

Module_Param* SPAT::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DSRC.SPAT'");
    }
    if (strcmp("msgID", param_field) == 0) {
      return msgID().get_param(param_name);
    } else if (strcmp("msgSubID", param_field) == 0) {
      return msgSubID().get_param(param_name);
    } else if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("intersections", param_field) == 0) {
      return intersections().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.SPAT'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgID = field_msgID.get_param(param_name);
  mp_field_msgID->set_id(new Module_Param_FieldName(mcopystr("msgID")));
  mp->add_elem(mp_field_msgID);
  Module_Param* mp_field_msgSubID = field_msgSubID.get_param(param_name);
  mp_field_msgSubID->set_id(new Module_Param_FieldName(mcopystr("msgSubID")));
  mp->add_elem(mp_field_msgSubID);
  Module_Param* mp_field_name = field_name.get_param(param_name);
  mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
  mp->add_elem(mp_field_name);
  Module_Param* mp_field_intersections = field_intersections.get_param(param_name);
  mp_field_intersections->set_id(new Module_Param_FieldName(mcopystr("intersections")));
  mp->add_elem(mp_field_intersections);
  Module_Param* mp_field_regional = field_regional.get_param(param_name);
  mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
  mp->add_elem(mp_field_regional);
  return mp;
  }

void SPAT::set_implicit_omit()
{
if (msgID().is_bound()) msgID().set_implicit_omit();
if (!msgSubID().is_bound()) msgSubID() = OMIT_VALUE;
else msgSubID().set_implicit_omit();
if (!name().is_bound()) name() = OMIT_VALUE;
else name().set_implicit_omit();
if (intersections().is_bound()) intersections().set_implicit_omit();
if (!regional().is_bound()) regional() = OMIT_VALUE;
else regional().set_implicit_omit();
}

void SPAT::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DSRC.SPAT.");
field_msgID.encode_text(text_buf);
field_msgSubID.encode_text(text_buf);
field_name.encode_text(text_buf);
field_intersections.encode_text(text_buf);
field_regional.encode_text(text_buf);
}

void SPAT::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgID.decode_text(text_buf);
field_msgSubID.decode_text(text_buf);
field_name.decode_text(text_buf);
field_intersections.decode_text(text_buf);
field_regional.decode_text(text_buf);
}

void SPAT::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SPAT::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* SPAT::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("msgID': ");
  new_tlv->add_TLV(field_msgID.BER_encode_TLV(SPAT_msgID_descr_, p_coding));
  ec_1.set_msg("msgSubID': ");
  new_tlv->add_TLV(field_msgSubID.BER_encode_TLV(SPAT_msgSubID_descr_, p_coding));
  ec_1.set_msg("name': ");
  new_tlv->add_TLV(field_name.BER_encode_TLV(SPAT_name_descr_, p_coding));
  ec_1.set_msg("intersections': ");
  new_tlv->add_TLV(field_intersections.BER_encode_TLV(SPAT_intersections_descr_, p_coding));
  ec_1.set_msg("regional': ");
  new_tlv->add_TLV(field_regional.BER_encode_TLV(SPAT_regional_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean SPAT::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DSRC.SPAT' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("msgID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_msgID.BER_decode_TLV(SPAT_msgID_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("msgSubID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_msgSubID=OMIT_VALUE;
    else {
      field_msgSubID.BER_decode_TLV(SPAT_msgSubID_descr_, tmp_tlv, L_form);
      if(field_msgSubID.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("name': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_name=OMIT_VALUE;
    else {
      field_name.BER_decode_TLV(SPAT_name_descr_, tmp_tlv, L_form);
      if(field_name.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("intersections': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_intersections.BER_decode_TLV(SPAT_intersections_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("regional': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_regional=OMIT_VALUE;
    else {
      field_regional.BER_decode_TLV(SPAT_regional_descr_, tmp_tlv, L_form);
      if(field_regional.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int SPAT::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DSRC.SPAT.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "msgID");
    enc_len += field_msgID.JSON_encode(SPAT_msgID_descr_, p_tok);
  }

  if (field_msgSubID.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "msgSubID");
    enc_len += field_msgSubID.JSON_encode(SPAT_msgSubID_descr_, p_tok);
  }

  if (field_name.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "name");
    enc_len += field_name.JSON_encode(SPAT_name_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "intersections");
    enc_len += field_intersections.JSON_encode(SPAT_intersections_descr_, p_tok);
  }

  if (field_regional.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "regional");
    enc_len += field_regional.JSON_encode(SPAT_regional_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SPAT::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "msgID", name_len)) {
         int ret_val = field_msgID.JSON_decode(SPAT_msgID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "msgID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "msgSubID", name_len)) {
         int ret_val = field_msgSubID.JSON_decode(SPAT_msgSubID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "msgSubID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "name", name_len)) {
         int ret_val = field_name.JSON_decode(SPAT_name_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "name");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "intersections", name_len)) {
         int ret_val = field_intersections.JSON_decode(SPAT_intersections_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "intersections");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "regional", name_len)) {
         int ret_val = field_regional.JSON_decode(SPAT_regional_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "regional");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_msgID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "msgID");
    return JSON_ERROR_FATAL;
  }
if (!field_msgSubID.is_bound()) {
    field_msgSubID = OMIT_VALUE;
  }
if (!field_name.is_bound()) {
    field_name = OMIT_VALUE;
  }
if (!field_intersections.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "intersections");
    return JSON_ERROR_FATAL;
  }
if (!field_regional.is_bound()) {
    field_regional = OMIT_VALUE;
  }

  return dec_len;
}

struct SPAT_template::single_value_struct {
INTEGER_template field_msgID;
INTEGER_template field_msgSubID;
CHARSTRING_template field_name;
IntersectionStateList_template field_intersections;
REGION::Reg__SPAT_template field_regional;
};

void SPAT_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgID = ANY_VALUE;
single_value->field_msgSubID = ANY_OR_OMIT;
single_value->field_name = ANY_OR_OMIT;
single_value->field_intersections = ANY_VALUE;
single_value->field_regional = ANY_OR_OMIT;
}
}
}

void SPAT_template::copy_value(const SPAT& other_value)
{
single_value = new single_value_struct;
if (other_value.msgID().is_bound()) {
  single_value->field_msgID = other_value.msgID();
} else {
  single_value->field_msgID.clean_up();
}
if (other_value.msgSubID().is_bound()) {
  if (other_value.msgSubID().ispresent()) single_value->field_msgSubID = other_value.msgSubID()();
  else single_value->field_msgSubID = OMIT_VALUE;
} else {
  single_value->field_msgSubID.clean_up();
}
if (other_value.name().is_bound()) {
  if (other_value.name().ispresent()) single_value->field_name = other_value.name()();
  else single_value->field_name = OMIT_VALUE;
} else {
  single_value->field_name.clean_up();
}
if (other_value.intersections().is_bound()) {
  single_value->field_intersections = other_value.intersections();
} else {
  single_value->field_intersections.clean_up();
}
if (other_value.regional().is_bound()) {
  if (other_value.regional().ispresent()) single_value->field_regional = other_value.regional()();
  else single_value->field_regional = OMIT_VALUE;
} else {
  single_value->field_regional.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SPAT_template::copy_template(const SPAT_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgID().get_selection()) {
single_value->field_msgID = other_value.msgID();
} else {
single_value->field_msgID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.msgSubID().get_selection()) {
single_value->field_msgSubID = other_value.msgSubID();
} else {
single_value->field_msgSubID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.name().get_selection()) {
single_value->field_name = other_value.name();
} else {
single_value->field_name.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.intersections().get_selection()) {
single_value->field_intersections = other_value.intersections();
} else {
single_value->field_intersections.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.regional().get_selection()) {
single_value->field_regional = other_value.regional();
} else {
single_value->field_regional.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SPAT_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DSRC.SPAT.");
break;
}
set_selection(other_value);
}

SPAT_template::SPAT_template()
{
}

SPAT_template::SPAT_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SPAT_template::SPAT_template(const SPAT& other_value)
{
copy_value(other_value);
}

SPAT_template::SPAT_template(const OPTIONAL<SPAT>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SPAT&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DSRC.SPAT from an unbound optional field.");
}
}

SPAT_template::SPAT_template(const SPAT_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SPAT_template::~SPAT_template()
{
clean_up();
}

SPAT_template& SPAT_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SPAT_template& SPAT_template::operator=(const SPAT& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SPAT_template& SPAT_template::operator=(const OPTIONAL<SPAT>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SPAT&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DSRC.SPAT.");
}
return *this;
}

SPAT_template& SPAT_template::operator=(const SPAT_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SPAT_template::match(const SPAT& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgID().is_bound()) return FALSE;
if(!single_value->field_msgID.match(other_value.msgID(), legacy))return FALSE;
if(!other_value.msgSubID().is_bound()) return FALSE;
if((other_value.msgSubID().ispresent() ? !single_value->field_msgSubID.match((const INTEGER&)other_value.msgSubID(), legacy) : !single_value->field_msgSubID.match_omit(legacy)))return FALSE;
if(!other_value.name().is_bound()) return FALSE;
if((other_value.name().ispresent() ? !single_value->field_name.match((const CHARSTRING&)other_value.name(), legacy) : !single_value->field_name.match_omit(legacy)))return FALSE;
if(!other_value.intersections().is_bound()) return FALSE;
if(!single_value->field_intersections.match(other_value.intersections(), legacy))return FALSE;
if(!other_value.regional().is_bound()) return FALSE;
if((other_value.regional().ispresent() ? !single_value->field_regional.match((const REGION::Reg__SPAT&)other_value.regional(), legacy) : !single_value->field_regional.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DSRC.SPAT.");
}
return FALSE;
}

boolean SPAT_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgID.is_bound()) return TRUE;
if (single_value->field_msgSubID.is_omit() || single_value->field_msgSubID.is_bound()) return TRUE;
if (single_value->field_name.is_omit() || single_value->field_name.is_bound()) return TRUE;
if (single_value->field_intersections.is_bound()) return TRUE;
if (single_value->field_regional.is_omit() || single_value->field_regional.is_bound()) return TRUE;
return FALSE;
}

boolean SPAT_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgID.is_value()) return FALSE;
if (!single_value->field_msgSubID.is_omit() && !single_value->field_msgSubID.is_value()) return FALSE;
if (!single_value->field_name.is_omit() && !single_value->field_name.is_value()) return FALSE;
if (!single_value->field_intersections.is_value()) return FALSE;
if (!single_value->field_regional.is_omit() && !single_value->field_regional.is_value()) return FALSE;
return TRUE;
}

void SPAT_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SPAT SPAT_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DSRC.SPAT.");
SPAT ret_val;
if (single_value->field_msgID.is_bound()) {
ret_val.msgID() = single_value->field_msgID.valueof();
}
if (single_value->field_msgSubID.is_omit()) ret_val.msgSubID() = OMIT_VALUE;
else if (single_value->field_msgSubID.is_bound()) {
ret_val.msgSubID() = single_value->field_msgSubID.valueof();
}
if (single_value->field_name.is_omit()) ret_val.name() = OMIT_VALUE;
else if (single_value->field_name.is_bound()) {
ret_val.name() = single_value->field_name.valueof();
}
if (single_value->field_intersections.is_bound()) {
ret_val.intersections() = single_value->field_intersections.valueof();
}
if (single_value->field_regional.is_omit()) ret_val.regional() = OMIT_VALUE;
else if (single_value->field_regional.is_bound()) {
ret_val.regional() = single_value->field_regional.valueof();
}
return ret_val;
}

void SPAT_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DSRC.SPAT.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SPAT_template[list_length];
}

SPAT_template& SPAT_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DSRC.SPAT.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DSRC.SPAT.");
return value_list.list_value[list_index];
}

INTEGER_template& SPAT_template::msgID()
{
set_specific();
return single_value->field_msgID;
}

const INTEGER_template& SPAT_template::msgID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgID of a non-specific template of type @DSRC.SPAT.");
return single_value->field_msgID;
}

INTEGER_template& SPAT_template::msgSubID()
{
set_specific();
return single_value->field_msgSubID;
}

const INTEGER_template& SPAT_template::msgSubID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgSubID of a non-specific template of type @DSRC.SPAT.");
return single_value->field_msgSubID;
}

CHARSTRING_template& SPAT_template::name()
{
set_specific();
return single_value->field_name;
}

const CHARSTRING_template& SPAT_template::name() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field name of a non-specific template of type @DSRC.SPAT.");
return single_value->field_name;
}

IntersectionStateList_template& SPAT_template::intersections()
{
set_specific();
return single_value->field_intersections;
}

const IntersectionStateList_template& SPAT_template::intersections() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field intersections of a non-specific template of type @DSRC.SPAT.");
return single_value->field_intersections;
}

REGION::Reg__SPAT_template& SPAT_template::regional()
{
set_specific();
return single_value->field_regional;
}

const REGION::Reg__SPAT_template& SPAT_template::regional() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field regional of a non-specific template of type @DSRC.SPAT.");
return single_value->field_regional;
}

int SPAT_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DSRC.SPAT which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_msgSubID.is_present()) ret_val++;
      if (single_value->field_name.is_present()) ret_val++;
      if (single_value->field_regional.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DSRC.SPAT containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DSRC.SPAT containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.SPAT containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.SPAT containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DSRC.SPAT containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DSRC.SPAT.");
  }
  return 0;
}

void SPAT_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgID := ");
single_value->field_msgID.log();
TTCN_Logger::log_event_str(", msgSubID := ");
single_value->field_msgSubID.log();
TTCN_Logger::log_event_str(", name := ");
single_value->field_name.log();
TTCN_Logger::log_event_str(", intersections := ");
single_value->field_intersections.log();
TTCN_Logger::log_event_str(", regional := ");
single_value->field_regional.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SPAT_template::log_match(const SPAT& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgID.match(match_value.msgID(), legacy)){
TTCN_Logger::log_logmatch_info(".msgID");
single_value->field_msgID.log_match(match_value.msgID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.msgSubID().ispresent()){
if(!single_value->field_msgSubID.match(match_value.msgSubID(), legacy)){
TTCN_Logger::log_logmatch_info(".msgSubID");
single_value->field_msgSubID.log_match(match_value.msgSubID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_msgSubID.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".msgSubID := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_msgSubID.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.name().ispresent()){
if(!single_value->field_name.match(match_value.name(), legacy)){
TTCN_Logger::log_logmatch_info(".name");
single_value->field_name.log_match(match_value.name(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_name.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".name := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_name.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_intersections.match(match_value.intersections(), legacy)){
TTCN_Logger::log_logmatch_info(".intersections");
single_value->field_intersections.log_match(match_value.intersections(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.regional().ispresent()){
if(!single_value->field_regional.match(match_value.regional(), legacy)){
TTCN_Logger::log_logmatch_info(".regional");
single_value->field_regional.log_match(match_value.regional(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_regional.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".regional := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_regional.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgID := ");
single_value->field_msgID.log_match(match_value.msgID(), legacy);
TTCN_Logger::log_event_str(", msgSubID := ");
if (match_value.msgSubID().ispresent()) single_value->field_msgSubID.log_match(match_value.msgSubID(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_msgSubID.log();
if (single_value->field_msgSubID.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", name := ");
if (match_value.name().ispresent()) single_value->field_name.log_match(match_value.name(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_name.log();
if (single_value->field_name.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", intersections := ");
single_value->field_intersections.log_match(match_value.intersections(), legacy);
TTCN_Logger::log_event_str(", regional := ");
if (match_value.regional().ispresent()) single_value->field_regional.log_match(match_value.regional(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_regional.log();
if (single_value->field_regional.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SPAT_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgID.encode_text(text_buf);
single_value->field_msgSubID.encode_text(text_buf);
single_value->field_name.encode_text(text_buf);
single_value->field_intersections.encode_text(text_buf);
single_value->field_regional.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DSRC.SPAT.");
}
}

void SPAT_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgID.decode_text(text_buf);
single_value->field_msgSubID.decode_text(text_buf);
single_value->field_name.decode_text(text_buf);
single_value->field_intersections.decode_text(text_buf);
single_value->field_regional.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SPAT_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DSRC.SPAT.");
}
}

void SPAT_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DSRC.SPAT'");
    }
    if (strcmp("msgID", param_field) == 0) {
      msgID().set_param(param);
      return;
    } else if (strcmp("msgSubID", param_field) == 0) {
      msgSubID().set_param(param);
      return;
    } else if (strcmp("name", param_field) == 0) {
      name().set_param(param);
      return;
    } else if (strcmp("intersections", param_field) == 0) {
      intersections().set_param(param);
      return;
    } else if (strcmp("regional", param_field) == 0) {
      regional().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DSRC.SPAT'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SPAT_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record template of type @DSRC.SPAT has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) msgSubID().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) intersections().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) regional().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgSubID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgSubID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "intersections")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          intersections().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "regional")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          regional().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DSRC.SPAT: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DSRC.SPAT");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SPAT_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DSRC.SPAT'");
    }
    if (strcmp("msgID", param_field) == 0) {
      return msgID().get_param(param_name);
    } else if (strcmp("msgSubID", param_field) == 0) {
      return msgSubID().get_param(param_name);
    } else if (strcmp("name", param_field) == 0) {
      return name().get_param(param_name);
    } else if (strcmp("intersections", param_field) == 0) {
      return intersections().get_param(param_name);
    } else if (strcmp("regional", param_field) == 0) {
      return regional().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DSRC.SPAT'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgID = single_value->field_msgID.get_param(param_name);
    mp_field_msgID->set_id(new Module_Param_FieldName(mcopystr("msgID")));
    mp->add_elem(mp_field_msgID);
    Module_Param* mp_field_msgSubID = single_value->field_msgSubID.get_param(param_name);
    mp_field_msgSubID->set_id(new Module_Param_FieldName(mcopystr("msgSubID")));
    mp->add_elem(mp_field_msgSubID);
    Module_Param* mp_field_name = single_value->field_name.get_param(param_name);
    mp_field_name->set_id(new Module_Param_FieldName(mcopystr("name")));
    mp->add_elem(mp_field_name);
    Module_Param* mp_field_intersections = single_value->field_intersections.get_param(param_name);
    mp_field_intersections->set_id(new Module_Param_FieldName(mcopystr("intersections")));
    mp->add_elem(mp_field_intersections);
    Module_Param* mp_field_regional = single_value->field_regional.get_param(param_name);
    mp_field_regional->set_id(new Module_Param_FieldName(mcopystr("regional")));
    mp->add_elem(mp_field_regional);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SPAT_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgID.check_restriction(t_res, t_name ? t_name : "@DSRC.SPAT");
single_value->field_msgSubID.check_restriction(t_res, t_name ? t_name : "@DSRC.SPAT");
single_value->field_name.check_restriction(t_res, t_name ? t_name : "@DSRC.SPAT");
single_value->field_intersections.check_restriction(t_res, t_name ? t_name : "@DSRC.SPAT");
single_value->field_regional.check_restriction(t_res, t_name ? t_name : "@DSRC.SPAT");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DSRC.SPAT");
}

boolean SPAT_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SPAT_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const IntersectionGeometryList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.IntersectionGeometryList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const LaneList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.LaneList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const NodeSet& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.NodeSet.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const NodeAttributeList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.NodeAttributeList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const SegmentAttributeList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.SegmentAttributeList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const LaneDataAttributeList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.LaneDataAttributeList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const SpeedLimitList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.SpeedLimitList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const RegionalNodeAttributeList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RegionalNodeAttributeList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const ConnectsToList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.ConnectsToList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const PreemptPriorityList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.PreemptPriorityList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const RoadSegmentList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RoadSegmentList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const RoadLaneSetList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RoadLaneSetList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const RestrictionClassList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RestrictionClassList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const RestrictionUserTypeList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.RestrictionUserTypeList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const IntersectionStateList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.IntersectionStateList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const MovementList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.MovementList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const MovementEventList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.MovementEventList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const AdvisorySpeedList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.AdvisorySpeedList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const ManeuverAssistList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DSRC.ManeuverAssistList.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("DSRC_REG_D.asn", 0, TTCN_Location::LOCATION_UNKNOWN, "DSRC");
REG__D::module_object.pre_init_module();
const_mapData__P = 18;
const_signalPhaseAndTimingMessage__P = 19;
}


} /* end of namespace */
