// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef LibItsIpv6OverGeoNetworking__TypesAndValues_HH
#define LibItsIpv6OverGeoNetworking__TypesAndValues_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "LibCommon_BasicTypesAndValues.hh"
#include "LibItsExternal_TypesAndValues.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef LibItsIpv6OverGeoNetworking__TypesAndValues_HH
#endif

namespace LibItsIpv6OverGeoNetworking__TypesAndValues {

/* Forward declarations of classes */

class GvlTableEntry;
class GvlTableEntry_template;
class GvlTable;
class GvlTable_template;
class AddressTableEntry;
class AddressTableEntry_template;
class AddressTable;
class AddressTable_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER GvlIdxList;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template GvlIdxList_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER UInt32List;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template UInt32List_template;
class Ipv6Header;
class Ipv6Header_template;
class Ipv6Packet;
class Ipv6Packet_template;
class Ipv6Payload;
class Ipv6Payload_template;
class RouterAdvertisementMsg;
class RouterAdvertisementMsg_template;
class RtAdvOptions;
class RtAdvOptions_template;
class SrcLinkLayerAddress;
class SrcLinkLayerAddress_template;
class PrefixInfoList;
class PrefixInfoList_template;
class PrefixInfo;
class PrefixInfo_template;
class AcGn6Primitive;
class AcGn6Primitive_template;
class AcGn6Response;
class AcGn6Response_template;
class AcGn6InterfaceInfoList;
class AcGn6InterfaceInfoList_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__OCTETSTRING Ipv6AddressList;
typedef PreGenRecordOf::PREGEN__RECORD__OF__OCTETSTRING_template Ipv6AddressList_template;
class AcGn6InterfaceInfo;
class AcGn6InterfaceInfo_template;

} /* end of namespace */

#ifndef LibItsIpv6OverGeoNetworking__TypesAndValues_HH
#define LibItsIpv6OverGeoNetworking__TypesAndValues_HH

namespace LibItsIpv6OverGeoNetworking__TypesAndValues {

/* Type definitions */

typedef OCTETSTRING Ipv6Address;
typedef OCTETSTRING_template Ipv6Address_template;
typedef OCTETSTRING ExtensionHeaderList;
typedef OCTETSTRING_template ExtensionHeaderList_template;
typedef OCTETSTRING Prefix;
typedef OCTETSTRING_template Prefix_template;

/* Class definitions */

class GvlTableEntry : public Base_Type {
  CHARSTRING field_key;
  OCTETSTRING field_prefix;
  INTEGER field_prefixLength;
  CHARSTRING field_area;
  CHARSTRING field_interface;
  boolean bound_flag;
public:
  GvlTableEntry();
  GvlTableEntry(const CHARSTRING& par_key,
    const OCTETSTRING& par_prefix,
    const INTEGER& par_prefixLength,
    const CHARSTRING& par_area,
    const CHARSTRING& par_interface);
  GvlTableEntry(const GvlTableEntry& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GvlTableEntry& operator=(const GvlTableEntry& other_value);
  boolean operator==(const GvlTableEntry& other_value) const;
  inline boolean operator!=(const GvlTableEntry& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& key()
    {return field_key;}
  inline const CHARSTRING& key() const
    {return field_key;}
  inline OCTETSTRING& prefix()
    {return field_prefix;}
  inline const OCTETSTRING& prefix() const
    {return field_prefix;}
  inline INTEGER& prefixLength()
    {return field_prefixLength;}
  inline const INTEGER& prefixLength() const
    {return field_prefixLength;}
  inline CHARSTRING& area()
    {return field_area;}
  inline const CHARSTRING& area() const
    {return field_area;}
  inline CHARSTRING& interface()
    {return field_interface;}
  inline const CHARSTRING& interface() const
    {return field_interface;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GvlTableEntry_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GvlTableEntry_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GvlTableEntry& other_value);
void copy_template(const GvlTableEntry_template& other_value);

public:
GvlTableEntry_template();
GvlTableEntry_template(template_sel other_value);
GvlTableEntry_template(const GvlTableEntry& other_value);
GvlTableEntry_template(const OPTIONAL<GvlTableEntry>& other_value);
GvlTableEntry_template(const GvlTableEntry_template& other_value);
~GvlTableEntry_template();
GvlTableEntry_template& operator=(template_sel other_value);
GvlTableEntry_template& operator=(const GvlTableEntry& other_value);
GvlTableEntry_template& operator=(const OPTIONAL<GvlTableEntry>& other_value);
GvlTableEntry_template& operator=(const GvlTableEntry_template& other_value);
boolean match(const GvlTableEntry& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GvlTableEntry valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GvlTableEntry_template& list_item(unsigned int list_index) const;
CHARSTRING_template& key();
const CHARSTRING_template& key() const;
OCTETSTRING_template& prefix();
const OCTETSTRING_template& prefix() const;
INTEGER_template& prefixLength();
const INTEGER_template& prefixLength() const;
CHARSTRING_template& area();
const CHARSTRING_template& area() const;
CHARSTRING_template& interface();
const CHARSTRING_template& interface() const;
int size_of() const;
void log() const;
void log_match(const GvlTableEntry& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GvlTable : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
GvlTableEntry **value_elements;
} *val_ptr;

static const GvlTableEntry UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const GvlTable& other_value);

public:
  typedef GvlTableEntry of_type;
GvlTable();
GvlTable(null_type other_value);
GvlTable(const GvlTable& other_value);
~GvlTable();

void clean_up();
GvlTable& operator=(null_type other_value);
GvlTable& operator=(const GvlTable& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const GvlTable& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GvlTable& other_value) const { return !(*this == other_value); }

GvlTableEntry& operator[](int index_value);
GvlTableEntry& operator[](const INTEGER& index_value);
const GvlTableEntry& operator[](int index_value) const;
const GvlTableEntry& operator[](const INTEGER& index_value) const;

GvlTable operator<<=(int rotate_count) const;
GvlTable operator<<=(const INTEGER& rotate_count) const;
GvlTable operator>>=(int rotate_count) const;
GvlTable operator>>=(const INTEGER& rotate_count) const;

GvlTable operator+(const GvlTable& other_value) const;

GvlTable substr(int index, int returncount) const;

GvlTable replace(int index, int len, const GvlTable& repl) const;

GvlTable replace(int index, int len, const GvlTable_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GvlTable_template : public Record_Of_Template {
union {
struct {
int n_elements;
GvlTableEntry_template **value_elements;
} single_value;
struct {
unsigned int n_values;
GvlTable_template *list_value;
} value_list;
};
void copy_value(const GvlTable& other_value);
void copy_template(const GvlTable_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
GvlTable_template();
GvlTable_template(template_sel other_value);
GvlTable_template(null_type other_value);
GvlTable_template(const GvlTable& other_value);
GvlTable_template(const OPTIONAL<GvlTable>& other_value);
GvlTable_template(const GvlTable_template& other_value);
~GvlTable_template();

void clean_up();
GvlTable_template& operator=(template_sel other_value);
GvlTable_template& operator=(null_type other_value);
GvlTable_template& operator=(const GvlTable& other_value);
GvlTable_template& operator=(const OPTIONAL<GvlTable>& other_value);
GvlTable_template& operator=(const GvlTable_template& other_value);

GvlTableEntry_template& operator[](int index_value);
GvlTableEntry_template& operator[](const INTEGER& index_value);
const GvlTableEntry_template& operator[](int index_value) const;
const GvlTableEntry_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const GvlTable& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
GvlTable valueof() const;
GvlTable substr(int index, int returncount) const;

GvlTable replace(int index, int len, const GvlTable_template& repl) const;

GvlTable replace(int index, int len, const GvlTable& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
GvlTable_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GvlTable& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AddressTableEntry : public Base_Type {
  CHARSTRING field_key;
  OCTETSTRING field_macAddress;
  OCTETSTRING field_macSolNodeMca;
  OCTETSTRING field_lla;
  OCTETSTRING field_solNodeMca;
  boolean bound_flag;
public:
  AddressTableEntry();
  AddressTableEntry(const CHARSTRING& par_key,
    const OCTETSTRING& par_macAddress,
    const OCTETSTRING& par_macSolNodeMca,
    const OCTETSTRING& par_lla,
    const OCTETSTRING& par_solNodeMca);
  AddressTableEntry(const AddressTableEntry& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AddressTableEntry& operator=(const AddressTableEntry& other_value);
  boolean operator==(const AddressTableEntry& other_value) const;
  inline boolean operator!=(const AddressTableEntry& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& key()
    {return field_key;}
  inline const CHARSTRING& key() const
    {return field_key;}
  inline OCTETSTRING& macAddress()
    {return field_macAddress;}
  inline const OCTETSTRING& macAddress() const
    {return field_macAddress;}
  inline OCTETSTRING& macSolNodeMca()
    {return field_macSolNodeMca;}
  inline const OCTETSTRING& macSolNodeMca() const
    {return field_macSolNodeMca;}
  inline OCTETSTRING& lla()
    {return field_lla;}
  inline const OCTETSTRING& lla() const
    {return field_lla;}
  inline OCTETSTRING& solNodeMca()
    {return field_solNodeMca;}
  inline const OCTETSTRING& solNodeMca() const
    {return field_solNodeMca;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AddressTableEntry_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AddressTableEntry_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AddressTableEntry& other_value);
void copy_template(const AddressTableEntry_template& other_value);

public:
AddressTableEntry_template();
AddressTableEntry_template(template_sel other_value);
AddressTableEntry_template(const AddressTableEntry& other_value);
AddressTableEntry_template(const OPTIONAL<AddressTableEntry>& other_value);
AddressTableEntry_template(const AddressTableEntry_template& other_value);
~AddressTableEntry_template();
AddressTableEntry_template& operator=(template_sel other_value);
AddressTableEntry_template& operator=(const AddressTableEntry& other_value);
AddressTableEntry_template& operator=(const OPTIONAL<AddressTableEntry>& other_value);
AddressTableEntry_template& operator=(const AddressTableEntry_template& other_value);
boolean match(const AddressTableEntry& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AddressTableEntry valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AddressTableEntry_template& list_item(unsigned int list_index) const;
CHARSTRING_template& key();
const CHARSTRING_template& key() const;
OCTETSTRING_template& macAddress();
const OCTETSTRING_template& macAddress() const;
OCTETSTRING_template& macSolNodeMca();
const OCTETSTRING_template& macSolNodeMca() const;
OCTETSTRING_template& lla();
const OCTETSTRING_template& lla() const;
OCTETSTRING_template& solNodeMca();
const OCTETSTRING_template& solNodeMca() const;
int size_of() const;
void log() const;
void log_match(const AddressTableEntry& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AddressTable : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
AddressTableEntry **value_elements;
} *val_ptr;

static const AddressTableEntry UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const AddressTable& other_value);

public:
  typedef AddressTableEntry of_type;
AddressTable();
AddressTable(null_type other_value);
AddressTable(const AddressTable& other_value);
~AddressTable();

void clean_up();
AddressTable& operator=(null_type other_value);
AddressTable& operator=(const AddressTable& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const AddressTable& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AddressTable& other_value) const { return !(*this == other_value); }

AddressTableEntry& operator[](int index_value);
AddressTableEntry& operator[](const INTEGER& index_value);
const AddressTableEntry& operator[](int index_value) const;
const AddressTableEntry& operator[](const INTEGER& index_value) const;

AddressTable operator<<=(int rotate_count) const;
AddressTable operator<<=(const INTEGER& rotate_count) const;
AddressTable operator>>=(int rotate_count) const;
AddressTable operator>>=(const INTEGER& rotate_count) const;

AddressTable operator+(const AddressTable& other_value) const;

AddressTable substr(int index, int returncount) const;

AddressTable replace(int index, int len, const AddressTable& repl) const;

AddressTable replace(int index, int len, const AddressTable_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddressTable_template : public Record_Of_Template {
union {
struct {
int n_elements;
AddressTableEntry_template **value_elements;
} single_value;
struct {
unsigned int n_values;
AddressTable_template *list_value;
} value_list;
};
void copy_value(const AddressTable& other_value);
void copy_template(const AddressTable_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
AddressTable_template();
AddressTable_template(template_sel other_value);
AddressTable_template(null_type other_value);
AddressTable_template(const AddressTable& other_value);
AddressTable_template(const OPTIONAL<AddressTable>& other_value);
AddressTable_template(const AddressTable_template& other_value);
~AddressTable_template();

void clean_up();
AddressTable_template& operator=(template_sel other_value);
AddressTable_template& operator=(null_type other_value);
AddressTable_template& operator=(const AddressTable& other_value);
AddressTable_template& operator=(const OPTIONAL<AddressTable>& other_value);
AddressTable_template& operator=(const AddressTable_template& other_value);

AddressTableEntry_template& operator[](int index_value);
AddressTableEntry_template& operator[](const INTEGER& index_value);
const AddressTableEntry_template& operator[](int index_value) const;
const AddressTableEntry_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const AddressTable& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
AddressTable valueof() const;
AddressTable substr(int index, int returncount) const;

AddressTable replace(int index, int len, const AddressTable_template& repl) const;

AddressTable replace(int index, int len, const AddressTable& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
AddressTable_template& list_item(unsigned int list_index);
void log() const;
void log_match(const AddressTable& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Ipv6Header : public Base_Type {
  INTEGER field_version;
  INTEGER field_trafficClass;
  INTEGER field_flowLabel;
  INTEGER field_payloadLength;
  INTEGER field_nextHeader;
  INTEGER field_hopLimit;
  OCTETSTRING field_sourceAddress;
  OCTETSTRING field_destinationAddress;
  boolean bound_flag;
public:
  Ipv6Header();
  Ipv6Header(const INTEGER& par_version,
    const INTEGER& par_trafficClass,
    const INTEGER& par_flowLabel,
    const INTEGER& par_payloadLength,
    const INTEGER& par_nextHeader,
    const INTEGER& par_hopLimit,
    const OCTETSTRING& par_sourceAddress,
    const OCTETSTRING& par_destinationAddress);
  Ipv6Header(const Ipv6Header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Ipv6Header& operator=(const Ipv6Header& other_value);
  boolean operator==(const Ipv6Header& other_value) const;
  inline boolean operator!=(const Ipv6Header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& version()
    {return field_version;}
  inline const INTEGER& version() const
    {return field_version;}
  inline INTEGER& trafficClass()
    {return field_trafficClass;}
  inline const INTEGER& trafficClass() const
    {return field_trafficClass;}
  inline INTEGER& flowLabel()
    {return field_flowLabel;}
  inline const INTEGER& flowLabel() const
    {return field_flowLabel;}
  inline INTEGER& payloadLength()
    {return field_payloadLength;}
  inline const INTEGER& payloadLength() const
    {return field_payloadLength;}
  inline INTEGER& nextHeader()
    {return field_nextHeader;}
  inline const INTEGER& nextHeader() const
    {return field_nextHeader;}
  inline INTEGER& hopLimit()
    {return field_hopLimit;}
  inline const INTEGER& hopLimit() const
    {return field_hopLimit;}
  inline OCTETSTRING& sourceAddress()
    {return field_sourceAddress;}
  inline const OCTETSTRING& sourceAddress() const
    {return field_sourceAddress;}
  inline OCTETSTRING& destinationAddress()
    {return field_destinationAddress;}
  inline const OCTETSTRING& destinationAddress() const
    {return field_destinationAddress;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Ipv6Header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Ipv6Header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Ipv6Header& other_value);
void copy_template(const Ipv6Header_template& other_value);

public:
Ipv6Header_template();
Ipv6Header_template(template_sel other_value);
Ipv6Header_template(const Ipv6Header& other_value);
Ipv6Header_template(const OPTIONAL<Ipv6Header>& other_value);
Ipv6Header_template(const Ipv6Header_template& other_value);
~Ipv6Header_template();
Ipv6Header_template& operator=(template_sel other_value);
Ipv6Header_template& operator=(const Ipv6Header& other_value);
Ipv6Header_template& operator=(const OPTIONAL<Ipv6Header>& other_value);
Ipv6Header_template& operator=(const Ipv6Header_template& other_value);
boolean match(const Ipv6Header& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Ipv6Header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Ipv6Header_template& list_item(unsigned int list_index) const;
INTEGER_template& version();
const INTEGER_template& version() const;
INTEGER_template& trafficClass();
const INTEGER_template& trafficClass() const;
INTEGER_template& flowLabel();
const INTEGER_template& flowLabel() const;
INTEGER_template& payloadLength();
const INTEGER_template& payloadLength() const;
INTEGER_template& nextHeader();
const INTEGER_template& nextHeader() const;
INTEGER_template& hopLimit();
const INTEGER_template& hopLimit() const;
OCTETSTRING_template& sourceAddress();
const OCTETSTRING_template& sourceAddress() const;
OCTETSTRING_template& destinationAddress();
const OCTETSTRING_template& destinationAddress() const;
int size_of() const;
void log() const;
void log_match(const Ipv6Header& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Ipv6Packet : public Base_Type {
  Ipv6Header field_ipv6Hdr;
  OPTIONAL<OCTETSTRING> field_extHdrList;
  OPTIONAL<Ipv6Payload> field_ipv6Payload;
  boolean bound_flag;
public:
  Ipv6Packet();
  Ipv6Packet(const Ipv6Header& par_ipv6Hdr,
    const OPTIONAL<OCTETSTRING>& par_extHdrList,
    const OPTIONAL<Ipv6Payload>& par_ipv6Payload);
  Ipv6Packet(const Ipv6Packet& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Ipv6Packet& operator=(const Ipv6Packet& other_value);
  boolean operator==(const Ipv6Packet& other_value) const;
  inline boolean operator!=(const Ipv6Packet& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline Ipv6Header& ipv6Hdr()
    {return field_ipv6Hdr;}
  inline const Ipv6Header& ipv6Hdr() const
    {return field_ipv6Hdr;}
  inline OPTIONAL<OCTETSTRING>& extHdrList()
    {return field_extHdrList;}
  inline const OPTIONAL<OCTETSTRING>& extHdrList() const
    {return field_extHdrList;}
  inline OPTIONAL<Ipv6Payload>& ipv6Payload()
    {return field_ipv6Payload;}
  inline const OPTIONAL<Ipv6Payload>& ipv6Payload() const
    {return field_ipv6Payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Ipv6Packet_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Ipv6Packet_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Ipv6Packet& other_value);
void copy_template(const Ipv6Packet_template& other_value);

public:
Ipv6Packet_template();
Ipv6Packet_template(template_sel other_value);
Ipv6Packet_template(const Ipv6Packet& other_value);
Ipv6Packet_template(const OPTIONAL<Ipv6Packet>& other_value);
Ipv6Packet_template(const Ipv6Packet_template& other_value);
~Ipv6Packet_template();
Ipv6Packet_template& operator=(template_sel other_value);
Ipv6Packet_template& operator=(const Ipv6Packet& other_value);
Ipv6Packet_template& operator=(const OPTIONAL<Ipv6Packet>& other_value);
Ipv6Packet_template& operator=(const Ipv6Packet_template& other_value);
boolean match(const Ipv6Packet& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Ipv6Packet valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Ipv6Packet_template& list_item(unsigned int list_index) const;
Ipv6Header_template& ipv6Hdr();
const Ipv6Header_template& ipv6Hdr() const;
OCTETSTRING_template& extHdrList();
const OCTETSTRING_template& extHdrList() const;
Ipv6Payload_template& ipv6Payload();
const Ipv6Payload_template& ipv6Payload() const;
int size_of() const;
void log() const;
void log_match(const Ipv6Packet& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Ipv6Payload : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_routerAdvMsg = 1, ALT_octetstringMsg = 2 };
private:
union_selection_type union_selection;
union {
RouterAdvertisementMsg *field_routerAdvMsg;
OCTETSTRING *field_octetstringMsg;
};
void copy_value(const Ipv6Payload& other_value);

public:
Ipv6Payload();
Ipv6Payload(const Ipv6Payload& other_value);
~Ipv6Payload();
Ipv6Payload& operator=(const Ipv6Payload& other_value);
boolean operator==(const Ipv6Payload& other_value) const;
inline boolean operator!=(const Ipv6Payload& other_value) const { return !(*this == other_value); }
RouterAdvertisementMsg& routerAdvMsg();
const RouterAdvertisementMsg& routerAdvMsg() const;
OCTETSTRING& octetstringMsg();
const OCTETSTRING& octetstringMsg() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Ipv6Payload_template : public Base_Template {
union {
struct {
Ipv6Payload::union_selection_type union_selection;
union {
RouterAdvertisementMsg_template *field_routerAdvMsg;
OCTETSTRING_template *field_octetstringMsg;
};
} single_value;
struct {
unsigned int n_values;
Ipv6Payload_template *list_value;
} value_list;
};
void copy_value(const Ipv6Payload& other_value);

void copy_template(const Ipv6Payload_template& other_value);

public:
Ipv6Payload_template();
Ipv6Payload_template(template_sel other_value);
Ipv6Payload_template(const Ipv6Payload& other_value);
Ipv6Payload_template(const OPTIONAL<Ipv6Payload>& other_value);
Ipv6Payload_template(const Ipv6Payload_template& other_value);
~Ipv6Payload_template();
void clean_up();
Ipv6Payload_template& operator=(template_sel other_value);
Ipv6Payload_template& operator=(const Ipv6Payload& other_value);
Ipv6Payload_template& operator=(const OPTIONAL<Ipv6Payload>& other_value);
Ipv6Payload_template& operator=(const Ipv6Payload_template& other_value);
boolean match(const Ipv6Payload& other_value, boolean legacy = FALSE) const;
boolean is_value() const;Ipv6Payload valueof() const;
Ipv6Payload_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
RouterAdvertisementMsg_template& routerAdvMsg();
const RouterAdvertisementMsg_template& routerAdvMsg() const;
OCTETSTRING_template& octetstringMsg();
const OCTETSTRING_template& octetstringMsg() const;
boolean ischosen(Ipv6Payload::union_selection_type checked_selection) const;
void log() const;
void log_match(const Ipv6Payload& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RouterAdvertisementMsg : public Base_Type {
  INTEGER field_icmpType;
  INTEGER field_icmpCode;
  OCTETSTRING field_checksum;
  INTEGER field_curHopLimit;
  INTEGER field_managedConfigFlag;
  INTEGER field_otherConfigFlag;
  INTEGER field_homeAgentFlag;
  INTEGER field_reserved;
  INTEGER field_routerLifetime;
  INTEGER field_reachableTime;
  INTEGER field_retransTimer;
  OPTIONAL<RtAdvOptions> field_rtAdvOptions;
  boolean bound_flag;
public:
  RouterAdvertisementMsg();
  RouterAdvertisementMsg(const INTEGER& par_icmpType,
    const INTEGER& par_icmpCode,
    const OCTETSTRING& par_checksum,
    const INTEGER& par_curHopLimit,
    const INTEGER& par_managedConfigFlag,
    const INTEGER& par_otherConfigFlag,
    const INTEGER& par_homeAgentFlag,
    const INTEGER& par_reserved,
    const INTEGER& par_routerLifetime,
    const INTEGER& par_reachableTime,
    const INTEGER& par_retransTimer,
    const OPTIONAL<RtAdvOptions>& par_rtAdvOptions);
  RouterAdvertisementMsg(const RouterAdvertisementMsg& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RouterAdvertisementMsg& operator=(const RouterAdvertisementMsg& other_value);
  boolean operator==(const RouterAdvertisementMsg& other_value) const;
  inline boolean operator!=(const RouterAdvertisementMsg& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& icmpType()
    {return field_icmpType;}
  inline const INTEGER& icmpType() const
    {return field_icmpType;}
  inline INTEGER& icmpCode()
    {return field_icmpCode;}
  inline const INTEGER& icmpCode() const
    {return field_icmpCode;}
  inline OCTETSTRING& checksum()
    {return field_checksum;}
  inline const OCTETSTRING& checksum() const
    {return field_checksum;}
  inline INTEGER& curHopLimit()
    {return field_curHopLimit;}
  inline const INTEGER& curHopLimit() const
    {return field_curHopLimit;}
  inline INTEGER& managedConfigFlag()
    {return field_managedConfigFlag;}
  inline const INTEGER& managedConfigFlag() const
    {return field_managedConfigFlag;}
  inline INTEGER& otherConfigFlag()
    {return field_otherConfigFlag;}
  inline const INTEGER& otherConfigFlag() const
    {return field_otherConfigFlag;}
  inline INTEGER& homeAgentFlag()
    {return field_homeAgentFlag;}
  inline const INTEGER& homeAgentFlag() const
    {return field_homeAgentFlag;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline INTEGER& routerLifetime()
    {return field_routerLifetime;}
  inline const INTEGER& routerLifetime() const
    {return field_routerLifetime;}
  inline INTEGER& reachableTime()
    {return field_reachableTime;}
  inline const INTEGER& reachableTime() const
    {return field_reachableTime;}
  inline INTEGER& retransTimer()
    {return field_retransTimer;}
  inline const INTEGER& retransTimer() const
    {return field_retransTimer;}
  inline OPTIONAL<RtAdvOptions>& rtAdvOptions()
    {return field_rtAdvOptions;}
  inline const OPTIONAL<RtAdvOptions>& rtAdvOptions() const
    {return field_rtAdvOptions;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RouterAdvertisementMsg_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RouterAdvertisementMsg_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RouterAdvertisementMsg& other_value);
void copy_template(const RouterAdvertisementMsg_template& other_value);

public:
RouterAdvertisementMsg_template();
RouterAdvertisementMsg_template(template_sel other_value);
RouterAdvertisementMsg_template(const RouterAdvertisementMsg& other_value);
RouterAdvertisementMsg_template(const OPTIONAL<RouterAdvertisementMsg>& other_value);
RouterAdvertisementMsg_template(const RouterAdvertisementMsg_template& other_value);
~RouterAdvertisementMsg_template();
RouterAdvertisementMsg_template& operator=(template_sel other_value);
RouterAdvertisementMsg_template& operator=(const RouterAdvertisementMsg& other_value);
RouterAdvertisementMsg_template& operator=(const OPTIONAL<RouterAdvertisementMsg>& other_value);
RouterAdvertisementMsg_template& operator=(const RouterAdvertisementMsg_template& other_value);
boolean match(const RouterAdvertisementMsg& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RouterAdvertisementMsg valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RouterAdvertisementMsg_template& list_item(unsigned int list_index) const;
INTEGER_template& icmpType();
const INTEGER_template& icmpType() const;
INTEGER_template& icmpCode();
const INTEGER_template& icmpCode() const;
OCTETSTRING_template& checksum();
const OCTETSTRING_template& checksum() const;
INTEGER_template& curHopLimit();
const INTEGER_template& curHopLimit() const;
INTEGER_template& managedConfigFlag();
const INTEGER_template& managedConfigFlag() const;
INTEGER_template& otherConfigFlag();
const INTEGER_template& otherConfigFlag() const;
INTEGER_template& homeAgentFlag();
const INTEGER_template& homeAgentFlag() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
INTEGER_template& routerLifetime();
const INTEGER_template& routerLifetime() const;
INTEGER_template& reachableTime();
const INTEGER_template& reachableTime() const;
INTEGER_template& retransTimer();
const INTEGER_template& retransTimer() const;
RtAdvOptions_template& rtAdvOptions();
const RtAdvOptions_template& rtAdvOptions() const;
int size_of() const;
void log() const;
void log_match(const RouterAdvertisementMsg& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RtAdvOptions : public Base_Type {
  OPTIONAL<SrcLinkLayerAddress> field_srcLinkLayerAddr;
  OPTIONAL<PrefixInfoList> field_prefixInfoList;
  OPTIONAL<OCTETSTRING> field_otherOption;
  boolean bound_flag;
public:
  RtAdvOptions();
  RtAdvOptions(const OPTIONAL<SrcLinkLayerAddress>& par_srcLinkLayerAddr,
    const OPTIONAL<PrefixInfoList>& par_prefixInfoList,
    const OPTIONAL<OCTETSTRING>& par_otherOption);
  RtAdvOptions(const RtAdvOptions& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RtAdvOptions& operator=(const RtAdvOptions& other_value);
  boolean operator==(const RtAdvOptions& other_value) const;
  inline boolean operator!=(const RtAdvOptions& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<SrcLinkLayerAddress>& srcLinkLayerAddr()
    {return field_srcLinkLayerAddr;}
  inline const OPTIONAL<SrcLinkLayerAddress>& srcLinkLayerAddr() const
    {return field_srcLinkLayerAddr;}
  inline OPTIONAL<PrefixInfoList>& prefixInfoList()
    {return field_prefixInfoList;}
  inline const OPTIONAL<PrefixInfoList>& prefixInfoList() const
    {return field_prefixInfoList;}
  inline OPTIONAL<OCTETSTRING>& otherOption()
    {return field_otherOption;}
  inline const OPTIONAL<OCTETSTRING>& otherOption() const
    {return field_otherOption;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RtAdvOptions_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RtAdvOptions_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RtAdvOptions& other_value);
void copy_template(const RtAdvOptions_template& other_value);

public:
RtAdvOptions_template();
RtAdvOptions_template(template_sel other_value);
RtAdvOptions_template(const RtAdvOptions& other_value);
RtAdvOptions_template(const OPTIONAL<RtAdvOptions>& other_value);
RtAdvOptions_template(const RtAdvOptions_template& other_value);
~RtAdvOptions_template();
RtAdvOptions_template& operator=(template_sel other_value);
RtAdvOptions_template& operator=(const RtAdvOptions& other_value);
RtAdvOptions_template& operator=(const OPTIONAL<RtAdvOptions>& other_value);
RtAdvOptions_template& operator=(const RtAdvOptions_template& other_value);
boolean match(const RtAdvOptions& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RtAdvOptions valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RtAdvOptions_template& list_item(unsigned int list_index) const;
SrcLinkLayerAddress_template& srcLinkLayerAddr();
const SrcLinkLayerAddress_template& srcLinkLayerAddr() const;
PrefixInfoList_template& prefixInfoList();
const PrefixInfoList_template& prefixInfoList() const;
OCTETSTRING_template& otherOption();
const OCTETSTRING_template& otherOption() const;
int size_of() const;
void log() const;
void log_match(const RtAdvOptions& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SrcLinkLayerAddress : public Base_Type {
  INTEGER field_icmpType;
  INTEGER field_optionLength;
  OCTETSTRING field_linkLayerAddr;
  boolean bound_flag;
public:
  SrcLinkLayerAddress();
  SrcLinkLayerAddress(const INTEGER& par_icmpType,
    const INTEGER& par_optionLength,
    const OCTETSTRING& par_linkLayerAddr);
  SrcLinkLayerAddress(const SrcLinkLayerAddress& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SrcLinkLayerAddress& operator=(const SrcLinkLayerAddress& other_value);
  boolean operator==(const SrcLinkLayerAddress& other_value) const;
  inline boolean operator!=(const SrcLinkLayerAddress& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& icmpType()
    {return field_icmpType;}
  inline const INTEGER& icmpType() const
    {return field_icmpType;}
  inline INTEGER& optionLength()
    {return field_optionLength;}
  inline const INTEGER& optionLength() const
    {return field_optionLength;}
  inline OCTETSTRING& linkLayerAddr()
    {return field_linkLayerAddr;}
  inline const OCTETSTRING& linkLayerAddr() const
    {return field_linkLayerAddr;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SrcLinkLayerAddress_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SrcLinkLayerAddress_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SrcLinkLayerAddress& other_value);
void copy_template(const SrcLinkLayerAddress_template& other_value);

public:
SrcLinkLayerAddress_template();
SrcLinkLayerAddress_template(template_sel other_value);
SrcLinkLayerAddress_template(const SrcLinkLayerAddress& other_value);
SrcLinkLayerAddress_template(const OPTIONAL<SrcLinkLayerAddress>& other_value);
SrcLinkLayerAddress_template(const SrcLinkLayerAddress_template& other_value);
~SrcLinkLayerAddress_template();
SrcLinkLayerAddress_template& operator=(template_sel other_value);
SrcLinkLayerAddress_template& operator=(const SrcLinkLayerAddress& other_value);
SrcLinkLayerAddress_template& operator=(const OPTIONAL<SrcLinkLayerAddress>& other_value);
SrcLinkLayerAddress_template& operator=(const SrcLinkLayerAddress_template& other_value);
boolean match(const SrcLinkLayerAddress& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SrcLinkLayerAddress valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SrcLinkLayerAddress_template& list_item(unsigned int list_index) const;
INTEGER_template& icmpType();
const INTEGER_template& icmpType() const;
INTEGER_template& optionLength();
const INTEGER_template& optionLength() const;
OCTETSTRING_template& linkLayerAddr();
const OCTETSTRING_template& linkLayerAddr() const;
int size_of() const;
void log() const;
void log_match(const SrcLinkLayerAddress& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PrefixInfoList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
PrefixInfo **value_elements;
} *val_ptr;

static const PrefixInfo UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PrefixInfoList& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef PrefixInfo of_type;
PrefixInfoList();
PrefixInfoList(null_type other_value);
PrefixInfoList(const PrefixInfoList& other_value);
~PrefixInfoList();

void clean_up();
PrefixInfoList& operator=(null_type other_value);
PrefixInfoList& operator=(const PrefixInfoList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PrefixInfoList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PrefixInfoList& other_value) const { return !(*this == other_value); }

PrefixInfo& operator[](int index_value);
PrefixInfo& operator[](const INTEGER& index_value);
const PrefixInfo& operator[](int index_value) const;
const PrefixInfo& operator[](const INTEGER& index_value) const;

PrefixInfoList operator<<=(int rotate_count) const;
PrefixInfoList operator<<=(const INTEGER& rotate_count) const;
PrefixInfoList operator>>=(int rotate_count) const;
PrefixInfoList operator>>=(const INTEGER& rotate_count) const;

PrefixInfoList operator+(const PrefixInfoList& other_value) const;

PrefixInfoList substr(int index, int returncount) const;

PrefixInfoList replace(int index, int len, const PrefixInfoList& repl) const;

PrefixInfoList replace(int index, int len, const PrefixInfoList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PrefixInfoList_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
PrefixInfo_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PrefixInfoList_template *list_value;
} value_list;
struct {
unsigned int n_items;
PrefixInfo_template *set_items;
} value_set;
};
void copy_value(const PrefixInfoList& other_value);
void copy_template(const PrefixInfoList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
PrefixInfoList_template();
PrefixInfoList_template(template_sel other_value);
PrefixInfoList_template(null_type other_value);
PrefixInfoList_template(const PrefixInfoList& other_value);
PrefixInfoList_template(const OPTIONAL<PrefixInfoList>& other_value);
PrefixInfoList_template(const PrefixInfoList_template& other_value);
~PrefixInfoList_template();

void clean_up();
PrefixInfoList_template& operator=(template_sel other_value);
PrefixInfoList_template& operator=(null_type other_value);
PrefixInfoList_template& operator=(const PrefixInfoList& other_value);
PrefixInfoList_template& operator=(const OPTIONAL<PrefixInfoList>& other_value);
PrefixInfoList_template& operator=(const PrefixInfoList_template& other_value);

PrefixInfo_template& operator[](int index_value);
PrefixInfo_template& operator[](const INTEGER& index_value);
const PrefixInfo_template& operator[](int index_value) const;
const PrefixInfo_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PrefixInfoList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PrefixInfoList valueof() const;
PrefixInfoList substr(int index, int returncount) const;

PrefixInfoList replace(int index, int len, const PrefixInfoList_template& repl) const;

PrefixInfoList replace(int index, int len, const PrefixInfoList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PrefixInfoList_template& list_item(unsigned int list_index);
PrefixInfo_template& set_item(unsigned int set_index);
void log() const;
void log_match(const PrefixInfoList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class PrefixInfo : public Base_Type {
  INTEGER field_icmpType;
  INTEGER field_optionLength;
  INTEGER field_prefixLength;
  INTEGER field_linkFlag;
  INTEGER field_autoConfigFlag;
  INTEGER field_rtAddrFlag;
  INTEGER field_reserved1;
  INTEGER field_validLifetime;
  INTEGER field_preferredLifetime;
  INTEGER field_reserved2;
  OCTETSTRING field_prefix;
  boolean bound_flag;
public:
  PrefixInfo();
  PrefixInfo(const INTEGER& par_icmpType,
    const INTEGER& par_optionLength,
    const INTEGER& par_prefixLength,
    const INTEGER& par_linkFlag,
    const INTEGER& par_autoConfigFlag,
    const INTEGER& par_rtAddrFlag,
    const INTEGER& par_reserved1,
    const INTEGER& par_validLifetime,
    const INTEGER& par_preferredLifetime,
    const INTEGER& par_reserved2,
    const OCTETSTRING& par_prefix);
  PrefixInfo(const PrefixInfo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PrefixInfo& operator=(const PrefixInfo& other_value);
  boolean operator==(const PrefixInfo& other_value) const;
  inline boolean operator!=(const PrefixInfo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& icmpType()
    {return field_icmpType;}
  inline const INTEGER& icmpType() const
    {return field_icmpType;}
  inline INTEGER& optionLength()
    {return field_optionLength;}
  inline const INTEGER& optionLength() const
    {return field_optionLength;}
  inline INTEGER& prefixLength()
    {return field_prefixLength;}
  inline const INTEGER& prefixLength() const
    {return field_prefixLength;}
  inline INTEGER& linkFlag()
    {return field_linkFlag;}
  inline const INTEGER& linkFlag() const
    {return field_linkFlag;}
  inline INTEGER& autoConfigFlag()
    {return field_autoConfigFlag;}
  inline const INTEGER& autoConfigFlag() const
    {return field_autoConfigFlag;}
  inline INTEGER& rtAddrFlag()
    {return field_rtAddrFlag;}
  inline const INTEGER& rtAddrFlag() const
    {return field_rtAddrFlag;}
  inline INTEGER& reserved1()
    {return field_reserved1;}
  inline const INTEGER& reserved1() const
    {return field_reserved1;}
  inline INTEGER& validLifetime()
    {return field_validLifetime;}
  inline const INTEGER& validLifetime() const
    {return field_validLifetime;}
  inline INTEGER& preferredLifetime()
    {return field_preferredLifetime;}
  inline const INTEGER& preferredLifetime() const
    {return field_preferredLifetime;}
  inline INTEGER& reserved2()
    {return field_reserved2;}
  inline const INTEGER& reserved2() const
    {return field_reserved2;}
  inline OCTETSTRING& prefix()
    {return field_prefix;}
  inline const OCTETSTRING& prefix() const
    {return field_prefix;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PrefixInfo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PrefixInfo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PrefixInfo& other_value);
void copy_template(const PrefixInfo_template& other_value);

public:
PrefixInfo_template();
PrefixInfo_template(template_sel other_value);
PrefixInfo_template(const PrefixInfo& other_value);
PrefixInfo_template(const OPTIONAL<PrefixInfo>& other_value);
PrefixInfo_template(const PrefixInfo_template& other_value);
~PrefixInfo_template();
PrefixInfo_template& operator=(template_sel other_value);
PrefixInfo_template& operator=(const PrefixInfo& other_value);
PrefixInfo_template& operator=(const OPTIONAL<PrefixInfo>& other_value);
PrefixInfo_template& operator=(const PrefixInfo_template& other_value);
boolean match(const PrefixInfo& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PrefixInfo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PrefixInfo_template& list_item(unsigned int list_index) const;
INTEGER_template& icmpType();
const INTEGER_template& icmpType() const;
INTEGER_template& optionLength();
const INTEGER_template& optionLength() const;
INTEGER_template& prefixLength();
const INTEGER_template& prefixLength() const;
INTEGER_template& linkFlag();
const INTEGER_template& linkFlag() const;
INTEGER_template& autoConfigFlag();
const INTEGER_template& autoConfigFlag() const;
INTEGER_template& rtAddrFlag();
const INTEGER_template& rtAddrFlag() const;
INTEGER_template& reserved1();
const INTEGER_template& reserved1() const;
INTEGER_template& validLifetime();
const INTEGER_template& validLifetime() const;
INTEGER_template& preferredLifetime();
const INTEGER_template& preferredLifetime() const;
INTEGER_template& reserved2();
const INTEGER_template& reserved2() const;
OCTETSTRING_template& prefix();
const OCTETSTRING_template& prefix() const;
int size_of() const;
void log() const;
void log_match(const PrefixInfo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AcGn6Primitive : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_getInterfaceInfos = 1 };
private:
union_selection_type union_selection;
union {
INTEGER *field_getInterfaceInfos;
};
void copy_value(const AcGn6Primitive& other_value);

public:
AcGn6Primitive();
AcGn6Primitive(const AcGn6Primitive& other_value);
~AcGn6Primitive();
AcGn6Primitive& operator=(const AcGn6Primitive& other_value);
boolean operator==(const AcGn6Primitive& other_value) const;
inline boolean operator!=(const AcGn6Primitive& other_value) const { return !(*this == other_value); }
INTEGER& getInterfaceInfos();
const INTEGER& getInterfaceInfos() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcGn6Primitive_template : public Base_Template {
union {
struct {
AcGn6Primitive::union_selection_type union_selection;
union {
INTEGER_template *field_getInterfaceInfos;
};
} single_value;
struct {
unsigned int n_values;
AcGn6Primitive_template *list_value;
} value_list;
};
void copy_value(const AcGn6Primitive& other_value);

void copy_template(const AcGn6Primitive_template& other_value);

public:
AcGn6Primitive_template();
AcGn6Primitive_template(template_sel other_value);
AcGn6Primitive_template(const AcGn6Primitive& other_value);
AcGn6Primitive_template(const OPTIONAL<AcGn6Primitive>& other_value);
AcGn6Primitive_template(const AcGn6Primitive_template& other_value);
~AcGn6Primitive_template();
void clean_up();
AcGn6Primitive_template& operator=(template_sel other_value);
AcGn6Primitive_template& operator=(const AcGn6Primitive& other_value);
AcGn6Primitive_template& operator=(const OPTIONAL<AcGn6Primitive>& other_value);
AcGn6Primitive_template& operator=(const AcGn6Primitive_template& other_value);
boolean match(const AcGn6Primitive& other_value, boolean legacy = FALSE) const;
boolean is_value() const;AcGn6Primitive valueof() const;
AcGn6Primitive_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& getInterfaceInfos();
const INTEGER_template& getInterfaceInfos() const;
boolean ischosen(AcGn6Primitive::union_selection_type checked_selection) const;
void log() const;
void log_match(const AcGn6Primitive& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AcGn6Response : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_interfaceInfoList = 1 };
private:
union_selection_type union_selection;
union {
AcGn6InterfaceInfoList *field_interfaceInfoList;
};
void copy_value(const AcGn6Response& other_value);

public:
AcGn6Response();
AcGn6Response(const AcGn6Response& other_value);
~AcGn6Response();
AcGn6Response& operator=(const AcGn6Response& other_value);
boolean operator==(const AcGn6Response& other_value) const;
inline boolean operator!=(const AcGn6Response& other_value) const { return !(*this == other_value); }
AcGn6InterfaceInfoList& interfaceInfoList();
const AcGn6InterfaceInfoList& interfaceInfoList() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcGn6Response_template : public Base_Template {
union {
struct {
AcGn6Response::union_selection_type union_selection;
union {
AcGn6InterfaceInfoList_template *field_interfaceInfoList;
};
} single_value;
struct {
unsigned int n_values;
AcGn6Response_template *list_value;
} value_list;
};
void copy_value(const AcGn6Response& other_value);

void copy_template(const AcGn6Response_template& other_value);

public:
AcGn6Response_template();
AcGn6Response_template(template_sel other_value);
AcGn6Response_template(const AcGn6Response& other_value);
AcGn6Response_template(const OPTIONAL<AcGn6Response>& other_value);
AcGn6Response_template(const AcGn6Response_template& other_value);
~AcGn6Response_template();
void clean_up();
AcGn6Response_template& operator=(template_sel other_value);
AcGn6Response_template& operator=(const AcGn6Response& other_value);
AcGn6Response_template& operator=(const OPTIONAL<AcGn6Response>& other_value);
AcGn6Response_template& operator=(const AcGn6Response_template& other_value);
boolean match(const AcGn6Response& other_value, boolean legacy = FALSE) const;
boolean is_value() const;AcGn6Response valueof() const;
AcGn6Response_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
AcGn6InterfaceInfoList_template& interfaceInfoList();
const AcGn6InterfaceInfoList_template& interfaceInfoList() const;
boolean ischosen(AcGn6Response::union_selection_type checked_selection) const;
void log() const;
void log_match(const AcGn6Response& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AcGn6InterfaceInfoList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
AcGn6InterfaceInfo **value_elements;
} *val_ptr;

static const AcGn6InterfaceInfo UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const AcGn6InterfaceInfoList& other_value);

public:
  typedef AcGn6InterfaceInfo of_type;
AcGn6InterfaceInfoList();
AcGn6InterfaceInfoList(null_type other_value);
AcGn6InterfaceInfoList(const AcGn6InterfaceInfoList& other_value);
~AcGn6InterfaceInfoList();

void clean_up();
AcGn6InterfaceInfoList& operator=(null_type other_value);
AcGn6InterfaceInfoList& operator=(const AcGn6InterfaceInfoList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const AcGn6InterfaceInfoList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AcGn6InterfaceInfoList& other_value) const { return !(*this == other_value); }

AcGn6InterfaceInfo& operator[](int index_value);
AcGn6InterfaceInfo& operator[](const INTEGER& index_value);
const AcGn6InterfaceInfo& operator[](int index_value) const;
const AcGn6InterfaceInfo& operator[](const INTEGER& index_value) const;

AcGn6InterfaceInfoList operator<<=(int rotate_count) const;
AcGn6InterfaceInfoList operator<<=(const INTEGER& rotate_count) const;
AcGn6InterfaceInfoList operator>>=(int rotate_count) const;
AcGn6InterfaceInfoList operator>>=(const INTEGER& rotate_count) const;

AcGn6InterfaceInfoList operator+(const AcGn6InterfaceInfoList& other_value) const;

AcGn6InterfaceInfoList substr(int index, int returncount) const;

AcGn6InterfaceInfoList replace(int index, int len, const AcGn6InterfaceInfoList& repl) const;

AcGn6InterfaceInfoList replace(int index, int len, const AcGn6InterfaceInfoList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcGn6InterfaceInfoList_template : public Record_Of_Template {
union {
struct {
int n_elements;
AcGn6InterfaceInfo_template **value_elements;
} single_value;
struct {
unsigned int n_values;
AcGn6InterfaceInfoList_template *list_value;
} value_list;
};
void copy_value(const AcGn6InterfaceInfoList& other_value);
void copy_template(const AcGn6InterfaceInfoList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
AcGn6InterfaceInfoList_template();
AcGn6InterfaceInfoList_template(template_sel other_value);
AcGn6InterfaceInfoList_template(null_type other_value);
AcGn6InterfaceInfoList_template(const AcGn6InterfaceInfoList& other_value);
AcGn6InterfaceInfoList_template(const OPTIONAL<AcGn6InterfaceInfoList>& other_value);
AcGn6InterfaceInfoList_template(const AcGn6InterfaceInfoList_template& other_value);
~AcGn6InterfaceInfoList_template();

void clean_up();
AcGn6InterfaceInfoList_template& operator=(template_sel other_value);
AcGn6InterfaceInfoList_template& operator=(null_type other_value);
AcGn6InterfaceInfoList_template& operator=(const AcGn6InterfaceInfoList& other_value);
AcGn6InterfaceInfoList_template& operator=(const OPTIONAL<AcGn6InterfaceInfoList>& other_value);
AcGn6InterfaceInfoList_template& operator=(const AcGn6InterfaceInfoList_template& other_value);

AcGn6InterfaceInfo_template& operator[](int index_value);
AcGn6InterfaceInfo_template& operator[](const INTEGER& index_value);
const AcGn6InterfaceInfo_template& operator[](int index_value) const;
const AcGn6InterfaceInfo_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const AcGn6InterfaceInfoList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
AcGn6InterfaceInfoList valueof() const;
AcGn6InterfaceInfoList substr(int index, int returncount) const;

AcGn6InterfaceInfoList replace(int index, int len, const AcGn6InterfaceInfoList_template& repl) const;

AcGn6InterfaceInfoList replace(int index, int len, const AcGn6InterfaceInfoList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
AcGn6InterfaceInfoList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const AcGn6InterfaceInfoList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AcGn6InterfaceInfo : public Base_Type {
  CHARSTRING field_interfaceName;
  Ipv6AddressList field_ipv6AddressList;
  boolean bound_flag;
public:
  AcGn6InterfaceInfo();
  AcGn6InterfaceInfo(const CHARSTRING& par_interfaceName,
    const Ipv6AddressList& par_ipv6AddressList);
  AcGn6InterfaceInfo(const AcGn6InterfaceInfo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AcGn6InterfaceInfo& operator=(const AcGn6InterfaceInfo& other_value);
  boolean operator==(const AcGn6InterfaceInfo& other_value) const;
  inline boolean operator!=(const AcGn6InterfaceInfo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& interfaceName()
    {return field_interfaceName;}
  inline const CHARSTRING& interfaceName() const
    {return field_interfaceName;}
  inline Ipv6AddressList& ipv6AddressList()
    {return field_ipv6AddressList;}
  inline const Ipv6AddressList& ipv6AddressList() const
    {return field_ipv6AddressList;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcGn6InterfaceInfo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AcGn6InterfaceInfo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AcGn6InterfaceInfo& other_value);
void copy_template(const AcGn6InterfaceInfo_template& other_value);

public:
AcGn6InterfaceInfo_template();
AcGn6InterfaceInfo_template(template_sel other_value);
AcGn6InterfaceInfo_template(const AcGn6InterfaceInfo& other_value);
AcGn6InterfaceInfo_template(const OPTIONAL<AcGn6InterfaceInfo>& other_value);
AcGn6InterfaceInfo_template(const AcGn6InterfaceInfo_template& other_value);
~AcGn6InterfaceInfo_template();
AcGn6InterfaceInfo_template& operator=(template_sel other_value);
AcGn6InterfaceInfo_template& operator=(const AcGn6InterfaceInfo& other_value);
AcGn6InterfaceInfo_template& operator=(const OPTIONAL<AcGn6InterfaceInfo>& other_value);
AcGn6InterfaceInfo_template& operator=(const AcGn6InterfaceInfo_template& other_value);
boolean match(const AcGn6InterfaceInfo& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AcGn6InterfaceInfo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcGn6InterfaceInfo_template& list_item(unsigned int list_index) const;
CHARSTRING_template& interfaceName();
const CHARSTRING_template& interfaceName() const;
Ipv6AddressList_template& ipv6AddressList();
const Ipv6AddressList_template& ipv6AddressList() const;
int size_of() const;
void log() const;
void log_match(const AcGn6InterfaceInfo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const GvlTable& other_value);
inline boolean operator!=(null_type null_value, const GvlTable& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const AddressTable& other_value);
inline boolean operator!=(null_type null_value, const AddressTable& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const PrefixInfoList& other_value);
inline boolean operator!=(null_type null_value, const PrefixInfoList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const AcGn6InterfaceInfoList& other_value);
inline boolean operator!=(null_type null_value, const AcGn6InterfaceInfoList& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t GvlTableEntry_key_xer_;
extern const TTCN_Typedescriptor_t GvlTableEntry_key_descr_;
extern const XERdescriptor_t GvlTableEntry_prefix_xer_;
extern const TTCN_Typedescriptor_t GvlTableEntry_prefix_descr_;
extern const XERdescriptor_t GvlTableEntry_prefixLength_xer_;
extern const TTCN_Typedescriptor_t GvlTableEntry_prefixLength_descr_;
extern const XERdescriptor_t GvlTableEntry_area_xer_;
extern const TTCN_Typedescriptor_t GvlTableEntry_area_descr_;
extern const XERdescriptor_t GvlTableEntry_interface_xer_;
extern const TTCN_Typedescriptor_t GvlTableEntry_interface_descr_;
extern const TTCN_RAWdescriptor_t GvlTableEntry_raw_;
extern const TTCN_JSONdescriptor_t GvlTableEntry_json_;
extern const TTCN_Typedescriptor_t GvlTableEntry_descr_;
extern const TTCN_RAWdescriptor_t GvlTable_raw_;
extern const TTCN_Typedescriptor_t GvlTable_descr_;
extern const XERdescriptor_t AddressTableEntry_key_xer_;
extern const TTCN_Typedescriptor_t AddressTableEntry_key_descr_;
extern const XERdescriptor_t AddressTableEntry_macAddress_xer_;
extern const TTCN_Typedescriptor_t AddressTableEntry_macAddress_descr_;
extern const XERdescriptor_t AddressTableEntry_macSolNodeMca_xer_;
extern const TTCN_Typedescriptor_t AddressTableEntry_macSolNodeMca_descr_;
extern const TTCN_RAWdescriptor_t Ipv6Address_raw_;
extern const XERdescriptor_t Ipv6Address_xer_;
extern const TTCN_Typedescriptor_t Ipv6Address_descr_;
extern const XERdescriptor_t AddressTableEntry_lla_xer_;
extern const TTCN_Typedescriptor_t AddressTableEntry_lla_descr_;
extern const XERdescriptor_t AddressTableEntry_solNodeMca_xer_;
extern const TTCN_Typedescriptor_t AddressTableEntry_solNodeMca_descr_;
extern const TTCN_RAWdescriptor_t AddressTableEntry_raw_;
extern const TTCN_JSONdescriptor_t AddressTableEntry_json_;
extern const TTCN_Typedescriptor_t AddressTableEntry_descr_;
extern const TTCN_RAWdescriptor_t AddressTable_raw_;
extern const TTCN_Typedescriptor_t AddressTable_descr_;
extern const TTCN_RAWdescriptor_t GvlIdxList_raw_;
extern const TTCN_Typedescriptor_t GvlIdxList_descr_;
extern const XERdescriptor_t GvlIdxList_0_xer_;
extern const TTCN_Typedescriptor_t GvlIdxList_0_descr_;
extern const TTCN_RAWdescriptor_t UInt32List_raw_;
extern const TTCN_Typedescriptor_t UInt32List_descr_;
extern const XERdescriptor_t UInt32List_0_xer_;
extern const TTCN_Typedescriptor_t UInt32List_0_descr_;
extern const INTEGER& c__gvl1;
extern const INTEGER& c__gvl2;
extern const INTEGER& c__gvl3;
extern const CHARSTRING& c__gvl1__name;
extern const CHARSTRING& c__gvl2__name;
extern const CHARSTRING& c__gvl3__name;
extern const CHARSTRING& c__gvlArea1;
extern const CHARSTRING& c__gvlArea2;
extern const CHARSTRING& c__gvlArea3;
extern const OCTETSTRING& c__macBroadcastAddr;
extern const XERdescriptor_t Ipv6Header_version_xer_;
extern const TTCN_Typedescriptor_t Ipv6Header_version_descr_;
extern const XERdescriptor_t Ipv6Header_trafficClass_xer_;
extern const TTCN_Typedescriptor_t Ipv6Header_trafficClass_descr_;
extern const XERdescriptor_t Ipv6Header_flowLabel_xer_;
extern const TTCN_Typedescriptor_t Ipv6Header_flowLabel_descr_;
extern const XERdescriptor_t Ipv6Header_payloadLength_xer_;
extern const TTCN_Typedescriptor_t Ipv6Header_payloadLength_descr_;
extern const XERdescriptor_t Ipv6Header_nextHeader_xer_;
extern const TTCN_Typedescriptor_t Ipv6Header_nextHeader_descr_;
extern const XERdescriptor_t Ipv6Header_hopLimit_xer_;
extern const TTCN_Typedescriptor_t Ipv6Header_hopLimit_descr_;
extern const XERdescriptor_t Ipv6Header_sourceAddress_xer_;
extern const TTCN_Typedescriptor_t Ipv6Header_sourceAddress_descr_;
extern const XERdescriptor_t Ipv6Header_destinationAddress_xer_;
extern const TTCN_Typedescriptor_t Ipv6Header_destinationAddress_descr_;
extern const TTCN_RAWdescriptor_t Ipv6Header_raw_;
extern const TTCN_JSONdescriptor_t Ipv6Header_json_;
extern const TTCN_Typedescriptor_t Ipv6Header_descr_;
extern const TTCN_RAWdescriptor_t Ipv6Packet_raw_;
extern const TTCN_JSONdescriptor_t Ipv6Packet_json_;
extern const TTCN_Typedescriptor_t Ipv6Packet_descr_;
extern const TTCN_RAWdescriptor_t ExtensionHeaderList_raw_;
extern const XERdescriptor_t ExtensionHeaderList_xer_;
extern const TTCN_Typedescriptor_t ExtensionHeaderList_descr_;
extern const XERdescriptor_t Ipv6Packet_extHdrList_xer_;
extern const TTCN_Typedescriptor_t Ipv6Packet_extHdrList_descr_;
extern const TTCN_RAWdescriptor_t Ipv6Payload_raw_;
extern const TTCN_JSONdescriptor_t Ipv6Payload_json_;
extern const TTCN_Typedescriptor_t Ipv6Payload_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_icmpType_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_icmpType_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_icmpCode_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_icmpCode_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_checksum_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_checksum_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_curHopLimit_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_curHopLimit_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_managedConfigFlag_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_managedConfigFlag_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_otherConfigFlag_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_otherConfigFlag_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_homeAgentFlag_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_homeAgentFlag_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_reserved_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_reserved_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_routerLifetime_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_routerLifetime_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_reachableTime_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_reachableTime_descr_;
extern const XERdescriptor_t RouterAdvertisementMsg_retransTimer_xer_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_retransTimer_descr_;
extern const TTCN_RAWdescriptor_t RouterAdvertisementMsg_raw_;
extern const TTCN_JSONdescriptor_t RouterAdvertisementMsg_json_;
extern const TTCN_Typedescriptor_t RouterAdvertisementMsg_descr_;
extern const TTCN_RAWdescriptor_t RtAdvOptions_raw_;
extern const TTCN_JSONdescriptor_t RtAdvOptions_json_;
extern const TTCN_Typedescriptor_t RtAdvOptions_descr_;
extern const XERdescriptor_t SrcLinkLayerAddress_icmpType_xer_;
extern const TTCN_Typedescriptor_t SrcLinkLayerAddress_icmpType_descr_;
extern const XERdescriptor_t SrcLinkLayerAddress_optionLength_xer_;
extern const TTCN_Typedescriptor_t SrcLinkLayerAddress_optionLength_descr_;
extern const XERdescriptor_t SrcLinkLayerAddress_linkLayerAddr_xer_;
extern const TTCN_Typedescriptor_t SrcLinkLayerAddress_linkLayerAddr_descr_;
extern const TTCN_RAWdescriptor_t SrcLinkLayerAddress_raw_;
extern const TTCN_JSONdescriptor_t SrcLinkLayerAddress_json_;
extern const TTCN_Typedescriptor_t SrcLinkLayerAddress_descr_;
extern const TTCN_RAWdescriptor_t PrefixInfoList_raw_;
extern const TTCN_JSONdescriptor_t PrefixInfoList_json_;
extern const TTCN_Typedescriptor_t PrefixInfoList_descr_;
extern const XERdescriptor_t PrefixInfo_icmpType_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_icmpType_descr_;
extern const XERdescriptor_t PrefixInfo_optionLength_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_optionLength_descr_;
extern const XERdescriptor_t PrefixInfo_prefixLength_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_prefixLength_descr_;
extern const XERdescriptor_t PrefixInfo_linkFlag_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_linkFlag_descr_;
extern const XERdescriptor_t PrefixInfo_autoConfigFlag_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_autoConfigFlag_descr_;
extern const XERdescriptor_t PrefixInfo_rtAddrFlag_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_rtAddrFlag_descr_;
extern const XERdescriptor_t PrefixInfo_reserved1_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_reserved1_descr_;
extern const XERdescriptor_t PrefixInfo_validLifetime_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_validLifetime_descr_;
extern const XERdescriptor_t PrefixInfo_preferredLifetime_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_preferredLifetime_descr_;
extern const XERdescriptor_t PrefixInfo_reserved2_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_reserved2_descr_;
extern const TTCN_RAWdescriptor_t Prefix_raw_;
extern const XERdescriptor_t Prefix_xer_;
extern const TTCN_Typedescriptor_t Prefix_descr_;
extern const XERdescriptor_t PrefixInfo_prefix_xer_;
extern const TTCN_Typedescriptor_t PrefixInfo_prefix_descr_;
extern const TTCN_RAWdescriptor_t PrefixInfo_raw_;
extern const TTCN_JSONdescriptor_t PrefixInfo_json_;
extern const TTCN_Typedescriptor_t PrefixInfo_descr_;
extern const XERdescriptor_t RtAdvOptions_otherOption_xer_;
extern const TTCN_Typedescriptor_t RtAdvOptions_otherOption_descr_;
extern const XERdescriptor_t Ipv6Payload_octetstringMsg_xer_;
extern const TTCN_Typedescriptor_t Ipv6Payload_octetstringMsg_descr_;
extern const INTEGER& c__hopHdr;
extern const INTEGER& c__tcpHdr;
extern const INTEGER& c__udpHdr;
extern const INTEGER& c__tunneledIpHdr;
extern const INTEGER& c__routeHdr;
extern const INTEGER& c__fragHdr;
extern const INTEGER& c__espHdr;
extern const INTEGER& c__authHdr;
extern const INTEGER& c__icmpHdr;
extern const INTEGER& c__noNextHdr;
extern const INTEGER& c__dstHdr;
extern const INTEGER& c__mobileHdr;
extern const INTEGER& c__prefixInfo;
extern const INTEGER& c__rtAdvMsg;
extern const OCTETSTRING& c__llaMcaPrefix;
extern const OCTETSTRING& c__llaPrefix;
extern const OCTETSTRING& c__allNodesMcaPostfix;
extern const OCTETSTRING& c__allRoutersMcaPostfix;
extern const OCTETSTRING& c__anycastPostfix;
extern const OCTETSTRING& c__haAnycastPostfix;
extern const OCTETSTRING& c__allNodesMca;
extern const OCTETSTRING& c__allRoutersMca;
extern const OCTETSTRING& c__unspecified;
extern const BITSTRING& c__itsGn6aslGeoAnycastID;
extern const INTEGER& c__maxNrPrefixInfo;
extern const INTEGER& c__rtAddrFlag0;
extern const INTEGER& c__aFlag0;
extern const INTEGER& c__aFlag1;
extern const INTEGER& c__rFlag0;
extern const INTEGER& c__rFlag1;
extern const INTEGER& c__sFlag0;
extern const INTEGER& c__sFlag1;
extern const INTEGER& c__oFlag0;
extern const INTEGER& c__oFlag1;
extern const INTEGER& c__mFlag0;
extern const INTEGER& c__mFlag1;
extern const INTEGER& c__lFlag0;
extern const INTEGER& c__lFlag1;
extern const INTEGER& c__zeroLifetime;
extern const INTEGER& c__validLifetime20s;
extern const INTEGER& c__validLifetime30s;
extern const INTEGER& c__preferredLifetime30s;
extern const INTEGER& c__srcLinkLayerAddress;
extern const INTEGER& c__prefixInfoLen;
extern const TTCN_RAWdescriptor_t AcGn6Primitive_raw_;
extern const TTCN_JSONdescriptor_t AcGn6Primitive_json_;
extern const TTCN_Typedescriptor_t AcGn6Primitive_descr_;
extern const XERdescriptor_t AcGn6Primitive_getInterfaceInfos_xer_;
extern const TTCN_Typedescriptor_t AcGn6Primitive_getInterfaceInfos_descr_;
extern const TTCN_RAWdescriptor_t AcGn6Response_raw_;
extern const TTCN_JSONdescriptor_t AcGn6Response_json_;
extern const TTCN_Typedescriptor_t AcGn6Response_descr_;
extern const TTCN_RAWdescriptor_t AcGn6InterfaceInfoList_raw_;
extern const TTCN_JSONdescriptor_t AcGn6InterfaceInfoList_json_;
extern const TTCN_Typedescriptor_t AcGn6InterfaceInfoList_descr_;
extern const XERdescriptor_t AcGn6InterfaceInfo_interfaceName_xer_;
extern const TTCN_Typedescriptor_t AcGn6InterfaceInfo_interfaceName_descr_;
extern const TTCN_RAWdescriptor_t Ipv6AddressList_raw_;
extern const TTCN_JSONdescriptor_t Ipv6AddressList_json_;
extern const TTCN_Typedescriptor_t Ipv6AddressList_descr_;
extern const XERdescriptor_t Ipv6AddressList_0_xer_;
extern const TTCN_Typedescriptor_t Ipv6AddressList_0_descr_;
extern const TTCN_RAWdescriptor_t AcGn6InterfaceInfo_raw_;
extern const TTCN_JSONdescriptor_t AcGn6InterfaceInfo_json_;
extern const TTCN_Typedescriptor_t AcGn6InterfaceInfo_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
