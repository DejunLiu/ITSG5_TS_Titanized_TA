// This C++ header file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef DSRC2_HH
#define DSRC2_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "ITS_Container.hh"
#include "REGION.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the ASN.1 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef DSRC2_HH
#endif

namespace DSRC2 {

/* Forward declarations of classes */

class PrioritizationResponseStatus;
class PrioritizationResponseStatus_template;
class NodeOffsetPoint;
class NodeOffsetPoint_template;
class Node__XY__20b;
class Node__XY__20b_template;
class Node__XY__22b;
class Node__XY__22b_template;
class Node__XY__24b;
class Node__XY__24b_template;
class Node__XY__26b;
class Node__XY__26b_template;
class Node__XY__28b;
class Node__XY__28b_template;
class Node__XY__32b;
class Node__XY__32b_template;
class Node__LLmD__64b;
class Node__LLmD__64b_template;

} /* end of namespace */

#ifndef DSRC2_HH
#define DSRC2_HH

namespace DSRC2 {

/* Type definitions */

typedef INTEGER SignalGroupID;
typedef INTEGER_template SignalGroupID_template;
typedef INTEGER Offset__B10;
typedef INTEGER_template Offset__B10_template;
typedef INTEGER Offset__B11;
typedef INTEGER_template Offset__B11_template;
typedef INTEGER Offset__B12;
typedef INTEGER_template Offset__B12_template;
typedef INTEGER Offset__B13;
typedef INTEGER_template Offset__B13_template;
typedef INTEGER Offset__B14;
typedef INTEGER_template Offset__B14_template;
typedef INTEGER Offset__B16;
typedef INTEGER_template Offset__B16_template;
typedef REGION::Reg__NodeOffsetPoint RegionalNodeOffsetPoint;
typedef REGION::Reg__NodeOffsetPoint_template RegionalNodeOffsetPoint_template;
typedef INTEGER LaneID;
typedef INTEGER_template LaneID_template;

/* Class definitions */

class PrioritizationResponseStatus : public Base_Type { // enum
friend class PrioritizationResponseStatus_template;
public:
enum enum_type { unknown = 0, requested = 1, processing = 2, watchOtherTraffic = 3, granted = 4, rejected = 5, maxPresence = 6, UNKNOWN_VALUE = 7, UNBOUND_VALUE = 8 };
private:
enum_type enum_value;

public:
PrioritizationResponseStatus();
PrioritizationResponseStatus(int other_value);
PrioritizationResponseStatus(enum_type other_value);
PrioritizationResponseStatus(const PrioritizationResponseStatus& other_value);

PrioritizationResponseStatus& operator=(int other_value);
PrioritizationResponseStatus& operator=(enum_type other_value);
PrioritizationResponseStatus& operator=(const PrioritizationResponseStatus& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const PrioritizationResponseStatus& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PrioritizationResponseStatus& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const PrioritizationResponseStatus& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const PrioritizationResponseStatus& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const PrioritizationResponseStatus& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const PrioritizationResponseStatus& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const PrioritizationResponseStatus& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PrioritizationResponseStatus_template : public Base_Template {
union {
PrioritizationResponseStatus::enum_type single_value;
struct {
unsigned int n_values;
PrioritizationResponseStatus_template *list_value;
} value_list;
};

void copy_template(const PrioritizationResponseStatus_template& other_value);

public:
PrioritizationResponseStatus_template();
PrioritizationResponseStatus_template(template_sel other_value);
PrioritizationResponseStatus_template(int other_value);
PrioritizationResponseStatus_template(PrioritizationResponseStatus::enum_type other_value);
PrioritizationResponseStatus_template(const PrioritizationResponseStatus& other_value);
PrioritizationResponseStatus_template(const OPTIONAL<PrioritizationResponseStatus>& other_value);
PrioritizationResponseStatus_template(const PrioritizationResponseStatus_template& other_value);
~PrioritizationResponseStatus_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
PrioritizationResponseStatus_template& operator=(template_sel other_value);
PrioritizationResponseStatus_template& operator=(int other_value);
PrioritizationResponseStatus_template& operator=(PrioritizationResponseStatus::enum_type other_value);
PrioritizationResponseStatus_template& operator=(const PrioritizationResponseStatus& other_value);
PrioritizationResponseStatus_template& operator=(const OPTIONAL<PrioritizationResponseStatus>& other_value);
PrioritizationResponseStatus_template& operator=(const PrioritizationResponseStatus_template& other_value);

boolean match(PrioritizationResponseStatus::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const PrioritizationResponseStatus& other_value, boolean legacy = FALSE) const;
PrioritizationResponseStatus::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PrioritizationResponseStatus_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PrioritizationResponseStatus& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class NodeOffsetPoint : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_node__XY1 = 1, ALT_node__XY2 = 2, ALT_node__XY3 = 3, ALT_node__XY4 = 4, ALT_node__XY5 = 5, ALT_node__XY6 = 6, ALT_node__LatLon = 7, ALT_node__Regional = 8 };
private:
union_selection_type union_selection;
union {
Node__XY__20b *field_node__XY1;
Node__XY__22b *field_node__XY2;
Node__XY__24b *field_node__XY3;
Node__XY__26b *field_node__XY4;
Node__XY__28b *field_node__XY5;
Node__XY__32b *field_node__XY6;
Node__LLmD__64b *field_node__LatLon;
REGION::Reg__NodeOffsetPoint *field_node__Regional;
};
void copy_value(const NodeOffsetPoint& other_value);

public:
NodeOffsetPoint();
NodeOffsetPoint(const NodeOffsetPoint& other_value);
~NodeOffsetPoint();
NodeOffsetPoint& operator=(const NodeOffsetPoint& other_value);
boolean operator==(const NodeOffsetPoint& other_value) const;
inline boolean operator!=(const NodeOffsetPoint& other_value) const { return !(*this == other_value); }
Node__XY__20b& node__XY1();
const Node__XY__20b& node__XY1() const;
Node__XY__22b& node__XY2();
const Node__XY__22b& node__XY2() const;
Node__XY__24b& node__XY3();
const Node__XY__24b& node__XY3() const;
Node__XY__26b& node__XY4();
const Node__XY__26b& node__XY4() const;
Node__XY__28b& node__XY5();
const Node__XY__28b& node__XY5() const;
Node__XY__32b& node__XY6();
const Node__XY__32b& node__XY6() const;
Node__LLmD__64b& node__LatLon();
const Node__LLmD__64b& node__LatLon() const;
REGION::Reg__NodeOffsetPoint& node__Regional();
const REGION::Reg__NodeOffsetPoint& node__Regional() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
private:
boolean BER_decode_set_selection(const ASN_BER_TLV_t& p_tlv);
public:
boolean BER_decode_isMyMsg(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv);
};

class NodeOffsetPoint_template : public Base_Template {
union {
struct {
NodeOffsetPoint::union_selection_type union_selection;
union {
Node__XY__20b_template *field_node__XY1;
Node__XY__22b_template *field_node__XY2;
Node__XY__24b_template *field_node__XY3;
Node__XY__26b_template *field_node__XY4;
Node__XY__28b_template *field_node__XY5;
Node__XY__32b_template *field_node__XY6;
Node__LLmD__64b_template *field_node__LatLon;
REGION::Reg__NodeOffsetPoint_template *field_node__Regional;
};
} single_value;
struct {
unsigned int n_values;
NodeOffsetPoint_template *list_value;
} value_list;
};
void copy_value(const NodeOffsetPoint& other_value);

void copy_template(const NodeOffsetPoint_template& other_value);

public:
NodeOffsetPoint_template();
NodeOffsetPoint_template(template_sel other_value);
NodeOffsetPoint_template(const NodeOffsetPoint& other_value);
NodeOffsetPoint_template(const OPTIONAL<NodeOffsetPoint>& other_value);
NodeOffsetPoint_template(const NodeOffsetPoint_template& other_value);
~NodeOffsetPoint_template();
void clean_up();
NodeOffsetPoint_template& operator=(template_sel other_value);
NodeOffsetPoint_template& operator=(const NodeOffsetPoint& other_value);
NodeOffsetPoint_template& operator=(const OPTIONAL<NodeOffsetPoint>& other_value);
NodeOffsetPoint_template& operator=(const NodeOffsetPoint_template& other_value);
boolean match(const NodeOffsetPoint& other_value, boolean legacy = FALSE) const;
boolean is_value() const;NodeOffsetPoint valueof() const;
NodeOffsetPoint_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
Node__XY__20b_template& node__XY1();
const Node__XY__20b_template& node__XY1() const;
Node__XY__22b_template& node__XY2();
const Node__XY__22b_template& node__XY2() const;
Node__XY__24b_template& node__XY3();
const Node__XY__24b_template& node__XY3() const;
Node__XY__26b_template& node__XY4();
const Node__XY__26b_template& node__XY4() const;
Node__XY__28b_template& node__XY5();
const Node__XY__28b_template& node__XY5() const;
Node__XY__32b_template& node__XY6();
const Node__XY__32b_template& node__XY6() const;
Node__LLmD__64b_template& node__LatLon();
const Node__LLmD__64b_template& node__LatLon() const;
REGION::Reg__NodeOffsetPoint_template& node__Regional();
const REGION::Reg__NodeOffsetPoint_template& node__Regional() const;
boolean ischosen(NodeOffsetPoint::union_selection_type checked_selection) const;
void log() const;
void log_match(const NodeOffsetPoint& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Node__XY__20b : public Base_Type {
  INTEGER field_x;
  INTEGER field_y;
  boolean bound_flag;
public:
  Node__XY__20b();
  Node__XY__20b(const INTEGER& par_x,
    const INTEGER& par_y);
  Node__XY__20b(const Node__XY__20b& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Node__XY__20b& operator=(const Node__XY__20b& other_value);
  boolean operator==(const Node__XY__20b& other_value) const;
  inline boolean operator!=(const Node__XY__20b& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& x()
    {return field_x;}
  inline const INTEGER& x() const
    {return field_x;}
  inline INTEGER& y()
    {return field_y;}
  inline const INTEGER& y() const
    {return field_y;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Node__XY__20b_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Node__XY__20b_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Node__XY__20b& other_value);
void copy_template(const Node__XY__20b_template& other_value);

public:
Node__XY__20b_template();
Node__XY__20b_template(template_sel other_value);
Node__XY__20b_template(const Node__XY__20b& other_value);
Node__XY__20b_template(const OPTIONAL<Node__XY__20b>& other_value);
Node__XY__20b_template(const Node__XY__20b_template& other_value);
~Node__XY__20b_template();
Node__XY__20b_template& operator=(template_sel other_value);
Node__XY__20b_template& operator=(const Node__XY__20b& other_value);
Node__XY__20b_template& operator=(const OPTIONAL<Node__XY__20b>& other_value);
Node__XY__20b_template& operator=(const Node__XY__20b_template& other_value);
boolean match(const Node__XY__20b& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Node__XY__20b valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Node__XY__20b_template& list_item(unsigned int list_index) const;
INTEGER_template& x();
const INTEGER_template& x() const;
INTEGER_template& y();
const INTEGER_template& y() const;
int size_of() const;
void log() const;
void log_match(const Node__XY__20b& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Node__XY__22b : public Base_Type {
  INTEGER field_x;
  INTEGER field_y;
  boolean bound_flag;
public:
  Node__XY__22b();
  Node__XY__22b(const INTEGER& par_x,
    const INTEGER& par_y);
  Node__XY__22b(const Node__XY__22b& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Node__XY__22b& operator=(const Node__XY__22b& other_value);
  boolean operator==(const Node__XY__22b& other_value) const;
  inline boolean operator!=(const Node__XY__22b& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& x()
    {return field_x;}
  inline const INTEGER& x() const
    {return field_x;}
  inline INTEGER& y()
    {return field_y;}
  inline const INTEGER& y() const
    {return field_y;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Node__XY__22b_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Node__XY__22b_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Node__XY__22b& other_value);
void copy_template(const Node__XY__22b_template& other_value);

public:
Node__XY__22b_template();
Node__XY__22b_template(template_sel other_value);
Node__XY__22b_template(const Node__XY__22b& other_value);
Node__XY__22b_template(const OPTIONAL<Node__XY__22b>& other_value);
Node__XY__22b_template(const Node__XY__22b_template& other_value);
~Node__XY__22b_template();
Node__XY__22b_template& operator=(template_sel other_value);
Node__XY__22b_template& operator=(const Node__XY__22b& other_value);
Node__XY__22b_template& operator=(const OPTIONAL<Node__XY__22b>& other_value);
Node__XY__22b_template& operator=(const Node__XY__22b_template& other_value);
boolean match(const Node__XY__22b& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Node__XY__22b valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Node__XY__22b_template& list_item(unsigned int list_index) const;
INTEGER_template& x();
const INTEGER_template& x() const;
INTEGER_template& y();
const INTEGER_template& y() const;
int size_of() const;
void log() const;
void log_match(const Node__XY__22b& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Node__XY__24b : public Base_Type {
  INTEGER field_x;
  INTEGER field_y;
  boolean bound_flag;
public:
  Node__XY__24b();
  Node__XY__24b(const INTEGER& par_x,
    const INTEGER& par_y);
  Node__XY__24b(const Node__XY__24b& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Node__XY__24b& operator=(const Node__XY__24b& other_value);
  boolean operator==(const Node__XY__24b& other_value) const;
  inline boolean operator!=(const Node__XY__24b& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& x()
    {return field_x;}
  inline const INTEGER& x() const
    {return field_x;}
  inline INTEGER& y()
    {return field_y;}
  inline const INTEGER& y() const
    {return field_y;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Node__XY__24b_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Node__XY__24b_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Node__XY__24b& other_value);
void copy_template(const Node__XY__24b_template& other_value);

public:
Node__XY__24b_template();
Node__XY__24b_template(template_sel other_value);
Node__XY__24b_template(const Node__XY__24b& other_value);
Node__XY__24b_template(const OPTIONAL<Node__XY__24b>& other_value);
Node__XY__24b_template(const Node__XY__24b_template& other_value);
~Node__XY__24b_template();
Node__XY__24b_template& operator=(template_sel other_value);
Node__XY__24b_template& operator=(const Node__XY__24b& other_value);
Node__XY__24b_template& operator=(const OPTIONAL<Node__XY__24b>& other_value);
Node__XY__24b_template& operator=(const Node__XY__24b_template& other_value);
boolean match(const Node__XY__24b& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Node__XY__24b valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Node__XY__24b_template& list_item(unsigned int list_index) const;
INTEGER_template& x();
const INTEGER_template& x() const;
INTEGER_template& y();
const INTEGER_template& y() const;
int size_of() const;
void log() const;
void log_match(const Node__XY__24b& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Node__XY__26b : public Base_Type {
  INTEGER field_x;
  INTEGER field_y;
  boolean bound_flag;
public:
  Node__XY__26b();
  Node__XY__26b(const INTEGER& par_x,
    const INTEGER& par_y);
  Node__XY__26b(const Node__XY__26b& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Node__XY__26b& operator=(const Node__XY__26b& other_value);
  boolean operator==(const Node__XY__26b& other_value) const;
  inline boolean operator!=(const Node__XY__26b& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& x()
    {return field_x;}
  inline const INTEGER& x() const
    {return field_x;}
  inline INTEGER& y()
    {return field_y;}
  inline const INTEGER& y() const
    {return field_y;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Node__XY__26b_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Node__XY__26b_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Node__XY__26b& other_value);
void copy_template(const Node__XY__26b_template& other_value);

public:
Node__XY__26b_template();
Node__XY__26b_template(template_sel other_value);
Node__XY__26b_template(const Node__XY__26b& other_value);
Node__XY__26b_template(const OPTIONAL<Node__XY__26b>& other_value);
Node__XY__26b_template(const Node__XY__26b_template& other_value);
~Node__XY__26b_template();
Node__XY__26b_template& operator=(template_sel other_value);
Node__XY__26b_template& operator=(const Node__XY__26b& other_value);
Node__XY__26b_template& operator=(const OPTIONAL<Node__XY__26b>& other_value);
Node__XY__26b_template& operator=(const Node__XY__26b_template& other_value);
boolean match(const Node__XY__26b& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Node__XY__26b valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Node__XY__26b_template& list_item(unsigned int list_index) const;
INTEGER_template& x();
const INTEGER_template& x() const;
INTEGER_template& y();
const INTEGER_template& y() const;
int size_of() const;
void log() const;
void log_match(const Node__XY__26b& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Node__XY__28b : public Base_Type {
  INTEGER field_x;
  INTEGER field_y;
  boolean bound_flag;
public:
  Node__XY__28b();
  Node__XY__28b(const INTEGER& par_x,
    const INTEGER& par_y);
  Node__XY__28b(const Node__XY__28b& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Node__XY__28b& operator=(const Node__XY__28b& other_value);
  boolean operator==(const Node__XY__28b& other_value) const;
  inline boolean operator!=(const Node__XY__28b& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& x()
    {return field_x;}
  inline const INTEGER& x() const
    {return field_x;}
  inline INTEGER& y()
    {return field_y;}
  inline const INTEGER& y() const
    {return field_y;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Node__XY__28b_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Node__XY__28b_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Node__XY__28b& other_value);
void copy_template(const Node__XY__28b_template& other_value);

public:
Node__XY__28b_template();
Node__XY__28b_template(template_sel other_value);
Node__XY__28b_template(const Node__XY__28b& other_value);
Node__XY__28b_template(const OPTIONAL<Node__XY__28b>& other_value);
Node__XY__28b_template(const Node__XY__28b_template& other_value);
~Node__XY__28b_template();
Node__XY__28b_template& operator=(template_sel other_value);
Node__XY__28b_template& operator=(const Node__XY__28b& other_value);
Node__XY__28b_template& operator=(const OPTIONAL<Node__XY__28b>& other_value);
Node__XY__28b_template& operator=(const Node__XY__28b_template& other_value);
boolean match(const Node__XY__28b& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Node__XY__28b valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Node__XY__28b_template& list_item(unsigned int list_index) const;
INTEGER_template& x();
const INTEGER_template& x() const;
INTEGER_template& y();
const INTEGER_template& y() const;
int size_of() const;
void log() const;
void log_match(const Node__XY__28b& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Node__XY__32b : public Base_Type {
  INTEGER field_x;
  INTEGER field_y;
  boolean bound_flag;
public:
  Node__XY__32b();
  Node__XY__32b(const INTEGER& par_x,
    const INTEGER& par_y);
  Node__XY__32b(const Node__XY__32b& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Node__XY__32b& operator=(const Node__XY__32b& other_value);
  boolean operator==(const Node__XY__32b& other_value) const;
  inline boolean operator!=(const Node__XY__32b& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& x()
    {return field_x;}
  inline const INTEGER& x() const
    {return field_x;}
  inline INTEGER& y()
    {return field_y;}
  inline const INTEGER& y() const
    {return field_y;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Node__XY__32b_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Node__XY__32b_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Node__XY__32b& other_value);
void copy_template(const Node__XY__32b_template& other_value);

public:
Node__XY__32b_template();
Node__XY__32b_template(template_sel other_value);
Node__XY__32b_template(const Node__XY__32b& other_value);
Node__XY__32b_template(const OPTIONAL<Node__XY__32b>& other_value);
Node__XY__32b_template(const Node__XY__32b_template& other_value);
~Node__XY__32b_template();
Node__XY__32b_template& operator=(template_sel other_value);
Node__XY__32b_template& operator=(const Node__XY__32b& other_value);
Node__XY__32b_template& operator=(const OPTIONAL<Node__XY__32b>& other_value);
Node__XY__32b_template& operator=(const Node__XY__32b_template& other_value);
boolean match(const Node__XY__32b& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Node__XY__32b valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Node__XY__32b_template& list_item(unsigned int list_index) const;
INTEGER_template& x();
const INTEGER_template& x() const;
INTEGER_template& y();
const INTEGER_template& y() const;
int size_of() const;
void log() const;
void log_match(const Node__XY__32b& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Node__LLmD__64b : public Base_Type {
  INTEGER field_lon;
  INTEGER field_lat;
  boolean bound_flag;
public:
  Node__LLmD__64b();
  Node__LLmD__64b(const INTEGER& par_lon,
    const INTEGER& par_lat);
  Node__LLmD__64b(const Node__LLmD__64b& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Node__LLmD__64b& operator=(const Node__LLmD__64b& other_value);
  boolean operator==(const Node__LLmD__64b& other_value) const;
  inline boolean operator!=(const Node__LLmD__64b& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& lon()
    {return field_lon;}
  inline const INTEGER& lon() const
    {return field_lon;}
  inline INTEGER& lat()
    {return field_lat;}
  inline const INTEGER& lat() const
    {return field_lat;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Node__LLmD__64b_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Node__LLmD__64b_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Node__LLmD__64b& other_value);
void copy_template(const Node__LLmD__64b_template& other_value);

public:
Node__LLmD__64b_template();
Node__LLmD__64b_template(template_sel other_value);
Node__LLmD__64b_template(const Node__LLmD__64b& other_value);
Node__LLmD__64b_template(const OPTIONAL<Node__LLmD__64b>& other_value);
Node__LLmD__64b_template(const Node__LLmD__64b_template& other_value);
~Node__LLmD__64b_template();
Node__LLmD__64b_template& operator=(template_sel other_value);
Node__LLmD__64b_template& operator=(const Node__LLmD__64b& other_value);
Node__LLmD__64b_template& operator=(const OPTIONAL<Node__LLmD__64b>& other_value);
Node__LLmD__64b_template& operator=(const Node__LLmD__64b_template& other_value);
boolean match(const Node__LLmD__64b& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Node__LLmD__64b valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Node__LLmD__64b_template& list_item(unsigned int list_index) const;
INTEGER_template& lon();
const INTEGER_template& lon() const;
INTEGER_template& lat();
const INTEGER_template& lat() const;
int size_of() const;
void log() const;
void log_match(const Node__LLmD__64b& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Global variable declarations */

extern const TTCN_JSONdescriptor_t PrioritizationResponseStatus_json_;
extern const TTCN_Typedescriptor_t PrioritizationResponseStatus_descr_;
extern const TTCN_Typedescriptor_t& SignalGroupID_descr_;
extern const TTCN_JSONdescriptor_t NodeOffsetPoint_json_;
extern const TTCN_Typedescriptor_t NodeOffsetPoint_descr_;
extern const TTCN_Typedescriptor_t& Offset__B10_descr_;
extern const ASN_BERdescriptor_t Node__XY__20b_x_ber_;
extern const TTCN_Typedescriptor_t Node__XY__20b_x_descr_;
extern const ASN_BERdescriptor_t Node__XY__20b_y_ber_;
extern const TTCN_Typedescriptor_t Node__XY__20b_y_descr_;
extern const TTCN_JSONdescriptor_t Node__XY__20b_json_;
extern const TTCN_Typedescriptor_t Node__XY__20b_descr_;
extern const ASN_BERdescriptor_t NodeOffsetPoint_node__XY1_ber_;
extern const TTCN_Typedescriptor_t NodeOffsetPoint_node__XY1_descr_;
extern const TTCN_Typedescriptor_t& Offset__B11_descr_;
extern const ASN_BERdescriptor_t Node__XY__22b_x_ber_;
extern const TTCN_Typedescriptor_t Node__XY__22b_x_descr_;
extern const ASN_BERdescriptor_t Node__XY__22b_y_ber_;
extern const TTCN_Typedescriptor_t Node__XY__22b_y_descr_;
extern const TTCN_JSONdescriptor_t Node__XY__22b_json_;
extern const TTCN_Typedescriptor_t Node__XY__22b_descr_;
extern const ASN_BERdescriptor_t NodeOffsetPoint_node__XY2_ber_;
extern const TTCN_Typedescriptor_t NodeOffsetPoint_node__XY2_descr_;
extern const TTCN_Typedescriptor_t& Offset__B12_descr_;
extern const ASN_BERdescriptor_t Node__XY__24b_x_ber_;
extern const TTCN_Typedescriptor_t Node__XY__24b_x_descr_;
extern const ASN_BERdescriptor_t Node__XY__24b_y_ber_;
extern const TTCN_Typedescriptor_t Node__XY__24b_y_descr_;
extern const TTCN_JSONdescriptor_t Node__XY__24b_json_;
extern const TTCN_Typedescriptor_t Node__XY__24b_descr_;
extern const ASN_BERdescriptor_t NodeOffsetPoint_node__XY3_ber_;
extern const TTCN_Typedescriptor_t NodeOffsetPoint_node__XY3_descr_;
extern const TTCN_Typedescriptor_t& Offset__B13_descr_;
extern const ASN_BERdescriptor_t Node__XY__26b_x_ber_;
extern const TTCN_Typedescriptor_t Node__XY__26b_x_descr_;
extern const ASN_BERdescriptor_t Node__XY__26b_y_ber_;
extern const TTCN_Typedescriptor_t Node__XY__26b_y_descr_;
extern const TTCN_JSONdescriptor_t Node__XY__26b_json_;
extern const TTCN_Typedescriptor_t Node__XY__26b_descr_;
extern const ASN_BERdescriptor_t NodeOffsetPoint_node__XY4_ber_;
extern const TTCN_Typedescriptor_t NodeOffsetPoint_node__XY4_descr_;
extern const TTCN_Typedescriptor_t& Offset__B14_descr_;
extern const ASN_BERdescriptor_t Node__XY__28b_x_ber_;
extern const TTCN_Typedescriptor_t Node__XY__28b_x_descr_;
extern const ASN_BERdescriptor_t Node__XY__28b_y_ber_;
extern const TTCN_Typedescriptor_t Node__XY__28b_y_descr_;
extern const TTCN_JSONdescriptor_t Node__XY__28b_json_;
extern const TTCN_Typedescriptor_t Node__XY__28b_descr_;
extern const ASN_BERdescriptor_t NodeOffsetPoint_node__XY5_ber_;
extern const TTCN_Typedescriptor_t NodeOffsetPoint_node__XY5_descr_;
extern const TTCN_Typedescriptor_t& Offset__B16_descr_;
extern const ASN_BERdescriptor_t Node__XY__32b_x_ber_;
extern const TTCN_Typedescriptor_t Node__XY__32b_x_descr_;
extern const ASN_BERdescriptor_t Node__XY__32b_y_ber_;
extern const TTCN_Typedescriptor_t Node__XY__32b_y_descr_;
extern const TTCN_JSONdescriptor_t Node__XY__32b_json_;
extern const TTCN_Typedescriptor_t Node__XY__32b_descr_;
extern const ASN_BERdescriptor_t NodeOffsetPoint_node__XY6_ber_;
extern const TTCN_Typedescriptor_t NodeOffsetPoint_node__XY6_descr_;
extern const ASN_BERdescriptor_t Node__LLmD__64b_lon_ber_;
extern const TTCN_Typedescriptor_t Node__LLmD__64b_lon_descr_;
extern const ASN_BERdescriptor_t Node__LLmD__64b_lat_ber_;
extern const TTCN_Typedescriptor_t Node__LLmD__64b_lat_descr_;
extern const TTCN_JSONdescriptor_t Node__LLmD__64b_json_;
extern const TTCN_Typedescriptor_t Node__LLmD__64b_descr_;
extern const ASN_BERdescriptor_t NodeOffsetPoint_node__LatLon_ber_;
extern const TTCN_Typedescriptor_t NodeOffsetPoint_node__LatLon_descr_;
extern const TTCN_Typedescriptor_t& RegionalNodeOffsetPoint_descr_;
extern const ASN_BERdescriptor_t NodeOffsetPoint_node__Regional_ber_;
extern const TTCN_Typedescriptor_t NodeOffsetPoint_node__Regional_descr_;
extern const TTCN_Typedescriptor_t& LaneID_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
