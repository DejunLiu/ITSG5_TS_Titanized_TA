// This C++ header file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef DENM__PDU__Descriptions_HH
#define DENM__PDU__Descriptions_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "ITS_Container.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the ASN.1 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef DENM__PDU__Descriptions_HH
#endif

namespace DENM__PDU__Descriptions {

/* Forward declarations of classes */

class ManagementContainer;
class ManagementContainer_template;
class Termination;
class Termination_template;
class DecentralizedEnvironmentalNotificationMessage;
class DecentralizedEnvironmentalNotificationMessage_template;
class SituationContainer;
class SituationContainer_template;
class LocationContainer;
class LocationContainer_template;
class AlacarteContainer;
class AlacarteContainer_template;
class ImpactReductionContainer;
class ImpactReductionContainer_template;
class RoadWorksContainerExtended;
class RoadWorksContainerExtended_template;
class ReferenceDenms;
class ReferenceDenms_template;
class StationaryVehicleContainer;
class StationaryVehicleContainer_template;
class DENM;
class DENM_template;

} /* end of namespace */

#ifndef DENM__PDU__Descriptions_HH
#define DENM__PDU__Descriptions_HH

namespace DENM__PDU__Descriptions {

/* Class definitions */

class ManagementContainer : public Base_Type {
  ITS__Container::ActionID field_actionID;
  INTEGER field_detectionTime;
  INTEGER field_referenceTime;
  OPTIONAL<Termination> field_termination;
  ITS__Container::ReferencePosition field_eventPosition;
  OPTIONAL<ITS__Container::RelevanceDistance> field_relevanceDistance;
  OPTIONAL<ITS__Container::RelevanceTrafficDirection> field_relevanceTrafficDirection;
  INTEGER field_validityDuration;
  OPTIONAL<INTEGER> field_transmissionInterval;
  INTEGER field_stationType;
  boolean bound_flag;
public:
  ManagementContainer();
  ManagementContainer(const ITS__Container::ActionID& par_actionID,
    const INTEGER& par_detectionTime,
    const INTEGER& par_referenceTime,
    const OPTIONAL<Termination>& par_termination,
    const ITS__Container::ReferencePosition& par_eventPosition,
    const OPTIONAL<ITS__Container::RelevanceDistance>& par_relevanceDistance,
    const OPTIONAL<ITS__Container::RelevanceTrafficDirection>& par_relevanceTrafficDirection,
    const INTEGER& par_validityDuration,
    const OPTIONAL<INTEGER>& par_transmissionInterval,
    const INTEGER& par_stationType);
  ManagementContainer(const ManagementContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ManagementContainer& operator=(const ManagementContainer& other_value);
  boolean operator==(const ManagementContainer& other_value) const;
  inline boolean operator!=(const ManagementContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ITS__Container::ActionID& actionID()
    {return field_actionID;}
  inline const ITS__Container::ActionID& actionID() const
    {return field_actionID;}
  inline INTEGER& detectionTime()
    {return field_detectionTime;}
  inline const INTEGER& detectionTime() const
    {return field_detectionTime;}
  inline INTEGER& referenceTime()
    {return field_referenceTime;}
  inline const INTEGER& referenceTime() const
    {return field_referenceTime;}
  inline OPTIONAL<Termination>& termination()
    {return field_termination;}
  inline const OPTIONAL<Termination>& termination() const
    {return field_termination;}
  inline ITS__Container::ReferencePosition& eventPosition()
    {return field_eventPosition;}
  inline const ITS__Container::ReferencePosition& eventPosition() const
    {return field_eventPosition;}
  inline OPTIONAL<ITS__Container::RelevanceDistance>& relevanceDistance()
    {return field_relevanceDistance;}
  inline const OPTIONAL<ITS__Container::RelevanceDistance>& relevanceDistance() const
    {return field_relevanceDistance;}
  inline OPTIONAL<ITS__Container::RelevanceTrafficDirection>& relevanceTrafficDirection()
    {return field_relevanceTrafficDirection;}
  inline const OPTIONAL<ITS__Container::RelevanceTrafficDirection>& relevanceTrafficDirection() const
    {return field_relevanceTrafficDirection;}
  inline INTEGER& validityDuration()
    {return field_validityDuration;}
  inline const INTEGER& validityDuration() const
    {return field_validityDuration;}
  inline OPTIONAL<INTEGER>& transmissionInterval()
    {return field_transmissionInterval;}
  inline const OPTIONAL<INTEGER>& transmissionInterval() const
    {return field_transmissionInterval;}
  inline INTEGER& stationType()
    {return field_stationType;}
  inline const INTEGER& stationType() const
    {return field_stationType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ManagementContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ManagementContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ManagementContainer& other_value);
void copy_template(const ManagementContainer_template& other_value);

public:
ManagementContainer_template();
ManagementContainer_template(template_sel other_value);
ManagementContainer_template(const ManagementContainer& other_value);
ManagementContainer_template(const OPTIONAL<ManagementContainer>& other_value);
ManagementContainer_template(const ManagementContainer_template& other_value);
~ManagementContainer_template();
ManagementContainer_template& operator=(template_sel other_value);
ManagementContainer_template& operator=(const ManagementContainer& other_value);
ManagementContainer_template& operator=(const OPTIONAL<ManagementContainer>& other_value);
ManagementContainer_template& operator=(const ManagementContainer_template& other_value);
boolean match(const ManagementContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ManagementContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ManagementContainer_template& list_item(unsigned int list_index) const;
ITS__Container::ActionID_template& actionID();
const ITS__Container::ActionID_template& actionID() const;
INTEGER_template& detectionTime();
const INTEGER_template& detectionTime() const;
INTEGER_template& referenceTime();
const INTEGER_template& referenceTime() const;
Termination_template& termination();
const Termination_template& termination() const;
ITS__Container::ReferencePosition_template& eventPosition();
const ITS__Container::ReferencePosition_template& eventPosition() const;
ITS__Container::RelevanceDistance_template& relevanceDistance();
const ITS__Container::RelevanceDistance_template& relevanceDistance() const;
ITS__Container::RelevanceTrafficDirection_template& relevanceTrafficDirection();
const ITS__Container::RelevanceTrafficDirection_template& relevanceTrafficDirection() const;
INTEGER_template& validityDuration();
const INTEGER_template& validityDuration() const;
INTEGER_template& transmissionInterval();
const INTEGER_template& transmissionInterval() const;
INTEGER_template& stationType();
const INTEGER_template& stationType() const;
int size_of() const;
void log() const;
void log_match(const ManagementContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Termination : public Base_Type { // enum
friend class Termination_template;
public:
enum enum_type { isCancellation = 0, isNegation = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
Termination();
Termination(int other_value);
Termination(enum_type other_value);
Termination(const Termination& other_value);

Termination& operator=(int other_value);
Termination& operator=(enum_type other_value);
Termination& operator=(const Termination& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Termination& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Termination& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Termination& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Termination& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Termination& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Termination& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Termination& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Termination_template : public Base_Template {
union {
Termination::enum_type single_value;
struct {
unsigned int n_values;
Termination_template *list_value;
} value_list;
};

void copy_template(const Termination_template& other_value);

public:
Termination_template();
Termination_template(template_sel other_value);
Termination_template(int other_value);
Termination_template(Termination::enum_type other_value);
Termination_template(const Termination& other_value);
Termination_template(const OPTIONAL<Termination>& other_value);
Termination_template(const Termination_template& other_value);
~Termination_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Termination_template& operator=(template_sel other_value);
Termination_template& operator=(int other_value);
Termination_template& operator=(Termination::enum_type other_value);
Termination_template& operator=(const Termination& other_value);
Termination_template& operator=(const OPTIONAL<Termination>& other_value);
Termination_template& operator=(const Termination_template& other_value);

boolean match(Termination::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const Termination& other_value, boolean legacy = FALSE) const;
Termination::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Termination_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Termination& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class DecentralizedEnvironmentalNotificationMessage : public Base_Type {
  ManagementContainer field_management;
  OPTIONAL<SituationContainer> field_situation;
  OPTIONAL<LocationContainer> field_location;
  OPTIONAL<AlacarteContainer> field_alacarte;
  boolean bound_flag;
public:
  DecentralizedEnvironmentalNotificationMessage();
  DecentralizedEnvironmentalNotificationMessage(const ManagementContainer& par_management,
    const OPTIONAL<SituationContainer>& par_situation,
    const OPTIONAL<LocationContainer>& par_location,
    const OPTIONAL<AlacarteContainer>& par_alacarte);
  DecentralizedEnvironmentalNotificationMessage(const DecentralizedEnvironmentalNotificationMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DecentralizedEnvironmentalNotificationMessage& operator=(const DecentralizedEnvironmentalNotificationMessage& other_value);
  boolean operator==(const DecentralizedEnvironmentalNotificationMessage& other_value) const;
  inline boolean operator!=(const DecentralizedEnvironmentalNotificationMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ManagementContainer& management()
    {return field_management;}
  inline const ManagementContainer& management() const
    {return field_management;}
  inline OPTIONAL<SituationContainer>& situation()
    {return field_situation;}
  inline const OPTIONAL<SituationContainer>& situation() const
    {return field_situation;}
  inline OPTIONAL<LocationContainer>& location()
    {return field_location;}
  inline const OPTIONAL<LocationContainer>& location() const
    {return field_location;}
  inline OPTIONAL<AlacarteContainer>& alacarte()
    {return field_alacarte;}
  inline const OPTIONAL<AlacarteContainer>& alacarte() const
    {return field_alacarte;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DecentralizedEnvironmentalNotificationMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DecentralizedEnvironmentalNotificationMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DecentralizedEnvironmentalNotificationMessage& other_value);
void copy_template(const DecentralizedEnvironmentalNotificationMessage_template& other_value);

public:
DecentralizedEnvironmentalNotificationMessage_template();
DecentralizedEnvironmentalNotificationMessage_template(template_sel other_value);
DecentralizedEnvironmentalNotificationMessage_template(const DecentralizedEnvironmentalNotificationMessage& other_value);
DecentralizedEnvironmentalNotificationMessage_template(const OPTIONAL<DecentralizedEnvironmentalNotificationMessage>& other_value);
DecentralizedEnvironmentalNotificationMessage_template(const DecentralizedEnvironmentalNotificationMessage_template& other_value);
~DecentralizedEnvironmentalNotificationMessage_template();
DecentralizedEnvironmentalNotificationMessage_template& operator=(template_sel other_value);
DecentralizedEnvironmentalNotificationMessage_template& operator=(const DecentralizedEnvironmentalNotificationMessage& other_value);
DecentralizedEnvironmentalNotificationMessage_template& operator=(const OPTIONAL<DecentralizedEnvironmentalNotificationMessage>& other_value);
DecentralizedEnvironmentalNotificationMessage_template& operator=(const DecentralizedEnvironmentalNotificationMessage_template& other_value);
boolean match(const DecentralizedEnvironmentalNotificationMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DecentralizedEnvironmentalNotificationMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DecentralizedEnvironmentalNotificationMessage_template& list_item(unsigned int list_index) const;
ManagementContainer_template& management();
const ManagementContainer_template& management() const;
SituationContainer_template& situation();
const SituationContainer_template& situation() const;
LocationContainer_template& location();
const LocationContainer_template& location() const;
AlacarteContainer_template& alacarte();
const AlacarteContainer_template& alacarte() const;
int size_of() const;
void log() const;
void log_match(const DecentralizedEnvironmentalNotificationMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SituationContainer : public Base_Type {
  INTEGER field_informationQuality;
  ITS__Container::CauseCode field_eventType;
  OPTIONAL<ITS__Container::CauseCode> field_linkedCause;
  OPTIONAL<ITS__Container::EventHistory> field_eventHistory;
  boolean bound_flag;
public:
  SituationContainer();
  SituationContainer(const INTEGER& par_informationQuality,
    const ITS__Container::CauseCode& par_eventType,
    const OPTIONAL<ITS__Container::CauseCode>& par_linkedCause,
    const OPTIONAL<ITS__Container::EventHistory>& par_eventHistory);
  SituationContainer(const SituationContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SituationContainer& operator=(const SituationContainer& other_value);
  boolean operator==(const SituationContainer& other_value) const;
  inline boolean operator!=(const SituationContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& informationQuality()
    {return field_informationQuality;}
  inline const INTEGER& informationQuality() const
    {return field_informationQuality;}
  inline ITS__Container::CauseCode& eventType()
    {return field_eventType;}
  inline const ITS__Container::CauseCode& eventType() const
    {return field_eventType;}
  inline OPTIONAL<ITS__Container::CauseCode>& linkedCause()
    {return field_linkedCause;}
  inline const OPTIONAL<ITS__Container::CauseCode>& linkedCause() const
    {return field_linkedCause;}
  inline OPTIONAL<ITS__Container::EventHistory>& eventHistory()
    {return field_eventHistory;}
  inline const OPTIONAL<ITS__Container::EventHistory>& eventHistory() const
    {return field_eventHistory;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SituationContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SituationContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SituationContainer& other_value);
void copy_template(const SituationContainer_template& other_value);

public:
SituationContainer_template();
SituationContainer_template(template_sel other_value);
SituationContainer_template(const SituationContainer& other_value);
SituationContainer_template(const OPTIONAL<SituationContainer>& other_value);
SituationContainer_template(const SituationContainer_template& other_value);
~SituationContainer_template();
SituationContainer_template& operator=(template_sel other_value);
SituationContainer_template& operator=(const SituationContainer& other_value);
SituationContainer_template& operator=(const OPTIONAL<SituationContainer>& other_value);
SituationContainer_template& operator=(const SituationContainer_template& other_value);
boolean match(const SituationContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SituationContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SituationContainer_template& list_item(unsigned int list_index) const;
INTEGER_template& informationQuality();
const INTEGER_template& informationQuality() const;
ITS__Container::CauseCode_template& eventType();
const ITS__Container::CauseCode_template& eventType() const;
ITS__Container::CauseCode_template& linkedCause();
const ITS__Container::CauseCode_template& linkedCause() const;
ITS__Container::EventHistory_template& eventHistory();
const ITS__Container::EventHistory_template& eventHistory() const;
int size_of() const;
void log() const;
void log_match(const SituationContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LocationContainer : public Base_Type {
  OPTIONAL<ITS__Container::Speed> field_eventSpeed;
  OPTIONAL<ITS__Container::Heading> field_eventPositionHeading;
  ITS__Container::Traces field_traces;
  OPTIONAL<ITS__Container::RoadType> field_roadType;
  boolean bound_flag;
public:
  LocationContainer();
  LocationContainer(const OPTIONAL<ITS__Container::Speed>& par_eventSpeed,
    const OPTIONAL<ITS__Container::Heading>& par_eventPositionHeading,
    const ITS__Container::Traces& par_traces,
    const OPTIONAL<ITS__Container::RoadType>& par_roadType);
  LocationContainer(const LocationContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LocationContainer& operator=(const LocationContainer& other_value);
  boolean operator==(const LocationContainer& other_value) const;
  inline boolean operator!=(const LocationContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<ITS__Container::Speed>& eventSpeed()
    {return field_eventSpeed;}
  inline const OPTIONAL<ITS__Container::Speed>& eventSpeed() const
    {return field_eventSpeed;}
  inline OPTIONAL<ITS__Container::Heading>& eventPositionHeading()
    {return field_eventPositionHeading;}
  inline const OPTIONAL<ITS__Container::Heading>& eventPositionHeading() const
    {return field_eventPositionHeading;}
  inline ITS__Container::Traces& traces()
    {return field_traces;}
  inline const ITS__Container::Traces& traces() const
    {return field_traces;}
  inline OPTIONAL<ITS__Container::RoadType>& roadType()
    {return field_roadType;}
  inline const OPTIONAL<ITS__Container::RoadType>& roadType() const
    {return field_roadType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LocationContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LocationContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LocationContainer& other_value);
void copy_template(const LocationContainer_template& other_value);

public:
LocationContainer_template();
LocationContainer_template(template_sel other_value);
LocationContainer_template(const LocationContainer& other_value);
LocationContainer_template(const OPTIONAL<LocationContainer>& other_value);
LocationContainer_template(const LocationContainer_template& other_value);
~LocationContainer_template();
LocationContainer_template& operator=(template_sel other_value);
LocationContainer_template& operator=(const LocationContainer& other_value);
LocationContainer_template& operator=(const OPTIONAL<LocationContainer>& other_value);
LocationContainer_template& operator=(const LocationContainer_template& other_value);
boolean match(const LocationContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LocationContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LocationContainer_template& list_item(unsigned int list_index) const;
ITS__Container::Speed_template& eventSpeed();
const ITS__Container::Speed_template& eventSpeed() const;
ITS__Container::Heading_template& eventPositionHeading();
const ITS__Container::Heading_template& eventPositionHeading() const;
ITS__Container::Traces_template& traces();
const ITS__Container::Traces_template& traces() const;
ITS__Container::RoadType_template& roadType();
const ITS__Container::RoadType_template& roadType() const;
int size_of() const;
void log() const;
void log_match(const LocationContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AlacarteContainer : public Base_Type {
  OPTIONAL<INTEGER> field_lanePosition;
  OPTIONAL<ImpactReductionContainer> field_impactReduction;
  OPTIONAL<INTEGER> field_externalTemperature;
  OPTIONAL<RoadWorksContainerExtended> field_roadWorks;
  OPTIONAL<ITS__Container::PositioningSolutionType> field_positioningSolution;
  OPTIONAL<StationaryVehicleContainer> field_stationaryVehicle;
  boolean bound_flag;
public:
  AlacarteContainer();
  AlacarteContainer(const OPTIONAL<INTEGER>& par_lanePosition,
    const OPTIONAL<ImpactReductionContainer>& par_impactReduction,
    const OPTIONAL<INTEGER>& par_externalTemperature,
    const OPTIONAL<RoadWorksContainerExtended>& par_roadWorks,
    const OPTIONAL<ITS__Container::PositioningSolutionType>& par_positioningSolution,
    const OPTIONAL<StationaryVehicleContainer>& par_stationaryVehicle);
  AlacarteContainer(const AlacarteContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AlacarteContainer& operator=(const AlacarteContainer& other_value);
  boolean operator==(const AlacarteContainer& other_value) const;
  inline boolean operator!=(const AlacarteContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& lanePosition()
    {return field_lanePosition;}
  inline const OPTIONAL<INTEGER>& lanePosition() const
    {return field_lanePosition;}
  inline OPTIONAL<ImpactReductionContainer>& impactReduction()
    {return field_impactReduction;}
  inline const OPTIONAL<ImpactReductionContainer>& impactReduction() const
    {return field_impactReduction;}
  inline OPTIONAL<INTEGER>& externalTemperature()
    {return field_externalTemperature;}
  inline const OPTIONAL<INTEGER>& externalTemperature() const
    {return field_externalTemperature;}
  inline OPTIONAL<RoadWorksContainerExtended>& roadWorks()
    {return field_roadWorks;}
  inline const OPTIONAL<RoadWorksContainerExtended>& roadWorks() const
    {return field_roadWorks;}
  inline OPTIONAL<ITS__Container::PositioningSolutionType>& positioningSolution()
    {return field_positioningSolution;}
  inline const OPTIONAL<ITS__Container::PositioningSolutionType>& positioningSolution() const
    {return field_positioningSolution;}
  inline OPTIONAL<StationaryVehicleContainer>& stationaryVehicle()
    {return field_stationaryVehicle;}
  inline const OPTIONAL<StationaryVehicleContainer>& stationaryVehicle() const
    {return field_stationaryVehicle;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AlacarteContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AlacarteContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AlacarteContainer& other_value);
void copy_template(const AlacarteContainer_template& other_value);

public:
AlacarteContainer_template();
AlacarteContainer_template(template_sel other_value);
AlacarteContainer_template(const AlacarteContainer& other_value);
AlacarteContainer_template(const OPTIONAL<AlacarteContainer>& other_value);
AlacarteContainer_template(const AlacarteContainer_template& other_value);
~AlacarteContainer_template();
AlacarteContainer_template& operator=(template_sel other_value);
AlacarteContainer_template& operator=(const AlacarteContainer& other_value);
AlacarteContainer_template& operator=(const OPTIONAL<AlacarteContainer>& other_value);
AlacarteContainer_template& operator=(const AlacarteContainer_template& other_value);
boolean match(const AlacarteContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AlacarteContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AlacarteContainer_template& list_item(unsigned int list_index) const;
INTEGER_template& lanePosition();
const INTEGER_template& lanePosition() const;
ImpactReductionContainer_template& impactReduction();
const ImpactReductionContainer_template& impactReduction() const;
INTEGER_template& externalTemperature();
const INTEGER_template& externalTemperature() const;
RoadWorksContainerExtended_template& roadWorks();
const RoadWorksContainerExtended_template& roadWorks() const;
ITS__Container::PositioningSolutionType_template& positioningSolution();
const ITS__Container::PositioningSolutionType_template& positioningSolution() const;
StationaryVehicleContainer_template& stationaryVehicle();
const StationaryVehicleContainer_template& stationaryVehicle() const;
int size_of() const;
void log() const;
void log_match(const AlacarteContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ImpactReductionContainer : public Base_Type {
  INTEGER field_heightLonCarrLeft;
  INTEGER field_heightLonCarrRight;
  INTEGER field_posLonCarrLeft;
  INTEGER field_posLonCarrRight;
  ITS__Container::PositionOfPillars field_positionOfPillars;
  INTEGER field_posCentMass;
  INTEGER field_wheelBaseVehicle;
  INTEGER field_turningRadius;
  INTEGER field_posFrontAx;
  BITSTRING field_positionOfOccupants;
  INTEGER field_vehicleMass;
  ITS__Container::RequestResponseIndication field_requestResponseIndication;
  boolean bound_flag;
public:
  ImpactReductionContainer();
  ImpactReductionContainer(const INTEGER& par_heightLonCarrLeft,
    const INTEGER& par_heightLonCarrRight,
    const INTEGER& par_posLonCarrLeft,
    const INTEGER& par_posLonCarrRight,
    const ITS__Container::PositionOfPillars& par_positionOfPillars,
    const INTEGER& par_posCentMass,
    const INTEGER& par_wheelBaseVehicle,
    const INTEGER& par_turningRadius,
    const INTEGER& par_posFrontAx,
    const BITSTRING& par_positionOfOccupants,
    const INTEGER& par_vehicleMass,
    const ITS__Container::RequestResponseIndication& par_requestResponseIndication);
  ImpactReductionContainer(const ImpactReductionContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ImpactReductionContainer& operator=(const ImpactReductionContainer& other_value);
  boolean operator==(const ImpactReductionContainer& other_value) const;
  inline boolean operator!=(const ImpactReductionContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& heightLonCarrLeft()
    {return field_heightLonCarrLeft;}
  inline const INTEGER& heightLonCarrLeft() const
    {return field_heightLonCarrLeft;}
  inline INTEGER& heightLonCarrRight()
    {return field_heightLonCarrRight;}
  inline const INTEGER& heightLonCarrRight() const
    {return field_heightLonCarrRight;}
  inline INTEGER& posLonCarrLeft()
    {return field_posLonCarrLeft;}
  inline const INTEGER& posLonCarrLeft() const
    {return field_posLonCarrLeft;}
  inline INTEGER& posLonCarrRight()
    {return field_posLonCarrRight;}
  inline const INTEGER& posLonCarrRight() const
    {return field_posLonCarrRight;}
  inline ITS__Container::PositionOfPillars& positionOfPillars()
    {return field_positionOfPillars;}
  inline const ITS__Container::PositionOfPillars& positionOfPillars() const
    {return field_positionOfPillars;}
  inline INTEGER& posCentMass()
    {return field_posCentMass;}
  inline const INTEGER& posCentMass() const
    {return field_posCentMass;}
  inline INTEGER& wheelBaseVehicle()
    {return field_wheelBaseVehicle;}
  inline const INTEGER& wheelBaseVehicle() const
    {return field_wheelBaseVehicle;}
  inline INTEGER& turningRadius()
    {return field_turningRadius;}
  inline const INTEGER& turningRadius() const
    {return field_turningRadius;}
  inline INTEGER& posFrontAx()
    {return field_posFrontAx;}
  inline const INTEGER& posFrontAx() const
    {return field_posFrontAx;}
  inline BITSTRING& positionOfOccupants()
    {return field_positionOfOccupants;}
  inline const BITSTRING& positionOfOccupants() const
    {return field_positionOfOccupants;}
  inline INTEGER& vehicleMass()
    {return field_vehicleMass;}
  inline const INTEGER& vehicleMass() const
    {return field_vehicleMass;}
  inline ITS__Container::RequestResponseIndication& requestResponseIndication()
    {return field_requestResponseIndication;}
  inline const ITS__Container::RequestResponseIndication& requestResponseIndication() const
    {return field_requestResponseIndication;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ImpactReductionContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ImpactReductionContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ImpactReductionContainer& other_value);
void copy_template(const ImpactReductionContainer_template& other_value);

public:
ImpactReductionContainer_template();
ImpactReductionContainer_template(template_sel other_value);
ImpactReductionContainer_template(const ImpactReductionContainer& other_value);
ImpactReductionContainer_template(const OPTIONAL<ImpactReductionContainer>& other_value);
ImpactReductionContainer_template(const ImpactReductionContainer_template& other_value);
~ImpactReductionContainer_template();
ImpactReductionContainer_template& operator=(template_sel other_value);
ImpactReductionContainer_template& operator=(const ImpactReductionContainer& other_value);
ImpactReductionContainer_template& operator=(const OPTIONAL<ImpactReductionContainer>& other_value);
ImpactReductionContainer_template& operator=(const ImpactReductionContainer_template& other_value);
boolean match(const ImpactReductionContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ImpactReductionContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ImpactReductionContainer_template& list_item(unsigned int list_index) const;
INTEGER_template& heightLonCarrLeft();
const INTEGER_template& heightLonCarrLeft() const;
INTEGER_template& heightLonCarrRight();
const INTEGER_template& heightLonCarrRight() const;
INTEGER_template& posLonCarrLeft();
const INTEGER_template& posLonCarrLeft() const;
INTEGER_template& posLonCarrRight();
const INTEGER_template& posLonCarrRight() const;
ITS__Container::PositionOfPillars_template& positionOfPillars();
const ITS__Container::PositionOfPillars_template& positionOfPillars() const;
INTEGER_template& posCentMass();
const INTEGER_template& posCentMass() const;
INTEGER_template& wheelBaseVehicle();
const INTEGER_template& wheelBaseVehicle() const;
INTEGER_template& turningRadius();
const INTEGER_template& turningRadius() const;
INTEGER_template& posFrontAx();
const INTEGER_template& posFrontAx() const;
BITSTRING_template& positionOfOccupants();
const BITSTRING_template& positionOfOccupants() const;
INTEGER_template& vehicleMass();
const INTEGER_template& vehicleMass() const;
ITS__Container::RequestResponseIndication_template& requestResponseIndication();
const ITS__Container::RequestResponseIndication_template& requestResponseIndication() const;
int size_of() const;
void log() const;
void log_match(const ImpactReductionContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RoadWorksContainerExtended : public Base_Type {
  OPTIONAL<BITSTRING> field_lightBarSirenInUse;
  OPTIONAL<ITS__Container::ClosedLanes> field_closedLanes;
  OPTIONAL<ITS__Container::RestrictedTypes> field_restriction;
  OPTIONAL<INTEGER> field_speedLimit;
  OPTIONAL<ITS__Container::CauseCode> field_incidentIndication;
  OPTIONAL<ITS__Container::ItineraryPath> field_recommendedPath;
  OPTIONAL<ITS__Container::DeltaReferencePosition> field_startingPointSpeedLimit;
  OPTIONAL<ITS__Container::TrafficRule> field_trafficFlowRule;
  OPTIONAL<ReferenceDenms> field_referenceDenms;
  boolean bound_flag;
public:
  RoadWorksContainerExtended();
  RoadWorksContainerExtended(const OPTIONAL<BITSTRING>& par_lightBarSirenInUse,
    const OPTIONAL<ITS__Container::ClosedLanes>& par_closedLanes,
    const OPTIONAL<ITS__Container::RestrictedTypes>& par_restriction,
    const OPTIONAL<INTEGER>& par_speedLimit,
    const OPTIONAL<ITS__Container::CauseCode>& par_incidentIndication,
    const OPTIONAL<ITS__Container::ItineraryPath>& par_recommendedPath,
    const OPTIONAL<ITS__Container::DeltaReferencePosition>& par_startingPointSpeedLimit,
    const OPTIONAL<ITS__Container::TrafficRule>& par_trafficFlowRule,
    const OPTIONAL<ReferenceDenms>& par_referenceDenms);
  RoadWorksContainerExtended(const RoadWorksContainerExtended& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RoadWorksContainerExtended& operator=(const RoadWorksContainerExtended& other_value);
  boolean operator==(const RoadWorksContainerExtended& other_value) const;
  inline boolean operator!=(const RoadWorksContainerExtended& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<BITSTRING>& lightBarSirenInUse()
    {return field_lightBarSirenInUse;}
  inline const OPTIONAL<BITSTRING>& lightBarSirenInUse() const
    {return field_lightBarSirenInUse;}
  inline OPTIONAL<ITS__Container::ClosedLanes>& closedLanes()
    {return field_closedLanes;}
  inline const OPTIONAL<ITS__Container::ClosedLanes>& closedLanes() const
    {return field_closedLanes;}
  inline OPTIONAL<ITS__Container::RestrictedTypes>& restriction()
    {return field_restriction;}
  inline const OPTIONAL<ITS__Container::RestrictedTypes>& restriction() const
    {return field_restriction;}
  inline OPTIONAL<INTEGER>& speedLimit()
    {return field_speedLimit;}
  inline const OPTIONAL<INTEGER>& speedLimit() const
    {return field_speedLimit;}
  inline OPTIONAL<ITS__Container::CauseCode>& incidentIndication()
    {return field_incidentIndication;}
  inline const OPTIONAL<ITS__Container::CauseCode>& incidentIndication() const
    {return field_incidentIndication;}
  inline OPTIONAL<ITS__Container::ItineraryPath>& recommendedPath()
    {return field_recommendedPath;}
  inline const OPTIONAL<ITS__Container::ItineraryPath>& recommendedPath() const
    {return field_recommendedPath;}
  inline OPTIONAL<ITS__Container::DeltaReferencePosition>& startingPointSpeedLimit()
    {return field_startingPointSpeedLimit;}
  inline const OPTIONAL<ITS__Container::DeltaReferencePosition>& startingPointSpeedLimit() const
    {return field_startingPointSpeedLimit;}
  inline OPTIONAL<ITS__Container::TrafficRule>& trafficFlowRule()
    {return field_trafficFlowRule;}
  inline const OPTIONAL<ITS__Container::TrafficRule>& trafficFlowRule() const
    {return field_trafficFlowRule;}
  inline OPTIONAL<ReferenceDenms>& referenceDenms()
    {return field_referenceDenms;}
  inline const OPTIONAL<ReferenceDenms>& referenceDenms() const
    {return field_referenceDenms;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class RoadWorksContainerExtended_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RoadWorksContainerExtended_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RoadWorksContainerExtended& other_value);
void copy_template(const RoadWorksContainerExtended_template& other_value);

public:
RoadWorksContainerExtended_template();
RoadWorksContainerExtended_template(template_sel other_value);
RoadWorksContainerExtended_template(const RoadWorksContainerExtended& other_value);
RoadWorksContainerExtended_template(const OPTIONAL<RoadWorksContainerExtended>& other_value);
RoadWorksContainerExtended_template(const RoadWorksContainerExtended_template& other_value);
~RoadWorksContainerExtended_template();
RoadWorksContainerExtended_template& operator=(template_sel other_value);
RoadWorksContainerExtended_template& operator=(const RoadWorksContainerExtended& other_value);
RoadWorksContainerExtended_template& operator=(const OPTIONAL<RoadWorksContainerExtended>& other_value);
RoadWorksContainerExtended_template& operator=(const RoadWorksContainerExtended_template& other_value);
boolean match(const RoadWorksContainerExtended& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RoadWorksContainerExtended valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RoadWorksContainerExtended_template& list_item(unsigned int list_index) const;
BITSTRING_template& lightBarSirenInUse();
const BITSTRING_template& lightBarSirenInUse() const;
ITS__Container::ClosedLanes_template& closedLanes();
const ITS__Container::ClosedLanes_template& closedLanes() const;
ITS__Container::RestrictedTypes_template& restriction();
const ITS__Container::RestrictedTypes_template& restriction() const;
INTEGER_template& speedLimit();
const INTEGER_template& speedLimit() const;
ITS__Container::CauseCode_template& incidentIndication();
const ITS__Container::CauseCode_template& incidentIndication() const;
ITS__Container::ItineraryPath_template& recommendedPath();
const ITS__Container::ItineraryPath_template& recommendedPath() const;
ITS__Container::DeltaReferencePosition_template& startingPointSpeedLimit();
const ITS__Container::DeltaReferencePosition_template& startingPointSpeedLimit() const;
ITS__Container::TrafficRule_template& trafficFlowRule();
const ITS__Container::TrafficRule_template& trafficFlowRule() const;
ReferenceDenms_template& referenceDenms();
const ReferenceDenms_template& referenceDenms() const;
int size_of() const;
void log() const;
void log_match(const RoadWorksContainerExtended& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReferenceDenms : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ITS__Container::ActionID **value_elements;
} *val_ptr;

static const ITS__Container::ActionID UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ReferenceDenms& other_value);

public:
  typedef ITS__Container::ActionID of_type;
ReferenceDenms();
ReferenceDenms(null_type other_value);
ReferenceDenms(const ReferenceDenms& other_value);
~ReferenceDenms();

void clean_up();
ReferenceDenms& operator=(null_type other_value);
ReferenceDenms& operator=(const ReferenceDenms& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ReferenceDenms& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ReferenceDenms& other_value) const { return !(*this == other_value); }

ITS__Container::ActionID& operator[](int index_value);
ITS__Container::ActionID& operator[](const INTEGER& index_value);
const ITS__Container::ActionID& operator[](int index_value) const;
const ITS__Container::ActionID& operator[](const INTEGER& index_value) const;

ReferenceDenms operator<<=(int rotate_count) const;
ReferenceDenms operator<<=(const INTEGER& rotate_count) const;
ReferenceDenms operator>>=(int rotate_count) const;
ReferenceDenms operator>>=(const INTEGER& rotate_count) const;

ReferenceDenms operator+(const ReferenceDenms& other_value) const;

ReferenceDenms substr(int index, int returncount) const;

ReferenceDenms replace(int index, int len, const ReferenceDenms& repl) const;

ReferenceDenms replace(int index, int len, const ReferenceDenms_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ReferenceDenms_template : public Record_Of_Template {
union {
struct {
int n_elements;
ITS__Container::ActionID_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ReferenceDenms_template *list_value;
} value_list;
};
void copy_value(const ReferenceDenms& other_value);
void copy_template(const ReferenceDenms_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ReferenceDenms_template();
ReferenceDenms_template(template_sel other_value);
ReferenceDenms_template(null_type other_value);
ReferenceDenms_template(const ReferenceDenms& other_value);
ReferenceDenms_template(const OPTIONAL<ReferenceDenms>& other_value);
ReferenceDenms_template(const ReferenceDenms_template& other_value);
~ReferenceDenms_template();

void clean_up();
ReferenceDenms_template& operator=(template_sel other_value);
ReferenceDenms_template& operator=(null_type other_value);
ReferenceDenms_template& operator=(const ReferenceDenms& other_value);
ReferenceDenms_template& operator=(const OPTIONAL<ReferenceDenms>& other_value);
ReferenceDenms_template& operator=(const ReferenceDenms_template& other_value);

ITS__Container::ActionID_template& operator[](int index_value);
ITS__Container::ActionID_template& operator[](const INTEGER& index_value);
const ITS__Container::ActionID_template& operator[](int index_value) const;
const ITS__Container::ActionID_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ReferenceDenms& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ReferenceDenms valueof() const;
ReferenceDenms substr(int index, int returncount) const;

ReferenceDenms replace(int index, int len, const ReferenceDenms_template& repl) const;

ReferenceDenms replace(int index, int len, const ReferenceDenms& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ReferenceDenms_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ReferenceDenms& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class StationaryVehicleContainer : public Base_Type {
  OPTIONAL<ITS__Container::StationarySince> field_stationarySince;
  OPTIONAL<ITS__Container::CauseCode> field_stationaryCause;
  OPTIONAL<ITS__Container::DangerousGoodsExtended> field_carryingDangerousGoods;
  OPTIONAL<INTEGER> field_numberOfOccupants;
  OPTIONAL<ITS__Container::VehicleIdentification> field_vehicleIdentification;
  OPTIONAL<BITSTRING> field_energyStorageType;
  boolean bound_flag;
public:
  StationaryVehicleContainer();
  StationaryVehicleContainer(const OPTIONAL<ITS__Container::StationarySince>& par_stationarySince,
    const OPTIONAL<ITS__Container::CauseCode>& par_stationaryCause,
    const OPTIONAL<ITS__Container::DangerousGoodsExtended>& par_carryingDangerousGoods,
    const OPTIONAL<INTEGER>& par_numberOfOccupants,
    const OPTIONAL<ITS__Container::VehicleIdentification>& par_vehicleIdentification,
    const OPTIONAL<BITSTRING>& par_energyStorageType);
  StationaryVehicleContainer(const StationaryVehicleContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  StationaryVehicleContainer& operator=(const StationaryVehicleContainer& other_value);
  boolean operator==(const StationaryVehicleContainer& other_value) const;
  inline boolean operator!=(const StationaryVehicleContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<ITS__Container::StationarySince>& stationarySince()
    {return field_stationarySince;}
  inline const OPTIONAL<ITS__Container::StationarySince>& stationarySince() const
    {return field_stationarySince;}
  inline OPTIONAL<ITS__Container::CauseCode>& stationaryCause()
    {return field_stationaryCause;}
  inline const OPTIONAL<ITS__Container::CauseCode>& stationaryCause() const
    {return field_stationaryCause;}
  inline OPTIONAL<ITS__Container::DangerousGoodsExtended>& carryingDangerousGoods()
    {return field_carryingDangerousGoods;}
  inline const OPTIONAL<ITS__Container::DangerousGoodsExtended>& carryingDangerousGoods() const
    {return field_carryingDangerousGoods;}
  inline OPTIONAL<INTEGER>& numberOfOccupants()
    {return field_numberOfOccupants;}
  inline const OPTIONAL<INTEGER>& numberOfOccupants() const
    {return field_numberOfOccupants;}
  inline OPTIONAL<ITS__Container::VehicleIdentification>& vehicleIdentification()
    {return field_vehicleIdentification;}
  inline const OPTIONAL<ITS__Container::VehicleIdentification>& vehicleIdentification() const
    {return field_vehicleIdentification;}
  inline OPTIONAL<BITSTRING>& energyStorageType()
    {return field_energyStorageType;}
  inline const OPTIONAL<BITSTRING>& energyStorageType() const
    {return field_energyStorageType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class StationaryVehicleContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
StationaryVehicleContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const StationaryVehicleContainer& other_value);
void copy_template(const StationaryVehicleContainer_template& other_value);

public:
StationaryVehicleContainer_template();
StationaryVehicleContainer_template(template_sel other_value);
StationaryVehicleContainer_template(const StationaryVehicleContainer& other_value);
StationaryVehicleContainer_template(const OPTIONAL<StationaryVehicleContainer>& other_value);
StationaryVehicleContainer_template(const StationaryVehicleContainer_template& other_value);
~StationaryVehicleContainer_template();
StationaryVehicleContainer_template& operator=(template_sel other_value);
StationaryVehicleContainer_template& operator=(const StationaryVehicleContainer& other_value);
StationaryVehicleContainer_template& operator=(const OPTIONAL<StationaryVehicleContainer>& other_value);
StationaryVehicleContainer_template& operator=(const StationaryVehicleContainer_template& other_value);
boolean match(const StationaryVehicleContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
StationaryVehicleContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
StationaryVehicleContainer_template& list_item(unsigned int list_index) const;
ITS__Container::StationarySince_template& stationarySince();
const ITS__Container::StationarySince_template& stationarySince() const;
ITS__Container::CauseCode_template& stationaryCause();
const ITS__Container::CauseCode_template& stationaryCause() const;
ITS__Container::DangerousGoodsExtended_template& carryingDangerousGoods();
const ITS__Container::DangerousGoodsExtended_template& carryingDangerousGoods() const;
INTEGER_template& numberOfOccupants();
const INTEGER_template& numberOfOccupants() const;
ITS__Container::VehicleIdentification_template& vehicleIdentification();
const ITS__Container::VehicleIdentification_template& vehicleIdentification() const;
BITSTRING_template& energyStorageType();
const BITSTRING_template& energyStorageType() const;
int size_of() const;
void log() const;
void log_match(const StationaryVehicleContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DENM : public Base_Type {
  ITS__Container::ItsPduHeader field_header;
  DecentralizedEnvironmentalNotificationMessage field_denm;
  boolean bound_flag;
public:
  DENM();
  DENM(const ITS__Container::ItsPduHeader& par_header,
    const DecentralizedEnvironmentalNotificationMessage& par_denm);
  DENM(const DENM& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DENM& operator=(const DENM& other_value);
  boolean operator==(const DENM& other_value) const;
  inline boolean operator!=(const DENM& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ITS__Container::ItsPduHeader& header()
    {return field_header;}
  inline const ITS__Container::ItsPduHeader& header() const
    {return field_header;}
  inline DecentralizedEnvironmentalNotificationMessage& denm()
    {return field_denm;}
  inline const DecentralizedEnvironmentalNotificationMessage& denm() const
    {return field_denm;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DENM_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DENM_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DENM& other_value);
void copy_template(const DENM_template& other_value);

public:
DENM_template();
DENM_template(template_sel other_value);
DENM_template(const DENM& other_value);
DENM_template(const OPTIONAL<DENM>& other_value);
DENM_template(const DENM_template& other_value);
~DENM_template();
DENM_template& operator=(template_sel other_value);
DENM_template& operator=(const DENM& other_value);
DENM_template& operator=(const OPTIONAL<DENM>& other_value);
DENM_template& operator=(const DENM_template& other_value);
boolean match(const DENM& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DENM valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DENM_template& list_item(unsigned int list_index) const;
ITS__Container::ItsPduHeader_template& header();
const ITS__Container::ItsPduHeader_template& header() const;
DecentralizedEnvironmentalNotificationMessage_template& denm();
const DecentralizedEnvironmentalNotificationMessage_template& denm() const;
int size_of() const;
void log() const;
void log_match(const DENM& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const ReferenceDenms& other_value);
inline boolean operator!=(null_type null_value, const ReferenceDenms& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const ASN_BERdescriptor_t DENM_header_ber_;
extern const TTCN_Typedescriptor_t DENM_header_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_actionID_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_actionID_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_detectionTime_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_detectionTime_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_referenceTime_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_referenceTime_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_eventPosition_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_eventPosition_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_validityDuration_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_validityDuration_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_stationType_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_stationType_descr_;
extern const TTCN_JSONdescriptor_t ManagementContainer_json_;
extern const TTCN_Typedescriptor_t ManagementContainer_descr_;
extern const INTEGER& ManagementContainer_validityDuration_defval_;
extern const TTCN_JSONdescriptor_t Termination_json_;
extern const TTCN_Typedescriptor_t Termination_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_termination_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_termination_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_relevanceDistance_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_relevanceDistance_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_relevanceTrafficDirection_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_relevanceTrafficDirection_descr_;
extern const ASN_BERdescriptor_t ManagementContainer_transmissionInterval_ber_;
extern const TTCN_Typedescriptor_t ManagementContainer_transmissionInterval_descr_;
extern const ASN_BERdescriptor_t DecentralizedEnvironmentalNotificationMessage_management_ber_;
extern const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_management_descr_;
extern const TTCN_JSONdescriptor_t DecentralizedEnvironmentalNotificationMessage_json_;
extern const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_descr_;
extern const ASN_BERdescriptor_t SituationContainer_informationQuality_ber_;
extern const TTCN_Typedescriptor_t SituationContainer_informationQuality_descr_;
extern const ASN_BERdescriptor_t SituationContainer_eventType_ber_;
extern const TTCN_Typedescriptor_t SituationContainer_eventType_descr_;
extern const TTCN_JSONdescriptor_t SituationContainer_json_;
extern const TTCN_Typedescriptor_t SituationContainer_descr_;
extern const ASN_BERdescriptor_t SituationContainer_linkedCause_ber_;
extern const TTCN_Typedescriptor_t SituationContainer_linkedCause_descr_;
extern const ASN_BERdescriptor_t SituationContainer_eventHistory_ber_;
extern const TTCN_Typedescriptor_t SituationContainer_eventHistory_descr_;
extern const ASN_BERdescriptor_t DecentralizedEnvironmentalNotificationMessage_situation_ber_;
extern const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_situation_descr_;
extern const ASN_BERdescriptor_t LocationContainer_traces_ber_;
extern const TTCN_Typedescriptor_t LocationContainer_traces_descr_;
extern const TTCN_JSONdescriptor_t LocationContainer_json_;
extern const TTCN_Typedescriptor_t LocationContainer_descr_;
extern const ASN_BERdescriptor_t LocationContainer_eventSpeed_ber_;
extern const TTCN_Typedescriptor_t LocationContainer_eventSpeed_descr_;
extern const ASN_BERdescriptor_t LocationContainer_eventPositionHeading_ber_;
extern const TTCN_Typedescriptor_t LocationContainer_eventPositionHeading_descr_;
extern const ASN_BERdescriptor_t LocationContainer_roadType_ber_;
extern const TTCN_Typedescriptor_t LocationContainer_roadType_descr_;
extern const ASN_BERdescriptor_t DecentralizedEnvironmentalNotificationMessage_location_ber_;
extern const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_location_descr_;
extern const TTCN_JSONdescriptor_t AlacarteContainer_json_;
extern const TTCN_Typedescriptor_t AlacarteContainer_descr_;
extern const ASN_BERdescriptor_t AlacarteContainer_lanePosition_ber_;
extern const TTCN_Typedescriptor_t AlacarteContainer_lanePosition_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_heightLonCarrLeft_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_heightLonCarrLeft_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_heightLonCarrRight_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_heightLonCarrRight_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_posLonCarrLeft_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_posLonCarrLeft_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_posLonCarrRight_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_posLonCarrRight_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_positionOfPillars_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_positionOfPillars_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_posCentMass_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_posCentMass_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_wheelBaseVehicle_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_wheelBaseVehicle_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_turningRadius_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_turningRadius_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_posFrontAx_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_posFrontAx_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_positionOfOccupants_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_positionOfOccupants_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_vehicleMass_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_vehicleMass_descr_;
extern const ASN_BERdescriptor_t ImpactReductionContainer_requestResponseIndication_ber_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_requestResponseIndication_descr_;
extern const TTCN_JSONdescriptor_t ImpactReductionContainer_json_;
extern const TTCN_Typedescriptor_t ImpactReductionContainer_descr_;
extern const ASN_BERdescriptor_t AlacarteContainer_impactReduction_ber_;
extern const TTCN_Typedescriptor_t AlacarteContainer_impactReduction_descr_;
extern const ASN_BERdescriptor_t AlacarteContainer_externalTemperature_ber_;
extern const TTCN_Typedescriptor_t AlacarteContainer_externalTemperature_descr_;
extern const TTCN_JSONdescriptor_t RoadWorksContainerExtended_json_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerExtended_lightBarSirenInUse_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_lightBarSirenInUse_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerExtended_closedLanes_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_closedLanes_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerExtended_restriction_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_restriction_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerExtended_speedLimit_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_speedLimit_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerExtended_incidentIndication_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_incidentIndication_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerExtended_recommendedPath_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_recommendedPath_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerExtended_startingPointSpeedLimit_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_startingPointSpeedLimit_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerExtended_trafficFlowRule_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_trafficFlowRule_descr_;
extern const TTCN_JSONdescriptor_t ReferenceDenms_json_;
extern const TTCN_Typedescriptor_t ReferenceDenms_descr_;
extern const ASN_BERdescriptor_t RoadWorksContainerExtended_referenceDenms_ber_;
extern const TTCN_Typedescriptor_t RoadWorksContainerExtended_referenceDenms_descr_;
extern const ASN_BERdescriptor_t AlacarteContainer_roadWorks_ber_;
extern const TTCN_Typedescriptor_t AlacarteContainer_roadWorks_descr_;
extern const ASN_BERdescriptor_t AlacarteContainer_positioningSolution_ber_;
extern const TTCN_Typedescriptor_t AlacarteContainer_positioningSolution_descr_;
extern const TTCN_JSONdescriptor_t StationaryVehicleContainer_json_;
extern const TTCN_Typedescriptor_t StationaryVehicleContainer_descr_;
extern const ASN_BERdescriptor_t StationaryVehicleContainer_stationarySince_ber_;
extern const TTCN_Typedescriptor_t StationaryVehicleContainer_stationarySince_descr_;
extern const ASN_BERdescriptor_t StationaryVehicleContainer_stationaryCause_ber_;
extern const TTCN_Typedescriptor_t StationaryVehicleContainer_stationaryCause_descr_;
extern const ASN_BERdescriptor_t StationaryVehicleContainer_carryingDangerousGoods_ber_;
extern const TTCN_Typedescriptor_t StationaryVehicleContainer_carryingDangerousGoods_descr_;
extern const ASN_BERdescriptor_t StationaryVehicleContainer_numberOfOccupants_ber_;
extern const TTCN_Typedescriptor_t StationaryVehicleContainer_numberOfOccupants_descr_;
extern const ASN_BERdescriptor_t StationaryVehicleContainer_vehicleIdentification_ber_;
extern const TTCN_Typedescriptor_t StationaryVehicleContainer_vehicleIdentification_descr_;
extern const ASN_BERdescriptor_t StationaryVehicleContainer_energyStorageType_ber_;
extern const TTCN_Typedescriptor_t StationaryVehicleContainer_energyStorageType_descr_;
extern const ASN_BERdescriptor_t AlacarteContainer_stationaryVehicle_ber_;
extern const TTCN_Typedescriptor_t AlacarteContainer_stationaryVehicle_descr_;
extern const ASN_BERdescriptor_t DecentralizedEnvironmentalNotificationMessage_alacarte_ber_;
extern const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_alacarte_descr_;
extern const ASN_BERdescriptor_t DENM_denm_ber_;
extern const TTCN_Typedescriptor_t DENM_denm_descr_;
extern const TTCN_JSONdescriptor_t DENM_json_;
extern const TTCN_Typedescriptor_t DENM_descr_;
extern const INTEGER& defaultValidity;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
