module LibItsDcc_Functions {
    
    // Libcommon
    import from LibCommon_Sync all;
    import from LibCommon_Time all;
    import from LibCommon_VerdictControl all;
    
    // LibIts
    import from LibItsDcc_TypesAndValues all;
    import from LibItsDcc_Templates all;
    import from LibItsDcc_Pixits all;
    import from LibItsDcc_Pics all;
    import from LibItsDcc_TestSystem all; 

    group dccConfigurationFunctions {
        
        /**
         * @desc    Setups default configuration   
         */
        function f_cfUp(out UtComp p_utComp,
                        out ItsInDcc p_itsInDcc,
                        out ItsRrxDcc p_itsRrxDcc,
                        in template (value) UtTrigger p_trigger) runs on ServerSyncComp {
            
            // Create
            p_utComp := UtComp.create("Upper Tester") alive;
            p_itsInDcc := ItsInDcc.create("IN_SAP");
            p_itsRrxDcc := ItsRrxDcc.create("RRX");
            
            // Connect
            connect(p_utComp:syncPort, self:syncPort);
            connect(p_itsInDcc:syncPort, self:syncPort);
            connect(p_itsRrxDcc:syncPort, self:syncPort);
            connect(p_itsInDcc:checkPort, mtc:checkPort);
            connect(p_itsRrxDcc:checkPort, mtc:checkPort);
            
            //Map
            map(p_utComp:utPort, system:utPort);
            map(p_itsInDcc:inPort, system:inPort);
            map(p_itsRrxDcc:rrxPort, system:rrxPort);
            
            // Initialize radio equipment
            p_utComp.start(f_utInitializeIut(m_utInitialize(m_utRadioInitialize)));
            p_utComp.done;
            // Put channel(s) into defined state
            p_utComp.start(f_utTriggerEvent(p_trigger));
            p_utComp.done;
        } // end f_cfUp
        
        /**
         * @desc    Deletes default configuration 
         */
        function f_cfDown(in UtComp p_utComp,
                          in ItsInDcc p_itsInDcc,
                          in ItsRrxDcc p_itsRrxDcc) runs on ServerSyncComp {
            
            f_serverWaitForAllClientsToStop();
            // Disconnect
            disconnect(p_utComp:syncPort, self:syncPort);
            disconnect(p_itsInDcc:syncPort, self:syncPort);
            disconnect(p_itsRrxDcc:syncPort, self:syncPort);
            disconnect(p_itsInDcc:checkPort, mtc:checkPort);
            disconnect(p_itsRrxDcc:checkPort, mtc:checkPort);
            
            // Unmap
            unmap(p_utComp:utPort, system:utPort);
            unmap(p_itsInDcc:inPort, system:inPort);
            unmap(p_itsRrxDcc:rrxPort, system:rrxPort);
            
        } // end f_cfDown
        
    } // end of dccConfigurationFunctions
    
    /**
     * @desc Upper tester functions
     */
    group utFuntions { 
        
        /**
         * @desc    Requests to bring the IUT in an initial state
         * @param   p_init The initialisation to trigger.
         */
        function f_utInitializeIut(template (value) UtInitialize p_init) runs on UtComp {
        
            utPort.send(p_init);
            tc_wait.start;
            alt {
                [] utPort.receive(UtResult:true) {
                    tc_wait.stop;
                    log("*** " & __SCOPE__ & ": INFO: IUT initialized ***");
                }
                [] utPort.receive {
                    tc_wait.stop;
                    log("*** " & __SCOPE__ & ": INFO: IUT could not be initialized ***");
                    f_selfOrClientSyncAndVerdict("error", e_error);
                }
                [] tc_wait.timeout {
                    log("*** " & __SCOPE__ & ": INFO: IUT could not be initialized in time ***");
                    f_selfOrClientSyncAndVerdict("error", e_timeout);
                }
                [else] { // Shortcut defaults
                    //f_sleep(0.050); // 50 ms
                    repeat; 
                }
            }
        }
        
        /**
         * @desc    Triggers event on the radio interface
         * @param   p_trigger The event to trigger.
         */
        function f_utTriggerEvent(template (value) UtTrigger p_trigger) runs on UtComp {
            
            utPort.send(p_trigger);
            alt {
                [] utPort.receive(UtResult:true) {
                    tc_wait.stop;
                    log("*** " & __SCOPE__ & ": INFO: Event sccessfully triggered ***");
                }
                [] utPort.receive {
                    tc_wait.stop;
                    log("*** " & __SCOPE__ & ": INFO: Event could not be triggered ***");
                    f_selfOrClientSyncAndVerdict("error", e_error);
                }
                [] tc_wait.timeout {
                    log("*** " & __SCOPE__ & ": INFO: Event could not be triggered in time ***");
                    f_selfOrClientSyncAndVerdict("error", e_timeout);
                }
                [else] { // Shortcut defaults
                    //f_sleep(0.050); // 50 ms
                    repeat; 
                }
            }
        
        }
    } // End of group utFunctions

    group rrxFunctions {
        
        /**
         * @desc Receive frames via the radio link and check that all expected frames are sent with
         *       the requested Tx power and inter-packet spacing on the chosen channel 
         * @param   p_tOff                 Requested Toff value
         * @param   p_expectedTxPower      Expected Tx send power value
         * @param   p_channel              Channel on which the frame has been sent
         * @param   p_checkPower           If true, the power of the received signal will be checked
         */
        function f_rRX_ExpectedFramesSent(float   p_tOff,
                                          integer p_expectedTxPower,
                                          Channel p_channel,
                                          boolean p_checkPower := true) runs on ItsRrxDcc {
            
            var RrxInd v_rrxInd;
            var integer v_frameReceivedCount := 0;
            
            template integer m_expectedPowerWithDelta := ((p_expectedTxPower - PIXIT_POWER_DELTA) .. (p_expectedTxPower + PIXIT_POWER_DELTA));
            
            timer tc_testDuration := f_getTestDuration(p_tOff) + p_tOff;
            timer tc_tOffCheck := 2.0 * p_tOff;
            
            f_selfOrClientSyncAndVerdict(c_prDone, e_success);

            tc_testDuration.start;
            
            alt {
                [] rrxPort.receive(m_rrxInd(p_channel, ?)) -> value v_rrxInd {
                    v_frameReceivedCount := v_frameReceivedCount + 1;
                    if(p_checkPower and match(v_rrxInd.measuredPower, m_expectedPowerWithDelta))
                       { log("*** function " & __SCOPE__ & ": FAIL: The measured Tx power is different to the requested Tx power. ***");
                         setverdict(fail)}
                    tc_tOffCheck.start;
                    alt {
                        [] rrxPort.receive(m_rrxInd(p_channel, ?)) -> value v_rrxInd {
                            v_frameReceivedCount := v_frameReceivedCount + 1;
                            if(p_checkPower and match(v_rrxInd.measuredPower, m_expectedPowerWithDelta))
                               { log("*** function " & __SCOPE__ & ": FAIL: The measured Tx power is different to the requested Tx power. ***");
                                 setverdict(fail)}
                            if(tc_tOffCheck.read < p_tOff)
                               { log("*** function " & __SCOPE__ & ": FAIL: The inter-packet spacing time interval is smaller than the minimum allowed. ***");
                                 setverdict(fail)}
                            tc_tOffCheck.start;
                            repeat;
                         }
                        [] tc_tOffCheck.timeout {
                            tc_tOffCheck.start;
                            repeat;
                         }
                        [] tc_testDuration.timeout 
                           {setverdict(pass)}
                    }
                }
                [] tc_testDuration.timeout {
                    log("*** function " & __SCOPE__ & ": FAIL: No packet received on the radio interface. ***");
                    setverdict(fail)
                 }
            }
            
            checkPort.send(v_frameReceivedCount);
            f_selfOrClientSyncAndVerdict(c_tbDone, e_success);
            
        } // End of function f_rRX_ExpectedFramesSent

        /**
         * @desc Receive frames via the radio link and check that all expected frames are sent with
         *       the requested Tx power and inter-packet spacing on the chosen channels
         * @param   p_tOff                 Requested Toff value
         * @param   p_expectedTxPower      Expected Tx send power value
         * @param   p_channel_1            Channel on which the frame has been sent
         * @param   p_channel_2            Channel on which the frame has been sent
         * @param   p_checkPower           If true, the power of the received signal will be checked
         */
        function f_rRX_ExpectedFramesSentOn2Channels(float   p_tOff,
                                                     integer p_expectedTxPower,
                                                     Channel p_channel_1,
                                                     Channel p_channel_2,
                                                     boolean p_checkPower := false) runs on ItsRrxDcc {
            
            var RrxInd v_rrxInd;
            var integer v_frameReceivedCount := 0;
            var boolean v_channel_1, v_channel_2 := false;
            
            template integer m_expectedPowerWithDelta := ((p_expectedTxPower - PIXIT_POWER_DELTA) .. (p_expectedTxPower + PIXIT_POWER_DELTA));
            
            timer tc_testDuration := f_getTestDuration(p_tOff) + p_tOff;
            timer tc_tOffCheck := 2.0 * p_tOff;
            
            f_selfOrClientSyncAndVerdict(c_prDone, e_success);

            tc_testDuration.start;
            
            alt {
                [] rrxPort.receive(m_rrxInd((p_channel_1, p_channel_2), ?)) -> value v_rrxInd {
                    v_frameReceivedCount := v_frameReceivedCount + 1;
                    select (v_rrxInd.channel) {
                        case (p_channel_1) {
                            v_channel_1 := true;
                        }
                        case (p_channel_2) {
                            v_channel_2 := true;
                        }
                    }
                    if(p_checkPower and match(v_rrxInd.measuredPower, m_expectedPowerWithDelta))
                       { log("*** function " & __SCOPE__ & ": FAIL: The measured Tx power is different to the requested Tx power. ***");
                         setverdict(fail)}
                    tc_tOffCheck.start;
                    alt {
                        [] rrxPort.receive(m_rrxInd((p_channel_1, p_channel_2), ?)) -> value v_rrxInd {
                            v_frameReceivedCount := v_frameReceivedCount + 1;
                            select (v_rrxInd.channel) {
                                case (p_channel_1) {
                                    v_channel_1 := true;
                                }
                                case (p_channel_2) {
                                    v_channel_2 := true;
                                }
                            }
                            if(p_checkPower and match(v_rrxInd.measuredPower, m_expectedPowerWithDelta))
                               { log("*** function " & __SCOPE__ & ": FAIL: The measured Tx power is different to the requested Tx power. ***");
                                 setverdict(fail)}
                            if(tc_tOffCheck.read < p_tOff)
                               { log("*** function " & __SCOPE__ & ": FAIL: The inter-packet spacing time interval is smaller than the minimum allowed. ***");
                                 setverdict(fail)}
                            tc_tOffCheck.start;
                            repeat;
                         }
                        [] tc_tOffCheck.timeout {
                            tc_tOffCheck.start;
                            repeat;
                         }
                        [] tc_testDuration.timeout {
                            if(not v_channel_1 and not v_channel_2) {
                                log("*** function " & __SCOPE__ & ": FAIL: All frames have been sent via the two channel. ***");
                                setverdict(fail);
                            }
                            else {
                                setverdict(pass);
                            }
                        }
                    }
                }
                [] tc_testDuration.timeout {
                    log("*** function " & __SCOPE__ & ": FAIL: No packet received on the radio interface. ***");
                    setverdict(fail)
                 }
            }
            
            checkPort.send(v_frameReceivedCount);
            f_selfOrClientSyncAndVerdict(c_tbDone, e_success);
            
        } // End of function f_rRX_ExpectedFramesSent

        /**
         * @desc Check that no frames are received via the radio link
         * @param   p_tOff Requested Toff value
         */
        function f_rRX_NoFramesSent(float p_tOff) runs on ItsRrxDcc {
            
            timer tc_testDuration := f_getTestDuration(p_tOff);
            
            f_selfOrClientSyncAndVerdict(c_prDone, e_success);

            tc_testDuration.start;
            
            alt {
                [] rrxPort.receive(m_rrxInd(?, ?)) {
                    log("*** function " & __SCOPE__ & ": FAIL: A radio frame was received when none was expected. ***");
                    setverdict(fail)
                 }
                [] tc_testDuration.timeout {
                    setverdict(pass)
                 }
            }
            
            f_selfOrClientSyncAndVerdict(c_tbDone, e_success);
            
        } // End of function f_rRX_NoFramesSent
    } // End of group rrxFunctions

    /**
     * @desc IN SAP functions
     */
    group inFuntions { 

        /**
         * @desc Request sending of frames via the IN_SAP and check that all frames are 
         *       reported as sent with the requested Tx power
         * @param   p_tOff                 Requested Toff value
         * @param   p_requestedTxPower     Requested Tx send power value
         * @param   p_dCCProfileIdentifier Requested DCC profile
         * @param   p_channel              Channel on which the frame has been sent
         */
        function f_iN_AllRequestedFramesSent(float   p_tOff,
                                             integer p_requestedTxPower,
                                             integer p_dCCProfileIdentifier,
                                             Channel p_channel) runs on ItsInDcc {
            
            var integer v_commandReference := float2int(int2float(c_maxCommandReference)*rnd());
            var InSta v_inSta;
            var integer v_frameRequestedCount := 1;
            var integer v_frameAcknowledgedCount := 0;
            
            timer tc_testDuration := f_getTestDuration(p_tOff);
            timer tc_tOff := p_tOff;
            
            f_selfOrClientSyncAndVerdict(c_prDone, e_success);
            
            inPort.send(m_In_Request(v_commandReference,
                                     PIXIT_REFERENCE_BURST,
                                     p_requestedTxPower,
                                     p_dCCProfileIdentifier));
            tc_testDuration.start;
            
            alt {
                [] inPort.receive(mw_In_Status(v_commandReference,
                                               p_channel,
                                               true)) -> value v_inSta {
                    v_commandReference := (v_commandReference + 1) mod c_maxCommandReference;
                    v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                    if(v_inSta.achievedSendPower != p_requestedTxPower)
                       { log("*** function " & __SCOPE__ & ": FAIL: The achieved Tx power is different to the requested Tx power. ***");
                         setverdict(fail)}
                    tc_tOff.start;
                    repeat;
                }
                
                [] tc_tOff.timeout {
                    inPort.send(m_In_Request(v_commandReference,
                                PIXIT_REFERENCE_BURST,
                                p_requestedTxPower,
                                p_dCCProfileIdentifier));
                    v_frameRequestedCount := v_frameRequestedCount + 1;
                    repeat;
                }
                                               
                [] tc_testDuration.timeout {
                    if(v_frameAcknowledgedCount == v_frameRequestedCount)
                       {setverdict(pass)}
                    else
                      {tc_tOff.start;
                      alt {
                          [] inPort.receive(mw_In_Status(v_commandReference,
                                                         p_channel,
                                                         true)) -> value v_inSta {
                              tc_tOff.stop;
                              v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                              if(v_inSta.achievedSendPower != p_requestedTxPower)
                                 { log("*** function " & __SCOPE__ & ": FAIL: The achieved Tx power is different to the requested Tx power. ***");
                                   setverdict(fail)}
                              else if(v_frameAcknowledgedCount != v_frameRequestedCount)
                                 { log("*** function " & __SCOPE__ & ": FAIL: Not all requested frames have been acknowledged. ***");
                                   setverdict(fail)}
                              else
                                 {setverdict(pass)}
                          }
                          
                          [] tc_tOff.timeout {
                             log("*** function " & __SCOPE__ & ": FAIL: Not all requested frames have been acknowledged. ***");
                             setverdict(fail)
                           }
                         }
                      }     
                }
             }
            checkPort.send(v_frameAcknowledgedCount);
            f_selfOrClientSyncAndVerdict(c_tbDone, e_success);
            
        } // End of function f_iN_AllRequestedFramesSent

        /**
         * @desc Request sending of frames via the IN_SAP and check that all frames are 
         *       reported as sent with reduced Tx power being lower than the maximum allowed Tx power
         * @param   p_tOff                 Requested Toff value
         * @param   p_requestedTxPower     Requested Tx send power value
         * @param   p_dCCProfileIdentifier Requested DCC profile
         * @param   p_channel              Channel on which the frame has been sent
         * @param   p_maxTxPower           Maximum allowed Tx power value
         */
        function f_iN_FramesSentTxPowerReduction(float   p_tOff,
                                                 integer p_requestedTxPower,
                                                 integer p_dCCProfileIdentifier,
                                                 Channel p_channel,
                                                 integer p_maxTxPower) runs on ItsInDcc {
            
            var integer v_commandReference := float2int(int2float(c_maxCommandReference)*rnd());
            var InSta v_inSta;
            var integer v_frameRequestedCount := 1;
            var integer v_frameAcknowledgedCount := 0;
            
            timer tc_testDuration := f_getTestDuration(p_tOff);
            timer tc_tOff := p_tOff;
            
            f_selfOrClientSyncAndVerdict(c_prDone, e_success);
            
            inPort.send(m_In_Request(v_commandReference,
                                     PIXIT_REFERENCE_BURST,
                                     p_requestedTxPower,
                                     p_dCCProfileIdentifier));
            tc_testDuration.start;
            
            alt {
                [] inPort.receive(mw_In_Status(v_commandReference,
                                               p_channel,
                                               true)) -> value v_inSta {
                    v_commandReference := (v_commandReference + 1) mod c_maxCommandReference;
                    v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                    if(v_inSta.achievedSendPower >= p_maxTxPower)
                       { log("*** function " & __SCOPE__ & ": FAIL: The achieved Tx power is higher than the maximum allowed Tx power. ***");
                         setverdict(fail)}
                    tc_tOff.start;
                    repeat;
                }
                
                [] tc_tOff.timeout {
                    inPort.send(m_In_Request(v_commandReference,
                                PIXIT_REFERENCE_BURST,
                                p_requestedTxPower,
                                p_dCCProfileIdentifier));
                    v_frameRequestedCount := v_frameRequestedCount + 1;
                    repeat;
                }
                                               
                [] tc_testDuration.timeout {
                    if(v_frameAcknowledgedCount == v_frameRequestedCount)
                       {setverdict(pass)}
                    else
                      {tc_tOff.start;
                      alt {
                          [] inPort.receive(mw_In_Status(v_commandReference,
                                                         p_channel,
                                                         true)) -> value v_inSta {
                              tc_tOff.stop;
                              v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                              if(v_inSta.achievedSendPower >= p_maxTxPower)
                                 { log("*** function " & __SCOPE__ & ": FAIL: The achieved Tx power is higher than the maximum allowed Tx power. ***");
                                   setverdict(fail)}
                              else if(v_frameAcknowledgedCount != v_frameRequestedCount)
                                 { log("*** function " & __SCOPE__ & ": FAIL: Not all requested frames have been acknowledged. ***");
                                   setverdict(fail)}
                              else
                                 {setverdict(pass)}
                          }
                          
                          [] tc_tOff.timeout {
                             log("*** function " & __SCOPE__ & ": FAIL: Not all requested frames have been acknowledged. ***");
                             setverdict(fail)
                          }
                         }
                      }     
                }
             }
            checkPort.send(v_frameAcknowledgedCount);
            f_selfOrClientSyncAndVerdict(c_tbDone, e_success);
            
        } // End of function f_iN_FramesSentTxPowerReduction

        /**
         * @desc Request sending of frames via the IN_SAP and check that all frames are dropped
         * @param   p_tOff                 Requested Toff value
         * @param   p_requestedTxPower     Requested Tx send power value
         * @param   p_dCCProfileIdentifier Requested DCC profile
         */
        function f_iN_AllRequestedFramesDropped(float   p_tOff,
                                                integer p_requestedTxPower,
                                                integer p_dCCProfileIdentifier) runs on ItsInDcc {
            
            var integer v_commandReference := float2int(int2float(c_maxCommandReference)*rnd());
            var InSta v_inSta;
            
            timer tc_testDuration := f_getTestDuration(p_tOff);
            timer tc_tOff := p_tOff;
            
            f_selfOrClientSyncAndVerdict(c_prDone, e_success);
            
            inPort.send(m_In_Request(v_commandReference,
                                     PIXIT_REFERENCE_BURST,
                                     p_requestedTxPower,
                                     p_dCCProfileIdentifier));
            tc_testDuration.start;
            
            alt {
                [] inPort.receive(mw_In_Status(v_commandReference,
                                               ?,
                                               ?)) -> value v_inSta {
                    v_commandReference := (v_commandReference + 1) mod c_maxCommandReference;
                    if(v_inSta.transmissionSuccessStatus)
                       { log("*** function " & __SCOPE__ & ": FAIL: A frame that should have been dropped is achnowledged as successfully sent. ***");
                         setverdict(fail)}
                    tc_tOff.start;
                    repeat;
                }
                
                [] tc_tOff.timeout {
                    inPort.send(m_In_Request(v_commandReference,
                                PIXIT_REFERENCE_BURST,
                                p_requestedTxPower,
                                p_dCCProfileIdentifier));
                    repeat;
                }
                                               
                [] tc_testDuration.timeout {
                    setverdict(pass)
                }
             }
            f_selfOrClientSyncAndVerdict(c_prDone, e_success);
            
        } // End of function f_iN_AllRequestedFramesDropped

        /**
         * @desc Request sending of frames via the IN_SAP and check that some frames are 
         *       reported as sent and some reported as dropped
         * @param   p_tOff                 Requested Toff value
         * @param   p_requestedTxPower     Requested Tx send power value
         * @param   p_dCCProfileIdentifier Requested DCC profile
         * @param   p_channel              Channel on which the frame has been sent
         */
        function f_iN_SomeRequestedFramesSent(float   p_tOff,
                                              integer p_requestedTxPower,
                                              integer p_dCCProfileIdentifier,
                                              Channel p_channel) runs on ItsInDcc {
            
            var integer v_commandReference := float2int(int2float(c_maxCommandReference)*rnd());
            var InSta v_inSta;
            var integer v_frameRequestedCount := 1;
            var integer v_frameAcknowledgedCount := 0;
            var integer v_frameSentCount := 0;
            var boolean v_frameSent, v_frameDropped := false;
            
            timer tc_testDuration := f_getTestDuration(p_tOff);
            timer tc_tOff := p_tOff;
            
            f_selfOrClientSyncAndVerdict(c_prDone, e_success);
            
            inPort.send(m_In_Request(v_commandReference,
                                     PIXIT_REFERENCE_BURST,
                                     p_requestedTxPower,
                                     p_dCCProfileIdentifier));
            tc_testDuration.start;
            
            alt {
                [] inPort.receive(mw_In_Status(v_commandReference,
                                               p_channel,
                                               true)) -> value v_inSta {
                    v_commandReference := (v_commandReference + 1) mod c_maxCommandReference;
                    v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                    v_frameSentCount := v_frameSentCount + 1;
                    v_frameSent := true;
                    tc_tOff.start;
                    repeat;
                }
                
                [] inPort.receive(mw_In_Status(v_commandReference,
                                               p_channel,
                                               false)) -> value v_inSta {
                    v_commandReference := (v_commandReference + 1) mod c_maxCommandReference;
                    v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                    v_frameDropped := true;
                    tc_tOff.start;
                    repeat;
                }
                
                [] tc_tOff.timeout {
                    inPort.send(m_In_Request(v_commandReference,
                                PIXIT_REFERENCE_BURST,
                                p_requestedTxPower,
                                p_dCCProfileIdentifier));
                    v_frameRequestedCount := v_frameRequestedCount + 1;
                    repeat;
                }
                                               
                [] tc_testDuration.timeout {
                    if(not v_frameSent and v_frameDropped)
                       { log("*** function " & __SCOPE__ & ": FAIL: There are either no sent frames or no dropped frames acknowledged. ***");
                         setverdict(fail)}
                    if(v_frameAcknowledgedCount == v_frameRequestedCount)
                       {setverdict(pass)}
                    else
                      {tc_tOff.start;
                      alt {
                          [] inPort.receive(mw_In_Status(v_commandReference,
                                                         p_channel,
                                                         ?)) -> value v_inSta {
                              tc_tOff.stop;
                              v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                              if(v_inSta.transmissionSuccessStatus)
                                 { v_frameSentCount := v_frameSentCount + 1;}
                              if(v_frameAcknowledgedCount != v_frameRequestedCount)
                                 { log("*** function " & __SCOPE__ & ": FAIL: Not all requested frames have been acknowledged. ***");
                                   setverdict(fail)}
                              else
                                 {setverdict(pass)}
                          }
                          
                          [] tc_tOff.timeout {
                             log("*** function " & __SCOPE__ & ": FAIL: Not all requested frames have been acknowledged. ***");
                             setverdict(fail)
                           }
                         }
                      }     
                }
             }
            checkPort.send(v_frameSentCount);
            f_selfOrClientSyncAndVerdict(c_tbDone, e_success);
            
        } // End of function f_iN_SomeRequestedFramesSent

        /**
         * @desc Request sending of frames via the IN_SAP and check that all frames are 
         *       reported as sent via two different channels
         * @param   p_tOff                 Requested Toff value
         * @param   p_requestedTxPower     Requested Tx send power value
         * @param   p_dCCProfileIdentifier Requested DCC profile
         * @param   p_channel_1            First channel on which the frame has been sent
         * @param   p_channel_2            Second channel on which the frame has been sent
         */
        function f_iN_AllRequestedFramesSentOn2Channels(float   p_tOff,
                                                        integer p_requestedTxPower,
                                                        integer p_dCCProfileIdentifier,
                                                        Channel p_channel_1,
                                                        Channel p_channel_2) runs on ItsInDcc {
            
            var integer v_commandReference := float2int(int2float(c_maxCommandReference)*rnd());
            var InSta v_inSta;
            var integer v_frameRequestedCount := 1;
            var integer v_frameAcknowledgedCount := 0;
            var boolean v_channel_1, v_channel_2 := false;
            
            timer tc_testDuration := f_getTestDuration(p_tOff);
            timer tc_tOff := p_tOff;
            
            f_selfOrClientSyncAndVerdict(c_prDone, e_success);
            
            inPort.send(m_In_Request(v_commandReference,
                                     PIXIT_REFERENCE_BURST,
                                     p_requestedTxPower,
                                     p_dCCProfileIdentifier));
            tc_testDuration.start;
            
            alt {
                [] inPort.receive(mw_In_Status(v_commandReference,
                                               p_channel_1,
                                               true)) -> value v_inSta {
                    v_commandReference := (v_commandReference + 1) mod c_maxCommandReference;
                    v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                    v_channel_1 := true;
                    tc_tOff.start;
                    repeat;
                }
                
                [] inPort.receive(mw_In_Status(v_commandReference,
                                               p_channel_2,
                                               true)) -> value v_inSta {
                    v_commandReference := (v_commandReference + 1) mod c_maxCommandReference;
                    v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                    v_channel_2 := true;
                    tc_tOff.start;
                    repeat;
                }
                
                [] tc_tOff.timeout {
                    inPort.send(m_In_Request(v_commandReference,
                                PIXIT_REFERENCE_BURST,
                                p_requestedTxPower,
                                p_dCCProfileIdentifier));
                    v_frameRequestedCount := v_frameRequestedCount + 1;
                    repeat;
                }
                                               
                [] tc_testDuration.timeout {
                    if(not v_channel_1 and not v_channel_2)
                       { log("*** function " & __SCOPE__ & ": FAIL: All frames have been sent via the two channel. ***");
                         setverdict(fail)}
                    if(v_frameAcknowledgedCount == v_frameRequestedCount)
                       {setverdict(pass)}
                    else
                      {tc_tOff.start;
                      alt {
                          [] inPort.receive(mw_In_Status(v_commandReference,
                                                         ?,
                                                         true)) -> value v_inSta {
                              tc_tOff.stop;
                              v_frameAcknowledgedCount := v_frameAcknowledgedCount + 1;
                              if(v_frameAcknowledgedCount != v_frameRequestedCount)
                                 { log("*** function " & __SCOPE__ & ": FAIL: Not all requested frames have been acknowledged. ***");
                                   setverdict(fail)}
                              else
                                 {setverdict(pass)}
                          }
                          
                          [] tc_tOff.timeout {
                             log("*** function " & __SCOPE__ & ": FAIL: Not all requested frames have been acknowledged. ***");
                             setverdict(fail)
                           }
                         }
                      }     
                }
             }
            checkPort.send(v_frameAcknowledgedCount);
            f_selfOrClientSyncAndVerdict(c_tbDone, e_success);
            
        } // End of function f_iN_AllRequestedFramesSentOn2Channels
    } // End of group inFunctions
    
    group checkFunctions {
        
        function f_checkExpectedFrames() runs on ItsDccMts return FncRetCode {
            var FncRetCode v_ret := e_success;
            var integer v_framesIn := -1;
            var integer v_framesRxx := -1;
            timer t_check := PX_TSYNC_TIME_LIMIT;
            
            t_check.start;
            alt {
                [v_framesIn==-1] checkPort.receive(integer:?) from vc_itsInDcc -> value v_framesIn {
                    t_check.stop;
                    if (v_framesRxx != -1) {
                        t_check.start;
                        repeat;
                    }
                }
                [v_framesRxx==-1] checkPort.receive(integer:?) from vc_itsRrxDcc -> value v_framesRxx {
                    t_check.stop;
                    if (v_framesIn != -1) {
                        t_check.start;
                        repeat;
                    }
                }
                [] t_check.timeout {
                    log("**** " & __SCOPE__ & ": Timeout while waiting for number of frames indication ****") ;
                    return e_error;
                }
            }
            
            if (v_framesIn != v_framesRxx) {
                v_ret := e_error;
            }
            
            return v_ret;
        } // End of function f_checkExpectedFrames
        
    } // End of group checkFunctions
    
    group auxiliaryFunction {
        
        /**
         * @desc Returns the test duration based on the number of requested frames
         * @param p_tOff Requested Toff value
         * @return Test duration
         */
        function f_getTestDuration(float p_tOff) return float {
            return p_tOff * int2float(PIXIT_NUMBER_OF_FRAMES + 1);
        }
        
        /**
         * @desc Retrieves the string representation of a Channel.
         * @param The channel enumerated.
         * @return The string representation.
         */
         function f_channel2str(Channel p_channel) return charstring {
             select(p_channel) {
                 case (cCH) {
                     return "CCH";
                 }
                 case (sCH1) {
                     return "SCH1";
                 }
                 case (sCH2) {
                     return "SCH2";
                 }
                 case (sCH3) {
                     return "SCH";
                 }
                 case (sCH4) {
                     return "SCH4";
                 }
                 case else {
                     return "unknown channel";
                 }
             }
         }
         
        /**
         * @desc Retrieves the string representation of a ChannelState.
         * @param The channel state enumerated.
         * @return The string representation.
         */
         function f_channelState2str(ChannelState p_state) return charstring {
             select(p_state) {
                 case (relaxed) {
                     return "relaxed";
                 }
                 case (active) {
                     return "active";
                 }
                 case (restrictive) {
                     return "restrictive";
                 }
                 case else {
                     return "unknown channel state";
                 }
             }
         }
         
         function f_getAcceptablePower(Channel p_channel, ChannelState p_state) return integer {
             var integer v_ret;
             
             select (p_channel) {
                 case (cCH) {
                     select (p_state) {
                         case (relaxed) {
                             return PIXIT_ACCEPTABLE_POWER_CCH_RELAXED;
                         }
                         case (active) {
                             return PIXIT_ACCEPTABLE_POWER_CCH_ACTIVE;
                         }
                         case (restrictive) {
                             return PIXIT_ACCEPTABLE_POWER_CCH_RESTRICTIVE;
                         }
                         case else {
                             testcase.stop(__SCOPE__ & ": Unknown channel state " & f_channelState2str(p_state) & " for " & f_channel2str(p_channel));
                         }
                     }
                 }
                 case (sCH1) {
                     select (p_state) {
                         case (relaxed) {
                             return PIXIT_ACCEPTABLE_POWER_SCH1_RELAXED;
                         }
                         case (active) {
                             return PIXIT_ACCEPTABLE_POWER_SCH1_ACTIVE;
                         }
                         case (restrictive) {
                             return PIXIT_ACCEPTABLE_POWER_SCH1_RESTRICTIVE;
                         }
                         case else {
                             testcase.stop(__SCOPE__ & ": Unknown channel state " & f_channelState2str(p_state) & " for " & f_channel2str(p_channel));
                         }
                     }
                 }
                 case (sCH2) {
                     select (p_state) {
                         case (relaxed) {
                             return PIXIT_ACCEPTABLE_POWER_SCH2_RELAXED;
                         }
                         case (active) {
                             return PIXIT_ACCEPTABLE_POWER_SCH2_ACTIVE;
                         }
                         case (restrictive) {
                             return PIXIT_ACCEPTABLE_POWER_SCH2_RESTRICTIVE;
                         }
                         case else {
                             testcase.stop(__SCOPE__ & ": Unknown channel state " & f_channelState2str(p_state) & " for " & f_channel2str(p_channel));
                         }
                     }
                 }
                 case (sCH3) {
                     select (p_state) {
                         case (relaxed) {
                             return PIXIT_ACCEPTABLE_POWER_SCH3_RELAXED;
                         }
                         case (active) {
                             return PIXIT_ACCEPTABLE_POWER_SCH3_ACTIVE;
                         }
                         case (restrictive) {
                             return PIXIT_ACCEPTABLE_POWER_SCH3_RESTRICTIVE;
                         }
                         case else {
                             testcase.stop(__SCOPE__ & ": Unknown channel state " & f_channelState2str(p_state) & " for " & f_channel2str(p_channel));
                         }
                     }
                 }
                 case (sCH4) {
                     select (p_state) {
                         case (relaxed) {
                             return PIXIT_ACCEPTABLE_POWER_SCH4_RELAXED;
                         }
                         case (active) {
                             return PIXIT_ACCEPTABLE_POWER_SCH4_ACTIVE;
                         }
                         case (restrictive) {
                             return PIXIT_ACCEPTABLE_POWER_SCH4_RESTRICTIVE;
                         }
                         case else {
                             testcase.stop(__SCOPE__ & ": Unknown channel state " & f_channelState2str(p_state) & " for " & f_channel2str(p_channel));
                         }
                     }
                 }
                 case else {
                     testcase.stop(__SCOPE__ & ": Unknown channel " & f_channel2str(p_channel));
                 }
             }
         }
    }

    group externalFunction {
        
        /**
         * @desc Returns the string representation of the float value
         * @param p_float The float value
         * @return The string representation of the float value
         */
        external function fx_float2str(float p_float) return charstring;
        
    }
} // End of module LibItsDcc_Functions